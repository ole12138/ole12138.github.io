<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Jingmin's blog</title><link>https://ole12138.github.io/</link><description>Recent content on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Wed, 06 Jan 2021 15:49:39 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/feed.xml" rel="self" type="application/rss+xml"/><item><title>Web前后端分离的实现方式</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 06 Jan 2021 15:49:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="web实现前后端分离前后端解耦">Web实现前后端分离，前后端解耦&lt;/h1>
&lt;p>博文非原创，转载来源：https://zhuanlan.zhihu.com/p/79336787&lt;/p>
&lt;h3 id="一前言">&lt;strong>一、前言&lt;/strong>&lt;/h3>
&lt;p>”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。&lt;/p>
&lt;p>并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。&lt;/p>
&lt;p>前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。&lt;/p>
&lt;blockquote>
&lt;p>注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。
应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】&lt;/p>
&lt;/blockquote>
&lt;p>一般只有Web服务器才能被外网访问，应用服务器只能内网访问。&lt;/p>
&lt;h3 id="二为什么前后端分离">&lt;strong>二、为什么前后端分离&lt;/strong>&lt;/h3>
&lt;p>一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。&lt;/p>
&lt;p>前后端工作分配不均。&lt;/p>
&lt;p>不仅仅开发效率慢，而且代码难以维护。&lt;/p>
&lt;p>而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。&lt;/p>
&lt;p>而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。&lt;/p>
&lt;p>前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。&lt;/p>
&lt;h3 id="三从mvc到前后端分离">&lt;strong>三、从MVC到前后端分离&lt;/strong>&lt;/h3>
&lt;p>MVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。&lt;/p>
&lt;p>其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。&lt;/p>
&lt;p>对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。&lt;/p>
&lt;p>模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。&lt;/p>
&lt;p>综上所述，MVC 的交互过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-e8f637c0d371d69629f84a2f027d4f2e_720w.jpg" alt="img">&lt;/p>
&lt;p>也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？&lt;/p>
&lt;p>答案是 REST。&lt;/p>
&lt;p>REST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！&lt;/p>
&lt;p>国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。&lt;/p>
&lt;p>如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-8a2866b2d43cd089f091bbcefbae7087_720w.jpg" alt="img">&lt;/p>
&lt;p>可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。&lt;/p>
&lt;h3 id="四认识rest架构">&lt;strong>四、认识Rest架构&lt;/strong>&lt;/h3>
&lt;p>REST 本质上是使用 URL 来访问资源种方式。&lt;/p>
&lt;p>众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式 与 请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。&lt;/p>
&lt;p>尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。&lt;/p>
&lt;p>REST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。&lt;/p>
&lt;p>也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？&lt;/p>
&lt;p>所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。&lt;/p>
&lt;p>&lt;strong>下面我们举几个例子对 REST 请求进行简单描述：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-ea128330d79975d807ec6657f930a578_720w.jpg" alt="img">&lt;/p>
&lt;p>可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。&lt;/p>
&lt;p>虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。&lt;/p>
&lt;h3 id="五前后端分离意义大吗">&lt;strong>五、前后端分离意义大吗？&lt;/strong>&lt;/h3>
&lt;p>1、该网站前端变化远比后端变化频繁，则意义大。&lt;/p>
&lt;p>2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。&lt;/p>
&lt;p>3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。&lt;/p>
&lt;p>4、该网站前端效果绚丽/跨设备兼容要求高，则意义大。&lt;/p>
&lt;h3 id="六术业有专攻开发人员分离">&lt;strong>六、术业有专攻（开发人员分离）&lt;/strong>&lt;/h3>
&lt;p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。&lt;/p>
&lt;p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。&lt;/p>
&lt;p>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。&lt;/p>
&lt;p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。&lt;/p>
&lt;h3 id="对于后端java工程师">&lt;strong>对于后端java工程师：&lt;/strong>&lt;/h3>
&lt;p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。&lt;/p>
&lt;p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。&lt;/p>
&lt;h3 id="对于前端工程师">&lt;strong>对于前端工程师：&lt;/strong>&lt;/h3>
&lt;p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。&lt;/p>
&lt;p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。&lt;/p>
&lt;h3 id="七耦合时代">&lt;strong>七、耦合时代&lt;/strong>&lt;/h3>
&lt;p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。&lt;/p>
&lt;p>大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。&lt;/p>
&lt;p>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;amp;渲染到jsp页面。&lt;/p>
&lt;p>然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（&amp;lt;%=%&amp;gt;）将后台的数据展现出来，玩的是MVC那套思路。&lt;/p>
&lt;p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？&lt;/p>
&lt;p>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？&lt;/p>
&lt;p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。&lt;/p>
&lt;p>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？&lt;/p>
&lt;p>好，下面在浏览器中输入你的网站域名（&lt;a href="https://link.zhihu.com/?target=http%3A//www.xxx.com">http://www.xxx.com&lt;/a>），之后发生了什么？（这个问题也是很多公司的面试题）&lt;/p>
&lt;p>我捡干的说了啊，基础不好的童鞋请自己去搜。&lt;/p>
&lt;p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。&lt;/p>
&lt;p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。&lt;/p>
&lt;p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？&lt;/p>
&lt;p>你的带宽有多大？&lt;/p>
&lt;p>你的服务器的内存有多大？&lt;/p>
&lt;p>你的硬盘是高性能的吗？&lt;/p>
&lt;p>你能抗住多少IO？&lt;/p>
&lt;p>你给web服务器分的内存有多大？&lt;/p>
&lt;p>会不会宕机？&lt;/p>
&lt;p>&lt;strong>这就是为什么，越是大中型的web应用，他们越是要解耦。&lt;/strong>&lt;/p>
&lt;p>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。&lt;/p>
&lt;p>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。&lt;/p>
&lt;p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。&lt;/p>
&lt;p>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。&lt;/p>
&lt;p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？
还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用：《架构探险-轻量级微服务架构》，黄勇）&lt;/p>
&lt;p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。&lt;/p>
&lt;p>&lt;strong>JSP的痛点&lt;/strong>&lt;/p>
&lt;p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。&lt;/p>
&lt;p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。&lt;/p>
&lt;p>一旦服务器出现状况，前后台一起玩完，用户体验极差。&lt;/p>
&lt;p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），
修改问题时需要双方协同开发，效率低下。&lt;/p>
&lt;p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），
性能提不上来。&lt;/p>
&lt;p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。&lt;/p>
&lt;p>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。&lt;/p>
&lt;p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。&lt;/p>
&lt;p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。&lt;/p>
&lt;p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。&lt;/p>
&lt;p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！&lt;/p>
&lt;h3 id="开发模式">&lt;strong>开发模式&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>以前老的方式是：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>产品经历/领导/客户提出需求&lt;/li>
&lt;li>UI做出设计图&lt;/li>
&lt;li>前端工程师做html页面&lt;/li>
&lt;li>后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）&lt;/li>
&lt;li>集成出现问题&lt;/li>
&lt;li>前端返工&lt;/li>
&lt;li>后端返工&lt;/li>
&lt;/ul>
&lt;p>二次集成&lt;/p>
&lt;p>集成成功&lt;/p>
&lt;p>交付&lt;/p>
&lt;p>&lt;strong>新的方式是：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>产品经历/领导/客户提出需求&lt;/li>
&lt;li>UI做出设计图&lt;/li>
&lt;li>前后端约定接口&amp;amp;数据&amp;amp;参数&lt;/li>
&lt;li>前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;amp;参数不变，就不用两边都修改代码，开发效率高）&lt;/li>
&lt;li>前后端集成&lt;/li>
&lt;li>前端页面调整&lt;/li>
&lt;li>集成成功&lt;/li>
&lt;li>交付&lt;/li>
&lt;/ul>
&lt;h3 id="请求方式">&lt;strong>请求方式&lt;/strong>&lt;/h3>
&lt;p>&lt;strong>以前老的方式是：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>客户端请求&lt;/li>
&lt;li>服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）&lt;/li>
&lt;li>调用service,dao代码完成业务逻辑&lt;/li>
&lt;li>返回jsp&lt;/li>
&lt;li>jsp展现一些动态的代码&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>新的方式是：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>浏览器发送请求&lt;/li>
&lt;li>直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）&lt;/li>
&lt;li>html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）&lt;/li>
&lt;li>填充html，展现动态效果，在页面上进行解析并操作DOM。&lt;/li>
&lt;/ul>
&lt;p>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）&lt;/p>
&lt;p>&lt;strong>总结一下新的方式的请求步骤：&lt;/strong>&lt;/p>
&lt;p>大量并发浏览器请求&amp;mdash;&amp;gt;web服务器集群(nginx)&amp;mdash;&amp;gt;应用服务器集群(tomcat)&amp;mdash;&amp;gt;文件/数据库/缓存/消息队列服务器集群&lt;/p>
&lt;p>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。&lt;/p>
&lt;h3 id="前后分离的优势">&lt;strong>前后分离的优势&lt;/strong>&lt;/h3>
&lt;p>1、可以实现真正的前后端解耦，前端服务器使用nginx。&lt;/p>
&lt;p>前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;amp;跳转&amp;amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。&lt;/p>
&lt;blockquote>
&lt;p>这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack&lt;/p>
&lt;/blockquote>
&lt;p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。&lt;/p>
&lt;p>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。&lt;/p>
&lt;p>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。&lt;/p>
&lt;p>双方互不干扰，前端与后端是相亲相爱的一家人。&lt;/p>
&lt;p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。&lt;/p>
&lt;blockquote>
&lt;p>去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。&lt;/p>
&lt;/blockquote>
&lt;p>4、减少后端服务器的并发/负载压力&lt;/p>
&lt;p>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。&lt;/p>
&lt;p>且除了第一次页面请求外，浏览器会大量调用本地缓存。&lt;/p>
&lt;p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。&lt;/p>
&lt;p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）&lt;/p>
&lt;p>7、页面显示的东西再多也不怕，因为是异步加载。&lt;/p>
&lt;p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。&lt;/p>
&lt;p>9、增加代码的维护性&amp;amp;易读性（前后端耦在一起的代码读起来相当费劲）。&lt;/p>
&lt;p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。&lt;/p>
&lt;p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），
内网使用http，性能和安全都有保障。&lt;/p>
&lt;p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！&lt;/p>
&lt;h3 id="注意事项">&lt;strong>注意事项&lt;/strong>&lt;/h3>
&lt;p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，
推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？&lt;/p>
&lt;p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。&lt;/p>
&lt;p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。&lt;/p>
&lt;p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。&lt;/p>
&lt;p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。&lt;/p>
&lt;p>6、以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。&lt;/p>
&lt;p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？&lt;/p>
&lt;p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。&lt;/p>
&lt;p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？&lt;/p>
&lt;p>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;amp;内存&amp;amp;cpu等等计算资源，你要记住一点就是：服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。&lt;/p>
&lt;blockquote>
&lt;p>类似于数据校验这种，前后端都需要做！&lt;/p>
&lt;/blockquote>
&lt;p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。&lt;/p>
&lt;h2 id="扩展阅读">&lt;strong>扩展阅读&lt;/strong>&lt;/h2>
&lt;p>1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。&lt;/p>
&lt;p>2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。&lt;/p>
&lt;p>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。&lt;/p>
&lt;p>3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。
JSONP的方式也被淘汰掉了。&lt;/p>
&lt;p>4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。&lt;/p>
&lt;p>5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。&lt;/p>
&lt;h3 id="总结">&lt;strong>总结&lt;/strong>&lt;/h3>
&lt;p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。&lt;/p>
&lt;p>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。&lt;/p>
&lt;p>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。&lt;/p>
&lt;p>前端只需要关注页面的样式与动态数据的解析&amp;amp;渲染，而后端专注于具体业务逻辑。&lt;/p></description></item><item><title>Spring构建restfulWebService</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%9E%84%E5%BB%BArestfulwebservice/</link><pubDate>Wed, 06 Jan 2021 11:18:01 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%9E%84%E5%BB%BArestfulwebservice/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="spring构建restfulwebservice">Spring构建restfulWebService&lt;/h1>
&lt;p>这是官网提供的一个例子，这里练习。&lt;/p>
&lt;p>实际上这里用的是Springboot来创建的。&lt;/p>
&lt;h2 id="what-you-will-build">What You Will Build&lt;/h2>
&lt;p>build a service that will accept HTTP GET requests at &lt;code>http://localhost:8080/greeting&lt;/code>.&lt;/p>
&lt;p>It will respond with a JSON representation of a greeting, as the following listing shows:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{&lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#f92672">&amp;#34;content&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Hello, World!&amp;#34;&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can customize the greeting with an optional &lt;code>name&lt;/code> parameter in the query string, as the following listing shows:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">&lt;span style="color:#960050;background-color:#1e0010">http://localhost:&lt;/span>&lt;span style="color:#ae81ff">8080&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">/greeting?name=User&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>The &lt;code>name&lt;/code> parameter value overrides the default value of &lt;code>World&lt;/code> and is reflected in the response, as the following listing shows:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">{&lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>:&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#f92672">&amp;#34;content&amp;#34;&lt;/span>:&lt;span style="color:#e6db74">&amp;#34;Hello, User!&amp;#34;&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="练习">练习&lt;/h2>
&lt;h3 id="初始化一个springboot项目">初始化一个springboot项目&lt;/h3>
&lt;p>使用&lt;a href="#https://start.spring.io/">springboot initializr&lt;/a>来初始化一个springboot的web项目。&lt;/p>
&lt;p>This example needs only the Spring Web dependency.&lt;/p>
&lt;p>注意到项目的入口类为：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.example.restfulWebService2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.boot.SpringApplication&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.boot.autoconfigure.SpringBootApplication&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@SpringBootApplication&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">RestfulWebService2Application&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
SpringApplication&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RestfulWebService2Application&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">,&lt;/span> args&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;p>&lt;code>@SpringBootApplication&lt;/code> is a convenience annotation that adds all of the following:&lt;/p>
&lt;ul>
&lt;li>&lt;code>@Configuration&lt;/code>: Tags the class as a source of bean definitions for the application context.&lt;/li>
&lt;li>&lt;code>@EnableAutoConfiguration&lt;/code>: Tells Spring Boot to start adding beans based on classpath settings, other beans, and various property settings. For example, if &lt;code>spring-webmvc&lt;/code> is on the classpath, this annotation flags the application as a web application and activates key behaviors, such as setting up a &lt;code>DispatcherServlet&lt;/code>.&lt;/li>
&lt;li>&lt;code>@ComponentScan&lt;/code>: Tells Spring to look for other components, configurations, and services in the &lt;code>com/example&lt;/code> package, letting it find the controllers.&lt;/li>
&lt;/ul>
&lt;p>The &lt;code>main()&lt;/code> method uses Spring Boot’s &lt;code>SpringApplication.run()&lt;/code> method to launch an application. Did you notice that there was not a single line of XML? There is no &lt;code>web.xml&lt;/code> file, either. This web application is 100% pure Java and you did not have to deal with configuring any plumbing or infrastructure.&lt;/p>
&lt;p>SpringBoot设置允许断点和调试：&lt;/p>
&lt;p>在ide (idea)资源目录resouces下有application.properties文件，可以添加一行:&lt;/p>
&lt;pre>&lt;code class="language-properties" data-lang="properties">debug=true
&lt;/code>&lt;/pre>&lt;h3 id="create-a-resource-representation-class">Create a Resource Representation Class&lt;/h3>
&lt;p>创建一个实体类&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.example.restfulWebService2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> String content&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Greeting&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">long&lt;/span> id&lt;span style="color:#f92672">,&lt;/span> String content&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">content&lt;/span> &lt;span style="color:#f92672">=&lt;/span> content&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">getId&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getContent&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> content&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="create-a-resource-controller">Create a Resource Controller&lt;/h3>
&lt;p>创建对应的controller来响应请求&amp;quot;/greeting&amp;quot;&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.example.restfulWebService2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.stereotype.Controller&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.web.bind.annotation.GetMapping&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.web.bind.annotation.RequestParam&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> org.springframework.web.bind.annotation.ResponseBody&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.concurrent.atomic.AtomicLong&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@Controller&lt;/span>
&lt;span style="color:#a6e22e">@ResponseBody&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">GreetingController&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> AtomicLong id &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> AtomicLong&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String template &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, %s&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#a6e22e">@GetMapping&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;/greeting&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> Greeting &lt;span style="color:#a6e22e">greeting&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#a6e22e">@RequestParam&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;name&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> defaultValue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;world&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> String name&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Greeting&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">incrementAndGet&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">(&lt;/span>template&lt;span style="color:#f92672">,&lt;/span> name&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;p>In Spring’s approach to building RESTful web services, HTTP requests are handled by a controller. These components are identified by the &lt;a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html">&lt;code>@RestController&lt;/code>&lt;/a> annotation, and the &lt;code>GreetingController&lt;/code> shown in the listing (from &lt;code>src/main/java/com/example/restservice/GreetingController.java&lt;/code>) handles &lt;code>GET&lt;/code> requests for &lt;code>/greeting&lt;/code> by returning a new instance of the &lt;code>Greeting&lt;/code> class).&lt;/p>
&lt;p>This application uses the &lt;a href="https://github.com/FasterXML/jackson">Jackson JSON&lt;/a> library to automatically marshal instances of type &lt;code>Greeting&lt;/code> into JSON. Jackson is included by default by the web starter.&lt;/p>
&lt;p>The &lt;code>@GetMapping&lt;/code> annotation ensures that HTTP GET requests to &lt;code>/greeting&lt;/code> are mapped to the &lt;code>greeting()&lt;/code> method.&lt;/p>
&lt;p>There are companion annotations for other HTTP verbs (e.g. &lt;code>@PostMapping&lt;/code> for POST). There is also a &lt;code>@RequestMapping&lt;/code> annotation that they all derive from, and can serve as a synonym (e.g. &lt;code>@RequestMapping(method=GET)&lt;/code>).&lt;/p>
&lt;p>&lt;code>@RequestParam&lt;/code> binds the value of the query string parameter &lt;code>name&lt;/code> into the &lt;code>name&lt;/code> parameter of the &lt;code>greeting()&lt;/code> method. If the &lt;code>name&lt;/code> parameter is absent in the request, the &lt;code>defaultValue&lt;/code> of &lt;code>World&lt;/code> is used.&lt;/p>
&lt;p>This code uses Spring &lt;a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RestController.html">&lt;code>@RestController&lt;/code>&lt;/a> annotation, which marks the class as a controller where every method returns a domain object instead of a view. It is shorthand for including both &lt;code>@Controller&lt;/code> and &lt;code>@ResponseBody&lt;/code>.&lt;/p>
&lt;p>The &lt;code>Greeting&lt;/code> object must be converted to JSON. Thanks to Spring’s HTTP message converter support, you need not do this conversion manually. Because &lt;a href="https://github.com/FasterXML/jackson">Jackson 2&lt;/a> is on the classpath, Spring’s &lt;a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.html">&lt;code>MappingJackson2HttpMessageConverter&lt;/code>&lt;/a> is automatically chosen to convert the &lt;code>Greeting&lt;/code> instance to JSON.&lt;/p>
&lt;h3 id="测试">测试&lt;/h3>
&lt;p>只有一个简单Java类和Controller，直接浏览器请求对应链接：
&lt;code>http://localhost:8080/greeting?name=xxx&lt;/code>就可以了。&lt;/p></description></item><item><title>转载：Maven pom.xml中的元素modules、parent、properties以及import</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/maven%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 06 Jan 2021 10:00:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/maven%E4%BD%BF%E7%94%A8/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="maven-pomxml中的元素modulesparentproperties以及import">Maven pom.xml中的元素modules、parent、properties以及import&lt;/h1>
&lt;p>非原创，转载来源：https://www.cnblogs.com/youzhibing/p/5427130.html&lt;/p>
&lt;p>另，Maven文档链接：https://maven.apache.org/guides/introduction/introduction-to-the-pom.html&lt;/p>
&lt;p>maven的核心是pom.xml。印象最深的就是如下四个元素：modules、parent、properties、import。&lt;/p>
&lt;h2 id="modules">modules&lt;/h2>
&lt;p>从字面意思来说，module就是模块，而pom.xml中的modules也正是这个意思，用来管理同个项目中的各个模块；如果maven用的比较简单，或者说项目的模块在pom.xml没进行划分，那么此元素是用不到的；不过一般大一点的项目是要用到的。&lt;/p>
&lt;h3 id="需求场景">需求场景&lt;/h3>
&lt;p>如果我们的项目分成了好几个模块，那么我们构建的时候是不是有几个模块就需要构建几次了（到每个模块的目录下执行mvn命令）？当然，你逐个构建没问题，但是非要这么麻烦的一个一个的构建吗，那么简单的做法就是使用聚合，一次构建全部模块。&lt;/p>
&lt;h3 id="具体实现">具体实现&lt;/h3>
&lt;p>a.既然使用聚合，那么就需要一个聚合的载体，先创建一个普通的maven项目account-aggregator,如下图：&lt;/p>
&lt;p>&lt;img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAUMAAAA/CAIAAAD1xj1eAAAKYElEQVR4nO2cUUwbRxrH/ZJ3P0S6PuahiixZuruUcpGiqKd7gqhSoZWsI7076WQpNHetlB5tBT3hdBMsSuEh3Fl2mkB6BCfGOEogjRT2UkECLRKilco1TrE4mhiSCjC2Zac4QEg1fVh7d2Z3ZteOjQcv308jtB7PzH6bzH+/b2c9nwUBAFD5WHgbAABACdgWJfdeGvppLaOqtDl923EuAABQSZRsc/rqPxpECNV/NCjJNXJvxnPOr21W/LkAAKBSGiXbnL63PSPSAUIo9qXr3CcfftDa+UFr5+mPPSuxBAIlA8B2Uhol150clDxzVq7piWwhmxV/LgAAqJRGyYN3vrc5fde+ms3KNflFtiBUd3JQblb8uUpKWLBbHCHeVhRAxRkMlI+8lHz79u2Ojo4CRo1dzxZMwKDkoqk4g4HyYazk0dFRu92+f/9+VoO337+IfgxI5eeHl78YuiS4gyfe8594z48QujIxKz0//+fW/+j9w4LdkgWbpiFHrtIuhA1rlK74bFeOQw6LXRAcWHesb264QqyyC4ID60itl04fciin0F4Ce0y1AVqDaZdPOSmwKzBQsiTjhoYGHSX/pbEPLfSihd71uQuu00HP8L3rCz/LBW/5VtNVTe+w4MhNuJDDoghPNQ+NauS+TCXnxg4L9mw/HRfHtAofGlcUrV7SonyGkEqmsj7pfSkG4AYzLl99UmC3oKdkWcZHjx7VUXL9ny+iH/71ZPbf73442HXth9Dsprb0fBk/9v7Nhz+mqSNQ3I/KnxjX5Ga5jk9WVKRVMuYYw9iIOlbJH1n1qjsF7kHlMzH70gzAB2RdPkTguxWmknEZ6yu55o+Xn3z3yVtNV9ou/7//mzVt8Ygrb564tfDoMaWz2ocVo2S7EH5uJRdu1XMoWRvusvpSDTBQsmGgAZgZppI7Ojr2Y7S3t7NavvLG4J/+fuWfPXPnx1Pnx1Pn7xDl48HFP7x548FDmowRMSPDgp0Wx4aE3GOttoYIL5WZjEe3z6VkY6vyja5Vz9hYqK07Jt0A3eiaflJgt1CCt1D9V76x1dw4UCceqBs5UDfyUt3IS/ViVf1I1evi4aO36o+L8eQ6u7cSQtodDtKdapeyVKs71CUfpSE2IFXJuZaUlSFDq1irU9oVL+qoNHM1fbUGkAbrrHjp/X8BpqQ0v7tey2yWZJxKghot69QXMyYAGAF7ofInLNiJcACLf6n1xYwJAIUBSi4ELDzWrBzT6osZEwAKAZQMAGYAlAwAZgCUDABmAJQMAGYAlAwAZgCUDABmAJQMAGZghyo5FRGjfdZURORtCD/y2n25baz4B1yN0ytaq9xejz+BEELRaU+NCO+/dww7VMnRPmtqyhbtsxq0C1F+qMzcm0j+3pkcRe/rskD9kXa5lTwfrPG6arzBiaKUHHZ7XYyvVvwDrhqvq4bRYELMfks7tWacgbEoYbZUPP6EXJM1dVewLUqenJxcW1srZoQZwRrtsxq7ZcYeIGyHkaEMVLuR8pdMaQWmm/agjEo2cLMGSo5Oe2q8HrdIF/mEKAuYcqeITnty4gy7vS73PNOI6LSnccBDKFk+ppm6K9gWJQcCgWAwGI/HDc59TPxd67XfCDdsbf99oWvSemZ6j/eu5ZiI5Oj6ji36qa5b1tkMnKeSlZ1RhQJKZjVmfTUhKurFjxFCkrZl9eqF7omxxoGxKK5eUDLaPiXHYrGenp5Hjx7pNPtVTSu1SN/OCNbUnX2R7udQMrZHuTCfrO2unILckqiXVQtLM2YXQtlujpDShHbroEbX+LZk7SOAJmUXZdck3sbhoF0XjqJkQldy0IuHrJjYpJg5KCdFZuowMdbo9fgTuPtVrteNjcAQp3SuXPxMi64xTw5KLp5AIIAQisfj3d3dc3NzOi1/7f0rq0gBdqRbN8CmPyfjM5R8TtZ7TCaTAmByVCcVwkbG9v3Tc3QpmQMstHwB9NFUFWRqLmbKLmbqLwvNTCVqwaApGQuJJc2olBx2ax5rDdy1WnIIIUnkxkpWRqY2yN0ppH8PUHLRSEpGCC0tLZ06dSqZTLJa7hFqW8RWbdkj1KYi4kyHdVncF+lgu2WaTyadbL6haVbx6uQ68oSXtKi+RyjNSXLpO+2YtqjHtNHUFaqv9FJ26aX+ol8XAUXJKj2oousg9YE2j+ha+5ych0/G1c6QOnYKUHLxSEpOJBKGPnmPUMsqCKEZwbos7psRmErG5qk6M442l1ceEL7MLoQZWT80S8r0DAHlVbJh6q9cK9p1ZSlUyV5PI22Jm6Fkcii1FIlv2ctpLrIEJ8g2oOSSEggEVldXDZ+Tx5t+r1+kAHumhRVgM5+HVcm8DFa8qFnzwoLd7nDYlY+C+tbAunfgObpKpmQyARFNpcapv2jXRWIUXUvqJaPrFf+A+pUSqUPZ/RJ+ODesUon1ykOE2I1gQsQcNUTXpSTPtevR4y/PXfwHq4wefzkVEadarMvDL0y1qN2y5tmW4rjkB1zqi2ayKeU5WpXCg77ipLfaVLCSCTNVftWhfedNu2Spt5L6i3Ij00lNQl/xCru98mveMeratbQk5p7XuE1Sqygx1uhVvU/G5a28bdZ5BaWYqrh02UJ6+LAr4Pk++WbDi+HOV6Vylzy42/nqzYYXEUIsJZcBsybV0rkuxtp1ZQJKLhvDR/ZK5fqRvcO1uXJk73BttgYhNNVilUq5jTNrjkrd65J/40UsAnODfPvF+t0YDfiNF4AQ+c7ITOR1XdlItcId8u4DlAwAZgCUDABmAJQMAGaAm5ItFouJ/wJAmYFpBwBmgLNPNh9mvS5gh8N/2n3e+Vtq4W0XAFQS/H3yUMeBzafPVCX8+d8qSszK1iLwyQAX+E+7UHuVVsnz46crSsz0TYIAUDb4++RQe9X65jNVmR8/LYk51F7Fy8JCAJ8McIb/tOtvq86sb2XWt55sKGV989mTja3M+lZ/WzVvA/MBfDLAGf4+ub+tOp3ZGv02OvptdHYxmc5szS4mpY/pjI6SWdmtEJnCA8+3mVdWLXw3cG7bsWFf8MkAZ/hPu7Oug+nMls3pszl9zb1j6cxWc++Y9DGd2TrrOsjox8puRW6/JevzzKqV3fenbP8z7As+GeAMf5981nUw/vipzemrfudC9TsX4o+fSgc2py/++Km+kik5cdS7b/H8ePnv+1dl7TLsCz4Z4Az/aXfWdXApuSE5ZJvTd+bq1/LxSmqzFEqWxVYOJQMAF/j75K7mQ5KSz1z9+rWTIZvT99rJkKTnpeRGV/MhxgCs7Faa6FqJkHXViOX+kqo0Fey+4JMB3vCfdl3NhxZjWSVLApYPFmMGSqZlt0J6K155KBm7E8j3B/DJwE6Hv09uazq8GNsYnrw/FVm9t5Aenrx/byE9FVkdnry/GNtoazrMGGCHpucBnwxwgf+0a2s6/GB5/cHyBvZXKRWnZADgAn+f3PruK/qFMcAOVTL4ZIALMO0AwAzw98kmw6zXBexweE67nZCmB1L/AOYAZh4AmAFQMgCYgZIpOZ5MnfMPeT4LeT4L9V4a+mktU6qRAQAw5BfaQggCHYNYBgAAAABJRU5ErkJggg==" alt="img">&lt;/p>
&lt;p>因为是个聚合体，仅仅负责聚合其他模块，那么就只需要上述目录，该删除的就删了；注意的是pom文件的书写：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;packaging&amp;gt;&lt;/span>pom&lt;span style="color:#f92672">&amp;lt;/packaging&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>Account Aggrregator&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modules&amp;gt;&lt;/span>　　　 &lt;span style="color:#75715e">&amp;lt;!-- 模块都写在此处 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/modules&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>b.创建子模account-register、account-persist:右击account-aggregator，new &amp;ndash;&amp;gt; other &amp;ndash;&amp;gt; Maven，选择Maven Module，创建maven模块。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2021%E5%B9%B41%E6%9C%886%E6%97%A5%E4%B8%8B%E8%BD%BD1.png" alt="img">&lt;/p>
&lt;p>c.创建完成后，项目结构如下，那么此时account-aggregator可以收缩起来了，我们操作具体子模块就好了。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2021%E5%B9%B41%E6%9C%886%E6%97%A5%E4%B8%8B%E8%BD%BD2.png" alt="2021年1月6日下载2">&lt;/p>
&lt;p>d.注意点，当我们打开包结构的子模块的pom文件时，发现离预期的多了一些内容，我们坐下处理就好了&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2021%E5%B9%B41%E6%9C%886%E6%97%A5%E4%B8%8B%E8%BD%BD3.png" alt="2021年1月6日下载3">&lt;/p>
&lt;p>e.那么编码完了之后，我们只需要构建account-aggregator就好了，所有的子模块都会构建。&lt;/p>
&lt;h2 id="parent">parent&lt;/h2>
&lt;p>继承，和java中的继承相当，作用就是复用&lt;/p>
&lt;h3 id="需求场景-1">需求场景&lt;/h3>
&lt;p>若每个子模块都都用的了spring，那么我们是不是每个子模块都需要单独配置spring依赖了?,这么做是可以的，但是我们有更优的做法，那就是继承，用parent来实现。&lt;/p>
&lt;h3 id="具体实现-1">具体实现&lt;/h3>
&lt;p>a.配置父pom.xml&lt;/p>
&lt;p>我就用聚合pom来做父pom,配置子模块的公共依赖。&lt;/p>
&lt;p>父(account-aggregator)pom.xml :&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;packaging&amp;gt;&lt;/span>pom&lt;span style="color:#f92672">&amp;lt;/packaging&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>Account Aggrregator&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modules&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- 模块都写在此处 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/modules&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 配置共有依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- spring 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-core&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-beans&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context-support&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- junit 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.7&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>b.account-register的pom.xml :&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;relativePath&amp;gt;&lt;/span>../pom.xml&lt;span style="color:#f92672">&amp;lt;/relativePath&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 与不配置一样，默认就是寻找上级目录下得pom.xml --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span>UTF-8&lt;span style="color:#f92672">&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 配置自己独有依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>javax.mail&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>mail&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.4.3&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.icegreen&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>greenmail&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.4.1&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>c.account-persist的pom.xml :&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span>UTF-8&lt;span style="color:#f92672">&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 配置自己独有依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-jdbc&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>druid&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.16&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>d.依赖的jar包全部ok，需要做的则是在各个模块中进行代码开发了！&lt;/p>
&lt;h3 id="依赖管理">依赖管理&lt;/h3>
&lt;p>继承可以消除重复，那是不是就没有问题了？ 答案是存在问题，假设将来需要添加一个新的子模块account-util，该模块只是提供一些简单的帮助工具，不需要依赖spring、junit，那么继承后就依赖上了，有没有什么办法了？ 有，maven已经替我们想到了，那就是dependencyManagement元素，既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。在dependencyManagement元素下得依赖声明不会引入实际的依赖，不过它能够约束dependencies下的依赖使用。&lt;/p>
&lt;p>在父pom.xml中配置dependencyManagement元素:&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;packaging&amp;gt;&lt;/span>pom&lt;span style="color:#f92672">&amp;lt;/packaging&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>Account Aggrregator&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modules&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- 模块都写在此处 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/modules&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencyManagement&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 配置共有依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- spring 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-core&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-beans&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context-support&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- junit 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.7&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencyManagement&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>account-persist的pom.xml(account-register也一样) ：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#75715e">&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/parent&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;project.build.sourceEncoding&amp;gt;&lt;/span>UTF-8&lt;span style="color:#f92672">&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- spring 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-core&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-beans&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context-support&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- junit 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-jdbc&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.alibaba&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>druid&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.16&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用这种依赖管理机制似乎不能减少太多的POM配置，就少了version(junit还少了个scope)，感觉没啥作用呀；其实作用还是挺大的，父POM使用dependencyManagement能够统一项目范围中依赖的版本，当依赖版本在父POM中声明后，子模块在使用依赖的时候就无须声明版本，也就不会发生多个子模块使用版本不一致的情况，帮助降低依赖冲突的几率。如果子模块不声明依赖的使用，即使该依赖在父POM中的dependencyManagement中声明了，也不会产生任何效果。&lt;/p>
&lt;h2 id="import">import&lt;/h2>
&lt;p>import只在dependencyManagement元素下才有效果，作用是将目标POM中的dependencyManagement配置导入并合并到当前POM的dependencyManagement元素中，如下就是讲account-aggregator中的dependencyManagement配置导入并合并到当前POM中。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#f92672">&amp;lt;dependencyManagement&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;type&amp;gt;&lt;/span>pom&lt;span style="color:#f92672">&amp;lt;/type&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>import&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencyManagement&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="properties">properties&lt;/h2>
&lt;p>通过&lt;code>&amp;lt;properties&amp;gt;&lt;/code>元素用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用${属性名}的方式引用该属性，这种做法的最大意义在于消除重复和统一管理。&lt;/p>
&lt;p>Maven总共有6类属性，内置属性、POM属性、自定义属性、Settings属性、java系统属性和环境变量属性；&lt;/p>
&lt;h3 id="内置属性">内置属性&lt;/h3>
&lt;p>两个常用内置属性 &lt;code>${basedir}&lt;/code> 表示项目跟目录，即包含pom.xml文件的目录；&lt;code>${version}&lt;/code> 表示项目版本&lt;/p>
&lt;h3 id="pom属性">pom属性&lt;/h3>
&lt;p>用户可以使用该类属性引用POM文件中对应元素的值。如&lt;code>${project.artifactId}&lt;/code>就对应了&lt;code>&amp;lt;project&amp;gt; &amp;lt;artifactId&amp;gt;&lt;/code>元素的值，常用的POM属性包括：&lt;/p>
&lt;pre>&lt;code>${project.build.sourceDirectory}:项目的主源码目录，默认为src/main/java/
${project.build.testSourceDirectory}:项目的测试源码目录，默认为src/test/java/
${project.build.directory} ： 项目构建输出目录，默认为target/
${project.outputDirectory} : 项目主代码编译输出目录，默认为target/classes/
${project.testOutputDirectory}：项目测试主代码输出目录，默认为target/testclasses/
${project.groupId}：项目的groupId
${project.artifactId}：项目的artifactId
${project.version}：项目的version,与${version} 等价
${project.build.finalName}：项目打包输出文件的名称，默认为${project.artifactId}-${project.version}
&lt;/code>&lt;/pre>&lt;h3 id="自定义属性">自定义属性&lt;/h3>
&lt;p>如下account-aggregator的pom.xml，那么继承了此pom.xml的子模块也可以用此自定义属性.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-xml" data-lang="xml">&lt;span style="color:#f92672">&amp;lt;project&lt;/span> &lt;span style="color:#a6e22e">xmlns=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34;&lt;/span> &lt;span style="color:#a6e22e">xmlns:xsi=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34;&lt;/span>
&lt;span style="color:#a6e22e">xsi:schemaLocation=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modelVersion&amp;gt;&lt;/span>4.0.0&lt;span style="color:#f92672">&amp;lt;/modelVersion&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>com.youzhibing.account&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>account-aggregator&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>1.0.0-SNAPSHOT&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;packaging&amp;gt;&lt;/span>pom&lt;span style="color:#f92672">&amp;lt;/packaging&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;name&amp;gt;&lt;/span>Account Aggrregator&lt;span style="color:#f92672">&amp;lt;/name&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;url&amp;gt;&lt;/span>http://maven.apache.org&lt;span style="color:#f92672">&amp;lt;/url&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;modules&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- 模块都写在此处 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-register&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-persist&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;module&amp;gt;&lt;/span>account-another&lt;span style="color:#f92672">&amp;lt;/module&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/modules&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;properties&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- 定义 spring版本号 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;spring.version&amp;gt;&lt;/span>4.0.2.RELEASE&lt;span style="color:#f92672">&amp;lt;/spring.version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;junit.version&amp;gt;&lt;/span>4.7&lt;span style="color:#f92672">&amp;lt;/junit.version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/properties&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencyManagement&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependencies&amp;gt;&lt;/span> &lt;span style="color:#75715e">&amp;lt;!-- 配置共有依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- spring 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-core&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-beans&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>org.springframework&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>spring-context-support&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${spring.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#75715e">&amp;lt;!-- junit 依赖 --&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;groupId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;artifactId&amp;gt;&lt;/span>junit&lt;span style="color:#f92672">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;version&amp;gt;&lt;/span>${junit.version}&lt;span style="color:#f92672">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;scope&amp;gt;&lt;/span>test&lt;span style="color:#f92672">&amp;lt;/scope&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencies&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/dependencyManagement&amp;gt;&lt;/span>
&lt;span style="color:#f92672">&amp;lt;/project&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="settings属性">settings属性&lt;/h3>
&lt;p>与POM属性同理，用户使用以settings. 开头的属性引用settings.xml文件中的XML元素的值。&lt;/p>
&lt;h3 id="java系统属性">Java系统属性&lt;/h3>
&lt;p>所有java系统属性都可以用Maven属性引用，如&lt;code>${user.home}&lt;/code>指向了用户目录。&lt;/p>
&lt;h3 id="环境变量属性">环境变量属性&lt;/h3>
&lt;p>所有环境变量属性都可以使用以env. 开头的Maven属性引用，如&lt;code>${env.JAVA_HOME}&lt;/code>指代了JAVA_HOME环境变量的的值。&lt;/p>
&lt;h2 id="聚合与继承的关系">聚合与继承的关系&lt;/h2>
&lt;p>1.聚合主要是为了方便快速构建项目，继承主要是为了消除重复配置；&lt;/p>
&lt;p>2.对于聚合模块而言，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在；对于继承的父pom而言，它不知道有哪些子模块继承它，但那些子模块都必须知道自己的父POM是什么；&lt;/p>
&lt;p>3.聚合POM与继承中的父POM的packaging都必须是pom；同时，聚合模块与继承中的父模块除了POM外，都没有实际的内容&lt;/p>
&lt;h2 id="结束语">结束语&lt;/h2>
&lt;p>maven越来越流行，这方面的资料也是越来越多，《Maven实战》给我的感觉就相当不错，本博客的内容大多取自其中；网上资料也越来越多，就博客园中就有不少；&lt;/p>
&lt;p>最后强调一点：&lt;strong>看了是好，实践更好，写博客记录下来那是最好！&lt;/strong>&lt;/p></description></item><item><title>转载：Java Annotation认知</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E6%B3%A8%E8%A7%A3annotation/</link><pubDate>Tue, 05 Jan 2021 12:00:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E6%B3%A8%E8%A7%A3annotation/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;p>转载，原网址：https://www.cnblogs.com/skywang12345/p/3344137.html&lt;/p>
&lt;h1 id="annotation">Annotation&lt;/h1>
&lt;p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。&lt;/p>
&lt;p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，&lt;strong>Java 标注可以通过反射获取标注内容&lt;/strong>。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。&lt;/p>
&lt;h3 id="内置的注解">内置的注解&lt;/h3>
&lt;p>Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。&lt;/p>
&lt;p>&lt;strong>作用在代码的注解是&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/li>
&lt;li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。&lt;/li>
&lt;li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。&lt;/li>
&lt;/ul>
&lt;p>作用在其他注解的注解(或者说 元注解)是:&lt;/p>
&lt;ul>
&lt;li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。&lt;/li>
&lt;li>@Documented - 标记这些注解是否包含在用户文档中。&lt;/li>
&lt;li>@Target - 标记这个注解应该是哪种 Java 成员。&lt;/li>
&lt;li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)&lt;/li>
&lt;/ul>
&lt;p>从 Java 7 开始，额外添加了 3 个注解:&lt;/p>
&lt;ul>
&lt;li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。&lt;/li>
&lt;li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。&lt;/li>
&lt;li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。&lt;/li>
&lt;/ul>
&lt;h2 id="annotation-架构">Annotation 架构&lt;/h2>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28123151-d471f82eb2bc4812b46cc5ff3e9e6b82.jpg" alt="img">&lt;/p>
&lt;p>从中，我们可以看出：&lt;/p>
&lt;p>&lt;strong>(01) 1 个 Annotation 和 1 个 RetentionPolicy 关联。&lt;/strong>&lt;/p>
&lt;p>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。&lt;/p>
&lt;p>&lt;strong>(02) 1 个 Annotation 和 1~n 个 ElementType 关联。&lt;/strong>&lt;/p>
&lt;p>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。&lt;/p>
&lt;p>&lt;strong>(03) Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。&lt;/strong>&lt;/p>
&lt;p>Annotation 的每一个实现类，都 &amp;ldquo;和 1 个 RetentionPolicy 关联&amp;rdquo; 并且 &amp;quot; 和 1~n 个 ElementType 关联&amp;quot;。&lt;/p>
&lt;h2 id="annotation-组成部分">Annotation 组成部分&lt;/h2>
&lt;p>下面，我先介绍框架图的左半边(如下图)，即 Annotation, RetentionPolicy, ElementType；然后在就 Annotation 的实现类进行举例说明。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28123653-84d14b886429482bb601dc97155220fb.jpg" alt="img">&lt;/p>
&lt;p>java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> java.lang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">Annotation&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Object obj&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">hashCode&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
String &lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Class&lt;span style="color:#f92672">&amp;lt;?&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> Annotation&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">annotationType&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> java.lang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> ElementType &lt;span style="color:#f92672">{&lt;/span>
TYPE&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 类、接口（包括注释类型）或枚举声明 */&lt;/span>
FIELD&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 字段声明（包括枚举常量） */&lt;/span>
METHOD&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 方法声明 */&lt;/span>
PARAMETER&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 参数声明 */&lt;/span>
CONSTRUCTOR&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 构造方法声明 */&lt;/span>
LOCAL_VARIABLE&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 局部变量声明 */&lt;/span>
ANNOTATION_TYPE&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 注释类型声明 */&lt;/span>
PACKAGE &lt;span style="color:#75715e">/* 包声明 */&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> java.lang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> RetentionPolicy &lt;span style="color:#f92672">{&lt;/span>
SOURCE&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了 */&lt;/span>
CLASS&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#75715e">/* 编译器将Annotation存储于类对应的.class文件中。默认行为 */&lt;/span>
RUNTIME &lt;span style="color:#75715e">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;p>&lt;strong>(01) Annotation 就是个接口。&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;每 1 个 Annotation&amp;rdquo; 都与 &amp;ldquo;1 个 RetentionPolicy&amp;rdquo; 关联，并且与 &amp;ldquo;1～n 个 ElementType&amp;rdquo; 关联。可以通俗的理解为：每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。&lt;/p>
&lt;p>&lt;strong>(02) ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型。&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;每 1 个 Annotation&amp;rdquo; 都与 &amp;ldquo;1～n 个 ElementType&amp;rdquo; 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。&lt;/p>
&lt;p>&lt;strong>(03) RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;每 1 个 Annotation&amp;rdquo; 都与 &amp;ldquo;1 个 RetentionPolicy&amp;rdquo; 关联。&lt;/p>
&lt;ul>
&lt;li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，&amp;quot; @Override&amp;quot; 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，&amp;quot;@Override&amp;quot; 就没有任何作用了。&lt;/li>
&lt;li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。&lt;/li>
&lt;li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入。&lt;/li>
&lt;/ul>
&lt;p>这时，只需要记住&amp;quot;每 1 个 Annotation&amp;quot; 都与 &amp;ldquo;1 个 RetentionPolicy&amp;rdquo; 关联，并且与 &amp;ldquo;1～n 个 ElementType&amp;rdquo; 关联。学完后面的内容之后，再回头看这些内容，会更容易理解。&lt;/p>
&lt;h2 id="annotation-实现类">Annotation 实现类&lt;/h2>
&lt;p>理解了上面的 3 个类的作用之后，我们接下来可以讲解 Annotation 实现类的语法定义了。&lt;/p>
&lt;p>注意：虽然从上文知道：&lt;strong>Annotation 就是个接口&lt;/strong>。但是&lt;strong>它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成&lt;/strong>。&lt;/p>
&lt;h3 id="annotation-通用定义">Annotation 通用定义&lt;/h3>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ElementType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">TYPE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> MyAnnotation1 &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>说明：&lt;/p>
&lt;p>上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 &amp;ldquo;@MyAnnotation1&amp;rdquo; 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：&lt;/p>
&lt;p>&lt;strong>(01) @interface&lt;/strong>&lt;/p>
&lt;p>使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。&lt;/p>
&lt;p>定义 Annotation 时，@interface 是必须的。&lt;/p>
&lt;p>注意：&lt;strong>它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成&lt;/strong>。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。&lt;/p>
&lt;p>&lt;strong>(02) @Documented&lt;/strong>&lt;/p>
&lt;p>类和方法的 Annotation 在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。&lt;/p>
&lt;p>定义 Annotation 时，@Documented 可有可无；若没有定义，则 Annotation 不会出现在 javadoc 中。&lt;/p>
&lt;p>&lt;strong>(03) @Target(ElementType.TYPE)&lt;/strong>&lt;/p>
&lt;p>前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。&lt;/p>
&lt;p>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰&amp;quot;类、接口（包括注释类型）或枚举声明&amp;quot;的注解。&lt;/p>
&lt;p>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。&lt;/p>
&lt;p>&lt;strong>(04) @Retention(RetentionPolicy.RUNTIME)&lt;/strong>&lt;/p>
&lt;p>前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。&lt;/p>
&lt;p>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。&lt;/p>
&lt;p>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。&lt;/p>
&lt;h3 id="java自带的annotation">java自带的Annotation&lt;/h3>
&lt;p>通过上面的示例，我们能理解：&lt;em>&lt;strong>@interface用来声明Annotation，@Documented用来表示该Annotation是否会出现在javadoc中， @Target用来指定Annotation的类型，@Retention用来指定Annotation的策略。&lt;/strong>&lt;/em>&lt;/p>
&lt;p>理解这一点之后，我们就很容易理解java中自带的Annotation的实现类，即Annotation架构图的右半边。如下图：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28124653-adf73c4cdcce4a63b7bf78efbe1a9cdf.jpg" alt="img">&lt;/p>
&lt;p>java 常用的Annotation：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Deprecated&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Deprecated&lt;/span> 所标注内容&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>不再被建议使用&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Override&lt;/span> 只能标注方法&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>表示该方法覆盖父类中的方法&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@Documented&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Documented&lt;/span> 所标注内容&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>可以出现在javadoc中&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@Inherited&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Inherited只能被用来标注&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>Annotation类型&lt;span style="color:#960050;background-color:#1e0010">”，&lt;/span>它所标注的Annotation具有继承性&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Retention只能被用来标注&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>Annotation类型&lt;span style="color:#960050;background-color:#1e0010">”，&lt;/span>而且它被用来指定Annotation的RetentionPolicy属性&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@Target只能被用来标注&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">“&lt;/span>Annotation类型&lt;span style="color:#960050;background-color:#1e0010">”，&lt;/span>而且它被用来指定Annotation的ElementType属性&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span> &lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span> 所标注内容产生的警告&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>编译器会对这些警告保持静默&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>由于“@Deprecated和@Override”类似，“@Documented, @Inherited, @Retention, @Target”类似；下面，我们只对@Deprecated, @Inherited, @SuppressWarnings 这3个Annotation进行说明。&lt;/p>
&lt;h4 id="deprecated">@Deprecated&lt;/h4>
&lt;p>@Deprecated 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> Deprecated &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：
(01) @interface &amp;ndash; 它的用来修饰Deprecated，意味着Deprecated实现了java.lang.annotation.Annotation接口；即Deprecated就是一个注解。
(02) @Documented &amp;ndash; 它的作用是说明该注解能出现在javadoc中。
(03) @Retention(RetentionPolicy.RUNTIME) &amp;ndash; 它的作用是指定Deprecated的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Deprecated的信息保留在.class文件中，并且能被虚拟机读取。
(04) @Deprecated 所标注内容，不再被建议使用。
例如，若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被@Deprecated标示的方法，编译器会给相应的提示信息。示例如下:&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28132554-8729c2663c5943a4b3302f210904e1d7.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>源码如下&lt;/strong>(DeprecatedTest.java)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.skywang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Date&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Calendar&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DeprecatedTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">// @Deprecated 修饰 getString1(),表示 它是建议不被使用的函数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">@Deprecated&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">getString1&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Deprecated Method&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">getString2&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Normal Method&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">// Date是日期/时间类。java已经不建议使用该类了
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testDate&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Date date &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Date&lt;span style="color:#f92672">(&lt;/span>113&lt;span style="color:#f92672">,&lt;/span> 8&lt;span style="color:#f92672">,&lt;/span> 25&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>date&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getYear&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">// Calendar是日期/时间类。java建议使用Calendar取代Date表示“日期/时间”
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">testCalendar&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Calendar cal &lt;span style="color:#f92672">=&lt;/span> Calendar&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getInstance&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>cal&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Calendar&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">YEAR&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
getString1&lt;span style="color:#f92672">();&lt;/span>
getString2&lt;span style="color:#f92672">();&lt;/span>
testDate&lt;span style="color:#f92672">();&lt;/span>
testCalendar&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：
上面是eclipse中的截图，比较类中 “getString1() 和 getString2()” 以及 “testDate() 和 testCalendar()” 。&lt;/p>
&lt;p>(01) getString1() 被@Deprecated标注，意味着建议不再使用getString1()；所以getString1()的定义和调用时，都会一横线。这一横线是eclipse()对@Deprecated方法的处理。
getString2() 没有被@Deprecated标注，它的显示正常。&lt;/p>
&lt;p>(02) testDate() 调用了Date的相关方法，而java已经建议不再使用Date操作日期/时间。因此，在调用Date的API时，会产生警告信息，途中的warnings。
testCalendar() 调用了Calendar的API来操作日期/时间，java建议用Calendar取代Date。因此，操作Calendar不回产生warning。&lt;/p>
&lt;h4 id="inherited">@Inherited&lt;/h4>
&lt;p>@Inherited 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Documented&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ElementType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">ANNOTATION_TYPE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> Inherited &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：
(01) @interface &amp;ndash; 它的用来修饰Inherited，意味着Inherited实现了java.lang.annotation.Annotation接口；即Inherited就是一个注解。
(02) @Documented &amp;ndash; 它的作用是说明该注解能出现在javadoc中。
(03) @Retention(RetentionPolicy.RUNTIME) &amp;ndash; 它的作用是指定Inherited的策略是RetentionPolicy.RUNTIME。这就意味着，编译器会将Inherited的信息保留在.class文件中，并且能被虚拟机读取。
(04) @Target(ElementType.ANNOTATION_TYPE) &amp;ndash; 它的作用是指定Inherited的类型是ANNOTATION_TYPE。这就意味着，@Inherited只能被用来标注“Annotation类型”。
(05) @Inherited 的含义是，它所标注的Annotation将具有继承性。
假设，我们定义了某个Annotaion，它的名称是MyAnnotation，并且MyAnnotation被标注为@Inherited。现在，某个类Base使用了MyAnnotation，则Base具有了“具有了注解MyAnnotation”；现在，Sub继承了Base，由于MyAnnotation是@Inherited的(具有继承性)，所以，Sub也“具有了注解MyAnnotation”。&lt;/p>
&lt;p>@Inherited的使用示例
&lt;strong>源码如下&lt;/strong>(InheritableSon.java)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @Inherited 演示示例
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @author skywang
&lt;/span>&lt;span style="color:#75715e"> * @email kuiwu-wang@163.com
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#f92672">package&lt;/span> com.skywang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Target&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.ElementType&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Retention&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.RetentionPolicy&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Inherited&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 自定义的Annotation。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ElementType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">TYPE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Inherited&lt;/span>
&lt;span style="color:#a6e22e">@interface&lt;/span> Inheritable
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Inheritable&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InheritableFather&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">InheritableFather&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">// InheritableBase是否具有 Inheritable Annotation
&lt;/span>&lt;span style="color:#75715e">&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;InheritableFather:&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>InheritableFather&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isAnnotationPresent&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Inheritable&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * InheritableSon 类只是继承于 InheritableFather，
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InheritableSon&lt;/span> &lt;span style="color:#66d9ef">extends&lt;/span> InheritableFather
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">InheritableSon&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">super&lt;/span>&lt;span style="color:#f92672">();&lt;/span> &lt;span style="color:#75715e">// 调用父类的构造函数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// InheritableSon类是否具有 Inheritable Annotation
&lt;/span>&lt;span style="color:#75715e">&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;InheritableSon:&amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>InheritableSon&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isAnnotationPresent&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Inheritable&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
InheritableSon is &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InheritableSon&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>运行结果&lt;/strong>：&lt;/p>
&lt;p>InheritableFather:true
InheritableSon:true&lt;/p>
&lt;p>现在，我们对InheritableSon.java进行修改：&lt;strong>注释掉“Inheritable的@Inherited注解”&lt;/strong>。
源码的修改部分如下(InheritableSon.java)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 自定义的Annotation。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ElementType&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">TYPE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#75715e">//@Inherited
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">@interface&lt;/span> Inheritable
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>运行结果&lt;/strong>：&lt;/p>
&lt;p>InheritableFather:true
InheritableSon:false&lt;/p>
&lt;p>对比上面的两个结果，我们发现：当注解Inheritable被@Inherited标注时，它具有继承性。否则，没有继承性。&lt;/p>
&lt;h4 id="suppresswarnings">@SuppressWarnings&lt;/h4>
&lt;p>@SuppressWarnings 的定义如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#a6e22e">@Target&lt;/span>&lt;span style="color:#f92672">({&lt;/span>TYPE&lt;span style="color:#f92672">,&lt;/span> FIELD&lt;span style="color:#f92672">,&lt;/span> METHOD&lt;span style="color:#f92672">,&lt;/span> PARAMETER&lt;span style="color:#f92672">,&lt;/span> CONSTRUCTOR&lt;span style="color:#f92672">,&lt;/span> LOCAL_VARIABLE&lt;span style="color:#f92672">})&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">SOURCE&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">@interface&lt;/span> SuppressWarnings &lt;span style="color:#f92672">{&lt;/span>
String&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>说明&lt;/strong>：
(01) @interface &amp;ndash; 它的用来修饰SuppressWarnings，意味着SuppressWarnings实现了java.lang.annotation.Annotation接口；即SuppressWarnings就是一个注解。
(02) @Retention(RetentionPolicy.SOURCE) &amp;ndash; 它的作用是指定SuppressWarnings的策略是RetentionPolicy.SOURCE。这就意味着，SuppressWarnings信息仅存在于编译器处理期间，编译器处理完之后SuppressWarnings就没有作用了。
(03) @Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE}) &amp;ndash; 它的作用是指定SuppressWarnings的类型同时包括TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE。
TYPE意味着，它能标注“类、接口（包括注释类型）或枚举声明”。
FIELD意味着，它能标注“字段声明”。
METHOD意味着，它能标注“方法”。
PARAMETER意味着，它能标注“参数”。
CONSTRUCTOR意味着，它能标注“构造方法”。
LOCAL_VARIABLE意味着，它能标注“局部变量”。
(04) String[] value(); 意味着，SuppressWarnings能指定参数
(05) SuppressWarnings 的作用是，让编译器对“它所标注的内容”的某些警告保持静默。例如，&amp;quot;@SuppressWarnings(value={&amp;ldquo;deprecation&amp;rdquo;, &amp;ldquo;unchecked&amp;rdquo;})&amp;quot; 表示对“它所标注的内容”中的 “SuppressWarnings不再建议使用警告”和“未检查的转换时的警告”保持沉默。示例如下：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28133438-ba03c958e2c047a08d150d9abe298b73.jpg" alt="img">&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28133459-3f430d51736d44edb17ada87e4398808.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>说明&lt;/strong>：
(01) 左边的图中，没有使用 @SuppressWarnings(value={&amp;ldquo;deprecation&amp;rdquo;}) , 而Date属于java不再建议使用的类。因此，调用Date的API时，会产生警告。
而右边的途中，使用了 @SuppressWarnings(value={&amp;ldquo;deprecation&amp;rdquo;})。因此，编译器对“调用Date的API产生的警告”保持沉默。&lt;/p>
&lt;p>补充：&lt;strong>SuppressWarnings 常用的关键字的表格&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">deprecation &lt;span style="color:#f92672">--&lt;/span> 使用了不赞成使用的类或方法时的警告
unchecked &lt;span style="color:#f92672">--&lt;/span> 执行了未检查的转换时的警告&lt;span style="color:#960050;background-color:#1e0010">，&lt;/span>例如当使用集合时没有用泛型 &lt;span style="color:#f92672">(&lt;/span>Generics&lt;span style="color:#f92672">)&lt;/span> 来指定集合保存的类型&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
fallthrough &lt;span style="color:#f92672">--&lt;/span> 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
path &lt;span style="color:#f92672">--&lt;/span> 在类路径&lt;span style="color:#960050;background-color:#1e0010">、&lt;/span>源文件路径等中有不存在的路径时的警告&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
serial &lt;span style="color:#f92672">--&lt;/span> 当在可序列化的类上缺少 serialVersionUID 定义时的警告&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;span style="color:#66d9ef">finally&lt;/span> &lt;span style="color:#f92672">--&lt;/span> 任何 &lt;span style="color:#66d9ef">finally&lt;/span> 子句不能正常完成时的警告&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
all &lt;span style="color:#f92672">--&lt;/span> 关于以上所有情况的警告&lt;span style="color:#960050;background-color:#1e0010">。&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="annotation-的作用">Annotation 的作用&lt;/h2>
&lt;p>Annotation 是一个辅助类，它在Junit、Struts、Spring等工具框架中被广泛使用。&lt;/p>
&lt;p>我们在编程中经常会使用到的Annotation作用有：&lt;/p>
&lt;h3 id="编译检查">编译检查&lt;/h3>
&lt;p>Annotation具有“让编译器进行编译检查的作用”。&lt;/p>
&lt;p>例如，@SuppressWarnings, @Deprecated和@Override都具有编译检查作用。
(01) 关于@SuppressWarnings和@Deprecated，已经在“第3部分”中详细介绍过了。这里就不再举例说明了。
(02) 若某个方法被 @Override的 标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被@Override标示，但父类中却没有“被@Override标注”的同名方法，则编译器会报错。示例如下：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/28134305-4722f5184b1d4cc0aac2c0d1223c0fcb.jpg" alt="img">&lt;/p>
&lt;p>&lt;strong>源码&lt;/strong>(OverrideTest.java):&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.skywang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @Override测试程序
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @author skywang
&lt;/span>&lt;span style="color:#75715e"> * @email kuiwu-wang@163.com
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">OverrideTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * toString() 在java.lang.Object中定义；
&lt;/span>&lt;span style="color:#75715e"> * 因此，这里用 @Override 标注是对的。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Override toString&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * getString() 没有在OverrideTest的任何父类中定义；
&lt;/span>&lt;span style="color:#75715e"> * 但是，这里却用 @Override 标注，因此会产生编译错误！
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">getString&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;get toString&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面是该程序在eclipse中的截图。从中，我们可以发现“getString()”函数会报错。这是因为“getString() 被@Override所标注，但在OverrideTest的任何父类中都没有定义getString1()函数”。
“将getString() 上面的@Override注释掉”，即可解决该错误。&lt;/p>
&lt;h3 id="在反射中使用annotation">在反射中使用Annotation&lt;/h3>
&lt;p>在反射的Class, Method, Field等函数中，有许多于Annotation相关的接口。
这也意味着，我们可以在反射中解析并使用Annotation。&lt;/p>
&lt;p>&lt;strong>源码如下&lt;/strong>(AnnotationTest.java)：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.skywang.annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Annotation&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Target&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.ElementType&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Retention&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.RetentionPolicy&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.annotation.Inherited&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.lang.reflect.Method&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * Annotation在反射函数中的使用示例
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @author skywang
&lt;/span>&lt;span style="color:#75715e"> * @email kuiwu-wang@163.com
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@Retention&lt;/span>&lt;span style="color:#f92672">(&lt;/span>RetentionPolicy&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">RUNTIME&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#a6e22e">@interface&lt;/span> MyAnnotation &lt;span style="color:#f92672">{&lt;/span>
String&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#66d9ef">default&lt;/span> &lt;span style="color:#e6db74">&amp;#34;unknown&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * Person类。它会使用MyAnnotation注解。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Person&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * empty()方法同时被 &amp;#34;@Deprecated&amp;#34; 和 “@MyAnnotation(value={&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;})”所标注
&lt;/span>&lt;span style="color:#75715e"> * (01) @Deprecated，意味着empty()方法，不再被建议使用
&lt;/span>&lt;span style="color:#75715e"> * (02) @MyAnnotation, 意味着empty() 方法对应的MyAnnotation的value值是默认值&amp;#34;unknown&amp;#34;
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@MyAnnotation&lt;/span>
&lt;span style="color:#a6e22e">@Deprecated&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">empty&lt;/span>&lt;span style="color:#f92672">(){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\nempty&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * sombody() 被 @MyAnnotation(value={&amp;#34;girl&amp;#34;,&amp;#34;boy&amp;#34;}) 所标注，
&lt;/span>&lt;span style="color:#75715e"> * @MyAnnotation(value={&amp;#34;girl&amp;#34;,&amp;#34;boy&amp;#34;}), 意味着MyAnnotation的value值是{&amp;#34;girl&amp;#34;,&amp;#34;boy&amp;#34;}
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#a6e22e">@MyAnnotation&lt;/span>&lt;span style="color:#f92672">(&lt;/span>value&lt;span style="color:#f92672">={&lt;/span>&lt;span style="color:#e6db74">&amp;#34;girl&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#e6db74">&amp;#34;boy&amp;#34;&lt;/span>&lt;span style="color:#f92672">})&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">somebody&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String name&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> age&lt;span style="color:#f92672">){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\nsomebody: &amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>name&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#f92672">+&lt;/span>age&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">AnnotationTest&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> Exception &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">// 新建Person
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Person person &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Person&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">// 获取Person的Class实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Class&lt;span style="color:#f92672">&amp;lt;&lt;/span>Person&lt;span style="color:#f92672">&amp;gt;&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> Person&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">// 获取 somebody() 方法的Method实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Method mSomebody &lt;span style="color:#f92672">=&lt;/span> c&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getMethod&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;somebody&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Class&lt;span style="color:#f92672">[]{&lt;/span>String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">});&lt;/span>
&lt;span style="color:#75715e">// 执行该方法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> mSomebody&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">invoke&lt;/span>&lt;span style="color:#f92672">(&lt;/span>person&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object&lt;span style="color:#f92672">[]{&lt;/span>&lt;span style="color:#e6db74">&amp;#34;lily&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> 18&lt;span style="color:#f92672">});&lt;/span>
iteratorAnnotations&lt;span style="color:#f92672">(&lt;/span>mSomebody&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">// 获取 somebody() 方法的Method实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Method mEmpty &lt;span style="color:#f92672">=&lt;/span> c&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getMethod&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;empty&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Class&lt;span style="color:#f92672">[]{});&lt;/span>
&lt;span style="color:#75715e">// 执行该方法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> mEmpty&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">invoke&lt;/span>&lt;span style="color:#f92672">(&lt;/span>person&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Object&lt;span style="color:#f92672">[]{});&lt;/span>
iteratorAnnotations&lt;span style="color:#f92672">(&lt;/span>mEmpty&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">iteratorAnnotations&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Method method&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">// 判断 somebody() 方法是否包含MyAnnotation注解
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>method&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isAnnotationPresent&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MyAnnotation&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">)){&lt;/span>
&lt;span style="color:#75715e">// 获取该方法的MyAnnotation注解实例
&lt;/span>&lt;span style="color:#75715e">&lt;/span> MyAnnotation myAnnotation &lt;span style="color:#f92672">=&lt;/span> method&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getAnnotation&lt;/span>&lt;span style="color:#f92672">(&lt;/span>MyAnnotation&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">class&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">// 获取 myAnnotation的值，并打印出来
&lt;/span>&lt;span style="color:#75715e">&lt;/span> String&lt;span style="color:#f92672">[]&lt;/span> values &lt;span style="color:#f92672">=&lt;/span> myAnnotation&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>String str&lt;span style="color:#f92672">:&lt;/span>values&lt;span style="color:#f92672">)&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">printf&lt;/span>&lt;span style="color:#f92672">(&lt;/span>str&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;, &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">// 获取方法上的所有注解，并打印出来
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Annotation&lt;span style="color:#f92672">[]&lt;/span> annotations &lt;span style="color:#f92672">=&lt;/span> method&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getAnnotations&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Annotation annotation &lt;span style="color:#f92672">:&lt;/span> annotations&lt;span style="color:#f92672">){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>annotation&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>运行结果&lt;/strong>：
somebody: lily, 18
girl, boy,
@com.skywang.annotation.MyAnnotation(value=[girl, boy])&lt;/p>
&lt;p>empty
unknown,
@com.skywang.annotation.MyAnnotation(value=[unknown])
@java.lang.Deprecated()&lt;/p>
&lt;h3 id="根据annotation生成帮助文档">根据Annotation生成帮助文档&lt;/h3>
&lt;p>通过给Annotation注解加上@Documented标签，能使该Annotation标签出现在javadoc中。&lt;/p>
&lt;h3 id="能够帮忙查看查看代码">能够帮忙查看查看代码&lt;/h3>
&lt;p>通过@Override, @Deprecated等，我们能很方便的了解程序的大致结构。
另外，我们也可以通过自定义Annotation来实现一些功能。&lt;/p></description></item><item><title>Java开发技能需求</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E9%9C%80%E6%B1%82/</link><pubDate>Tue, 05 Jan 2021 11:02:34 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E9%9C%80%E6%B1%82/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="java开发技能需求待掌握技能">Java开发技能需求（待掌握技能）&lt;/h1>
&lt;p>参考：BOSS直聘招聘需求&lt;/p>
&lt;p>常用Java中间件&lt;/p>
&lt;p>dubbo，分布式缓存，消息队列&lt;/p>
&lt;p>redis，kafka，zookeeper，etcd&lt;/p>
&lt;p>大数据：Hadoop，spark，flink&lt;/p>
&lt;p>Spring，SpringBoot，SpringCloud&lt;/p>
&lt;p>分布式数据库：DRDS，oceanBase，ShardingSphere&lt;/p>
&lt;p>docker，CI，CD工具&lt;/p>
&lt;p>maven，gradle&lt;/p>
&lt;p>Java多线程、缓存、安全&lt;/p>
&lt;p>HTTP、Rest相关概念&lt;/p>
&lt;p>VUE，REAT&lt;/p>
&lt;h1 id="java生态圈技术框架中间件系统架构汇总">Java生态圈技术框架、中间件、系统架构汇总&lt;/h1>
&lt;p>参考：&lt;a href="https://juejin.cn/post/6844903620979212296">Java生态圈技术框架、中间件、系统架构汇总&lt;/a>&lt;/p></description></item><item><title>概率论与数理统计-数理统计-假设检验</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</link><pubDate>Tue, 22 Dec 2020 22:58:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-数理统计-假设检验">概率论与数理统计-数理统计-假设检验&lt;/h1>
&lt;p>除了对总体的参数的估计外，统计推断的另一类重要问题是假设检验问题。 在总体的1）&lt;strong>分布函数完全未知&lt;/strong>或2）&lt;strong>只知其形式、但不知其参数&lt;/strong>的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。 例如，提出总体服从泊松分布的假设，又如，对于正态总体提出数学期望等于&lt;span class="math inline">\(\mu_{0}\)&lt;/span>的假设等。 我们要&lt;strong>根据样本对所提出的假设作出是接受，还是拒绝的决策，假设检验是作出这一决策的过程&lt;/strong>。这里，先结合例子来说明假设检验的基本思想和做法。&lt;/p>
&lt;h2 id="假设检验">假设检验&lt;/h2>
&lt;h3 id="假设检验的引入">假设检验的引入&lt;/h3>
&lt;h4 id="例子">例子&lt;/h4>
&lt;p>例 1 某车间用一台包装机包装葡萄糖. &lt;strong>袋装糖的净重&lt;/strong>是一个随机变量,它 服从&lt;strong>正态分布.&lt;/strong> 当机器&lt;strong>正常时&lt;/strong>,其&lt;strong>均值&lt;/strong>为 0.5 kg,&lt;strong>标准差&lt;/strong>为 0.015 kg. 某日开工后为检验包装机是否正常,随机地&lt;strong>抽取&lt;/strong>它所包装的糖 9 袋,称得净重为 &lt;span class="math inline">\((\mathrm{kg})\)&lt;/span>： &lt;span class="math inline">\(\begin{array}{llllllll}0.497 &amp;amp; 0.506 &amp;amp; 0.518 &amp;amp; 0.524 &amp;amp; 0.498 &amp;amp; 0.511 &amp;amp; 0.520 &amp;amp; 0.515 &amp;amp; 0.512\end{array}\)&lt;/span> 问机器是否正常?&lt;/p>
&lt;p>也就是问，根据抽取的样本，可不可以判断正态总体&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span> 的分布为&lt;span class="math inline">\(X\sim N(0.5,0.015^2)\)&lt;/span>? 这里以 &lt;span class="math inline">\(\mu, \sigma\)&lt;/span> 分别表示这一天袋装糖的净重总体 &lt;span class="math inline">\(X\)&lt;/span> 的均值和标准差. 由于长期实践表明标准差比较稳定,我们就设 &lt;span class="math inline">\(\sigma=0.015 .\)&lt;/span> （也就是作了简化，只检验均值）。 于是 &lt;span class="math inline">\(X \sim N\left(\mu, 0.015^{2}\right),\)&lt;/span> 这里 &lt;span class="math inline">\(\mu\)&lt;/span> 未 知. 问题是根据样本值来判断 &lt;span class="math inline">\(\mu=0.5\)&lt;/span> 还是 &lt;span class="math inline">\(\mu \neq 0.5 .\)&lt;/span> 为此,我们提出两个相互对立的&lt;strong>假设&lt;/strong>&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}=0.5\)&lt;/span>和&lt;span class="math inline">\(H_{1}: \mu \neq \mu_{0}\)&lt;/span> 然后,我们&lt;strong>给出一个合理的法则，根据这一法则，利用已知样本作出决策&lt;/strong>： 是接受假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> (即拒绝假设 &lt;span class="math inline">\(H_{1}\)&lt;/span> ) ,还是拒绝假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> (即接受假设 &lt;span class="math inline">\(H_{1}\)&lt;/span> ). 如果作出的决策是接受 &lt;span class="math inline">\(H_{0},\)&lt;/span> 则认为 &lt;span class="math inline">\(\mu=\mu_{0}\)&lt;/span>, 即认为机器工作是正常的,否则，则认为是不正常的.&lt;/p>
&lt;p>&lt;strong>检验法则的推导&lt;/strong>过程： 由于要检验的假设涉及总体均值 &lt;span class="math inline">\(\mu\)&lt;/span>,故首先想到是否可借助样本均值 &lt;span class="math inline">\(\bar{X}\)&lt;/span> 这 一统计量来进行判断. 我们知道, &lt;span class="math inline">\(\bar{X}\)&lt;/span> 是 &lt;span class="math inline">\(\mu\)&lt;/span> 的无偏估计, &lt;span class="math inline">\(\bar{X}\)&lt;/span> 的观察值 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 的大小在一 定程度上反映 &lt;span class="math inline">\(\mu\)&lt;/span> 的大小. 因此,如果假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真,则观察值 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 与 &lt;span class="math inline">\(\mu_{0}\)&lt;/span> 的偏差 &lt;span class="math inline">\(\left|\bar{x}-\mu_{0}\right|\)&lt;/span> 一般不应太大. 若 &lt;span class="math inline">\(\left|\bar{x}-\mu_{0}\right|\)&lt;/span> 过分大,我们就怀疑假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的正确性而拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>。 考虑到当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} \sim N(0,1) .\)&lt;/span> 而衡量 &lt;span class="math inline">\(\left|\bar{x}-\mu_{0}\right|\)&lt;/span> 的大小可归结为衡量&lt;span class="math inline">\(\frac{\left|\bar{x}-\mu_{0}\right|}{\sigma / \sqrt{n}}\)&lt;/span> 的大小. 基于上面的想法,我们可适当选定一正数 &lt;span class="math inline">\(k,\)&lt;/span> 使当观察值 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 满足&lt;span class="math inline">\(\frac{\left|\bar{x}-\mu_{0}\right|}{\sigma / \sqrt{n}} \geqslant k\)&lt;/span> 时就拒绝假设 &lt;span class="math inline">\(H_{0},\)&lt;/span> 反之,若 &lt;span class="math inline">\(\frac{\left|\bar{x}-\mu_{0}\right|}{\sigma / \sqrt{n}}&amp;lt;k,\)&lt;/span> 就接受假设 &lt;span class="math inline">\(H_{0} .\)&lt;/span>&lt;/p>
&lt;p>然而,由于&lt;strong>作出决策的依据是一个样本&lt;/strong>,当实际上 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时仍可能作出拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的决策(这种可能性是无法消除的)，这是一种错误（弃真错误）,犯这种错误的概率记为 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad P_{\mu_{0}}\left\{\right.\)&lt;/span> 拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad P_{\mu \in H_{0}}\left\{\right.\)&lt;/span> 拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}\)&lt;/span> 或 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 拒绝&lt;span class="math inline">\(H_0\)&lt;/span> | 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(\left.\right\} \quad\)&lt;/span>&lt;/p>
&lt;p>我们&lt;strong>无法排除犯这类错误的可能性&lt;/strong>,因此自然希望将犯这类错误的概率控制在一定限度之内,即给出一个较小的数 &lt;span class="math inline">\(\alpha \quad(0&amp;lt;\alpha&amp;lt;1)\)&lt;/span>,使犯 这类错误的概率不超过 &lt;span class="math inline">\(\alpha\)&lt;/span>, 即使得：&lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \leqslant \alpha .\)&lt;/span>&lt;/p>
&lt;p>为了确定常数 &lt;span class="math inline">\(k,\)&lt;/span> 我们考虑统计量 &lt;span class="math inline">\(\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} .\)&lt;/span> 由于只允许犯这类错误的概率最大为 &lt;span class="math inline">\(\alpha\)&lt;/span>,令上面不等式右端取等号,即令： &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{\mu_{0}}\left\{\left|\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant k\right\}=\alpha\)&lt;/span> 由于当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(, Z=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} \sim N(0,1),\)&lt;/span> 由标准正态分布分位点的定义得&lt;span class="math inline">\(k=z_{\alpha / 2}\)&lt;/span> 因而,若 &lt;span class="math inline">\(Z\)&lt;/span> 的观察值满足&lt;span class="math inline">\(|z|=\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant k=z_{a / 2}\)&lt;/span>则拒绝 &lt;span class="math inline">\(H_{0},\)&lt;/span> 而若&lt;span class="math inline">\(|z|=\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right|&amp;lt;k=z_{\alpha / 2}\)&lt;/span>则接受 &lt;span class="math inline">\(H_{0}\)&lt;/span>. &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201222233752219.png" alt="image-20201222233752219" />&lt;/p>
&lt;h4 id="实际推断原理小概率事件原理与反证法思想">实际推断原理（小概率事件原理）与反证法思想&lt;/h4>
&lt;p>小概率事件原理：认为概率很小的事件在一次试验中时不会发生的。由此，如果小概率事件发生了，我们就认为发生了不合理的现象。&lt;/p>
&lt;p>上例中所采用的检验法则是符合实际推断原理的. 因通常 &lt;span class="math inline">\(\alpha\)&lt;/span> 总是取得较小，一般取 &lt;span class="math inline">\(\alpha=0.01,0.05 .\)&lt;/span> 因而若 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真, 即当 &lt;span class="math inline">\(\mu=\mu_{0}\)&lt;/span> 时 &lt;span class="math inline">\(,\left\{\left|\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant z_{\alpha / 2}\right\}\)&lt;/span> 是一个小概率事件, 根据实际推断原理,就可以认为,如果 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真,则由一次试验得到 的观察值 &lt;span class="math inline">\(\bar{x},\)&lt;/span> 满足不等式 &lt;span class="math inline">\(\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant z_{a / 2}\)&lt;/span> 几乎是不会发生的. 现在在一次观察中竟然出现了满足 &lt;span class="math inline">\(\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant z_{\alpha / 2}\)&lt;/span> 的 &lt;span class="math inline">\(\bar{x},\)&lt;/span> 则我们有理由怀疑原来的假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的正确性，因而拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> （也运用反证法的思想） 若出现的观察值 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 满足 &lt;span class="math inline">\(\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right|&amp;lt;z_{\alpha / 2},\)&lt;/span> 此时没有理由拒绝假设&lt;span class="math inline">\(H_{0},\)&lt;/span> 因此只能接受假设 &lt;span class="math inline">\(H_{0} .\)&lt;/span>&lt;/p>
&lt;h3 id="假设检验问题">假设检验问题&lt;/h3>
&lt;p>前面的检验问题通常叙述成: 在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下,检验假设&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}, \quad H_{1}: \mu \neq \mu_{0}\)&lt;/span> 也常说成 “在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下,针对 &lt;span class="math inline">\(H_{1}\)&lt;/span> 检验 &lt;span class="math inline">\(H_{0}\)&lt;/span>” . &lt;span class="math inline">\(H_{0}\)&lt;/span> 称为&lt;strong>原假设&lt;/strong>或零假设 &lt;span class="math inline">\(, H_{1}\)&lt;/span> 称为&lt;strong>备择假设&lt;/strong>(意指在原假设被拒绝后可供选择的假设).&lt;/p>
&lt;pre class="flow">&lt;code>开始=&amp;gt;start: 开始
结束=&amp;gt;end: 结束
提出假设=&amp;gt;operation: 提出假设 H0,H1
取定显著性水平=&amp;gt;operation: 取定显著性水平α
选取检验统计量=&amp;gt;operation: 选取检验统计量（分布）
检验（检验法则）=&amp;gt;subroutine: 检验（检验法则）
开始-&amp;gt;提出假设-&amp;gt;取定显著性水平-&amp;gt;选取检验统计量-&amp;gt;检验（检验法则）-&amp;gt;结束
&lt;/code>&lt;/pre>
&lt;pre class="flow">&lt;code>substart=&amp;gt;start: 检验开始（检验法则）
subend=&amp;gt;end: 结束检验
检验统计量的值在拒绝域=&amp;gt;condition: 检验统计量的值在显著性水平α确定的拒绝域？
拒绝H0（接受H1）=&amp;gt;operation: 拒绝H0（接受H1）
拒绝H1（接受H0）=&amp;gt;operation: 拒绝H1（接受H0）
substart-&amp;gt;检验统计量的值在拒绝域(yes)-&amp;gt;拒绝H0（接受H1）-&amp;gt;subend
substart-&amp;gt;检验统计量的值在拒绝域(no)-&amp;gt;拒绝H1（接受H0）-&amp;gt;subend&lt;/code>&lt;/pre>
&lt;h4 id="显著性水平alpha">显著性水平&lt;span class="math inline">\(\alpha\)&lt;/span>&lt;/h4>
&lt;p>在前面的例子中，我们看到当样本容量固定时,选定 &lt;span class="math inline">\(\alpha\)&lt;/span> 后,数 &lt;span class="math inline">\(k\)&lt;/span> 就可以确定， 然后按照统计量 &lt;span class="math inline">\(Z=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\)&lt;/span> 的观察值的绝对值 &lt;span class="math inline">\(|z|\)&lt;/span> 大于等于 &lt;span class="math inline">\(k\)&lt;/span> 还是小于 &lt;span class="math inline">\(k\)&lt;/span> 来作出决策. 数 &lt;span class="math inline">\(k\)&lt;/span> 是检验上述假设的一个&lt;strong>门槛值&lt;/strong>. 如果 &lt;span class="math inline">\(|z|=\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant k,\)&lt;/span> 则称 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 与 &lt;span class="math inline">\(\mu_{0}\)&lt;/span>的&lt;strong>差异是显著的&lt;/strong>,这时&lt;strong>拒绝&lt;/strong> &lt;span class="math inline">\(H_{0}\)&lt;/span>; 反之, 如果 &lt;span class="math inline">\(|z|=\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right|&amp;lt;k,\)&lt;/span> 则称 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 与 &lt;span class="math inline">\(\mu_{0}\)&lt;/span> 的&lt;strong>差异是不显著的&lt;/strong>,这时&lt;strong>接受&lt;/strong> &lt;span class="math inline">\(H_{0}\)&lt;/span>. 数 &lt;span class="math inline">\(\alpha\)&lt;/span> 称为（差异的）&lt;strong>显著性水平&lt;/strong>,上面关于 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 与 &lt;span class="math inline">\(\mu_{0}\)&lt;/span> 有无显著差异的判断是在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 之下作出的.&lt;/p>
&lt;h4 id="检验统计量">检验统计量&lt;/h4>
&lt;p>统计量 &lt;span class="math inline">\(Z=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\)&lt;/span> 称为&lt;strong>检验统计量&lt;/strong>.&lt;/p>
&lt;h4 id="假设检验的类别">假设检验的类别&lt;/h4>
&lt;p>形如&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}, \quad H_{1}: \mu \neq \mu_{0}\)&lt;/span>中的备择假设 &lt;span class="math inline">\(H_{1},\)&lt;/span> 表示 &lt;span class="math inline">\(\mu\)&lt;/span> 可能大于 &lt;span class="math inline">\(\mu_{0},\)&lt;/span> 也可能小于 &lt;span class="math inline">\(\mu_{0}\)&lt;/span>,称为&lt;strong>双边备择假设&lt;/strong>,而称形如&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}, \quad H_{1}: \mu \neq \mu_{0}\)&lt;/span>的假设检验为&lt;strong>双边假设检验&lt;/strong>.&lt;/p>
&lt;p>有时,我们只关心总体均值是否增大,例如,试验新工艺以提高材料的强度. 这时,所考虑的总体的均值应该越大越好. 如果我们能判断在新工艺下总体均值 较以往正常生产的大,则可考虑采用新工艺. 此时，我们需要检验（右边）假设&lt;span class="math inline">\(H_{0}: \mu \leqslant \mu_{0}, \quad H_{1}: \mu&amp;gt;\mu_{0}\)&lt;/span>，这样的假设检验,称为&lt;strong>右边检验&lt;/strong>.&lt;/p>
&lt;p>类似的，有时候我们需要检验（左边）假设&lt;span class="math inline">\(H_{0}: \mu \geqslant \mu_{0}, \quad H_{1}: \mu&amp;lt;\mu_{0}\)&lt;/span>，这样的假设检验,称为&lt;strong>左边检验&lt;/strong>.&lt;/p>
&lt;h4 id="拒绝域">拒绝域&lt;/h4>
&lt;p>在前面的例子中，是在&lt;strong>假设&lt;/strong>&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}=0.5\)&lt;/span>和&lt;span class="math inline">\(H_{1}: \mu \neq \mu_{0}\)&lt;/span>下的假设检验， 若 &lt;span class="math inline">\(Z\)&lt;/span> 的观察值满足&lt;span class="math inline">\(|z|=\left|\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}}\right| \geqslant k=z_{a / 2}\)&lt;/span>则拒绝 &lt;span class="math inline">\(H_{0},\)&lt;/span> 即&lt;span class="math inline">\(\bar{x} \geqslant \mu_{0}+\frac{\sigma}{\sqrt{n}} z_{\alpha/2}\)&lt;/span>或&lt;span class="math inline">\(\bar{x} \leqslant \mu_{0}-\frac{\sigma}{\sqrt{n}} z_{\alpha/2}\)&lt;/span> 这两个区间称为拒绝域。（双边假设检验的拒绝域）&lt;/p>
&lt;blockquote>
&lt;p>还可以讨论单边假设检验的拒绝域： 设总体 &lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right), \mu\)&lt;/span> 未知、 &lt;span class="math inline">\(\sigma\)&lt;/span> 为已知 &lt;span class="math inline">\(, X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本. 给 定显著性水平 &lt;span class="math inline">\(\alpha .\)&lt;/span> 我们来求检验问题 &lt;span class="math inline">\(H_{0}: \mu \leqslant \mu_{0}, \quad H_{1}: \mu&amp;gt;\mu_{0}\)&lt;/span>的拒绝域。 因 &lt;span class="math inline">\(H_{0}\)&lt;/span> 中的全部 &lt;span class="math inline">\(\mu\)&lt;/span> 都比 &lt;span class="math inline">\(H_{1}\)&lt;/span> 中的 &lt;span class="math inline">\(\mu\)&lt;/span> 要小,当 &lt;span class="math inline">\(H_{1}\)&lt;/span> 为真时,观察值 &lt;span class="math inline">\(\bar{x}\)&lt;/span> 往往偏大， 因此,拒绝域的形式为&lt;span class="math inline">\(\bar{x} \geqslant k \quad(k\)&lt;/span> 是某一正常数 &lt;span class="math inline">\() .\)&lt;/span> 下面来确定常数 &lt;span class="math inline">\(k\)&lt;/span> ， &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{\mu \in H_{0}}\{\bar{X} \geqslant k\}\)&lt;/span> &lt;span class="math display">\[
\begin{array}{l}
=P_{\mu \leqslant \mu_{0}}\left\{\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} \geqslant \frac{k-\mu_{0}}{\sigma / \sqrt{n}}\right\} \\
\leqslant P_{\mu \leqslant \mu_{0}}\left\{\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \geqslant \frac{k-\mu_{0}}{\sigma / \sqrt{n}}\right\}
\end{array}
\]&lt;/span> &lt;span class="math inline">\(\left(\right.\)&lt;/span> 上式不等号成立是由于 &lt;span class="math inline">\(\mu \leqslant \mu_{0}, \frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \geqslant \frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}},\)&lt;/span> 事件 &lt;span class="math inline">\(\left\{\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}} \geqslant \frac{k-\mu_{0}}{\sigma / \sqrt{n}}\right\} \subset\left\{\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \geqslant\right.\)&lt;/span>&lt;span class="math inline">\(\left.\left.\frac{k-\mu_{0}}{\sigma / \sqrt{n}}\right\}\right) .\)&lt;/span> &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \leqslant \alpha,\)&lt;/span> 只需令&lt;span class="math inline">\(P_{\mu \leqslant \mu_{0}}\left\{\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \geqslant \frac{k-\mu_{0}}{\sigma / \sqrt{n}}\right\}=\alpha\)&lt;/span>， 又由于 &lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)\)&lt;/span>， &lt;span class="math inline">\(\frac{k-\mu_{0}}{\sigma / \sqrt{n}}=\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{z}_{\boldsymbol{\alpha}}\)&lt;/span>，&lt;span class="math inline">\(k=\mu_{0}+\frac{\sigma}{\sqrt{n}} z_{a}\)&lt;/span>， 即得此右边检验的拒绝域为&lt;span class="math inline">\(\bar{x} \geqslant \mu_{0}+\frac{\sigma}{\sqrt{n}} z_{a}\)&lt;/span> 即&lt;span class="math inline">\(z=\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}} \geqslant z_{\alpha}\)&lt;/span>&lt;/p>
&lt;p>同理可得左边检验问题&lt;span class="math inline">\(H_{0}: \mu \geqslant \mu_{0}, \quad H_{1}: \mu&amp;lt;\mu_{0}\)&lt;/span>的拒绝域为&lt;span class="math inline">\(z=\frac{\bar{x}-\mu_{0}}{\sigma / \sqrt{n}} \leqslant-z_{\alpha}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="显著性检验">显著性检验&lt;/h4>
&lt;p>在确定检验法则时,我们应尽可能使犯&lt;a href="#错误决策">两类错误&lt;/a>的概率都较小.但是， 进一步讨论可知,一般来说,当样本容量固定时,若减少犯一类错误的概率,则犯 另一类错误的概率往往增大. 若要使犯两类错误的概率都减小,除非增加样本容 量.&lt;/p>
&lt;p>在给定样本容量的情况下，一般来说,我们&lt;strong>总是控制犯第 I 类错误的概率,使 它不大于&lt;/strong> &lt;span class="math inline">\(\alpha .\)&lt;/span> 即&lt;span class="math inline">\(P\left\{\text{当}H_{0}\text{为真时拒绝}H_{0}\right\} =\)&lt;/span> &lt;span class="math inline">\(P_{\mu \in H_{0}}\left\{\text{拒绝}H_{0}\right\} \leqslant \alpha\)&lt;/span> &lt;span class="math inline">\(\alpha\)&lt;/span> 的大小视具体情况而定，通常 &lt;span class="math inline">\(\alpha\)&lt;/span> 取 0.1,0.05,0.01,0.005 等值. 这种&lt;strong>只对犯第 I 类错误的概率加以控制，而不考虑犯第 II 类错误的概率的检验&lt;/strong>,称 为&lt;strong>显著性检验&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>在进行显著性检验时,犯第 I 类错误的概率是由我们控制的. &lt;span class="math inline">\(\alpha\)&lt;/span> 取得小,则概率 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span>为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}\)&lt;/span> 就小,这保证了当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时错误地拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的可能性很小. 这意味着 &lt;span class="math inline">\(H_{0}\)&lt;/span> 是受到保护的,也表明 &lt;span class="math inline">\(H_{0}, H_{1}\)&lt;/span> 的地位不是对等的.于是,在一对对立假设中,选哪一个作为 &lt;span class="math inline">\(H_{0}\)&lt;/span> 需要小心・ 例如,考虑某种药品是否为真,这里可能犯两种错误 : （1）将假药误作为真药，冒着伤害病人的健康甚至生命的风险； （2）将真药误作为假药，则冒着造成经济损失的风险. 显然,犯错误( 1 ) 比犯 错误 (2) 的后果严重, 因此,我们选取“ &lt;span class="math inline">\(H_{0}\)&lt;/span> : 药品为假, &lt;span class="math inline">\(H_{1}\)&lt;/span> : 药品为 真”,即是使得犯第 I 类错误“当药品为假时错判药品为真”的概率&lt;span class="math inline">\(\leqslant \alpha\)&lt;/span>. 就是说，&lt;strong>选择 &lt;span class="math inline">\(H_{0}, H_{1}\)&lt;/span>使得两类错误中后果严重的错误成为第 I 类错误.&lt;/strong> 这是选择 &lt;span class="math inline">\(H_{0}, H_{1}\)&lt;/span> 的一个原则 &lt;span class="math inline">\(.\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>如果在两类错误中,没有一类错误的后果严重更需要避免时,常常取 &lt;span class="math inline">\(\mathrm{H}_{0}\)&lt;/span> 为维持现状&lt;/strong>, 即取 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为“无效益”、无改进”、无价值”等等・ 例如，取 &lt;span class="math inline">\(H_{0}\)&lt;/span> :新技术未提高效益， &lt;span class="math inline">\(H_{1}\)&lt;/span> :新技术提高效益. 实际上,我们感兴趣的是 &lt;span class="math inline">\(H_{1}\)&lt;/span> “提高效益”,但对采用新技术应持慎重态度. 选取 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为“新技术未提高效益”,一旦 &lt;span class="math inline">\(H_{0}\)&lt;/span> 被拒绝了,表示有较强的理由去采用新技术&lt;/p>
&lt;p>在实际问题中,情况比较复杂，如何选取 &lt;span class="math inline">\(H_{0} 、 H_{1}\)&lt;/span> 只能在实践中积累经验,根据实际情况去判断了.&lt;/p>
&lt;/blockquote>
&lt;h4 id="检验检验方法检验法则">检验（检验方法/检验法则）&lt;/h4>
&lt;p>选取合适的检验统计量，将样本与假设的偏差归结为一个常见的标准化分布。 取定合适的（错误）显著性水平，若检验统计量的值落到了显著性水平确定的拒绝域之内，就拒绝原假设，否则接受原假设。&lt;/p>
&lt;p>我们要进行的工作是， 根据样本,按上述检验方法作出决策在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 与 &lt;span class="math inline">\(H_{1}\)&lt;/span> 两者之间接受其一.&lt;/p>
&lt;h4 id="决策接受或拒绝">决策（接受或拒绝）&lt;/h4>
&lt;p>根据样本,按上述检验方法作出决策在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 与 &lt;span class="math inline">\(H_{1}\)&lt;/span> 两者之间接受其一：接受&lt;span class="math inline">\(H_0\)&lt;/span>（同时拒绝&lt;span class="math inline">\(H_1\)&lt;/span>），或者接受&lt;span class="math inline">\(H_1\)&lt;/span>（同时拒绝&lt;span class="math inline">\(H_0\)&lt;/span>）&lt;/p>
&lt;p>当检验统计量取某个区域 &lt;span class="math inline">\(C\)&lt;/span> 中的值时,我们拒绝原假设 &lt;span class="math inline">\(H_{0}\)&lt;/span>,则称区域 &lt;span class="math inline">\(C\)&lt;/span> 为 &lt;strong>拒绝域&lt;/strong>,拒绝域的边界点称为&lt;strong>临界点&lt;/strong>. 如在上例中拒绝域为 &lt;span class="math inline">\(|z| \geqslant z_{\alpha / 2},\)&lt;/span> 而 &lt;span class="math inline">\(z=\)&lt;/span> &lt;span class="math inline">\(-z_{a / 2}, z=z_{\alpha / 2}\)&lt;/span> 为临界点.&lt;/p>
&lt;h4 id="错误决策">错误决策&lt;/h4>
&lt;p>由于检验法则是根据样本作出的,总有可能作出错误的决策.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201223134856288.png" alt="" />&lt;figcaption>image-20201223134856288&lt;/figcaption>
&lt;/figure>
&lt;p>如上面所说的那样,在假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 实际上为真时,我们可能犯拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的错误,称这类“&lt;strong>弃真&lt;/strong>”的 错误为第 I 类错误. 又当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 实际上不真时,我们也有可能接受 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 称这类“&lt;strong>取伪&lt;/strong>”的错误为第 II 类错误. 犯第 I 类错误的概率记为&lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad P_{\mu_{0}}\left\{\right.\)&lt;/span> 拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad P_{\mu \in H_{0}}\left\{\right.\)&lt;/span> 拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}\)&lt;/span> 或 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 拒绝&lt;span class="math inline">\(H_0\)&lt;/span> | 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(\left.\right\} \quad\)&lt;/span> 犯第 II 类错误的概率记为&lt;span class="math inline">\(P\left\{ H_{0}\right.\)&lt;/span> 不真接受 &lt;span class="math inline">\(\left.H_{0}\right\} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad P_{\mu \in H_{1}}\left\{\right.\)&lt;/span> 接受 &lt;span class="math inline">\(\left.H_{0}\right\} .\)&lt;/span>&lt;/p>
&lt;h2 id="正态总体的均值的假设检验">正态总体的均值的假设检验&lt;/h2>
&lt;h3 id="单个总体-nleftmu-sigma2right-均值-mu-的检验">单个总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 均值 &lt;span class="math inline">\(\mu\)&lt;/span> 的检验&lt;/h3>
&lt;h4 id="sigma2-已知关于-mu-的检验-z-检验">&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 已知,关于 &lt;span class="math inline">\(\mu\)&lt;/span> 的检验 &lt;span class="math inline">\((Z\)&lt;/span> 检验 &lt;span class="math inline">\()\)&lt;/span>&lt;/h4>
&lt;p>前面的例子（&lt;a href="#假设检验的引入">假设检验的引入&lt;/a>）中已讨论过正态总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 当 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 已知时关于 &lt;span class="math inline">\(\mu\)&lt;/span> 的检验问题, 在这些检验问题中.我们都是利用统计量 &lt;span class="math inline">\(Z=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\)&lt;/span> 来确定拒绝域的. 这种检验法常称为 &lt;span class="math inline">\(Z\)&lt;/span> 检验法.&lt;/p>
&lt;h4 id="sigma2-未知关于-mu-的检验-t-检验">&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 未知,关于 &lt;span class="math inline">\(\mu\)&lt;/span> 的检验 &lt;span class="math inline">\((t\)&lt;/span> 检验 &lt;span class="math inline">\()\)&lt;/span>&lt;/h4>
&lt;p>设总体 &lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right),\)&lt;/span> 其中 &lt;span class="math inline">\(\mu, \sigma^{2}\)&lt;/span> 未知,我们来求（双边）检验问题&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}, \quad H_{1}: \mu \neq \mu_{0}\)&lt;/span>的拒绝域(显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> ). 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(X\)&lt;/span> 的样本. 由于 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 未知,现在不能利用 &lt;span class="math inline">\(\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\)&lt;/span>来确定拒绝域了. 注意到 &lt;span class="math inline">\(S^{2}\)&lt;/span> 是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计,我们用 &lt;span class="math inline">\(S\)&lt;/span> 来代替 &lt;span class="math inline">\(\sigma,\)&lt;/span> 采用&lt;span class="math inline">\(t=\frac{\bar{X}-\mu_{0}}{S / \sqrt{n}}\)&lt;/span>作为检验统计量. 当观察值 &lt;span class="math inline">\(|t|=\left|\frac{\bar{x}-\mu_{0}}{s / \sqrt{n}}\right|\)&lt;/span> 过分大时就拒绝 &lt;span class="math inline">\(H_{0},\)&lt;/span> 拒绝域的形式为&lt;span class="math inline">\(|t|=\left|\frac{\bar{x}-\mu_{0}}{s / \sqrt{n}}\right| \geqslant k\)&lt;/span> 根据&lt;a href="../概率论与数理统计-数理统计-基本概念#统计量的抽样分布">统计量的抽样分布&lt;/a>章节介绍的性质，当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时, &lt;span class="math inline">\(\frac{\bar{X}-\mu_{0}}{S / \sqrt{n}} \sim t(n-1),\)&lt;/span> 故由&lt;span class="math inline">\(P\left\{\text { 当 }H_{0}\right.\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{\mu_{0}}\left\{\left|\frac{\bar{X}-\mu_{0}}{S / \sqrt{n}}\right| \geqslant k\right\}=\alpha\)&lt;/span>，得&lt;span class="math inline">\(k=t_{a / 2}(n-1),\)&lt;/span> 即得拒绝域为&lt;span class="math inline">\(|t|=\left|\frac{\bar{x}-\mu_{0}}{s / \sqrt{n}}\right| \geqslant t_{a / 2}(n-1)\)&lt;/span>&lt;/p>
&lt;p>对于正态总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right),\)&lt;/span> 当 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 未知时,关于 &lt;span class="math inline">\(\mu\)&lt;/span> 的单边检验的拒绝域在后面附表中给出。&lt;/p>
&lt;p>上述利用 &lt;span class="math inline">\(t\)&lt;/span> 统计量得出的检验法称为 &lt;span class="math inline">\(t\)&lt;/span> 检验法. 在实际中,正态总体的方差常为未知,所以我们常用 &lt;span class="math inline">\(t\)&lt;/span> 检验法来检验关于正 态总体均值的检验问题.&lt;/p>
&lt;h3 id="两个正态总体均值差的检验-t-检验">两个正态总体均值差的检验( &lt;span class="math inline">\(t\)&lt;/span> 检验)&lt;/h3>
&lt;h4 id="两正态总体具有相同方差时">两正态总体具有相同方差时&lt;/h4>
&lt;p>我们还可以用 &lt;span class="math inline">\(t\)&lt;/span> 检验法检验&lt;strong>具有相同方差&lt;/strong>的两正态总体均值差的假设. （一般要先完成两总体的方差相同的假设检验） 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n_{1}}\)&lt;/span> 是来自正态总体 &lt;span class="math inline">\(N\left(\mu_{1}, \sigma^{2}\right)\)&lt;/span> 的样本 &lt;span class="math inline">\(, Y_{1}, Y_{2}, \cdots, Y_{n_{2}}\)&lt;/span> 是来自正态总体 &lt;span class="math inline">\(N\left(\mu_{2}, \sigma^{2}\right)\)&lt;/span> 的样本,且设两样本独立. 又分别记它们的样本均值为 &lt;span class="math inline">\(\bar{X}, \bar{Y},\)&lt;/span> 记样本 方差为 &lt;span class="math inline">\(S_{1}^{2}, S_{2}^{2} .\)&lt;/span> 设 &lt;span class="math inline">\(\mu_{1}, \mu_{2}, \sigma^{2}\)&lt;/span> 均为未知,要特别引起注意的是,在这里假设两总体 的方差是相等的. 现在来求检验问题:&lt;span class="math inline">\(H_{0}: \mu_{1}-\mu_{2}=\delta, \quad H_{1}: \mu_{1}-\mu_{2} \neq \delta\)&lt;/span>的拒绝域 &lt;span class="math inline">\((\delta\)&lt;/span> 为已知常数) . 取显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span>.&lt;/p>
&lt;p>引用下述 &lt;span class="math inline">\(t\)&lt;/span> 统计量作为检验统计量： &lt;span class="math inline">\(t=\frac{(\bar{X}-\bar{Y})-\delta}{S_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}}\)&lt;/span> 其中&lt;span class="math inline">\(S_{w}^{2}=\frac{\left(n_{1}-1\right) S_{1}^{2}+\left(n_{2}-1\right) S_{2}^{2}}{n_{1}+n_{2}-2}, S_{w}=\sqrt{S_{w}^{2}}\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时，由&lt;a href="../概率论与数理统计-数理统计-基本概念#统计量的抽样分布">统计量的抽样分布&lt;/a>章节介绍的性质，有&lt;span class="math inline">\(t \sim t\left(n_{1}+n_{2}-2\right) .\)&lt;/span> 与单个总体的 &lt;span class="math inline">\(t\)&lt;/span> 检验法相仿,其拒绝域的形式为&lt;span class="math inline">\(\left|\frac{(\bar{x}-\bar{y})-\delta}{s_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}}\right| \geqslant k\)&lt;/span> 由&lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{\mu_{1}-\mu_{2}=\delta}\left\{\left|\frac{(\bar{X}-\bar{Y})-\delta}{S_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}}\right| \geqslant k\right\}=\alpha\)&lt;/span>， 可得可得 &lt;span class="math inline">\(k=t_{a / 2}\left(n_{1}+n_{2}-2\right) .\)&lt;/span> 于是得拒绝域为&lt;span class="math inline">\(|t|=\frac{|(\bar{x}-\bar{y})-\delta|}{s_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}} \geqslant t_{a / 2}\left(n_{1}+n_{2}-2\right)\)&lt;/span>&lt;/p>
&lt;h4 id="两正态总体方差已知时">两正态总体方差已知时&lt;/h4>
&lt;p>当两个正态总体的方差均为已知(不一定相等)时,我们可用 &lt;span class="math inline">\(Z\)&lt;/span> 检验法来检验两正态总体均值差的假设问题,见后面附表。&lt;/p>
&lt;h3 id="基于成对数据的检验-ttext检验">基于成对数据的检验 &lt;span class="math inline">\((t\text{检验})\)&lt;/span>&lt;/h3>
&lt;p>有时为了比较两种产品、两种仪器、两种方法等的差异,我们常在相同的条 件下做对比试验,得到一批成对的观察值. 然后分析观察数据作出推断. 这种方法常称为&lt;strong>逐对比较法&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>例子 有两台光谱仪 &lt;span class="math inline">\(I_{x}, I_{y}\)&lt;/span>, 用来测量材料中某种金属的含量,为鉴定它们 的测量结果有无显著的差异,制备了 9 件试块(它们的成分、金属含量、均匀性等 均各不相同)，现在分别用这两台仪器对每一试块测量一次,得到 9 对观察值： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201223170042943.png" alt="image-20201223170042943" /> 问&lt;strong>能否认为这两台仪器的测量结果有显著的差异&lt;/strong>(取 &lt;span class="math inline">\(\alpha=0.01\)&lt;/span> ) ?&lt;/p>
&lt;p>本题中的&lt;strong>数据是成对&lt;/strong>的,即对同一试块测出一对数据. 我们看到&lt;strong>一对与另一对之间的差异是由各种因素&lt;/strong>,如材料成分、金属含量、均匀性等因素引起的. 由于各试块的特性有广泛的差别,就不能将仪器 &lt;span class="math inline">\(I_{x}\)&lt;/span> 对 9 个试块的测量结果 (即 表中第一行)看成是同分布随机变量的观察值 . 因而表中第一行不能看成是一个样本的样本值 . 同样,表中第二行也不能看成是一个样本的样本值 . 再者,对 于每一对数据而言,它们是同一试块用不同仪器 &lt;span class="math inline">\(I_{x}, I_{y}\)&lt;/span> 测得的结果,因此,它们不是两个独立的随机变量的观察值。 综上所述,我们不能用前面介绍的&lt;a href="#两个正态总体均值差的检验(%20$t$%20检验)">两个正态总体均值差的检验( &lt;span class="math inline">\(t\)&lt;/span> 检验)&lt;/a>来作检验。而同一对中两个数据的差异则可看成是仅由这两台仪器性能 的差异所引起的,这样,局限于各对中两个数据来比较就能排除种种其他因素， 而只考虑单独由仪器的性能所产生的影响. 从而能比较这两台仪器的测量结果 是否有显著的差异。&lt;/p>
&lt;/blockquote>
&lt;p>一般,设有 &lt;span class="math inline">\(n\)&lt;/span> 对相互独立的观察结果 &lt;span class="math inline">\(:\left(X_{1}, Y_{1}\right),\left(X_{2}, Y_{2}\right), \cdots,\left(X_{n}, Y_{n}\right),\)&lt;/span> 令&lt;span class="math inline">\(D_{1}=X_{1}-Y_{1}, D_{2}=X_{2}-Y_{2}, \cdots, D_{n}=X_{n}-Y_{n},\)&lt;/span> 则 &lt;span class="math inline">\(D_{1}, D_{2}, \cdots, D_{n}\)&lt;/span> 相互独立. 由于 &lt;span class="math inline">\(D_{1}, D_{2}, \cdots, D_{n}\)&lt;/span> 是由同一因素所引起的,可认为它们服从同一分布。 今假设&lt;span class="math inline">\(D_{i} \sim N\left(\mu_{D}, \sigma_{D}^{2}\right), i=1,2, \cdots, n .\)&lt;/span> 这就是说 &lt;span class="math inline">\(D_{1}, D_{2}, \cdots, D_{n}\)&lt;/span> 构成正态总体 &lt;span class="math inline">\(N\left(\mu_{D}, \sigma_{D}^{2}\right)\)&lt;/span>的一个样本,其中 &lt;span class="math inline">\(\mu_{D}, \sigma_{D}^{2}\)&lt;/span> 未知 &lt;span class="math inline">\(.\)&lt;/span> 我们需要基于这一样本检验假设: (1) &lt;span class="math inline">\(\quad H_{0}: \mu_{D}=0, \quad H_{1}: \mu_{D} \neq 0\)&lt;/span> (2) &lt;span class="math inline">\(H_{0}: \mu_{D} \leqslant 0, \quad H_{1}: \mu_{D}&amp;gt;0\)&lt;/span> (3) &lt;span class="math inline">\(\quad H_{0}: \mu_{D} \geqslant 0, \quad H_{1}: \mu_{D}&amp;lt;0\)&lt;/span> 分别记 &lt;span class="math inline">\(D_{1}, D_{2}, \cdots, D_{n}\)&lt;/span> 的样本均值和样本方差的观察值为 &lt;span class="math inline">\(\bar{d}, s_{D}^{2},\)&lt;/span> 按单个正态总体均值的 &lt;span class="math inline">\(t\)&lt;/span> 检验・知检验问题 (1),(2),(3) 的拒绝域分别 为（显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> ) : &lt;span class="math inline">\(|t|=\left|\frac{\bar{d}}{s_{D} / \sqrt{n}}\right| \geqslant t_{a / 2}(n-1)\)&lt;/span> &lt;span class="math inline">\(t=\frac{\bar{d}}{s_{D} / \sqrt{n}} \geqslant t_{a}(n-1)\)&lt;/span> &lt;span class="math inline">\(t=\frac{\bar{d}}{s_{D} / \sqrt{n}} \leqslant-t_{a}(n-1)\)&lt;/span>&lt;/p>
&lt;h2 id="正态总体方差的假设检验">正态总体方差的假设检验&lt;/h2>
&lt;h3 id="单个总体的情况">单个总体的情况&lt;/h3>
&lt;p>设总体 &lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right), \mu, \sigma^{2}\)&lt;/span> 均未知 &lt;span class="math inline">\(, X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本. 要求&lt;strong>（双边）检验&lt;/strong>假设(显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> ): &lt;span class="math inline">\(H_{0}: \sigma^{2}=\sigma_{0}^{2}, \quad H_{1}: \sigma^{2} \neq \sigma_{0}^{2}\)&lt;/span>, 其中&lt;span class="math inline">\(\sigma_{0}^{2}\)&lt;/span> 为已知常数. 由于 &lt;span class="math inline">\(S^{2}\)&lt;/span> 是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计,当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时,观察值 &lt;span class="math inline">\(s^{2}\)&lt;/span> 与 &lt;span class="math inline">\(\sigma_{0}^{2}\)&lt;/span> 的比值 &lt;span class="math inline">\(\frac{s^{2}}{\sigma_{0}^{2}}\)&lt;/span> 般来说 应在 1 附近摆动,而不应过分大于 1 或过分小于 &lt;span class="math inline">\(1 .\)&lt;/span> 由&lt;a href="../概率论与数理统计-数理统计-基本概念#统计量的抽样分布">统计量的抽样分布&lt;/a>章节介绍的性质，当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时，有&lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \sim \chi^{2}(n-1)\)&lt;/span>。 取&lt;span class="math inline">\(\chi^{2}=\frac{(n-1) S^{2}}{\sigma_{0}^{2}}\)&lt;/span>作为检验统计量, 如上所说知道上述检验问题的拒绝域具有以下的形式： &lt;span class="math inline">\(\frac{(n-1) s^{2}}{\sigma_{0}^{2}} \leqslant k_{1} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad \frac{(n-1) s^{2}}{\sigma_{0}^{2}} \geqslant k_{2}\)&lt;/span> 此处 &lt;span class="math inline">\(k_{1}, k_{2}\)&lt;/span> 的值由下式确定 : &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}\)&lt;/span> &lt;span class="math inline">\(=P_{o_{0}^{2}}\left\{\left(\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \leqslant k_{1}\right) \cup\left(\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \geqslant k_{2}\right)\right\}=\alpha\)&lt;/span> 为计算方便起见，习惯上取： &lt;span class="math inline">\(P_{a_{0}^{2}}\left\{\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \leqslant k_{1}\right\}=\frac{\alpha}{2}, P_{o_{0}^{2}}\left\{\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \geqslant k_{2}\right\}=\frac{\alpha}{2}\)&lt;/span> 故得 &lt;span class="math inline">\(k_{1}=\chi_{1^{-} \alpha / 2}^{2}(n-1), k_{2}=\chi_{\alpha / 2}^{2}(n-1) .\)&lt;/span> 于是得拒绝域为&lt;span class="math inline">\(\frac{(n-1) s^{2}}{\sigma_{0}^{2}} \leqslant \chi_{1-a / 2}^{2}(n-1) \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad \frac{(n-1) s^{2}}{\sigma_{0}^{2}} \geqslant \chi_{\alpha / 2}^{2}(n-1)\)&lt;/span>&lt;/p>
&lt;p>下面求&lt;strong>右边检验&lt;/strong>问题（显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> )：&lt;span class="math inline">\(H_{0}: \sigma^{2} \leqslant \sigma_{0}^{2}, \quad H_{1}: \sigma^{2}&amp;gt;\sigma_{0}^{2}\)&lt;/span>的拒绝域。 因 &lt;span class="math inline">\(H_{0}\)&lt;/span> 中的全部 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 都比 &lt;span class="math inline">\(H_{1}\)&lt;/span> 中的 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 要小,当 &lt;span class="math inline">\(H_{1}\)&lt;/span> 为真时, &lt;span class="math inline">\(S^{2}\)&lt;/span> 的观察值 &lt;span class="math inline">\(s^{2}\)&lt;/span> 往往偏大,因此拒绝域的形式为&lt;span class="math inline">\(s^{2} \geqslant k\)&lt;/span> 下面来确定常数 &lt;span class="math inline">\(k\)&lt;/span>. &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{o^{2} \leqslant_{o}^{2}}\left\{S^{2} \geqslant k\right\}\)&lt;/span> &lt;span class="math inline">\(=P_{o^{2} \leqslant\sigma_{0}^{2}}\left\{\frac{(n-1) S^{2}}{\sigma_{0}^{2}} \geqslant \frac{(n-1) k}{\sigma_{0}^{2}}\right\}\)&lt;/span> &lt;span class="math inline">\(\leqslant P_{\sigma^{2} \leqslant \sigma_{0}^{2}}\left\{\frac{(n-1) S^{2}}{\sigma^{2}} \geqslant \frac{(n-1) k}{\sigma_{0}^{2}}\right\} \quad\left(\right.\)&lt;/span> 因为 &lt;span class="math inline">\(\left.\sigma^{2} \leqslant \sigma_{0}^{2}\right)\)&lt;/span> 要控制 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \leqslant \alpha,\)&lt;/span> 只需令&lt;span class="math inline">\(P_{a^{2} \leqslant o_{0}^{2}}\left\{\frac{(n-1) S^{2}}{\sigma^{2}} \geqslant \frac{(n-1) k}{\sigma_{0}^{2}}\right\}=\alpha\)&lt;/span> 又因 &lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma^{2}} \sim \chi^{2}(n-1),\)&lt;/span> 得 &lt;span class="math inline">\(\frac{(n-1) k}{\sigma_{0}^{2}}\)&lt;/span>&lt;span class="math inline">\(=\chi_{\alpha}^{2}(n-1)\)&lt;/span> 。 于是 &lt;span class="math inline">\(k=\frac{\sigma_{0}^{2}}{n-1} \chi_{a}^{2}(n-1),\)&lt;/span> 得此单边检验问题的拒绝域为 &lt;span class="math inline">\(s^{2} \geqslant\)&lt;/span> &lt;span class="math inline">\(\frac{\sigma_{0}^{2}}{n-1} \chi_{\sigma}^{2}(n-1),\)&lt;/span> 即&lt;span class="math inline">\(\chi^{2}=\frac{(n-1) s^{2}}{\sigma_{0}^{2}} \geqslant \chi_{a}^{2}(n-1)\)&lt;/span>&lt;/p>
&lt;p>类似地，可得&lt;strong>左边检验问题&lt;/strong>：&lt;span class="math inline">\(H_{0}: \sigma^{2} \geqslant \sigma_{0}^{2}, \quad H_{1}: \sigma^{2}&amp;lt;\sigma_{0}^{2}\)&lt;/span>的拒绝域： &lt;span class="math inline">\(\chi^{2}=\frac{(n-1) s^{2}}{\sigma_{0}^{2}} \leqslant \chi_{1-\alpha}^{2}(n-1)\)&lt;/span>&lt;/p>
&lt;p>以上检验法称为&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 检验法&lt;/p>
&lt;h3 id="两个总体的情况">两个总体的情况&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n_{1}}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(N\left(\mu_{1}, \sigma_{1}^{2}\right)\)&lt;/span> 的样本 &lt;span class="math inline">\(, Y_{1}, Y_{2}, \cdots, Y_{n_{2}}\)&lt;/span> 是来自总体&lt;span class="math inline">\(N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span> 的样本,且两样本独立. 其样本方差分别为 &lt;span class="math inline">\(S_{1}^{2}, S_{2}^{2} .\)&lt;/span> 且设 &lt;span class="math inline">\(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}\)&lt;/span> 均为未知. 现在需要检验假设(显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> )：&lt;span class="math inline">\(H_{0}: \sigma_{1}^{2} \leqslant \sigma_{2}^{2}, \quad H_{1}: \sigma_{1}^{2}&amp;gt;\sigma_{2}^{2}\)&lt;/span>&lt;/p>
&lt;p>当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(, E\left(S_{1}^{2}\right)=\sigma_{1}^{2} \leqslant \sigma_{2}^{2}=E\left(S_{2}^{2}\right),\)&lt;/span> 当 &lt;span class="math inline">\(H_{1}\)&lt;/span> 为真时 &lt;span class="math inline">\(E\left(S_{1}^{2}\right)=\sigma_{1}^{2}&amp;gt;\sigma_{2}^{2}=E\left(S_{2}^{2}\right)\)&lt;/span>. 当 &lt;span class="math inline">\(H_{1}\)&lt;/span> 为真时,观察值 &lt;span class="math inline">\(\frac{S_{1}^{2}}{S_{2}^{2}}\)&lt;/span> 有偏大的趋势,故拒绝域具有形式：&lt;span class="math inline">\(\frac{s_{1}^{2}}{s_{2}^{2}} \geqslant k\)&lt;/span>&lt;/p>
&lt;p>常数 &lt;span class="math inline">\(k\)&lt;/span> 确定如下： &lt;span class="math inline">\(P\left\{\underline{y} H_{0}\right.\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{o_{1}^{2} \leqslant \sigma_{2}^{2}}\left\{\frac{S_{1}^{2}}{S_{2}^{2}} \geqslant k\right\}\)&lt;/span> &lt;span class="math inline">\(\leqslant P_{o_{1}^{2} \leqslant \sigma_{2}^{2}}\left\{\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}} \geqslant k\right\} \quad\left(\right.\)&lt;/span> 因为 &lt;span class="math inline">\(\left.\sigma_{1}^{2} / \sigma_{2}^{2} \leqslant 1\right)\)&lt;/span> 要控制 &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\} \leqslant \alpha,\)&lt;/span> 只需令&lt;span class="math inline">\(P_{o_{1}^{2} \leqslant \sigma_{2}^{2}}\left\{\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}} \geqslant k\right\}=\alpha\)&lt;/span> 再由&lt;a href="../概率论与数理统计-数理统计-基本概念#统计量的抽样分布">统计量的抽样分布&lt;/a>章节介绍的性质，知 &lt;span class="math inline">\(\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}} \sim F\left(n_{1}-1, n_{2}-1\right),\)&lt;/span> 得 &lt;span class="math inline">\(k=F_{\alpha}\left(n_{1}-1, n_{2}- 1\right)\)&lt;/span>. 即得检验问题的拒绝域为&lt;span class="math inline">\(F=\frac{s_{1}^{2}}{s_{2}^{2}} \geqslant F_{a}\left(n_{1}-1, n_{2}-1\right)\)&lt;/span>&lt;/p>
&lt;p>上述检验法称为 &lt;span class="math inline">\(F\)&lt;/span> 检验法. 关于 &lt;span class="math inline">\(\sigma_{1}^{2}, \sigma_{2}^{2}\)&lt;/span> 的另外两个检验问题的拒绝域在后面附表中给出.&lt;/p>
&lt;h2 id="正态总体均值和方差的假设检验汇总">正态总体均值和方差的假设检验汇总&lt;/h2>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2020-12-23-pic1.png" alt="" />&lt;figcaption>2020-12-23-pic1&lt;/figcaption>
&lt;/figure>
&lt;h2 id="置信区间域假设检验的关系">置信区间域假设检验的关系&lt;/h2>
&lt;p>置信区间与假设检验之间有明显的联系, 先考察置信区间与双边检验之间的对应关系. 设 &lt;span class="math inline">\(X_{1}, \cdots, X_{n}\)&lt;/span> 是一个来自总体的样本 &lt;span class="math inline">\(, x_{1}, \cdots, x_{n}\)&lt;/span> 是相应的样本值, &lt;span class="math inline">\(\Theta\)&lt;/span> 是参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的可能取值范围。 设 &lt;span class="math inline">\(\left(\underline{\theta}\left(X_{1}, \cdots, X_{n}\right), \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\)&lt;/span> 是参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间,则对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span>,有&lt;span class="math inline">\(P_{\theta}\left\{\theta\left(X_{1}, \cdots, X_{n}\right)&amp;lt;\theta&amp;lt;\bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right\} \geqslant 1-\alpha\)&lt;/span>， 即有&lt;span class="math inline">\(P_{\theta_{0}}\left\{\left(\theta_{0} \leqslant \theta\left(X_{1}, \cdots, X_{n}\right)\right) \cup\left(\theta_{0} \geqslant \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\right\} \leqslant \alpha\)&lt;/span>，&lt;/p>
&lt;p>考虑显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的双边检验：&lt;span class="math inline">\(H_{0}: \theta=\theta_{0}, \quad H_{1}: \theta \neq \theta_{0}\)&lt;/span>， 按显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的假设检验的拒绝域的定义, 双边检验：&lt;span class="math inline">\(H_{0}: \theta=\theta_{0}, \quad H_{1}: \theta \neq \theta_{0}\)&lt;/span>的拒绝域为&lt;span class="math inline">\(\theta_{0} \leqslant \underline\theta\left(x_{1}, \cdots, x_{n}\right) \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad \theta_{0} \geqslant \bar{\theta}\left(x_{1}, \cdots, x_{n}\right)\)&lt;/span> 接受域为&lt;span class="math inline">\(\underline\theta\left(x_{1}, \cdots, x_{n}\right)&amp;lt;\theta_{0}&amp;lt;\bar{\theta}\left(x_{1}, \cdots, x_{n}\right)\)&lt;/span>.&lt;/p>
&lt;p>这就是说,当我们要检验假设：&lt;span class="math inline">\(H_{0}: \theta=\theta_{0}, \quad H_{1}: \theta \neq \theta_{0}\)&lt;/span>时,先求出 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信 区间 &lt;span class="math inline">\((\underline\theta, \bar{\theta}),\)&lt;/span> 然后考察区间 &lt;span class="math inline">\((\theta, \bar{\theta})\)&lt;/span> 是否包含 &lt;span class="math inline">\(\theta_{0},\)&lt;/span> 若 &lt;span class="math inline">\(\theta_{0} \in(\underline\theta, \bar{\theta})\)&lt;/span> 则接受 &lt;span class="math inline">\(H_{0},\)&lt;/span> 若 &lt;span class="math inline">\(\theta_{0} \notin(\underline{\theta},\bar{\theta}),\)&lt;/span> 则拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span>&lt;/p>
&lt;p>反之,对于任意 &lt;span class="math inline">\(\theta_{0} \in \Theta,\)&lt;/span> 考虑显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的假设检验问题: &lt;span class="math inline">\(H_{0}: \theta=\theta_{0}, \quad H_{1}: \theta \neq \theta_{0}\)&lt;/span>, 假设它的接受域为&lt;span class="math inline">\(\underline\theta\left(x_{1}, \cdots, x_{n}\right)&amp;lt;\theta_{0}&amp;lt;\bar{\theta}\left(x_{1}, \cdots, x_{n}\right)\)&lt;/span> 即有&lt;span class="math inline">\(P_{\theta_{0}}\left\{\underline\theta\left(X_{1}, \cdots, X_{n}\right)&amp;lt;\theta_{0}&amp;lt;\bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right\} \geqslant 1-\alpha\)&lt;/span> 由 &lt;span class="math inline">\(\theta_{0}\)&lt;/span> 的任意性,由上式知对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span>,有&lt;span class="math inline">\(P_{\theta}\left\{\underline\theta\left(X_{1}, \cdots, X_{n}\right)&amp;lt;\theta&amp;lt;\bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right\} \geqslant 1-\alpha\)&lt;/span>, 因此 &lt;span class="math inline">\(\left(\theta\left(X_{1}, \cdots, X_{n}\right), \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\)&lt;/span> 是参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间.&lt;/p>
&lt;p>这就是说,为要求出参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间， 我们先求出显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的假设检验问题 &lt;span class="math inline">\(: H_{0}: \theta=\theta_{0}, H_{1}: \theta \neq \theta_{0}\)&lt;/span> 的接受域 &lt;span class="math inline">\(\underline{\theta}\left(x_{1}, \cdots, x_{n}\right)&amp;lt;\theta_{0}\)&lt;/span>&lt;span class="math inline">\(&amp;lt;\bar{\theta}\left(x_{1}, \cdots, x_{n}\right),\)&lt;/span> 那么 &lt;span class="math inline">\(,\left(\underline{\theta}\left(X_{1}, \cdots, X_{n}\right), \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\)&lt;/span> 就是 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span>的置信区间&lt;/p>
&lt;p>还可验证,置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信区间 &lt;span class="math inline">\(\left(-\infty, \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\)&lt;/span> 与显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的左边检验问题 &lt;span class="math inline">\(H_{0}: \theta \geqslant \theta_{0}, H_{1}: \theta&amp;lt;\theta_{0}\)&lt;/span> 有类似的对应关系. 即若已求得单侧置信区间 &lt;span class="math inline">\(\left(-\infty, \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right),\)&lt;/span> 则当 &lt;span class="math inline">\(\theta_{0} \in\left(-\infty, \bar{\theta}\left(x_{1}, \cdots, x_{n}\right)\right)\)&lt;/span> 时接受&lt;span class="math inline">\(H_{0},\)&lt;/span> 当 &lt;span class="math inline">\(\theta_{0} \notin\left(-\infty, \bar{\theta}\left(x_{1}, \cdots, x_{n}\right)\right)\)&lt;/span> 时拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 反之,若已求得检验问题 &lt;span class="math inline">\(H_{0}: \theta \geqslant \theta_{0},\)&lt;/span>&lt;span class="math inline">\(H_{1}: \theta&amp;lt;\theta_{0}\)&lt;/span> 的接受域为 &lt;span class="math inline">\(-\infty&amp;lt;\theta_{0} \leqslant \bar{\theta}\left(x_{1}, \cdots, x_{n}\right),\)&lt;/span> 则可得 &lt;span class="math inline">\(\theta\)&lt;/span> 的一个单侧置信区间&lt;span class="math inline">\(\left(-\infty, \bar{\theta}\left(X_{1}, \cdots, X_{n}\right)\right)\)&lt;/span>&lt;/p>
&lt;p>置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信区间 &lt;span class="math inline">\(\left(\theta\left(X_{1}, \cdots, X_{n}\right), \infty\right)\)&lt;/span> 与显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的右边检验问题 &lt;span class="math inline">\(H_{0}: \theta \leqslant \theta_{0}, H_{1}: \theta&amp;gt;\theta_{0}\)&lt;/span> 也有类似的对应关系. 即若已求得单侧置信区间 &lt;span class="math inline">\(\left(\theta\left(X_{1}, \cdots, X_{n}\right), \infty\right) .\)&lt;/span> 则 当 &lt;span class="math inline">\(\theta_{0} \in\left(\theta\left(x_{1}, \cdots, x_{n}\right), \infty\right)\)&lt;/span> 时接 受 &lt;span class="math inline">\(H_{0},\)&lt;/span> 当 &lt;span class="math inline">\(\theta_{0} \notin\)&lt;/span>&lt;span class="math inline">\(\left(\theta\left(x_{1}, \cdots, x_{n}\right), \infty\right)\)&lt;/span> 时拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 反之,若已求得检验问题 &lt;span class="math inline">\(H_{0}: \theta \leqslant \theta_{0}, H_{1}: \theta&amp;gt;\theta_{0}\)&lt;/span> 的接受域为 &lt;span class="math inline">\(\theta\left(x_{1}, \cdots, x_{n}\right) \leqslant \theta_{0}&amp;lt;\infty,\)&lt;/span> 则可得 &lt;span class="math inline">\(\theta\)&lt;/span> 的一个单侧置信区间 &lt;span class="math inline">\(\left(\theta\left(X_{1}, \cdots, X_{n}\right)\right.\)&lt;/span>,&lt;span class="math inline">\(\infty)\)&lt;/span>&lt;/p>
&lt;h2 id="样本容量的选取">样本容量的选取&lt;/h2>
&lt;p>以上我们在进行假设检验时，总是根据问题的要求，预先给出显著性水平以控制犯第Ⅰ类错误的概率，而犯第Ⅱ类错误的概率则依赖于样本容量的选择。 在些实际问题中，我们除了希望控制犯第Ⅰ类错误的概率外，往往还希望&lt;strong>控制犯第Ⅱ类错误的概率&lt;/strong>。在这一节，我们将阐明如何选取样本的容量使得犯第Ⅱ类错误的概率控制在预先给定的限度之内。为此，我们引入施行特征函数&lt;/p>
&lt;p>//TODO 施行特征函数&lt;/p>
&lt;h2 id="分布拟合检验">分布拟合检验&lt;/h2>
&lt;p>上面介绍的各种检验法都是在总体分布形式为已知的前提下进行讨论的。 但在实际问题中,有时不能知道总体服从什么类型的分布,这时就需要根据样本来检验关于分布的假设. 本节介绍 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法. 它可以用来检验总体是否具 有某一个指定的分布或属于某一个分布族,还介绍专用于检验分布是否为正态的“偏度、峰度检验法”&lt;/p>
&lt;h3 id="单个分布的-chi2-拟合检验法">单个分布的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法&lt;/h3>
&lt;p>设总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布未知 &lt;span class="math inline">\(, x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本值. 我们来检验假设: &lt;span class="math inline">\(H_{0}:\)&lt;/span> 总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数为 &lt;span class="math inline">\(F(x) .\)&lt;/span> &lt;span class="math inline">\(H_{1}:\)&lt;/span> 总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数不是 &lt;span class="math inline">\(F(x)\)&lt;/span> 其中设 &lt;span class="math inline">\(F(x)\)&lt;/span> 不含未知参数. (也常以分布律或概率密度代替 &lt;span class="math inline">\(F(x))\)&lt;/span>.&lt;/p>
&lt;p>下面来定义检验统计量. 将在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 下 &lt;span class="math inline">\(X\)&lt;/span> 可能取值的全体 &lt;span class="math inline">\(\Omega\)&lt;/span> 分成互不相交的 子集 &lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{k},\)&lt;/span> 以 &lt;span class="math inline">\(f_{i} \quad(i=1,2, \cdots, k)\)&lt;/span> 记样本观察值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 中落在 &lt;span class="math inline">\(A_{i}\)&lt;/span>的个数,这表示事件 &lt;span class="math inline">\(A_{i}=\left\{X\right.\)&lt;/span> 的值落在子集 &lt;span class="math inline">\(A_{i}\)&lt;/span> 内 &lt;span class="math inline">\(\}\)&lt;/span> 在 &lt;span class="math inline">\(n\)&lt;/span> 次独立试验中发生 &lt;span class="math inline">\(f_{i}\)&lt;/span> 次,于是在这 &lt;span class="math inline">\(n\)&lt;/span> 次试验中事件 &lt;span class="math inline">\(A_{i}\)&lt;/span> 发生的频率为 &lt;span class="math inline">\(f_{i} / n .\)&lt;/span> 另一方面, 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时， 我们可以根据 &lt;span class="math inline">\(H_{0}\)&lt;/span> 中所假设的 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数来计算事件 &lt;span class="math inline">\(A_{i}\)&lt;/span> 的概率,得到 &lt;span class="math inline">\(p_{i}=\)&lt;/span>&lt;span class="math inline">\(P\left(A_{i}\right), i=1,2, \cdots, k .\)&lt;/span> 频率 &lt;span class="math inline">\(f_{i} / n\)&lt;/span> 与概率 &lt;span class="math inline">\(p_{i}\)&lt;/span> 会有差异,但一般来说,当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真,且试验的次数又甚多时,这种差异不应太大,因此 &lt;span class="math inline">\(\left(\frac{f_{i}}{n}-p_{i}\right)^{2}\)&lt;/span>不应太大. 我们采用形如&lt;span class="math inline">\(\sum_{i=1}^{k} C_{i}\left(\frac{f_{i}}{n}-p_{i}\right)^{2}\)&lt;/span>的统计量来度量样本与 &lt;span class="math inline">\(H_{0}\)&lt;/span> 中所假设的分布的吻合程度, 其中 &lt;span class="math inline">\(C_{i} \quad(i=1,2, \cdots,k)\)&lt;/span> 为给定的常数. 皮尔逊证明,如果选取 &lt;span class="math inline">\(C_{i}=n / p_{i} \quad(i=1,2, \cdots, k),\)&lt;/span> 即&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{k} \frac{n}{p_{i}}\left(\frac{f_{i}}{n}-p_{i}\right)^{2}=\sum_{i=1}^{k} \frac{\left(f_{i}-n p_{i}\right)^{2}}{n p_{i}}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>, 则统计量&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>具有下述定理中所述的简单性质. 于是我们就采用其作为检验统计量。&lt;/p>
&lt;p>&lt;strong>定理&lt;/strong>：若 &lt;span class="math inline">\(n\)&lt;/span> 充分大 &lt;span class="math inline">\((n \geqslant 50),\)&lt;/span> 则当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时统计量近似服&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>从 &lt;span class="math inline">\(\chi^{2}(k-1)\)&lt;/span>分布.（证略）&lt;/p>
&lt;p>据以上的讨论,当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时,&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>中的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 不应太大,如 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 过分大就拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>, 拒绝域的形式为&lt;span class="math inline">\(\chi^{2} \geqslant G \quad(G\)&lt;/span> 为正常数 &lt;span class="math inline">\() .\)&lt;/span> 对于给定的显著性水平 &lt;span class="math inline">\(\alpha,\)&lt;/span> 确定 &lt;span class="math inline">\(G\)&lt;/span> 使： &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}=P_{H_{0}}\left\{\chi^{2} \geqslant G\right\}=\alpha\)&lt;/span>. 由上述定理得 &lt;span class="math inline">\(G=\chi_{\alpha}^{2}(k-1) .\)&lt;/span> 即当样本观察值使&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>式中的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 的值有&lt;span class="math inline">\(\chi^{2} \geqslant \chi_{\alpha}^{2}(k-1)\)&lt;/span>， 则在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>;否则就接受 &lt;span class="math inline">\(H_{0}\)&lt;/span>. 这就是单个分布的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法.&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>：&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法是基于上述定理得到的,所以使用时必须注意 &lt;span class="math inline">\(n\)&lt;/span> 不能小于 &lt;span class="math inline">\(50 .\)&lt;/span> 另 外 &lt;span class="math inline">\(n p_{i}\)&lt;/span> 不能太小,应有 &lt;span class="math inline">\(n p_{i} \geqslant 5\)&lt;/span>,否则应适当合并 &lt;span class="math inline">\(A_{i}\)&lt;/span>,以满足这个要求。&lt;/p>
&lt;h3 id="分布族的-chi2-拟合检验">分布族的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验&lt;/h3>
&lt;p>在上面要检验的原假设是 &lt;span class="math inline">\(H_{0}:\)&lt;/span> 总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数是 &lt;span class="math inline">\(F(x),\)&lt;/span> 其中 &lt;span class="math inline">\(F(x)\)&lt;/span> 是 已知的,这种情况是不多的.&lt;/p>
&lt;p>我们经常遇到的所需检验的原假设是： &lt;span class="math inline">\(H_{0}:\)&lt;/span> 总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数是 &lt;span class="math inline">\(F\left(x ; \theta_{1}, \cdots, \theta_{r}\right),\)&lt;/span>其中 &lt;span class="math inline">\(F\)&lt;/span> 的形式已知,而 &lt;span class="math inline">\(\boldsymbol{\theta}=\left(\theta_{1}, \theta_{2}, \cdots, \theta_{r}\right)\)&lt;/span> 是未知参数，它们在某一个范围取值. 在 &lt;span class="math inline">\(F\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{r}\right)\)&lt;/span> 中当参数 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{r}\)&lt;/span> 取不同的值时,就得到不同的分布，因而 &lt;span class="math inline">\(F\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{r}\right)\)&lt;/span> 代表一族分布. &lt;span class="math inline">\(H_{0}\)&lt;/span> 表示总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布属于分布族 &lt;span class="math inline">\(F\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{r}\right)\)&lt;/span>。 采用类似&lt;a href="#单个分布的%20$\chi%5E%7B2%7D$%20拟合检验">单个分布的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验&lt;/a>中的方法来定义检验统计量,将在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 下&lt;span class="math inline">\(X\)&lt;/span> 可能取值的全体 &lt;span class="math inline">\(\Omega\)&lt;/span> 分成 &lt;span class="math inline">\(k \quad(k&amp;gt;r+1)\)&lt;/span> 个互不相交的子集 &lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{k},\)&lt;/span> 以&lt;span class="math inline">\(f_{i} \quad(i=1,2, \cdots, k)\)&lt;/span> 记样本观察值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 落在 &lt;span class="math inline">\(A_{i}\)&lt;/span> 的个数 &lt;span class="math inline">\(,\)&lt;/span> 则事件 &lt;span class="math inline">\(A_{i}=\{X\)&lt;/span>的值落在 &lt;span class="math inline">\(A_{i}\)&lt;/span> 内 &lt;span class="math inline">\(\}\)&lt;/span> 的频率为 &lt;span class="math inline">\(f_{i} / n .\)&lt;/span> 另一方面,当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时,由 &lt;span class="math inline">\(H_{0}\)&lt;/span> 所假设的分布 函数来计算 &lt;span class="math inline">\(P\left(A_{i}\right),\)&lt;/span> 得到&lt;span class="math inline">\(P\left(A_{i}\right)=p_{i}\left(\theta_{1}, \theta_{2}, \cdots, \theta_{r}\right)=p_{i}(\boldsymbol{\theta})=p_{i} .\)&lt;/span> 此时,&lt;strong>需先利用样本求出未知参数的最大似然估计&lt;/strong> (在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 下 )，以估计值作为参数值,求出 &lt;span class="math inline">\(p_{i}\)&lt;/span>的估计值 &lt;span class="math inline">\(\hat{p}_{i}=\hat{P}\left(A_{i}\right),\)&lt;/span> 在&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} \frac{f_{i}^{2}}{n p_{i}}-n\)&lt;/span>中以 &lt;span class="math inline">\(\hat{p}_{i}\)&lt;/span> 代替 &lt;span class="math inline">\(p_{i},\)&lt;/span> 取&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{k} \frac{f_{i}^{2}}{n \hat{p}_{i}}-n\)&lt;/span>作为检验假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的统计量. 可以证明,在某些条件下,在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时近似地有&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{k} \frac{f_{\hat{p}}^{2}}{n \hat{p}_{i}}-n \sim \chi^{2}(k-r-1)\)&lt;/span>， 与在&lt;a href="#单个分布的%20$\chi%5E%7B2%7D$%20拟合检验">单个分布的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验&lt;/a>中中一样， 可得假设检验问题&lt;span class="math inline">\(H_{0}:\)&lt;/span> 总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数是 &lt;span class="math inline">\(F\left(x ; \theta_{1}, \cdots, \theta_{r}\right)\)&lt;/span>的拒绝域为&lt;span class="math inline">\(\chi^{2} \geqslant \chi_{\alpha}^{2}(k-r-1)\)&lt;/span>， &lt;span class="math inline">\(\alpha\)&lt;/span> 为显著性水平. 以上就是用来检验分布族的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法.&lt;/p>
&lt;h3 id="偏度峰度检验">偏度、峰度检验&lt;/h3>
&lt;p>根据关于中心极限定理的论述知道,正态分布随机变量是较广泛地存在的,因此,当研究一连续型总体时,人们往往先考察它是否服从正态分布. 上面介绍的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 拟合检验法虽然是检验总体分布的较一般的方法,但用它来检验总体的正态性时,犯第 II 类错误的概率往往较大. 为此,统计学家们对检验正态总体的种种方法进行了比较,根据奥野忠一等人在 20 世纪 70 年代进行的大量模 拟计的结果,认为正态性检验方法中,总的来说,以“偏度、峰度检验法”及“夏 皮罗一威尔克法”较为有效. 在这里我们仅介绍偏度、峰度检验法.&lt;/p>
&lt;p>随机变量 &lt;span class="math inline">\(X\)&lt;/span> 的偏度和峰度指的是 &lt;span class="math inline">\(X\)&lt;/span> 的标准化变量 &lt;span class="math inline">\([X-E(X)] / \sqrt{D(X)}\)&lt;/span> 的 三阶矩和四阶矩: &lt;span class="math inline">\(\nu_{1}=E\left[\left(\frac{X-E(X)}{\sqrt{D(X)}}\right)^{3}\right]=\frac{E\left[(X-E(X))^{3}\right]}{(D(X))^{3 / 2}}\)&lt;/span> &lt;span class="math inline">\(\nu_{2}=E\left[\left(\frac{X-E(X)}{\sqrt{D(X)}}\right)^{4}\right]=\frac{E\left[(X-E(X))^{4}\right]}{(D(X))^{2}}\)&lt;/span>&lt;/p>
&lt;p>当随机变量 &lt;span class="math inline">\(X\)&lt;/span> 服从正态分布时 &lt;span class="math inline">\(, \nu_{1}=0\)&lt;/span> 且 &lt;span class="math inline">\(\nu_{2}=3\)&lt;/span>.&lt;/p>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(X\)&lt;/span> 的样本,则 &lt;span class="math inline">\(\nu_{1}, \nu_{2}\)&lt;/span> 的矩估计量分别是&lt;span class="math inline">\(G_{1}=B_{3} / B_{2}^{3 / 2}, \quad G_{2}=B_{4} / B_{2}^{2}\)&lt;/span>&lt;/p>
&lt;p>若总体 &lt;span class="math inline">\(X\)&lt;/span> 为正态变量,则可证当 &lt;span class="math inline">\(n\)&lt;/span> 充分大时,近似地有： &lt;span class="math inline">\(G_{1} \sim N\left(0, \frac{6(n-2)}{(n+1)(n+3)}\right)\)&lt;/span> &lt;span class="math inline">\(G_{2} \sim N\left(3-\frac{6}{n+1}, \frac{24 n(n-2)(n-3)}{(n+1)^{2}(n+3)(n+5)}\right)\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(X\)&lt;/span> 的样本,现在来检验假设： &lt;span class="math inline">\(H_{0}: X\)&lt;/span> 为正态总体.&lt;/p>
&lt;p>记&lt;span class="math inline">\(\sigma_{1}=\sqrt{\frac{6(n-2)}{(n+1)(n+3)}}, \quad \sigma_{2}=\sqrt{\frac{24 n(n-2)(n-3)}{(n+1)^{2}(n+3)(n+5)}}\)&lt;/span> &lt;span class="math inline">\(\mu_{2}=3-\frac{6}{n+1}, U_{1}=G_{1} / \sigma_{1}, U_{2}=\left(G_{2}-\mu_{2}\right) / \sigma_{2} .\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真且 &lt;span class="math inline">\(n\)&lt;/span> 充分大时,近似地有&lt;span class="math inline">\(U_{1} \sim N(0,1), \quad U_{2} \sim N(0,1)\)&lt;/span>&lt;/p>
&lt;p>可以证明样本偏度 &lt;span class="math inline">\(G_{1}\)&lt;/span> 、样本峰度 &lt;span class="math inline">\(G_{2}\)&lt;/span> 分别依概率收豆于总体偏度 &lt;span class="math inline">\(\nu_{1}\)&lt;/span> 和总体峰度 &lt;span class="math inline">\(\nu_{2} .\)&lt;/span> 因此当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真且 &lt;span class="math inline">\(n\)&lt;/span> 充分大时,一般来说 &lt;span class="math inline">\(, G_{1}\)&lt;/span> 与 &lt;span class="math inline">\(\nu_{1}=0\)&lt;/span> 的偏离不应太大,而 &lt;span class="math inline">\(G_{2}\)&lt;/span> 与 &lt;span class="math inline">\(\nu_{2}=3\)&lt;/span> 的偏离不应太大. 故从直观来看当 &lt;span class="math inline">\(\left|U_{1}\right|\)&lt;/span> 的观察值 &lt;span class="math inline">\(\left|u_{1}\right|\)&lt;/span> 或 &lt;span class="math inline">\(\left|U_{2}\right|\)&lt;/span> 的观察值 &lt;span class="math inline">\(\left|u_{2}\right|\)&lt;/span> 过大时就拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 取显著性水平为 &lt;span class="math inline">\(\alpha, H_{0}\)&lt;/span> 的拒绝域为&lt;span class="math inline">\(\left|u_{1}\right| \geqslant k_{1} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad\left|u_{2}\right| \geqslant k_{2}\)&lt;/span> 其中 &lt;span class="math inline">\(k_{1}, k_{2}\)&lt;/span> 由以下两式确定： &lt;span class="math inline">\(P_{H_{0}}\left\{\left|U_{1}\right| \geqslant k_{1}\right\}=\frac{\alpha}{2}, \quad P_{H_{0}}\left\{\left|U_{2}\right| \geqslant k_{2}\right\}=\frac{\alpha}{2}\)&lt;/span> 这里记号 &lt;span class="math inline">\(P_{H_{0}}\{\bullet\}\)&lt;/span> 表示当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时事件 &lt;span class="math inline">\(\{\bullet\}\)&lt;/span> 的概率,即有 &lt;span class="math inline">\(k_{1}=z_{\alpha / 4}, k_{2}=z_{\alpha / 4} .\)&lt;/span> 于是得拒绝域为&lt;span class="math inline">\(\left|u_{1}\right| \geqslant z_{\alpha / 4} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad\left|u_{2}\right| \geqslant z_{\alpha / 4}\)&lt;/span>&lt;/p>
&lt;p>下面来验证当 &lt;span class="math inline">\(n\)&lt;/span> 充分大时上述检验法近似地满足显著性水平为 &lt;span class="math inline">\(\alpha\)&lt;/span> 的要求. 事实上当 &lt;span class="math inline">\(n\)&lt;/span> 充分大时有： &lt;span class="math inline">\(P\left\{\right.\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真拒绝 &lt;span class="math inline">\(\left.H_{0}\right\}\)&lt;/span> &lt;span class="math inline">\(=P_{H_{0}}\left\{\left(\left|U_{1}\right| \geqslant z_{\alpha / 4}\right) \cup\left(\left|U_{2}\right| \geqslant z_{\alpha / 4}\right)\right\}\)&lt;/span> &lt;span class="math inline">\(\leqslant P_{H_{0}}\left\{\left|U_{1}\right| \geqslant z_{\alpha / 4}\right\}+P_{H_{0}}\left\{\left|U_{2}\right| \geqslant z_{\alpha / 4}\right\}=\frac{\alpha}{2}+\frac{\alpha}{2}=\alpha\)&lt;/span>&lt;/p>
&lt;h2 id="秩和检验">秩和检验&lt;/h2>
&lt;p>//TODO 秩和检验&lt;/p>
&lt;h2 id="假设检验问题的-p-值检验法">假设检验问题的 &lt;span class="math inline">\(p\)&lt;/span> 值检验法&lt;/h2>
&lt;p>以上讨论的假设检验方法称为&lt;strong>临界值法&lt;/strong>. 本节介绍另一种被称为 &lt;strong>&lt;span class="math inline">\(p\)&lt;/span> 值检验法&lt;/strong>的检验方法. 先从一个例题讲起.&lt;/p>
&lt;blockquote>
&lt;p>例子： 设总体 &lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right), \mu\)&lt;/span> 未知 &lt;span class="math inline">\(, \sigma^{2}=100,\)&lt;/span> 现有样本 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{52},\)&lt;/span> 算得&lt;span class="math inline">\(\bar{x}=62.75 .\)&lt;/span> 现在来检验假设&lt;span class="math inline">\(H_{0}: \mu=\mu_{0}=60, \quad H_{1}: \mu&amp;gt;60\)&lt;/span>&lt;/p>
&lt;p>采用 &lt;span class="math inline">\(Z\)&lt;/span> 检验法,检验统计量为&lt;span class="math inline">\(Z=\frac{\bar{X}-\mu_{0}}{\sigma / \sqrt{n}}\)&lt;/span> 以数据代人,得 &lt;span class="math inline">\(Z\)&lt;/span> 的观察值为&lt;span class="math inline">\(z_{0}=\frac{62.75-60}{10 / \sqrt{52}}=1.983\)&lt;/span>&lt;/p>
&lt;p>概率&lt;span class="math inline">\(P\left\{Z \geqslant z_{0}\right\}=P\{Z \geqslant 1.983\}=1-\Phi(1.983)=0.0238\)&lt;/span> 此即为标准正态曲线下-位于 &lt;span class="math inline">\(z_{0}\)&lt;/span> 右边的尾部面积. &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201223232516805.png" alt="image-20201223232516805" />&lt;/p>
&lt;p>此概率称为 &lt;span class="math inline">\(Z\)&lt;/span> 检验法的右边检验的 &lt;span class="math inline">\(p\)&lt;/span> 值. 记为&lt;span class="math inline">\(P\left\{Z \geqslant z_{0}\right\}=p\)&lt;/span> 值 &lt;span class="math inline">\((这里=0.0237)\)&lt;/span>&lt;/p>
&lt;p>若显著性水平 &lt;span class="math inline">\(\alpha \geqslant p=0.0238\)&lt;/span>,（如上图（1）），则对应的临界值 &lt;span class="math inline">\(z_{\alpha} \leqslant 1.983\)&lt;/span>, 这表示观察值 &lt;span class="math inline">\(z_{0}=1.983\)&lt;/span> 落在拒绝域内，因而拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>; 又若显著性水平 &lt;span class="math inline">\(\alpha&amp;lt;p=\)&lt;/span> 0.0238 ,（如上图（2）），则对应的临界值 &lt;span class="math inline">\(z_{\alpha}&amp;gt;1.983\)&lt;/span>, 这表示观察值 &lt;span class="math inline">\(z_{0}=1.983\)&lt;/span> 不落在拒绝域内 ， 因而接受 &lt;span class="math inline">\(H_{0}\)&lt;/span>. 据此 &lt;span class="math inline">\(, p\)&lt;/span> 值 &lt;span class="math inline">\(=P\left\{Z \geqslant z_{0}\right\}=0.0238\)&lt;/span> 是原假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 可&lt;strong>被拒绝的最小显著性水平&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>一般, &lt;span class="math inline">\(p\)&lt;/span> 值的定义是 : &lt;strong>定义&lt;/strong>：假设检验问题的 &lt;span class="math inline">\(p\)&lt;/span> 值（probability value )是由检验统计量的样本观察值得出的原假设可被拒绝的最小显著性水平.&lt;/p>
&lt;p>任一检验问题的 &lt;span class="math inline">\(p\)&lt;/span> 值可以根据检验统计量的样本观察值以及检验统计量 在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 下一个特定的参数值(一般是 &lt;span class="math inline">\(H_{0}\)&lt;/span> 与 &lt;span class="math inline">\(H_{1}\)&lt;/span> 所规定的参数的分界点)对应的分布求出. 例如在正态总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 均值的检验中,当 &lt;span class="math inline">\(\sigma\)&lt;/span> 未知时,可采用检验统计量 &lt;span class="math inline">\(t=\frac{\bar{X}-\mu_{0}}{S / \sqrt{n}},\)&lt;/span> 在以下三个检验问题中,当 &lt;span class="math inline">\(\mu=\mu_{0}\)&lt;/span> 时 &lt;span class="math inline">\(t \sim t(n-1) .\)&lt;/span> 如果由样本求得统计量 &lt;span class="math inline">\(t\)&lt;/span> 的观察值为 &lt;span class="math inline">\(t_{0}\)&lt;/span>,那么在检验问题 &lt;span class="math inline">\(H_{0}: \mu \leqslant \mu_{0}, H_{1}: \mu&amp;gt;\mu_{0}\)&lt;/span> 中, &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(=P_{\mu_{0}}\left\{t \geqslant t_{0}\right\}=t_{0}\)&lt;/span> 右侧尾部面积; &lt;span class="math inline">\(H_{0}: \mu \geqslant \mu_{0}, H_{1}: \mu&amp;lt;\mu_{0}\)&lt;/span> 中, &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(=P_{\mu_{0}}\left\{t \leqslant t_{0}\right\}=t_{0}\)&lt;/span> 左侧尾部面积; &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201223233202191.png" alt="image-20201223233202191" /> &lt;span class="math inline">\(H_{0}: \mu=\mu_{0}, H_{1}: \mu \neq \mu_{0}\)&lt;/span> 中, (i) 当 &lt;span class="math inline">\(t_{0}&amp;gt;0\)&lt;/span> 时, &lt;span class="math inline">\(p \text { 值 }=P_{\mu_{0}}\left\{|t| \geqslant t_{0}\right\}=P_{\mu_{0}}\left\{\left(t \leqslant-t_{0}\right) \cup\left(t \geqslant t_{0}\right)\right\}\)&lt;/span>&lt;span class="math inline">\(=2 \times\left(t_{0}\right.\)&lt;/span> 右侧尾部面积) (ii) 当 &lt;span class="math inline">\(t_{0}&amp;lt;0\)&lt;/span> 时, &lt;span class="math inline">\(p \text { 值 }=P_{\mu_{0}}\left\{|t| \geqslant-t_{0}\right\}=P_{\mu_{0}}\left\{\left(t \leqslant t_{0}\right) \cup\left(t \geqslant-t_{0}\right)\right\}\)&lt;/span>&lt;span class="math inline">\(=2 \times\left(t_{0}\right.\)&lt;/span> 左侧尾部面积 &lt;span class="math inline">\()\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201223233515034.png" alt="image-20201223233515034" /> 上述各图中的曲线均为 &lt;span class="math inline">\(t(n-1)\)&lt;/span> 分布的概率密度曲线.&lt;/p>
&lt;p>在现代计算机统计软件中,一般都给出检验问题的 &lt;span class="math inline">\(p\)&lt;/span> 值. 按 &lt;span class="math inline">\(p\)&lt;/span> 值的定义,对于任意指定的显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span>,就有 (1) 若 &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(\leqslant \alpha\)&lt;/span>,则在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>. (2) 若 &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(&amp;gt;\alpha\)&lt;/span>,则在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下接受 &lt;span class="math inline">\(H_{0}\)&lt;/span>.&lt;/p>
&lt;p>有了这两条结论就能方便地确定 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的拒绝域. 这种利用 &lt;span class="math inline">\(p\)&lt;/span> 值来确定检验 拒绝域的方法,称为 &lt;strong>&lt;span class="math inline">\(p\)&lt;/span> 值检验法&lt;/strong>.&lt;/p>
&lt;p>用临界值法来确定 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的拒绝域时,例如当取 &lt;span class="math inline">\(\alpha=0.05\)&lt;/span> 时知道要拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>, 再取 &lt;span class="math inline">\(\alpha=0.01\)&lt;/span> 也要拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span>,但不能知道将 &lt;span class="math inline">\(\alpha\)&lt;/span> 再降低一些是否也要拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 而 &lt;span class="math inline">\(p\)&lt;/span> 值法给出了拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的最小显著性水平. 因此 &lt;span class="math inline">\(p\)&lt;/span> 值法比临界值法给出了有关拒绝域的更多的信息.&lt;/p>
&lt;p>&lt;strong>&lt;span class="math inline">\(p\)&lt;/span> 值表示反对原假设 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的依据的强度&lt;/strong>, &lt;span class="math inline">\(p\)&lt;/span> 值越小,反对 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的依据越强、越 充分 (端如对于某个检验问题的检验统计量的观察值的 &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(=0.0009, p\)&lt;/span> 值如 此的小,以至于几乎不可能在 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时出现目前的观察值,这说明拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的 理由很强,我们就拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> ).&lt;/p>
&lt;p>一般,若 &lt;span class="math inline">\(p\)&lt;/span> 值&lt;span class="math inline">\(\leqslant 0.01\)&lt;/span>,称推断&lt;strong>拒绝&lt;/strong> &lt;span class="math inline">\(H_{0}\)&lt;/span> 的&lt;strong>依据很强&lt;/strong>或称&lt;strong>检验是高度显著的&lt;/strong>; 若 &lt;span class="math inline">\(0.01&amp;lt;p\)&lt;/span> 值 &lt;span class="math inline">\(\leqslant 0.05\)&lt;/span> ,称推断拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的依据是强的或称检验是显著的; 若 0.05 &lt;span class="math inline">\(&amp;lt;p\)&lt;/span> 值&lt;span class="math inline">\(\leqslant 0.1\)&lt;/span> ,称推断拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的理由是弱的,检验是不显著的; 若 &lt;span class="math inline">\(p\)&lt;/span> 值 &lt;span class="math inline">\(&amp;gt;0.1\)&lt;/span> 一 般来说没有理由拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 基于 &lt;span class="math inline">\(p\)&lt;/span> 值,研究者可以使用任意希望的显著性水平来作计算。在杂志上或在一些技术报告中，许多研究者在讲述假设检验的结果时，常不明显地论及显著性水平以及临界值，代之以简单地引用假设检验的p值，利用或让读者利用它来评价反对原假设的依据的强度，作出推断.&lt;/p></description></item><item><title>概率论与数理统计-数理统计-参数估计</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</link><pubDate>Thu, 17 Dec 2020 19:57:46 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-数理统计-参数估计">概率论与数理统计-数理统计-参数估计&lt;/h1>
&lt;p>统计推断的基本问题可以分为两大类，一类是&lt;strong>估计问题&lt;/strong>，另一类是&lt;strong>假设检验问题&lt;/strong>。本章讨论总体参数的点估计和区间估计.&lt;/p>
&lt;h2 id="点估计">点估计&lt;/h2>
&lt;p>设总体X的分布函数的形式已知，但它的一个或多个参数未知，借助于总体X的一个样本来估计总体未知参数的值的问题称为参数的&lt;strong>点估计问题&lt;/strong>&lt;/p>
&lt;p>&lt;strong>点估计问题的一般提法&lt;/strong>如下: 设总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数 &lt;span class="math inline">\(F(x ; \theta)\)&lt;/span> 的形式为已知, $ $ 是待估参数. &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本 &lt;span class="math inline">\(, x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是相应的一个样本值. 点估计间题就是要构造一个适当的统计量 &lt;span class="math inline">\(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right),\)&lt;/span> 用它的观察值 &lt;span class="math inline">\(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span> 作为未知参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的近似值. 我们称 &lt;span class="math inline">\(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 为 &lt;span class="math inline">\(\theta\)&lt;/span> 的估计量,称 &lt;span class="math inline">\(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span> 为 &lt;span class="math inline">\(\theta\)&lt;/span> 的估计值. 在不致混淆的情况下统称估计量和估计值为估计。&lt;/p>
&lt;p>注意：由于估计量是样本的函数. 因此对于不同的样本值， &lt;span class="math inline">\(\theta\)&lt;/span> 的估计值一般是不相同的.&lt;/p>
&lt;h3 id="矩估计法">矩估计法&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(X\)&lt;/span> 为连续型随机变量,其概率密度为 &lt;span class="math inline">\(f\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right),\)&lt;/span> 或 &lt;span class="math inline">\(X\)&lt;/span> 为离散型随机变量,其分布律为 &lt;span class="math inline">\(P\{X=x\}=p\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right),\)&lt;/span> 其中 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\)&lt;/span> 为待估参数 &lt;span class="math inline">\(, X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本. 假设总体 &lt;span class="math inline">\(X\)&lt;/span> 的前 &lt;span class="math inline">\(k\)&lt;/span> 阶矩（&lt;span class="math inline">\(l=1,2, \cdots, k\)&lt;/span>）： &lt;span class="math display">\[
\mu_{l}=E\left(X^{l}\right)=\int_{-\infty}^{\infty} x^{l} f\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right) \mathrm{d} x \quad(X \text { 连续型 })
\]&lt;/span> 或者： &lt;span class="math display">\[
\mu_{l}=E\left(X^{l}\right)=\sum_{x \in R_{X}} x^{\prime} p\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right) \quad(X \text { 离散型 })
\]&lt;/span> （其中 &lt;span class="math inline">\(R_{X}\)&lt;/span> 是 &lt;span class="math inline">\(X\)&lt;/span> 可能取值的范围） 一般来说,它们(总体 &lt;span class="math inline">\(X\)&lt;/span> 的前 &lt;span class="math inline">\(k\)&lt;/span> 阶矩)是 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\)&lt;/span> 的函数.&lt;/p>
&lt;p>对于&lt;span class="math inline">\((l=1,2, \cdots, k)\)&lt;/span>,&lt;a href="../概率论与数理统计-数理统计-基本概念/#样本矩与统计量的性质">样本矩&lt;span class="math inline">\(A_{l}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{l}\)&lt;/span>依概率收敛于相应的总体矩&lt;span class="math inline">\(\mu_{l}\)&lt;/span>, 样本矩的连续函数依概率收敛于相应的总体矩的连续函数&lt;/a>。&lt;/p>
&lt;p>这样我们就用样本矩作为相应总体矩的估计量，而以样本矩的连续函数作为相应的总体矩的连续函数的估计量。这种估计方法称为&lt;strong>矩估计法&lt;/strong>。&lt;/p>
&lt;p>矩估计法的具体做法： 设总体的各阶矩（总体分布已知的情况下，各阶矩显然是参数的函数）： &lt;span class="math inline">\(\left\{\begin{aligned} \mu_{1} &amp;amp;=\mu_{1}\left(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\right) \\ \mu_{2} &amp;amp;=\mu_{2}\left(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\right) \\ &amp;amp; \vdots \\ \mu_{k} &amp;amp;=\mu_{k}\left(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\right) \end{aligned}\right.\)&lt;/span> 这是一个包含 &lt;span class="math inline">\(k\)&lt;/span> 个未知参数 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\)&lt;/span> 的联立方程组.一般来说,可以从中解 出 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{k},\)&lt;/span> 得到： &lt;span class="math inline">\(\left\{\begin{aligned} \theta_{1} &amp;amp;=\theta_{1}\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right) \\ \theta_{2} &amp;amp;=\theta_{2}\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right) \\ &amp;amp; \vdots \\ \theta_{k} &amp;amp;=\theta_{k}\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right) \end{aligned}\right.\)&lt;/span> 然后以样本的各阶矩&lt;span class="math inline">\(A_{i}\)&lt;/span>替换上面总体的各阶矩&lt;span class="math inline">\(\mu_i\)&lt;/span>, 即将&lt;span class="math inline">\(\hat{\theta}_{i}=\theta_{i}\left(A_{1}, A_{2}, \cdots, A_{k}\right), i=1,2, \cdots, k\)&lt;/span>作为&lt;span class="math inline">\(\theta_{i}, i=1,2, \cdots, k\)&lt;/span> 的估计量,这种估计量称为&lt;strong>矩估计量&lt;/strong>。矩估计量的观察值称为&lt;strong>矩估计值&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>例子： 设总体 &lt;span class="math inline">\(X\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上服从均匀分布 &lt;span class="math inline">\(, a, b\)&lt;/span> 未知 &lt;span class="math inline">\(. X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自&lt;span class="math inline">\(X\)&lt;/span> 的样本,试求 &lt;span class="math inline">\(a, b\)&lt;/span> 的矩估计量. &lt;span class="math inline">\(\begin{aligned} \mu_{1} &amp;amp;=E(X)=(a+b) / 2 \\ \mu_{2} &amp;amp;=E\left(X^{2}\right)=D(X)+[E(X)]^{2} \\ &amp;amp;=(b-a)^{2} / 12+(a+b)^{2} / 4 \end{aligned}\)&lt;/span> &lt;span class="math inline">\(\left\{\begin{array}{l}a+b=2 \mu_{1} \\ b-a=\sqrt{12\left(\mu_{2}-\mu_{1}^{2}\right)}\end{array}\right.\)&lt;/span> 解得&lt;span class="math inline">\(a=\mu_{1}-\sqrt{3\left(\mu_{2}-\mu_{1}^{2}\right)}, \quad b=\mu_{1}+\sqrt{3\left(\mu_{2}-\mu_{1}^{2}\right)}\)&lt;/span> 然后以&lt;span class="math inline">\(A_{1}, A_{2}\)&lt;/span> 代替 &lt;span class="math inline">\(\mu_{1}, \mu_{2},\)&lt;/span> 得到 &lt;span class="math inline">\(a, b\)&lt;/span> 的矩估计量： &lt;span class="math inline">\(\hat{a}=A_{1}-\sqrt{3\left(A_{2}-A_{1}^{2}\right)}=\bar{X}-\sqrt{\frac{3}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}}\)&lt;/span> &lt;span class="math inline">\(\hat{b}=A_{1}+\sqrt{3\left(A_{2}-A_{1}^{2}\right)}=\bar{X}+\sqrt{\frac{3}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}}\)&lt;/span> （注意到&lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n} X_{i}^{2}-\bar{X}^{2}=\)&lt;/span>&lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\)&lt;/span>）&lt;/p>
&lt;/blockquote>
&lt;h3 id="极大似然估计法">极大似然估计法&lt;/h3>
&lt;p>极大似然估计法是英国统计学家费希尔(R.A.Fisher)于1922年提出的。它是建立在极大似然原理的基础上的一种估计方法。&lt;/p>
&lt;h4 id="极大似然原理">极大似然原理&lt;/h4>
&lt;p>&lt;strong>极大似然原理&lt;/strong>是人们从长期的生活实践中提炼出来的，其内容可以简单叙述为： 若一个随机试验由若干可能结果：&lt;span class="math inline">\(A_1,A_2,\cdots\)&lt;/span>,如果在&lt;strong>一次试验中，结果&lt;span class="math inline">\(A_1\)&lt;/span>发生了，那么就说明试验的条件对事件&lt;span class="math inline">\(A_1\)&lt;/span>最有利，即认为事件&lt;span class="math inline">\(A_1\)&lt;/span>发生的概率最大&lt;/strong>。 比如两个箱子：甲箱放了99白球和1黑球，乙箱子放了99黑球和1白球，从两箱子任选一箱子，取出一球， 结果取到了黑球，就认为当前情况下很可能取到黑球的概率最大（对取到黑球最有利），即最有可能是从乙箱子取出的，这也是“极大似然”之意。&lt;/p>
&lt;h4 id="似然函数">似然函数&lt;/h4>
&lt;p>我们从极大似然原理出发，对离散型和连续型总体量汇总情形来阐述极大似然法的具体实现途径。为此我们先介绍似然函数的概念。&lt;/p>
&lt;p>&lt;strong>若总体 &lt;span class="math inline">\(X\)&lt;/span> 属离散型&lt;/strong>,其分布律 &lt;span class="math inline">\(P\{X=x\}=p(x ; \theta), \theta \in \Theta\)&lt;/span> 的形式为已知, &lt;span class="math inline">\(\theta\)&lt;/span>为待估参数, &lt;span class="math inline">\(\Theta\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 可能取值的范围. 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本,则 &lt;span class="math inline">\(X_{1}\)&lt;/span>,&lt;span class="math inline">\(X_{2}, \cdots, X_{n}\)&lt;/span> 的联合分布律为&lt;span class="math inline">\(\prod_{i=1}^{n} p\left(x_{i} ; \theta\right)\)&lt;/span>， 又设 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是相应于样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 的一个样本值. 易知样本 &lt;span class="math inline">\(X_{1},X_{2}, \cdots, X_{n}\)&lt;/span> 取到观察值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 的&lt;strong>概率&lt;/strong>（即事件 &lt;span class="math inline">\(\left\{X_{1}=x_{1}, X_{2}=x_{2}, \cdots, X_{n}\right.\)&lt;/span> &lt;span class="math inline">\(\left.=x_{n}\right\}\)&lt;/span> 发生的概率）为： &lt;span class="math inline">\(L(\theta)=L\left(x_{1}, x_{2}, \cdots, x_{n} ; \theta\right)=\prod_{i=1}^{n} p\left(x_{i} ; \theta\right), \theta \in \Theta\)&lt;/span>，&lt;span class="math inline">\(L(\theta)\)&lt;/span> ， 称为&lt;strong>样本的似然函数&lt;/strong>。&lt;/p>
&lt;p>注意：这里的&lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是已知的样本值，它们都是常数。&lt;/p>
&lt;p>&lt;strong>若总体 &lt;span class="math inline">\(X\)&lt;/span> 属连续型&lt;/strong>,其概率密度 &lt;span class="math inline">\(f(x ; \theta), \theta \in \Theta\)&lt;/span> 的形式已知, &lt;span class="math inline">\(\theta\)&lt;/span> 为待估参数，&lt;span class="math inline">\(\Theta\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 可能取值的范围. 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本,则 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 的联合密度为&lt;span class="math inline">\(\prod_{i=1}^{n} f\left(x_{i}, \theta\right)\)&lt;/span>， 又设 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是相应于样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 的一个样本值. 则随机点&lt;span class="math inline">\((X_{1}, X_{2}, \cdots, X_{n})\)&lt;/span> 落在点 &lt;span class="math inline">\(\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span> 的邻域 &lt;span class="math inline">\(\left(\right.\)&lt;/span> 边长分别为 &lt;span class="math inline">\(\mathrm{d} x_{1}, \mathrm{~d} x_{2}, \cdots, \mathrm{d} x_{n}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 维立方体内的概率近似为&lt;span class="math inline">\(\prod_{i=1}^{n} f\left(x_{i} ; \theta\right) \mathrm{d} x_{i}\)&lt;/span>， 又因为因子 &lt;span class="math inline">\(\prod_{i=1}^{n} \mathrm{~d} x_{i}\)&lt;/span> 不随 &lt;span class="math inline">\(\theta\)&lt;/span> 而变,故将联合密度函数： &lt;span class="math inline">\(L(\theta)=L\left(x_{1}, x_{2}, \cdots, x_{n} ; \theta\right)=\prod_{i=1}^{n} f\left(x_{i} ; \theta\right)\)&lt;/span>， 称为&lt;strong>样本的似然函数&lt;/strong>。&lt;/p>
&lt;h4 id="参数theta的极大似然估计">参数&lt;span class="math inline">\(\theta\)&lt;/span>的极大似然估计&lt;/h4>
&lt;p>关于最大似然估计原理,我们有直观想法: 现在已经取到样本值 &lt;span class="math inline">\(x_{1}\)&lt;/span> ，&lt;span class="math inline">\(x_{2}, \cdots, x_{n}\)&lt;/span> 了,这表明取到这一样本值的概率 &lt;span class="math inline">\(L(\theta(x_{1}, x_{2}, \cdots, x_{n}))\)&lt;/span> 比较大。也即在$ &lt;span class="math inline">\(的范围内，找到一个\)&lt;/span>&lt;span class="math inline">\(，使取得样本值\)&lt;/span>x_{1}, x_{2}, , x_{n}&lt;span class="math inline">\(的概率\)&lt;/span>L()$最大。&lt;/p>
&lt;p>设&lt;span class="math inline">\(L(\theta) = L\left(x_{1}, x_{2}, \cdots, x_{n} ; \theta\right)\)&lt;/span>为似然函数，若存在&lt;span class="math inline">\(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>，使得&lt;span class="math inline">\(L(\hat{\theta})=\max _{\theta \in \Theta} L(\theta)\)&lt;/span>，则称&lt;span class="math inline">\(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>为未知&lt;strong>参数&lt;span class="math inline">\(\theta\)&lt;/span>的极大似然估计值&lt;/strong>，&lt;span class="math inline">\(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>为未知&lt;strong>参数&lt;span class="math inline">\(\theta\)&lt;/span>的极大似然估计值&lt;/strong>。&lt;/p>
&lt;p>这样，&lt;strong>确定最大似然估计量的问题就归结为微分学中的求最大值的问题&lt;/strong>了。&lt;/p>
&lt;h5 id="若似然函数可微">若似然函数可微&lt;/h5>
&lt;p>在很多情形下 &lt;span class="math inline">\(, p(x ; \theta)\)&lt;/span> 和 &lt;span class="math inline">\(f(x ; \theta)\)&lt;/span> 关于 &lt;span class="math inline">\(\theta\)&lt;/span> &lt;strong>可微&lt;/strong>, 这时 &lt;span class="math inline">\(\hat{\theta}\)&lt;/span> 常可从方程&lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} \theta} L(\theta)=0\)&lt;/span>解得，该方程也称&lt;strong>似然方程&lt;/strong>。 又因 &lt;span class="math inline">\(L(\theta)\)&lt;/span> 与 &lt;span class="math inline">\(\ln L(\theta)\)&lt;/span> 在同一 &lt;span class="math inline">\(\theta\)&lt;/span> 处取到极值，因此 &lt;span class="math inline">\(, \theta\)&lt;/span> 的最大似然估计 &lt;span class="math inline">\(\theta\)&lt;/span> 也可从方程&lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} \theta} \ln L(\theta)=0\)&lt;/span>，该方程称为&lt;strong>对数似然方程&lt;/strong>。 函数取对数可以将连乘化为加法，后一方程求解往往比较方便。&lt;/p>
&lt;blockquote>
&lt;p>例子： 设 &lt;span class="math inline">\(X \sim b(1, p) . X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本,试求参数 &lt;span class="math inline">\(p\)&lt;/span> 的极大似然估计量。 设 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是相应于样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 的一个样本值. &lt;span class="math inline">\(X\)&lt;/span> 的分布律为&lt;span class="math inline">\(P\{X=x\}=p^{x}(1-p)^{1-x}, \quad x=0,1\)&lt;/span>。 故似然函数为&lt;span class="math inline">\(L(p)=\prod_{i=1}^{n} p^{x_{i}}(1-p)^{1-x_{i}}=p^{\sum_{i=1}^{n} x_{i}}(1-p)^{n-\sum_{i=1}^{n} x_{i}}\)&lt;/span> 对数似然函数为&lt;span class="math inline">\(\ln L(p)=\left(\sum_{i=1}^{n} x_{i}\right) \ln p+\left(n-\sum_{i=1}^{n} x_{i}\right) \ln (1-p)\)&lt;/span> 令&lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} p} \ln L(p)=\frac{\sum_{i=1}^{n} x_{i}}{p}-\frac{n-\sum_{i=1}^{n} x_{i}}{1-p}=0\)&lt;/span> 解得p的极大似然估计值&lt;span class="math inline">\(\hat{p}=\frac{1}{n} \sum_{i=1}^{n} x_{i}=\bar{x}\)&lt;/span>， p的极大似然估计量为&lt;span class="math inline">\(\hat{p}=\frac{1}{n} \sum_{i=1}^{n} X_{i}=\bar{X}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="若似然函数不可微">若似然函数不可微&lt;/h5>
&lt;p>除了一些简单的情况外,似然方程往往没有有限函数形式的解,这就需要用&lt;strong>数值方法求近似解&lt;/strong> .常用算法是&lt;a href="https://zh.wikipedia.org/wiki/%E7%89%9B%E9%A1%BF%E6%B3%95">牛顿一拉弗森（Newton-Raphson）算法&lt;/a>。&lt;/p>
&lt;h4 id="多个参数的情况">多个参数的情况&lt;/h4>
&lt;h5 id="若似然函数可微-1">若似然函数可微&lt;/h5>
&lt;p>最大似然估计法也适用于分布中含多个未知参数 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\)&lt;/span> 的情况. 这时,似然函数 &lt;span class="math inline">\(L\)&lt;/span> 是这些未知参数的函数. 分别令：&lt;span class="math inline">\(\frac{\partial}{\partial \theta_{i}} L=0, i=1,2, \cdots, k\)&lt;/span> 或者令：&lt;span class="math inline">\(\frac{\partial}{\partial \theta_{i}} \ln L=0, i=1,2, \cdots, k\)&lt;/span> 解上述由 &lt;span class="math inline">\(k\)&lt;/span> 个方程组成的方程组,即可得到各未知参数 &lt;span class="math inline">\(\theta_{i}(i=1,2, \cdots, k)\)&lt;/span> 的最大似然估计值&lt;span class="math inline">\(\hat{\theta}_{i}\)&lt;/span>。&lt;/p>
&lt;h5 id="若似然函数不可微-1">若似然函数不可微&lt;/h5>
&lt;p>似然方程组没有有限函数形式的解,这就需要用&lt;strong>数值方法求近似解&lt;/strong> .常用拟牛顿法等最优化方法。&lt;/p>
&lt;p>进一步阅读：https://kangcai.github.io/2018/12/17/ml-overall-9-algorithm-QNM/ 进一步阅读：最优化问题总结&lt;/p>
&lt;h4 id="基于截尾样本的最大似然估计">基于截尾样本的最大似然估计&lt;/h4>
&lt;p>在研究产品的可靠性时，需要研究产品寿命T的各种特征。产品寿命T是一个随机变量，它的分布称为寿命分布，为了对寿命分布进行统计推断，就需要通过产品的寿命试验，以取得寿命数据。 一种典型的寿命试验是,将随机抽取的 &lt;span class="math inline">\(n\)&lt;/span> 个产品在时间 &lt;span class="math inline">\(t=0\)&lt;/span> 时,同时投入试验,直到每个产品都失效。记录每一个产品的失效时间，这样得到的样本 (即 由所有产品的失效时间 &lt;span class="math inline">\(0 \leqslant t_{1} \leqslant t_{2} \leqslant \cdots \leqslant t_{n}\)&lt;/span> 所组成的样本) 叫&lt;strong>完全样本&lt;/strong>。 然而产品的寿命往往较长,由于时间和财力的限制，我们不可能得到完全样本,于是就考虑&lt;strong>截尾寿命试验&lt;/strong>。截尾寿命试验常用的有两种 : 一种是&lt;strong>定时截尾寿命试验&lt;/strong>。假设将随机抽取的 &lt;span class="math inline">\(n\)&lt;/span> 个产品在时间 &lt;span class="math inline">\(t=0\)&lt;/span> 时同时投入试验,试验进行到事先规定的截尾时间 &lt;span class="math inline">\(t_{0}\)&lt;/span> 停止。如试验截止时共有 &lt;span class="math inline">\(m\)&lt;/span> 个产品失效,它们的失效时间分别为&lt;span class="math inline">\(0 \leqslant t_{1} \leqslant t_{2} \leqslant \cdots \leqslant t_{m} \leqslant t_{0}\)&lt;/span>，此时 &lt;span class="math inline">\(m\)&lt;/span> 是一个随机变量,所得的样本 &lt;span class="math inline">\(t_{1}, t_{2}, \cdots, t_{m}\)&lt;/span> 称为&lt;strong>定时截尾样本&lt;/strong> 。 另一种是&lt;strong>定数截尾寿命试验&lt;/strong>。假设将随机抽取的 &lt;span class="math inline">\(n\)&lt;/span> 个产品在 &lt;span class="math inline">\(t=0\)&lt;/span> 时同时投入试验。试验进行到有 &lt;span class="math inline">\(m\)&lt;/span> 个 &lt;span class="math inline">\((m\)&lt;/span> 是事先规定的 &lt;span class="math inline">\(, m&amp;lt;n)\)&lt;/span> 产品失效时停止， &lt;span class="math inline">\(m\)&lt;/span> 个失效产品的失效时间分别为&lt;span class="math inline">\(0 \leqslant t_{1} \leqslant t_{2} \leqslant \cdots \leqslant t_{m}\)&lt;/span>，这里 &lt;span class="math inline">\(t_{m}\)&lt;/span> 是第 &lt;span class="math inline">\(m\)&lt;/span> 个产品的失效时间 &lt;span class="math inline">\(, t_{m}\)&lt;/span> 是随机变量。所得的样本 &lt;span class="math inline">\(t_{1}, t_{2}, \cdots, t_{m}\)&lt;/span> 称为&lt;strong>定数截尾样本&lt;/strong>。&lt;/p>
&lt;p>用截尾样本来进行统计推断是可靠性研究中常见的问题 .&lt;/p>
&lt;p>&lt;strong>设产品的寿命服从指数分布&lt;/strong>， 其概率密度为&lt;span class="math inline">\(f(t)=\left\{\begin{array}{l}\frac{1}{\theta} \mathrm{e}^{-t / \theta}, t&amp;gt;0 \\ 0, \quad t \leqslant 0\end{array}\right.\)&lt;/span> &lt;span class="math inline">\(\theta&amp;gt;0\)&lt;/span> 未知 &lt;span class="math inline">\(.\)&lt;/span> 设有 &lt;span class="math inline">\(n\)&lt;/span> 个产品投入&lt;strong>定数截尾试验&lt;/strong>,截尾数为 &lt;span class="math inline">\(m,\)&lt;/span> 得&lt;strong>定数截尾样本&lt;/strong> &lt;span class="math inline">\(0 \leqslant t_{1} \leqslant t_{2} \leqslant \cdots \leqslant t_{m},\)&lt;/span> 现在要利用这一样本来估计未知参数 &lt;span class="math inline">\(\theta\)&lt;/span> (即产品的平均寿命). 在时间区间 &lt;span class="math inline">\(\left[0, t_{m}\right]\)&lt;/span> 有 &lt;span class="math inline">\(m\)&lt;/span> 个产品失效,而有 &lt;span class="math inline">\(n-m\)&lt;/span> 个产品在 &lt;span class="math inline">\(t_{m}\)&lt;/span> 时尚未失效,即有 &lt;span class="math inline">\(n-m\)&lt;/span> 个产品的寿命超过 &lt;span class="math inline">\(t_{m} .\)&lt;/span> 我们用最大似然估计法来估计 &lt;span class="math inline">\(\theta,\)&lt;/span> 为了确定似然函数,需要知道上述观察结果出现的概率 . 我们知道一个产品在 &lt;span class="math inline">\(\left(t_{i}, t_{i}+\mathrm{d} t_{i}\right]\)&lt;/span> 失效的概率近似地为 &lt;span class="math inline">\(f\left(t_{i}\right) \mathrm{d} t_{i}=\frac{1}{\theta} \mathrm{e}^{-t_{i} / \theta} \mathrm{d} t_{i}, i=1,2, \cdots, m,\)&lt;/span> 其余 &lt;span class="math inline">\(n-m\)&lt;/span> 个产品寿命超过 &lt;span class="math inline">\(t_{m}\)&lt;/span> 的概率为 &lt;span class="math inline">\(\left(\int_{t_{m}}^{\infty} \frac{1}{\theta} \mathrm{e}^{-t / \theta} \mathrm{d} t\right)^{n-m}=\left(\mathrm{e}^{-t_{m} / \theta}\right)^{n-m},\)&lt;/span> 故上述观察结果出现的概率近似为： &lt;span class="math inline">\(\left(\begin{array}{l}n \\ m\end{array}\right)\left(\frac{1}{\theta} \mathrm{e}^{-t_{1} / \theta} \mathrm{d} t_{1}\right)\left(\frac{1}{\theta} \mathrm{e}^{-t_{2} / \theta} \mathrm{d} t_{2}\right) \cdots\left(\frac{1}{\theta} \mathrm{e}^{-t_{m} / \theta} \mathrm{d} t_{m}\right)\left(\mathrm{e}^{-t_{m} / \theta}\right)^{n-m}\)&lt;/span> &lt;span class="math inline">\(\quad=\left(\begin{array}{l}n \\ m\end{array}\right) \frac{1}{\theta^{m}} \mathrm{e}^{-\frac{1}{\theta}\left[t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{m}\right]} \mathrm{d} t_{1} \mathrm{~d} t_{2} \cdots \mathrm{d} t_{m}\)&lt;/span> 其中&lt;span class="math inline">\(\mathrm{d} t_{1}, \cdots, \mathrm{d} t_{m}\)&lt;/span>为常数。因忽略一个常数因子不影响θ的最大似然估计， 故可取似然函数为&lt;span class="math inline">\(L(\theta)=\frac{1}{\theta^{m}} \mathrm{e}^{-\frac{1}{\theta}\left[t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{m}\right]}\)&lt;/span> 对数似然函数为&lt;span class="math inline">\(\ln L(\theta)=-m \ln \theta-\frac{1}{\theta}\left[t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{m}\right]\)&lt;/span> 令&lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} \theta} \ln L(\theta)=-\frac{m}{\theta}+\frac{1}{\theta^{2}}\left[t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{m}\right]=0\)&lt;/span> 于是得到&lt;span class="math inline">\(\theta\)&lt;/span> 的最大似然估计为&lt;span class="math inline">\(\hat{\theta}=\frac{s\left(t_{m}\right)}{m}\)&lt;/span>，其中&lt;span class="math inline">\(s\left(t_{m}\right)=t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{m}\)&lt;/span> 称为总试验时间 &lt;span class="math inline">\(,\)&lt;/span> 它表示直至时刻 &lt;span class="math inline">\(t_{m}\)&lt;/span> 为止n个产品的试验时间的总和。&lt;/p>
&lt;p>对于&lt;strong>定时截尾样本&lt;/strong>&lt;span class="math inline">\(0 \leqslant t_{1} \leqslant t_{2} \leqslant \cdots \leqslant t_{m} \leqslant t_{0}\)&lt;/span>（其中 &lt;span class="math inline">\(t_{0}\)&lt;/span> 是截尾时间 &lt;span class="math inline">\()\)&lt;/span>, 与上面的讨论类似， 可得似然函数为&lt;span class="math inline">\(L(\theta)=\frac{1}{\theta^{m}} \mathrm{e}^{-\frac{1}{\theta}\left[t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{0}\right]}\)&lt;/span> &lt;span class="math inline">\(\theta\)&lt;/span> 的最大似然估计为&lt;span class="math inline">\(\hat{\theta}=\frac{s\left(t_{0}\right)}{m}\)&lt;/span>，其中&lt;span class="math inline">\(s\left(t_{0}\right)=t_{1}+t_{2}+\cdots+t_{m}+(n-m) t_{0}\)&lt;/span> 称为总试验时间, 它表示直至时刻 &lt;span class="math inline">\(t_{0}\)&lt;/span> 为止n个产品的试验时间的总和。&lt;/p>
&lt;h2 id="估计量的评选标准">估计量的评选标准&lt;/h2>
&lt;p>自前一节可以看到，对于同一参数，用&lt;strong>不同的估计方法求出的估计量可能不相同&lt;/strong>.而且，很明显，&lt;strong>原则上任何统计量都可以作为未知参数的估计量&lt;/strong>。我们自然会问，采用哪一个估计量为好呢？这就涉及用什么样的标准来评价估计量的问题。下面介绍几个常用的标准。&lt;/p>
&lt;h3 id="无偏性">无偏性&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是总体 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本 &lt;span class="math inline">\(, \theta \in \Theta\)&lt;/span> 是包含在总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布中的 待估参数,这里 &lt;span class="math inline">\(\Theta\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的取值范围.&lt;/p>
&lt;p>&lt;strong>无偏性&lt;/strong>： 若估计量 &lt;span class="math inline">\(\hat{\theta}=\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 的数学期望 &lt;span class="math inline">\(E(\hat{\theta})\)&lt;/span> 存在,且对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 有&lt;span class="math inline">\(E(\hat{\theta})=\theta\)&lt;/span>，则称&lt;span class="math inline">\(\hat{\theta}\)&lt;/span>是 &lt;span class="math inline">\(\theta\)&lt;/span> 的&lt;strong>无偏估计量&lt;/strong>。&lt;/p>
&lt;p>估计量的无偏性是说对于某些样本值,由这一估计量得到的估计值相对于真值来说偏大,有些则偏小. 反复将这一估计量使用多次,就“平均”来说其偏差 为零. 在科学技术中 &lt;span class="math inline">\(E(\hat{\theta})-\theta\)&lt;/span> 称为以含作为 &lt;span class="math inline">\(\theta\)&lt;/span> 的估计的&lt;strong>系统误差&lt;/strong>. 无偏估计的实际意义就是无系统误差.&lt;/p>
&lt;blockquote>
&lt;p>例子： 设总体 &lt;span class="math inline">\(X\)&lt;/span> 的均值为 &lt;span class="math inline">\(\mu,\)&lt;/span> 方差 &lt;span class="math inline">\(\sigma^{2}&amp;gt;0\)&lt;/span> 均未知， 前面已经计算过&lt;span class="math inline">\(E(\bar{X})=\mu, \quad E\left(S^{2}\right)=\sigma^{2}\)&lt;/span>， 则不论总体服从什么分布,样本均值 &lt;span class="math inline">\(\bar{X}\)&lt;/span> 是总体均值 &lt;span class="math inline">\(\mu\)&lt;/span> 的无偏估计； 样本方差&lt;span class="math inline">\(S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\)&lt;/span> 是总体方差的无偏估计，而估计量&lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n}\left(X_{i}-\right.\)&lt;/span>&lt;span class="math inline">\(\bar{X})^{2}\)&lt;/span> 却不是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计,因此我们一般取 &lt;span class="math inline">\(S^{2}\)&lt;/span> 作为 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的估计量。&lt;/p>
&lt;/blockquote>
&lt;h3 id="有效性">有效性&lt;/h3>
&lt;p>现在来比较参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的两个无偏估计量 &lt;span class="math inline">\(\hat{\theta}_{1}\)&lt;/span> 和 &lt;span class="math inline">\(\hat{\theta}_{2},\)&lt;/span> 如果在样本容量 &lt;span class="math inline">\(n\)&lt;/span> 相同的情况下, &lt;span class="math inline">\(\hat{\theta}_{1}\)&lt;/span> 的观察值较 &lt;span class="math inline">\(\hat{\theta}_{2}\)&lt;/span> 更密集在真值 &lt;span class="math inline">\(\theta\)&lt;/span> 的附近,我们就认为 &lt;span class="math inline">\(\hat{\theta}_{1}\)&lt;/span> 较 &lt;span class="math inline">\(\hat{\theta}_{2}\)&lt;/span> 为理想. 由于方差是随机变量取值与其数学期望(无偏估计的数学期望 &lt;span class="math inline">\(\left.E\left(\hat{\theta}_{1}\right)=E\left(\hat{\theta}_{2}\right)=\theta\right)\)&lt;/span> 的偏离程度的度量,所以无偏估计以方差小者为好. 这就引出了估计量的有效性这一概念.&lt;/p>
&lt;p>&lt;strong>有效性&lt;/strong>：设 &lt;span class="math inline">\(\hat{\theta}_{1}=\hat{\theta}_{1}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 与 &lt;span class="math inline">\(\hat{\theta}_{2}=\hat{\theta}_{2}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 都是 &lt;span class="math inline">\(\theta\)&lt;/span> 的无偏估计量,若对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span>,有&lt;span class="math inline">\(D\left(\hat{\theta}_{1}\right) \leqslant D\left(\hat{\theta}_{2}\right)\)&lt;/span>，且至少对于某一个 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 上式中的不等号成立,则称 &lt;span class="math inline">\(\hat{\theta}_{1}\)&lt;/span> 较 &lt;span class="math inline">\(\hat{\theta}_{2}\)&lt;/span> 有效.&lt;/p>
&lt;h3 id="相合性">相合性&lt;/h3>
&lt;p>前面讲的无偏性与有效性都是在样本容量n固定的前提下提出的。我们自然希望随着样本容量的增大，一个估计量的值稳定于待估参数的真值。这样，对估计量又有下述相合性的要求。&lt;/p>
&lt;p>&lt;strong>相合性&lt;/strong> ： 设 &lt;span class="math inline">\(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 为参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的估计量, 若对于任意 &lt;span class="math inline">\(\theta \in \Theta,\)&lt;/span> 当 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span>时 &lt;span class="math inline">\(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 依概率收敛于 &lt;span class="math inline">\(\theta,\)&lt;/span> 则称 &lt;span class="math inline">\(\hat{\theta}\)&lt;/span> 为 &lt;span class="math inline">\(\theta\)&lt;/span> 的&lt;strong>相合估计量&lt;/strong>. 即,若对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 都满足 : 对于任意 &lt;span class="math inline">\(\varepsilon&amp;gt;0,\)&lt;/span> 有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\{|\hat{\theta}-\theta|&amp;lt;\varepsilon\}=1\)&lt;/span>，则称 &lt;span class="math inline">\(\hat{\theta}\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的&lt;strong>相合估计量&lt;/strong>。&lt;/p>
&lt;p>在矩估计法中，我们知道样本 &lt;span class="math inline">\(k(k \geqslant 1)\)&lt;/span> 阶矩是总体 &lt;span class="math inline">\(X\)&lt;/span> 的 &lt;span class="math inline">\(k\)&lt;/span> 阶矩 &lt;span class="math inline">\(\mu_{k}=E\left(X^{k}\right)\)&lt;/span> 的相合估计量（样本矩依概率收敛于对应总体矩），进而若待估参数 &lt;span class="math inline">\(\theta=g\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right),\)&lt;/span> 其中 &lt;span class="math inline">\(g\)&lt;/span> 为连续函数,则 &lt;span class="math inline">\(\theta\)&lt;/span> 的矩估计量 &lt;span class="math inline">\(\hat{\theta}=g\left(\hat{\mu}_{1}, \hat{\mu}_{2}, \cdots, \hat{\mu}_{k}\right)=g\left(A_{1}, A_{2}, \cdots, A_{k}\right)\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的相合估计量（样本矩的连续函数依概率收敛于对应总体矩的连续函数）&lt;/p>
&lt;p>极大似然估计法得到的估计量, 在一定条件下也具有相合性. 其详细讨论已超出本书范围,从略.&lt;/p>
&lt;p>上述无偏性、有效性、相合性是评价估计量的一些基本标准，其他的标准这里就不讲了。&lt;/p>
&lt;h2 id="区间估计">区间估计&lt;/h2>
&lt;p>对于一个未知量,人们在测量或计算时,常不以&lt;strong>得到近似值&lt;/strong>为满足,&lt;strong>还需估计误差&lt;/strong>,即要求知道近似值的精确程度(亦即所求真值所在的范围). 类似地,对 于未知参数 &lt;span class="math inline">\(\theta,\)&lt;/span> 除了求出它的点估计 &lt;span class="math inline">\(\hat{\theta}\)&lt;/span> 外,&lt;strong>我们还希望估计出一个范围,并希望知道这个范围包含参数 &lt;span class="math inline">\(\theta\)&lt;/span> 真值的可信程度.&lt;/strong> 这样的范围通常以区间的形式给出,同 时还给出此区间包含参数 &lt;span class="math inline">\(\theta\)&lt;/span> 真值的可信程度. 这种形式的估计称为区间估计,这 样的区间即所谓置信区间. 现在我们引人置信区间的定义.&lt;/p>
&lt;h3 id="置信区间">置信区间&lt;/h3>
&lt;p>设总体 &lt;span class="math inline">\(X\)&lt;/span> 的分布函数 &lt;span class="math inline">\(F(x ; \theta)\)&lt;/span> 含有一个未知参数 &lt;span class="math inline">\(\theta, \theta \in \Theta(\Theta\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 可能取值的范围 &lt;span class="math inline">\()\)&lt;/span>, 对于给定值 &lt;span class="math inline">\(\alpha(0&amp;lt;\alpha&amp;lt;1),\)&lt;/span> 若由来自 &lt;span class="math inline">\(X\)&lt;/span> 的样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots,\)&lt;/span> &lt;span class="math inline">\(X_{n}\)&lt;/span> 确定的两个统计量 &lt;span class="math inline">\(\theta=\underline{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 和 &lt;span class="math inline">\(\bar{\theta}=\bar{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)(\theta&amp;lt;\bar{\theta}),\)&lt;/span> 对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 满足&lt;span class="math inline">\(P\left\{\underline{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)&amp;lt;\theta&amp;lt;\bar{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\right\} \geqslant 1-\alpha\)&lt;/span>， 则称随机区间 &lt;span class="math inline">\((\theta, \bar{\theta})\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>置信区间&lt;/strong> &lt;span class="math inline">\(, \theta\)&lt;/span> 和 &lt;span class="math inline">\(\bar{\theta}\)&lt;/span> 分别称为置信水 平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>双侧置信区间&lt;/strong>的&lt;strong>置信下限&lt;/strong>和&lt;strong>置信上限&lt;/strong>, &lt;span class="math inline">\(1-\alpha\)&lt;/span> 称为&lt;strong>置信水平&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(P\left\{\underline{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)&amp;lt;\theta&amp;lt;\bar{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\right\} \geqslant 1-\alpha\)&lt;/span>的含义： 若反复抽样多次(各次得到的样本的容量相等,都是 &lt;span class="math inline">\(n\)&lt;/span> ). 每个样本值确定一个区间 &lt;span class="math inline">\((\theta, \bar{\theta})\)&lt;/span>,每个这样的区间要么包含 &lt;span class="math inline">\(\theta\)&lt;/span> 的真值,要么不 包含 &lt;span class="math inline">\(\theta\)&lt;/span> 的真值. 按伯努利大数定理,在这么多的区间中,包含 &lt;span class="math inline">\(\theta\)&lt;/span> 真 值的约占 &lt;span class="math inline">\(100(1-\alpha) \%\)&lt;/span>,不包含 &lt;span class="math inline">\(\theta\)&lt;/span> 真值的约仅占 &lt;span class="math inline">\(100 \alpha \% .\)&lt;/span> 例如,若 &lt;span class="math inline">\(\alpha=0.01,\)&lt;/span> 反复 抽样 1000 次,则得到的 1000 个区间中不包含 &lt;span class="math inline">\(\theta\)&lt;/span> 真值的约仅为 10 个.&lt;/p>
&lt;/blockquote>
&lt;p>当 &lt;span class="math inline">\(X\)&lt;/span> 是连续型随机变量时,对于给定的 &lt;span class="math inline">\(\alpha,\)&lt;/span> 按 &lt;span class="math inline">\(P\{\theta&amp;lt;\theta&amp;lt;\bar{\theta}\}\)&lt;/span> &lt;span class="math inline">\(=1-\alpha\)&lt;/span> 求置信区间 &lt;span class="math inline">\(.\)&lt;/span> 而当 &lt;span class="math inline">\(X\)&lt;/span> 是离散型随机变量时,对于给定的 &lt;span class="math inline">\(\alpha,\)&lt;/span> 可能找不到 &lt;span class="math inline">\(P\{\theta&amp;lt;\theta&amp;lt;\bar{\theta}\}\)&lt;/span> 恰为 &lt;span class="math inline">\(1-\alpha\)&lt;/span>的区间 &lt;span class="math inline">\((\theta, \bar{\theta})\)&lt;/span> ，则取 &lt;span class="math inline">\(P\{\theta&amp;lt;\theta&amp;lt;\bar{\theta}\}\)&lt;/span>至少为 &lt;span class="math inline">\(1-\alpha,\)&lt;/span> 且尽可能地接近 &lt;span class="math inline">\(1-\alpha\)&lt;/span>区间 &lt;span class="math inline">\((\theta, \bar{\theta})\)&lt;/span> （向外取近似区间）&lt;/p>
&lt;blockquote>
&lt;p>例子 设总体 &lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right), \sigma^{2}\)&lt;/span> 为已知 &lt;span class="math inline">\(, \mu\)&lt;/span> 为未知,设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自&lt;span class="math inline">\(X\)&lt;/span> 的样本,求 &lt;span class="math inline">\(\mu\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间. 我们知道 &lt;span class="math inline">\(\bar{X}\)&lt;/span> 是 &lt;span class="math inline">\(\mu\)&lt;/span> 的无偏估计. 且有&lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)\)&lt;/span>， &lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}}\)&lt;/span> 所服从的分布 &lt;span class="math inline">\(N(0,1)\)&lt;/span> 不依赖于任何未知参数. 按标准正态分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点的定义，有： &lt;span class="math inline">\(P\left\{\left|\frac{\bar{X}-\mu}{\sigma / \sqrt{n}}\right|&amp;lt;z_{\alpha / 2}\right\}=1-\alpha\)&lt;/span> 即&lt;span class="math inline">\(P\left\{\bar{X}-\frac{\sigma}{\sqrt{n}} z_{a / 2}&amp;lt;\mu&amp;lt;\bar{X}+\frac{\sigma}{\sqrt{n}} z_{a / 2}\right\}=1-\alpha\)&lt;/span> 这样,我们就得到了 &lt;span class="math inline">\(\mu\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间： &lt;span class="math inline">\(\left(\bar{X}-\frac{\sigma}{\sqrt{n}} z_{\alpha / 2}, \quad \bar{X}+\frac{\sigma}{\sqrt{n}} z_{\alpha / 2}\right)\)&lt;/span> 这样的置信区间常写成&lt;span class="math inline">\(\left(\bar{X} \pm \frac{\sigma}{\sqrt{n}} z_{\alpha / 2}\right)\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201218190425146.png" alt="image-20201218190425146" /> 若取&lt;span class="math inline">\(1-\alpha=0.95,\)&lt;/span> 即 &lt;span class="math inline">\(\alpha=0.05,\)&lt;/span> 又若 &lt;span class="math inline">\(\sigma=1, n=16,\)&lt;/span> 查表得 $z_{/ 2}=z_{0.025}=1.96 &lt;span class="math inline">\(。 于是我们得到一个置信水平为 0.95 的置信区间\)&lt;/span>({X} ), $ 即 &lt;span class="math inline">\((\bar{X} \pm 0.49)\)&lt;/span> 再者,若由一个样本值算得样本均值的观察值 &lt;span class="math inline">\(\bar{x}=5.20,\)&lt;/span> 则得到一个区间&lt;span class="math inline">\((5.20 \pm 0.49),\)&lt;/span> 即 &lt;span class="math inline">\(\quad(4.71,5.69) .\)&lt;/span> 注意,这已经不是随机区间了.但我们仍称它为置信水平为 0.95 的置信区间. 含义:若反复抽样多次,每个样本值 &lt;span class="math inline">\((n=16)\)&lt;/span> 按置信区间定义确定一个区间,按上面 的解释,在这么多的区间中,包含 &lt;span class="math inline">\(\mu\)&lt;/span> 的约占 &lt;span class="math inline">\(95 \%\)&lt;/span>,不包含 &lt;span class="math inline">\(\mu\)&lt;/span> 的约仅占 &lt;span class="math inline">\(5 \% .\)&lt;/span> 现在抽 样得到区间 &lt;span class="math inline">\((4.71,5.69),\)&lt;/span> 则该区间属于那些包含 &lt;span class="math inline">\(\mu\)&lt;/span> 的区间的可信程度为 &lt;span class="math inline">\(95 \%\)&lt;/span>, 或“该区间包含 &lt;span class="math inline">\(\mu\)&lt;/span>”这一陈述的可信程度为 &lt;span class="math inline">\(95 \%\)&lt;/span>.&lt;/p>
&lt;/blockquote>
&lt;p>置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间并不是唯一的. 以上面的例子来说,若给定 &lt;span class="math inline">\(\alpha=0.05\)&lt;/span>则又有 &lt;span class="math inline">\(P\left\{-z_{0.04}&amp;lt;\frac{\bar{X}-\mu}{\sigma / \sqrt{n}}&amp;lt;z_{0.01}\right\}=0.95\)&lt;/span>， 即&lt;span class="math inline">\(P\left\{\bar{X}-\frac{\sigma}{\sqrt{n}} z_{0.01}&amp;lt;\mu&amp;lt;\bar{X}+\frac{\sigma}{\sqrt{n}} z_{0.04}\right\}=0.95\)&lt;/span>， 即&lt;span class="math inline">\(\left(\bar{X}-\frac{\sigma}{\sqrt{n}} z_{0.01}, \bar{X}+\frac{\sigma}{\sqrt{n}} z_{0.04}\right)\)&lt;/span> 与之前得到的置信区间比较可以得到：使用&lt;span class="math inline">\(z_{\alpha/2}\)&lt;/span>的区间更小，区间小则精度高。 易知，像 &lt;span class="math inline">\(N(0,1)\)&lt;/span> 分布那样其概率密度的图形是单峰且对称的情况,当 &lt;span class="math inline">\(n\)&lt;/span> 固定时，使用&lt;span class="math inline">\(z_{\alpha/2}\)&lt;/span>的区间其长度为最短,我们自然选用它.&lt;/p>
&lt;p>寻求未知参数 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信区间的具体做法如下： 1） 寻求一个样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 和 &lt;span class="math inline">\(\theta\)&lt;/span> 的函数 &lt;span class="math inline">\(W=W\left(X_{1}, X_{2}, \cdots, X_{n} ; \theta\right),\)&lt;/span> 使得 &lt;span class="math inline">\(W\)&lt;/span> 的分布不依赖于 &lt;span class="math inline">\(\theta\)&lt;/span> 以及其他未知参数,称具有这种性质的函数 &lt;span class="math inline">\(W\)&lt;/span> 为&lt;strong>枢轴量&lt;/strong>. 2）对于给定的置信水平 &lt;span class="math inline">\(1-\alpha,\)&lt;/span> 定出两个常数 &lt;span class="math inline">\(a, b\)&lt;/span> 使得&lt;span class="math inline">\(P\left\{a&amp;lt;W\left(X_{1}, X_{2}, \cdots, X_{n} ; \theta\right)&amp;lt;b\right\}=1-\alpha\)&lt;/span>， 若能从 &lt;span class="math inline">\(a&amp;lt;W\left(X_{1}, X_{2}, \cdots, X_{n} ; \theta\right)&amp;lt;b\)&lt;/span> 得到与之等价的 &lt;span class="math inline">\(\theta\)&lt;/span> 的不等式 &lt;span class="math inline">\(\underline{\theta}&amp;lt;\theta&amp;lt;\bar{\theta},\)&lt;/span> 其中&lt;span class="math inline">\(\theta=\underline{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right), \bar{\theta}=\bar{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 都是统计量.那么 &lt;span class="math inline">\((\underline{\theta}, \bar{\theta})\)&lt;/span> 就是 &lt;span class="math inline">\(\theta\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间.&lt;/p>
&lt;p>函数 &lt;span class="math inline">\(W\left(X_{1}, X_{2}, \cdots, X_{n} ; \theta\right)\)&lt;/span> 的构造,通常可以从 &lt;span class="math inline">\(\theta\)&lt;/span> 的点估计着手考虑.常用的正 态总体的参数的置信区间可以用上述步骤推得.&lt;/p>
&lt;h3 id="正态总体均值与方差的区间估计">正态总体均值与方差的区间估计&lt;/h3>
&lt;p>设已给定置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span>,并设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 为总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 的样本. &lt;span class="math inline">\(\bar{X}\)&lt;/span>, &lt;span class="math inline">\(S^{2}\)&lt;/span> 分别是样本均值和样本方差.&lt;/p>
&lt;h4 id="单个总体-nleftmu-sigma2right-的情况">单个总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 的情况&lt;/h4>
&lt;h5 id="均值-mu-的置信区间">均值 &lt;span class="math inline">\(\mu\)&lt;/span> 的置信区间&lt;/h5>
&lt;h6 id="sigma2-为已知">&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 为已知&lt;/h6>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)\)&lt;/span>，且 &lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}}\)&lt;/span>是枢轴量， 上面置信区间的例子中已得到 &lt;span class="math inline">\(\mu\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为&lt;span class="math inline">\(\left(\bar{X} \pm \frac{\sigma}{\sqrt{n}} z_{\alpha / 2}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="sigma2-为未知">&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 为未知&lt;/h6>
&lt;p>在实际问题中,总体方差 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 未知的情况居多。因此不能使用上面给出的置信区间,因其中含未知参数 &lt;span class="math inline">\(\sigma .\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>考虑到到 &lt;span class="math inline">\(S^{2}\)&lt;/span> 是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计,将&lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)\)&lt;/span>中的 &lt;span class="math inline">\(\sigma\)&lt;/span> 换成 &lt;span class="math inline">\(S=\sqrt{S^{2}}\)&lt;/span>， 再根据t分布的性质&lt;span class="math inline">\(\frac{\bar{X}-\mu}{S / \sqrt{n}} \sim t(n-1)\)&lt;/span> 即&lt;span class="math inline">\(\frac{\bar{X}-\mu}{S / \sqrt{n}}\)&lt;/span>是枢轴量。 可得&lt;span class="math inline">\(P\left\{-t_{\alpha / 2}(n-1)&amp;lt;\frac{\bar{X}-\mu}{S / \sqrt{n}}&amp;lt;t_{a / 2}(n-1)\right\}=1-\alpha\)&lt;/span>，&lt;span class="math inline">\(P\left\{\bar{X}-\frac{S}{\sqrt{n}} t_{\alpha / 2}(n-1)&amp;lt;\mu&amp;lt;\bar{X}+\frac{S}{\sqrt{n}} t_{\alpha / 2}(n-1)\right\}=1-\alpha\)&lt;/span>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201219000309976.png" alt="image-20201219000309976" /> 于是得 &lt;span class="math inline">\(\mu\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间&lt;span class="math inline">\(\left(\bar{X} \pm \frac{S}{\sqrt{n}} t_{a / 2}(n-1)\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="方差-sigma2-的置信区间">方差 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的置信区间&lt;/h5>
&lt;h6 id="mu-已知的情况">&lt;span class="math inline">\(\mu\)&lt;/span> 已知的情况&lt;/h6>
&lt;blockquote>
&lt;p>由于样本各 &lt;span class="math inline">\(X_{i}\)&lt;/span> 相互独立,且与总体 &lt;span class="math inline">\(X\)&lt;/span> 同分布, 故每个 &lt;span class="math inline">\(\frac{X_{i}-\mu}{\sigma} \sim N(0,1)\)&lt;/span>且相互独立， 则&lt;span class="math inline">\(\frac{1}{\sigma^{2}} \sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}=\sum_{i=1}^{n}\left(\frac{X_{i}-\mu}{\sigma}\right)^{2} \sim \chi^{2}(n)\)&lt;/span>， 且该分布不依赖于任何未知参数，故此样本函数可作为枢轴量。 由&lt;span class="math inline">\(\chi^2\)&lt;/span>分布上的&lt;span class="math inline">\(\alpha\)&lt;/span>分位点的定义，有&lt;span class="math inline">\(P\left(\chi_{1-\frac{\alpha}{2}}^{2}(n)&amp;lt;\frac{1}{\sigma^{2}} \sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}&amp;lt;\chi_{\frac{\alpha}{2}}^{2}(n)\right)=1-\alpha\)&lt;/span> 即&lt;span class="math inline">\(P\left(\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{\frac{\alpha}{2}}^{2}(n)}&amp;lt;\sigma^{2}&amp;lt;\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{1-\frac{\alpha}{2}}^{2}(n)}\right)=1-\alpha\)&lt;/span> 由此得到方差&lt;span class="math inline">\(\sigma^2\)&lt;/span>的一个置信度为&lt;span class="math inline">\(1-\alpha\)&lt;/span>的置信区间： &lt;span class="math inline">\(\left(\frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{\frac{\alpha}{2}}^{2}(n)}, \frac{\sum_{i=1}^{n}\left(X_{i}-\mu\right)^{2}}{\chi_{1-\frac{\alpha}{2}}^{2}(n)}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="mu-未知的情况">&lt;span class="math inline">\(\mu\)&lt;/span> 未知的情况&lt;/h6>
&lt;p>实际问题的需要,一般是 &lt;span class="math inline">\(\mu\)&lt;/span> 未知的情况.&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计为 &lt;span class="math inline">\(S^{2},\)&lt;/span> 再根据&lt;a href="../概率论与数理统计-数理统计-基本概念#$\chi%5E%7B2%7D$分布">卡方分布的性质&lt;/a>以及&lt;a href="../概率论与数理统计-数理统计-基本概念#正态总体的抽样分布">正态总体的抽样分布&lt;/a>：&lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma^{2}} \sim \chi^{2}(n-1)\)&lt;/span>,&lt;/p>
&lt;p>且上式右端的分布不依赖于任何未知参数， 取 &lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma^{2}}\)&lt;/span> 作为枢轴量, 得&lt;span class="math inline">\(P\left\{\chi_{1-\alpha / 2}^{2}(n-1)&amp;lt;\frac{(n-1) S^{2}}{\sigma^{2}}&amp;lt;\chi_{a / 2}^{2}(n-1)\right\}=1-\alpha\)&lt;/span>， 即&lt;span class="math inline">\(P\left\{\frac{(n-1) S^{2}}{\chi_{a / 2}^{2}(n-1)}&amp;lt;\sigma^{2}&amp;lt;\frac{(n-1) S^{2}}{\chi_{1}^{2}-\alpha / 2(n-1)}\right\}=1-\alpha\)&lt;/span>， 这就得到方差 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的貴信区间： &lt;span class="math inline">\(\left(\frac{(n-1) S^{2}}{\chi_{\alpha / 2}^{2}(n-1)}, \frac{(n-1) S^{2}}{\chi_{1-\alpha / 2}^{2}(n-1)}\right)\)&lt;/span> 注意：在密度函数不对称时,如 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布和 &lt;span class="math inline">\(F\)&lt;/span> 分布,&lt;strong>习惯上&lt;/strong>仍是取对称的分位点来确定置信区间的.（如上面取了分位点 &lt;span class="math inline">\(\chi_{1-a / 2}^{2}(n-1)\)&lt;/span> 与 &lt;span class="math inline">\(\chi_{\alpha / 2}^{2}(n-1)\)&lt;/span> ）。&lt;/p>
&lt;/blockquote>
&lt;h4 id="两个总体-nleftmu_1-sigma_12right-nleftmu_2-sigma_22right-的情况">两个总体 &lt;span class="math inline">\(N\left(\mu_{1}, \sigma_{1}^{2}\right), N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span> 的情况&lt;/h4>
&lt;p>在实际中常遇到下面的问题 : 已知产品的某一质量指标服从正态分布,但由 于原料、设备条件、操作人员不同,或工艺过程的改变等因素,引起总体均值、总 体方差有所改变. 我们需要知道这些变化有多大,这就需要考虑两个正态总体均 值差或方差比的估计问题.&lt;/p>
&lt;p>设已给定置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span>,并设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n_{1}}\)&lt;/span> 是来自第一个总体的样本 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n_{2}}\)&lt;/span> 是来自第二个总体的样本,这两个样本相互独立. 且设 &lt;span class="math inline">\(\bar{X}, \bar{Y}\)&lt;/span> 分别 为第一、第二个总体的样本均值, &lt;span class="math inline">\(S_{1}^{2}, S_{2}^{2}\)&lt;/span> 分别是第一、第二个总体的样本方差.&lt;/p>
&lt;h5 id="两个总体均值差-mu_1-mu_2-的置信区间">两个总体均值差 &lt;span class="math inline">\(\mu_{1}-\mu_{2}\)&lt;/span> 的置信区间&lt;/h5>
&lt;h6 id="sigma_12-sigma_22-均为已知">&lt;span class="math inline">\(\sigma_{1}^{2}, \sigma_{2}^{2}\)&lt;/span> 均为已知&lt;/h6>
&lt;blockquote>
&lt;p>因 &lt;span class="math inline">\(\bar{X}, \bar{Y}\)&lt;/span> 分别为 &lt;span class="math inline">\(\mu_{1}, \mu_{2}\)&lt;/span> 的无偏估计,故 &lt;span class="math inline">\(\bar{X}-\bar{Y}\)&lt;/span> 是 &lt;span class="math inline">\(\mu_{1}-\mu_{2}\)&lt;/span>的无偏估计. 由 &lt;span class="math inline">\(\bar{X}, \bar{Y}\)&lt;/span> 的独立性以及 &lt;span class="math inline">\(\bar{X} \sim N\left(\mu_{1}, \sigma_{1}^{2} / n_{1}\right), \bar{Y} \sim N\left(\mu_{2}, \sigma_{2}^{2} / n_{2}\right)\)&lt;/span> 得&lt;span class="math inline">\(\bar{X}-\bar{Y} \sim N\left(\mu_{1}-\mu_{2}, \frac{\sigma_{1}^{2}}{n_{1}}+\frac{\sigma_{2}^{2}}{n_{2}}\right)\)&lt;/span>， 得&lt;span class="math inline">\(\frac{(\bar{X}-\bar{Y})-\left(\mu_{1}-\mu_{2}\right)}{\sqrt{\frac{\sigma_{1}^{2}}{n_{1}}+\frac{\sigma_{2}^{2}}{n_{2}}}} \sim N(0,1)\)&lt;/span> 取左边的函数为枢轴量,即得 &lt;span class="math inline">\(\mu_{1}-\mu_{2}\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间： &lt;span class="math inline">\(\left(\bar{X}-\bar{Y} \pm z_{a / 2} \sqrt{\frac{\sigma_{1}^{2}}{n_{1}}+\frac{\sigma_{2}^{2}}{n_{2}}}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="sigma_12sigma_22sigma2-但-sigma2-为未知">&lt;span class="math inline">\(\sigma_{1}^{2}=\sigma_{2}^{2}=\sigma^{2},\)&lt;/span> 但 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 为未知&lt;/h6>
&lt;blockquote>
&lt;p>根据&lt;a href="../概率论与数理统计-数理统计-基本概念#正态总体的抽样分布">正态总体的抽样分布&lt;/a>有：&lt;span class="math inline">\(\frac{(\bar{X}-\bar{Y})-\left(\mu_{1}-\mu_{2}\right)}{S_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}} \sim t\left(n_{1}+n_{2}-2\right)\)&lt;/span>， 取左边的函数为枢轴量， 可得 &lt;span class="math inline">\(\mu_{1}-\mu_{2}\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为： &lt;span class="math inline">\(\left(\bar{X}-\bar{Y} \pm t_{a / 2}\left(n_{1}+n_{2}-2\right) S_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}\right)\)&lt;/span> 这里&lt;span class="math inline">\(S_{w}^{2}=\frac{\left(n_{1}-1\right) S_{1}^{2}+\left(n_{2}-1\right) S_{2}^{2}}{n_{1}+n_{2}-2}, S_{w}=\sqrt{S_{w}^{2}}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="两个总体方差比-sigma_12-sigma_22-的置信区间">两个总体方差比 &lt;span class="math inline">\(\sigma_{1}^{2} / \sigma_{2}^{2}\)&lt;/span> 的置信区间&lt;/h5>
&lt;p>我们仅讨论总体均值 &lt;span class="math inline">\(\mu_{1}, \mu_{2}\)&lt;/span> 均为未知的情况。&lt;/p>
&lt;blockquote>
&lt;p>根据&lt;a href="../概率论与数理统计-数理统计-基本概念#正态总体的抽样分布">正态总体的抽样分布&lt;/a>有：&lt;span class="math inline">\(\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}} \sim F\left(n_{1}-1, n_{2}-1\right)\)&lt;/span>， 并且分布 &lt;span class="math inline">\(F\left(n_{1}-1, n_{2}-1\right)\)&lt;/span> 不依赖任何未知参数. 取 &lt;span class="math inline">\(\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}}\)&lt;/span> 为枢轴量， 得&lt;span class="math inline">\(P\left\{F_{1-\alpha / 2}\left(n_{1}-1, n_{2}-1\right)&amp;lt;\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}}&amp;lt;F_{a / 2}\left(n_{1}-1, n_{2}-1\right)\right\}=1-\alpha\)&lt;/span> 即&lt;span class="math inline">\(P\left(\frac{S_{1}^{2}}{S_{2}^{2}} \frac{1}{F_{a / 2}\left(n_{1}-1, n_{2}-1\right)}&amp;lt;\frac{\sigma_{1}^{2}}{\sigma_{2}^{2}}&amp;lt;\frac{S_{1}^{2}}{S_{2}^{2}} \frac{1}{F_{1-\alpha / 2}\left(n_{1}-1, n_{2}-1\right)}\right\}=1-\alpha\)&lt;/span> 于是得 &lt;span class="math inline">\(\sigma_{1}^{2} / \sigma_{2}^{2}\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为： &lt;span class="math inline">\(\left(\frac{S_{1}^{2}}{S_{2}^{2}} \frac{1}{F_{a / 2}\left(n_{1}-1, n_{2}-1\right)}, \frac{S_{1}^{2}}{S_{2}^{2}} \frac{1}{F_{1-a / 2}\left(n_{1}-1, n_{2}-1\right)}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>若 &lt;span class="math inline">\(\sigma_{1}^{2} / \sigma_{2}^{2}\)&lt;/span> 的置信区间包含 1 ,在实际中我们就认为 &lt;span class="math inline">\(\sigma_{1}^{2}, \sigma_{2}^{2}\)&lt;/span> 两者没有显著差别。&lt;/p>
&lt;h4 id="正态总体的区间估计汇总">正态总体的区间估计汇总&lt;/h4>
&lt;script>
window.onload = function(){
var current = 0;
document.getElementById('#pic1').onclick = function(){
current = (current+90)%360;
this.style.transform = 'rotate('+current+'deg)';
}
};
&lt;/script>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2020-12-20-pic1.jpg" alt="" />&lt;figcaption>pic1&lt;/figcaption>
&lt;/figure>
&lt;h3 id="非正态整体参数的区间估计">非正态整体参数的区间估计&lt;/h3>
&lt;p>前面我们主要介绍了关于正态总体参数的区间估计问题，但再很多的实际问题中，有时我们无法判断总体是否服从正态分布。这时，只要样本容量n很大(&lt;span class="math inline">\(n\leqslant 50\)&lt;/span>)时，可用中心极限定理求得其近似的置信区间。&lt;/p>
&lt;p>对于总体 &lt;span class="math inline">\(X,\)&lt;/span> 设 &lt;span class="math inline">\(E(X)=\mu, D(X)=\sigma^{2}(\)&lt;/span> 已知 &lt;span class="math inline">\()\)&lt;/span> 均存在, &lt;span class="math inline">\(\mu\)&lt;/span> 是未知参数. 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的一组样本, 根据中心极限定理, 对充分大的 &lt;span class="math inline">\(n,\)&lt;/span> 近似地有&lt;span class="math inline">\(\frac{\sum_{i=1}^{n} X_{i}-n \mu}{\sqrt{n} \sigma} \sim N(0,1)\)&lt;/span> 即&lt;span class="math inline">\(\frac{\bar{X}-\mu}{\sigma / \sqrt{n}} \sim N(0,1)\)&lt;/span>， 因此，当样本容量n充分大时， 若总体方差&lt;span class="math inline">\(\sigma^2\)&lt;/span>已知，可得总体均值&lt;span class="math inline">\(\mu\)&lt;/span>的置信度为&lt;span class="math inline">\(1-\alpha\)&lt;/span>的一个近似区间&lt;span class="math inline">\(\begin{equation} \left(\bar{X} \pm \frac{\sigma}{\sqrt{n}} z_{\frac{\alpha}{2}}\right) \end{equation}\)&lt;/span> 若总体方差&lt;span class="math inline">\(\sigma^2\)&lt;/span>未知，用&lt;span class="math inline">\(\sigma\)&lt;/span>的估计无偏估计&lt;span class="math inline">\(S\)&lt;/span>来替代，总体均值&lt;span class="math inline">\(\mu\)&lt;/span>的置信度为&lt;span class="math inline">\(1-\alpha\)&lt;/span>的一个近似区间&lt;span class="math inline">\(\left(\bar{X} \pm \frac{S}{\sqrt{n}} z_{\frac{\alpha}{2}}\right)\)&lt;/span>&lt;/p>
&lt;p>可以看到，当样本容量n充分大时，非正态总体均值&lt;span class="math inline">\(\mu\)&lt;/span>的置信区间于正态总体区间估计一致。&lt;/p>
&lt;h4 id="分布参数的区间估计">&lt;span class="math inline">\((0-1)\)&lt;/span> 分布参数的区间估计&lt;/h4>
&lt;p>设有一容量 &lt;span class="math inline">\(n&amp;gt;50\)&lt;/span> 的大样本,它来自 &lt;span class="math inline">\((0-1)\)&lt;/span> 分布的总体 &lt;span class="math inline">\(X\)&lt;/span>, &lt;span class="math inline">\(X\)&lt;/span> 的分布律为&lt;span class="math inline">\(f(x ; p)=p^{x}(1-p)^{1-x}, x=0,1\)&lt;/span> 已知 &lt;span class="math inline">\((0-1)\)&lt;/span> 分布的均值和方差分别为&lt;span class="math inline">\(\mu=p, \quad \sigma^{2}=p(1-p)\)&lt;/span>, 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是一个样本. 因样本容量 &lt;span class="math inline">\(n\)&lt;/span> 较大,由中心极限定理, 知&lt;span class="math inline">\(\frac{\sum_{i=1}^{n} X_{i}-n p}{\sqrt{n p(1-p)}}=\frac{n \bar{X}-n p}{\sqrt{n p(1-p)}}\)&lt;/span>近似地服从 &lt;span class="math inline">\(N\)&lt;/span> (0,1)分布, 于是有&lt;span class="math inline">\(P\left\{-z_{a / 2}&amp;lt;\frac{n \bar{X}-n p}{\sqrt{n p(1-p)}}&amp;lt;z_{a / 2}\right\} \approx 1-\alpha\)&lt;/span> 而不等式&lt;span class="math inline">\(-z_{\alpha / 2}&amp;lt;\frac{n \bar{X}-n p}{\sqrt{n p(1-p)}}&amp;lt;z_{a / 2}\)&lt;/span>等价于&lt;span class="math inline">\(\left(n+z_{\alpha / 2}^{2}\right) p^{2}-\left(2 n \bar{X}+z_{\alpha / 2}^{2}\right) p+n \bar{X}^{2}&amp;lt;0\)&lt;/span> 记：&lt;span class="math inline">\(p_{1}=\frac{1}{2 a}\left(-b-\sqrt{b^{2}-4 a c}\right)\)&lt;/span> &lt;span class="math inline">\(p_{2}=\frac{1}{2 a}\left(-b+\sqrt{b^{2}-4 a c}\right),\)&lt;/span> 其中&lt;span class="math inline">\(a=n+z_{\alpha / 2}^{2}, b=-\left(2 n \bar{X}+z_{\alpha / 2}^{2}\right), c=n \bar{X}^{2}\)&lt;/span> 于是得得 &lt;span class="math inline">\(p\)&lt;/span> 的一个近似的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为&lt;span class="math inline">\(\left(p_{1}, p_{2}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="单侧置信区间">单侧置信区间&lt;/h3>
&lt;p>前面讨论中,对于未知参数 &lt;span class="math inline">\(\theta,\)&lt;/span> 我们给出两个统计量 &lt;span class="math inline">\(\theta, \bar{\theta},\)&lt;/span> 得到 &lt;span class="math inline">\(\theta\)&lt;/span> 的双侧置信区间 &lt;span class="math inline">\((\underline{\theta}, \bar{\theta}) .\)&lt;/span> 但在某些实际问题中,例如，对于设备、元件的寿命来说,平均寿命 长是我们所希望的,我们关心的是平均寿命 &lt;span class="math inline">\(\theta\)&lt;/span> 的“下限”;与之相反,在考虑化学 药品中杂质含量的均值 &lt;span class="math inline">\(\mu\)&lt;/span> 时,我们常关心参数 &lt;span class="math inline">\(\mu\)&lt;/span> 的“上限”。 这就引出了单侧置信区间的概念.&lt;/p>
&lt;p>对于给定值 &lt;span class="math inline">\(\alpha(0&amp;lt;\alpha&amp;lt;1),\)&lt;/span> 若由样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 确定的统计量 &lt;span class="math inline">\(\theta=\underline\theta\left(X_{1},\right.\left.X_{2}, \cdots, X_{n}\right),\)&lt;/span> 对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 满足&lt;span class="math inline">\(P\{\theta&amp;gt;\theta\} \geqslant 1-\alpha\)&lt;/span>， 称随机区间 &lt;span class="math inline">\((\underline\theta, \infty)\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>单侧置信区间&lt;/strong> &lt;span class="math inline">\(, \underline\theta\)&lt;/span> 称为 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>单侧置信下限&lt;/strong>.&lt;/p>
&lt;p>对于给定值 &lt;span class="math inline">\(\alpha(0&amp;lt;\alpha&amp;lt;1),\)&lt;/span> 又若统计量 &lt;span class="math inline">\(\bar{\theta}=\bar{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right),\)&lt;/span> 对于任意 &lt;span class="math inline">\(\theta \in \Theta\)&lt;/span> 满足&lt;span class="math inline">\(P\{\theta&amp;lt;\bar{\theta}\} \geqslant 1-\alpha\)&lt;/span>， 称随机区间 &lt;span class="math inline">\((-\infty, \bar{\theta})\)&lt;/span> 是 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>单侧置信区间&lt;/strong> &lt;span class="math inline">\(, \bar{\theta}\)&lt;/span> 称为 &lt;span class="math inline">\(\theta\)&lt;/span> 的置信 水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的&lt;strong>单侧置信上限&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>例子 例如对于正态总体 &lt;span class="math inline">\(X,\)&lt;/span> 若均值 &lt;span class="math inline">\(\mu,\)&lt;/span> 方差 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 均为未知, 设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是一 个样本, 由&lt;span class="math inline">\(\frac{\bar{X}-\mu}{S / \sqrt{n}} \sim t(n-1)\)&lt;/span> 有&lt;span class="math inline">\(P\left\{\frac{\bar{X}-\mu}{S / \sqrt{n}}&amp;lt;t_{a}(n-1)\right\}=1-\alpha\)&lt;/span> 即&lt;span class="math inline">\(P\left\{\mu&amp;gt;\bar{X}-\frac{S}{\sqrt{n}} t_{a}(n-1)\right\}=1-\alpha\)&lt;/span>， 于是得到 &lt;span class="math inline">\(\mu\)&lt;/span> 的一个置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信区间&lt;span class="math inline">\(\left(\bar{X}-\frac{S}{\sqrt{n}} t_{a}(n-1), \infty\right)\)&lt;/span> &lt;span class="math inline">\(\mu\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信下限为&lt;span class="math inline">\(\mu=\bar{X}-\frac{S}{\sqrt{n}} t_{\alpha}(n-1)\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201219163310568.png" alt="image-20201219163310568" />&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>例子2 &lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma^{2}} \sim \chi^{2}(n-1)\)&lt;/span> 有&lt;span class="math inline">\(P\left\{\frac{(n-1) S^{2}}{\sigma^{2}}&amp;gt;\chi_{1-\alpha}^{2}(n-1)\right\}=1-\alpha\)&lt;/span> 即&lt;span class="math inline">\(P\left\{\sigma^{2}&amp;lt;\frac{(n-1) S^{2}}{\chi_{1-a}^{2}(n-1)}\right\}=1-\alpha\)&lt;/span> 于是得 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信区间&lt;span class="math inline">\(\left(0, \frac{(n-1) S^{2}}{\chi_{1-\alpha}^{2}(n-1)}\right)\)&lt;/span> &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的单侧置信上限为&lt;span class="math inline">\(\bar{\sigma}^{2}=\frac{(n-1) S^{2}}{\chi_{1}^{2}-\alpha}\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201219163649704.png" alt="image-20201219163649704" />&lt;/p>
&lt;/blockquote>
&lt;p>相同条件下，同一置信度的单侧置信上/下限与双侧置信区间的上下限，对比发现，只是&lt;span class="math inline">\(\alpha\)&lt;/span>与&lt;span class="math inline">\(\frac{\alpha}{2}\)&lt;/span>的区别。 这种规律对前面介绍的各种条件下的正态总体都适用，即值序将双侧置信区间的上（或下）限中的&lt;span class="math inline">\(\frac{\alpha}{2}\)&lt;/span>换成&lt;span class="math inline">\(\alpha\)&lt;/span>，就是相同条件下相同参数的同一置信度的单侧置信上（或下）限。&lt;/p></description></item><item><title>概率论与数理统计-数理统计-基本概念</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Sun, 13 Dec 2020 07:31:02 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-数理统计-基本概念">概率论与数理统计-数理统计-基本概念&lt;/h1>
&lt;p>前面章节讲述了概率论的基本内容，随后将讲述数理统计。&lt;/p>
&lt;p>数理统计以概率论为理论基础，根据试验或观察得到的数据，来研究随机现象，对研究对象的客观规律性作出种种合理的估计和判断。&lt;/p>
&lt;p>&lt;strong>数理统计的内容&lt;/strong>包括：&lt;/p>
&lt;ul>
&lt;li>如何收集、整理数据资料&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>&lt;/li>
&lt;li>如何对所得的数据资料进行分析、研究，从而对所研究的对象的性质、特点作出推断（统计推断）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>概率论与数理统计的对比&lt;/strong>：&lt;/p>
&lt;p>在概率论中，我们所研究的随机变量，它的分布都是假设已知的，在这一前提下去研究它的性质、特点和规律性，例如求出它的数字特征，讨论随机变量函数的分布，介绍常用的各种分布等。 在数理统计中，我们研究的随机变量，它的分布是未知的，或者是不完全知道的，人们是通过对所研究的随机变量进行&lt;strong>重复独立的观察，得到许多观察值，对这些数据进行分析，从而对所研究的随机变量的分布作出种种推断&lt;/strong>的。&lt;/p>
&lt;p>本章我们介绍总体、随机样本及统计量等基本概念，并着重介绍几个常用统计量及抽样分布。&lt;/p>
&lt;h2 id="总体与样本">总体与样本&lt;/h2>
&lt;h3 id="总体的概念">总体的概念&lt;/h3>
&lt;p>我们知道，随机试验的结果很多是可以用数来表示的，另有一些试验的结果虽是定性的，但总可以将它数量化。&lt;/p>
&lt;details>
&lt;summary>例如&lt;/summary> 例如，检验某个学校学生的血型这一试验，其可能结果有O型、A型、B型、AB型4种，是定性的。如果分别以1,2,3,4依次记这4种血型，那么试验的结果就能用数来表示了。
&lt;/details>
&lt;p>研究对象的总体，简称为总体。 而在数理统计中，我们往往关心研究对象的某一项数量指标（即随机变量，例如研究某种型号灯泡的寿命这一数量指标），考虑与这一数量指标相联系的随机试验，对这一数量指标进行试验或观察，我们将试验的全部可能的观察值称为&lt;strong>总体&lt;/strong>&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref">&lt;sup>2&lt;/sup>&lt;/a>，这些值不一定都不相同，数目上也不一定是有限的，每一个可能观察值称为&lt;strong>个体&lt;/strong>。 总体中所包含的个体的个数称为&lt;strong>总体的容量&lt;/strong>。容量为有限的称为&lt;strong>有限总体&lt;/strong>，容量为无限的称为&lt;strong>无限总体&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>总体中的每一个个体是随机试验的一个观察值，因此它是某一随机变量X的值，这样，一个总体对应于一个随机变量X&lt;/strong>.我们对总体的研究就是对一个随机变量X的研究，X的分布函数和数字特征就称为总体的分布函数和数字特征，&lt;strong>今后将不区分总体与相应的随机变量&lt;/strong>，笼统称为总体X&lt;/p>
&lt;h3 id="样本的概念">样本的概念&lt;/h3>
&lt;h4 id="样本的引入">样本的引入&lt;/h4>
&lt;p>在实际中，总体的分布一般是未知的，或只知道它具有某种形式而其中包含着未知参数。 在数理统计中，人们都是通过从总体中抽取一部分个体，根据获得的数据来对总体分布作出推断的。被抽出的部分个体叫做总体的一个&lt;strong>样本&lt;/strong>。&lt;/p>
&lt;p>所谓&lt;strong>从总体抽取一个个体&lt;/strong>，就是对总体X进行一次观察并记录其结果。 我们在相同的条件下对总体X，进行&lt;strong>n次重复的、独立的观察&lt;/strong>，将n次观察结果按试验的次序记为&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>。 由于&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>是都随机变量X的观察结果，且每次观察都是在相同条件下进行的，有理由认为&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>都是&lt;strong>与X同分布&lt;/strong>的随机变量。 由于&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>是都随机变量X的观察结果，且每次观察都是独立进行的，则&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>作为随机变量是&lt;strong>相互独立&lt;/strong>的。 这样获取的互相独立的、与X同分布的&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>，称为来自&lt;strong>总体的一个简单随机样本&lt;/strong>。&lt;/p>
&lt;p>当 &lt;span class="math inline">\(n\)&lt;/span> 次观察一经完成,我们就得到一组实数 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n},\)&lt;/span> 它们依次是随机 变量 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 的观察值,称为&lt;strong>样本值&lt;/strong>.&lt;/p>
&lt;p>对于有限总体，采用放回抽样（独立重复试验）就能得到简单随机样本，但放回抽样使用起来不方便，当个体的总数N比要得到的样本的容量n大得多时，在实际中可将不放回抽样近似地当作放回抽样来处理。 至于无限总体，因抽取一个个体不影响它的分布，所以总是用不放回抽样例如，在生产过程中，每隔一定时间抽取一个个体，抽取n个就得到一个简单随机样本，实验室中的记录，水文、气象等观察资料都是样本。试制新产品得到的样品的质量指标，也常被认为是样本&lt;/p>
&lt;h4 id="样本的定义">样本的定义&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X\)&lt;/span> 是具有分布函数 &lt;span class="math inline">\(F\)&lt;/span> 的随机变量,若 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是具有同一分布函数 &lt;span class="math inline">\(F\)&lt;/span> 的、相互独立的随机变量,则称 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 为从分布函数 &lt;span class="math inline">\(F\)&lt;/span> （ 或总体F、或总体X）得到的容量为n的&lt;strong>简单随机样本&lt;/strong>，简称&lt;strong>样本&lt;/strong>，它们的观察值&lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 称为&lt;strong>样本值&lt;/strong>,又称为 &lt;span class="math inline">\(X\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个独立的观察值.&lt;/p>
&lt;p>可以将样本看成一个随机向量，写成&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>，此时样本值可以写成&lt;span class="math inline">\(\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>。 若&lt;span class="math inline">\(\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>和&lt;span class="math inline">\(\left(y_{1}, y_{2}, \cdots, y_{n}\right)\)&lt;/span>都是相应于样本&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的样本值，一般来说它们是不相同的。&lt;/p>
&lt;p>若&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>是F的一个样本，则&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>相互独立，且它们的分布函数都是F， 所以&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的分布函数为&lt;span class="math inline">\(F^{*}\left(x_{1}, x_{2}, \cdots, x_{n}\right)=\prod_{i=1}^{n} F\left(x_{i}\right)\)&lt;/span>， 又若X具有概率密度函数&lt;span class="math inline">\(f\)&lt;/span>，则&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的概率密度为&lt;span class="math inline">\(f^{*}\left(x_{1}, x_{2}, \cdots, x_{n}\right)=\prod_{i=1}^{n} f\left(x_{i}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="总体分布的粗略了解-直方图和箱线图">总体分布的粗略了解-直方图和箱线图&lt;/h2>
&lt;p>为了研究总体分布的性质，人们通过试验得到许多观察值，一般来说这些数值是杂乱无章的。 为了利用这些观察值进行统计分析，需要将这些数据进行整理，还常常借助表格或图形来加以描述。 通过对连续型随机变量X引入“频率直方图”，然后介绍“箱线图”，可以使人们对总体的分布有一个粗略的了解。&lt;/p>
&lt;h3 id="频率直方图">频率直方图&lt;/h3>
&lt;p>比如要考察伊特拉斯坎人头颅的大小（总体），抽取/调查84个伊特拉斯坎人头颅大小数据（样本），作为样本： &lt;span class="math inline">\(\begin{array}{llllllllll}141 &amp;amp; 148 &amp;amp; 132 &amp;amp; 138 &amp;amp; 154 &amp;amp; 142 &amp;amp; 150 &amp;amp; 146 &amp;amp; 155 &amp;amp; 158 \\ 150 &amp;amp; 140 &amp;amp; 147 &amp;amp; 148 &amp;amp; 144 &amp;amp; 150 &amp;amp; 149 &amp;amp; 145 &amp;amp; 149 &amp;amp; 158 \\ 143 &amp;amp; 141 &amp;amp; 144 &amp;amp; 144 &amp;amp; 126 &amp;amp; 140 &amp;amp; 144 &amp;amp; 142 &amp;amp; 141 &amp;amp; 140 \\ 145 &amp;amp; 135 &amp;amp; 147 &amp;amp; 146 &amp;amp; 141 &amp;amp; 136 &amp;amp; 140 &amp;amp; 146 &amp;amp; 142 &amp;amp; 137 \\ 148 &amp;amp; 154 &amp;amp; 137 &amp;amp; 139 &amp;amp; 143 &amp;amp; 140 &amp;amp; 131 &amp;amp; 143 &amp;amp; 141 &amp;amp; 149 \\ 148 &amp;amp; 135 &amp;amp; 148 &amp;amp; 152 &amp;amp; 143 &amp;amp; 144 &amp;amp; 141 &amp;amp; 143 &amp;amp; 147 &amp;amp; 146 \\ 150 &amp;amp; 132 &amp;amp; 142 &amp;amp; 142 &amp;amp; 143 &amp;amp; 153 &amp;amp; 149 &amp;amp; 146 &amp;amp; 149 &amp;amp; 138 \\ 142 &amp;amp; 149 &amp;amp; 142 &amp;amp; 137 &amp;amp; 134 &amp;amp; 144 &amp;amp; 146 &amp;amp; 147 &amp;amp; 140 &amp;amp; 142 \\ 140 &amp;amp; 137 &amp;amp; 152 &amp;amp; 145 &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \end{array}\)&lt;/span>&lt;/p>
&lt;p>样本看起来比较杂乱，需要先进行整理（作频数/频率分布表）： 根据最大最小值划分成几个区间，每个区间组距&lt;span class="math inline">\(\Delta\)&lt;/span>.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201214163924048.png" alt="" />&lt;figcaption>image-20201214163924048&lt;/figcaption>
&lt;/figure>
&lt;p>根据频数分布表作频率分布直方图：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201214162618722.png" alt="" />&lt;figcaption>image-20201214162618722&lt;/figcaption>
&lt;/figure>
&lt;p>其中&lt;span class="math inline">\(f_i\)&lt;/span>是在对应区间内的频数，n是总体的大小，&lt;span class="math inline">\(\Delta\)&lt;/span>是区间大小。&lt;/p>
&lt;h3 id="箱线图">箱线图&lt;/h3>
&lt;h4 id="样本p分位数">样本p分位数&lt;/h4>
&lt;p>设有容量为n的样本观察值&lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span>，样本的p分位数(0&amp;lt;p&amp;lt;1)记为&lt;span class="math inline">\(x_p\)&lt;/span>, &lt;span class="math inline">\(x_p\)&lt;/span>具有如下性质： 1)至少有np个数小于等于&lt;span class="math inline">\(x_p\)&lt;/span>, 2)至少有n(1-p)个数大于等于&lt;span class="math inline">\(x_p\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(x_{p}=\left\{\begin{array}{ll}x_{([n p]+1)}, &amp;amp; \text { 当 } n p \text { 不是整数 } \\ \frac{1}{2}\left[x_{(n p)}+x_{(n p+1)}\right], &amp;amp; \text { 当 } n p \text { 是整数. }\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>0.25 分位数 &lt;span class="math inline">\(x_{0.25}\)&lt;/span> 称为第一四分位数,又记为 &lt;span class="math inline">\(Q_{1} ; 0.75\)&lt;/span> 分位数 &lt;span class="math inline">\(x_{0.75}\)&lt;/span> 称为第三四分位数,又记为 &lt;span class="math inline">\(Q_{3}\)&lt;/span>. $ x_{0.25}, x_{0.5}, x_{0.75}$ 在统计中是很有用的.&lt;/p>
&lt;h4 id="箱线图的组成">箱线图的组成&lt;/h4>
&lt;p>数据集的箱线图是由箱子和直线组成的图形,它是基于以下 5 个数的图形 概括 : 最小值 Min, 第一四分位数 &lt;span class="math inline">\(Q_{1}\)&lt;/span>, 中位数 &lt;span class="math inline">\(M,\)&lt;/span> 第三四分位数 &lt;span class="math inline">\(Q_{3}\)&lt;/span> 和最大值 Max.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201214170651475.png" alt="" />&lt;figcaption>image-20201214170651475&lt;/figcaption>
&lt;/figure>
&lt;p>从箱线图上可以看出数据集的如下特征： 1）中心位置（M点）， 2）散布程度（各区间中数据各占1/4，区间越短数据越集中）， 3）对称性&lt;/p>
&lt;p>箱线图特别适合比较两个数据集之间的性质，为此可以将几个数据集的数据画在同一个数轴上。&lt;/p>
&lt;p>若如下表示男生和女生肺活量数据，则可以明显看出男生的肺活量比女生的大。 &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201214171009972.png" alt="image-20201214171009972" />&lt;/p>
&lt;h4 id="修正箱线图">修正箱线图&lt;/h4>
&lt;p>在数据集中某一个观察值不寻常地大于或小于该数集中的其他数据，称为&lt;strong>疑似异常值&lt;/strong>。疑似异常值的存在，会对随后的计算结果产生不适当的影响检查疑似异常值并加以适当的处理是十分重要的。箱线图只要稍加修改，就能用来检测数据集是否存在疑似异常值。&lt;/p>
&lt;p>第一四分位数 &lt;span class="math inline">\(Q_{1}\)&lt;/span> 与第三四分位数 &lt;span class="math inline">\(Q_{3}\)&lt;/span> 之间的距离 &lt;span class="math inline">\(: Q_{3}-Q_{1} \stackrel{\text { 记为 }}{=}I Q R\)&lt;/span> ，称为四分位数间距. 若数据小于 &lt;span class="math inline">\(Q_{1}-1.5 I Q R\)&lt;/span> 或大于 &lt;span class="math inline">\(Q_{3}+1.5 I Q R\)&lt;/span>,就认为它是疑似异常值.&lt;/p>
&lt;p>画箱线图时，将疑似异常值用*号在图上对应位置单独画出，用排除疑似异常值后的数据集画箱线图。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201214175101867.png" alt="" />&lt;figcaption>image-20201214175101867&lt;/figcaption>
&lt;/figure>
&lt;p>疑似异常值的来源： （1）数据的测量、记录或输入计算机时的错误； （2）数据来自不同的总体； （3）数据是正确的，但它只体现小概率事件。&lt;/p>
&lt;p>当检测出疑似异常值时，人们需对疑似异常值出现的原因加以分析。如果是由于测量或记录的错误，或某些其他明显的原因造成的，将这些疑似异常值从数据集中丢弃就可以了。&lt;/p>
&lt;p>用中位数来描述数据集的中心趋势，而不用平均值，也是因为后者受疑似异常值的影响较大。&lt;/p>
&lt;h2 id="抽样分布">抽样分布&lt;/h2>
&lt;p>样本是进行统计推断的依据。在应用时，往往不是直接使用样本本身，而是针对不同的问题构造样本的适当函数，利用这些样本的函数进行统计推断。&lt;/p>
&lt;h3 id="统计量">统计量&lt;/h3>
&lt;h4 id="统计量定义无参样本函数">统计量定义：无参样本函数&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本 &lt;span class="math inline">\(, g\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 是 &lt;span class="math inline">\(X_{1},\)&lt;/span>&lt;span class="math inline">\(X_{2}, \cdots, X_{n}\)&lt;/span> 的函数,若 &lt;span class="math inline">\(g\)&lt;/span> 中不含未知参数 &lt;span class="math inline">\(,\)&lt;/span> 则称 &lt;span class="math inline">\(g\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 是一&lt;strong>统计量&lt;/strong>.&lt;/p>
&lt;p>因为 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 都是随机变量,而统计量 &lt;span class="math inline">\(g\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 是&lt;strong>随机变量的函数&lt;/strong>,因此&lt;strong>统计量是一个随机变量&lt;/strong>. 设 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是相应于样本 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots,\)&lt;/span> &lt;span class="math inline">\(X_{n}\)&lt;/span> 的样本值,则称 &lt;span class="math inline">\(g\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span> 是 &lt;span class="math inline">\(g\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 的观察值（&lt;strong>统计量的观察值&lt;/strong>）.&lt;/p>
&lt;h4 id="常用统计量">常用统计量&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本,&lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 是这一样本的观察值.&lt;/p>
&lt;h5 id="样本均值">样本均值&lt;/h5>
&lt;p>&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span>&lt;/p>
&lt;h5 id="样本方差3">样本方差&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref">&lt;sup>3&lt;/sup>&lt;/a>&lt;/h5>
&lt;p>&lt;span class="math inline">\(S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}=\frac{1}{n-1}\left(\sum_{i=1}^{n} X_{i}^{2}-n \bar{X}^{2}\right)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>注意区分：样本方差、随机变量的方差（总体的方差）、样本的二阶中心矩 样本&lt;span class="math inline">\(X_1,\cdots,X_n\)&lt;/span>的方差&lt;span class="math inline">\(S^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\)&lt;/span>, 样本&lt;span class="math inline">\(X_1,\cdots,X_n\)&lt;/span>的二阶中心矩&lt;span class="math inline">\(B_{2}=\frac{1}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}\)&lt;/span> 随机变量X的方差（总体的方差）&lt;span class="math inline">\(D(X)=E\left[X-E(X)\right]^2\)&lt;/span>, 随机变量X的方差同时也是随机变量X的二阶中心矩。 若X是离散型随机变量，方差为&lt;span class="math inline">\(D(X)=\sum_{i=1}^{\infty}\left[x_{i}-E(X)\right]^{2} p\left(x_{i}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="样本标准差">样本标准差&lt;/h5>
&lt;p>&lt;span class="math inline">\(S=\sqrt{S^{2}}=\sqrt{\frac{1}{n-1} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{2}}\)&lt;/span>&lt;/p>
&lt;h5 id="样本k阶原点矩">样本k阶（原点）矩&lt;/h5>
&lt;p>&lt;span class="math inline">\(A_{k}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{k}, k=1,2, \cdots\)&lt;/span>&lt;/p>
&lt;h5 id="样本k阶中心矩">样本k阶中心矩&lt;/h5>
&lt;p>&lt;span class="math inline">\(B_{k}=\frac{1}{n} \sum_{i=1}^{n}\left(X_{i}-\bar{X}\right)^{k}, k=2,3, \cdots\)&lt;/span>&lt;/p>
&lt;h5 id="样本均值的观测值">样本均值的观测值&lt;/h5>
&lt;p>&lt;span class="math inline">\(\bar{x}=\frac{1}{n} \sum_{i=1}^{n} x_{i} ;\)&lt;/span>&lt;/p>
&lt;h5 id="样本方差的观测值">样本方差的观测值&lt;/h5>
&lt;p>&lt;span class="math inline">\(s^{2}=\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}=\frac{1}{n-1}\left(\sum_{i=1}^{n} x_{i}^{2}-n \bar{x}^{2}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="样本标准差的观测值">样本标准差的观测值&lt;/h5>
&lt;p>&lt;span class="math inline">\(s=\sqrt{\frac{1}{n-1} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}}\)&lt;/span>&lt;/p>
&lt;h5 id="样本k阶原点矩的观测值">样本k阶（原点）矩的观测值&lt;/h5>
&lt;p>&lt;span class="math inline">\(a_{k}=\frac{1}{n} \sum_{i=1}^{n} x_{i}^{k}, \quad k=1,2, \cdots ;\)&lt;/span>&lt;/p>
&lt;h5 id="样本k阶中心矩的观测值">样本k阶中心矩的观测值&lt;/h5>
&lt;p>&lt;span class="math inline">\(b_{k}=\frac{1}{n} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{k}, \quad k=2,3, \cdots\)&lt;/span>&lt;/p>
&lt;h4 id="样本矩与统计量的性质">样本矩与统计量的性质&lt;/h4>
&lt;h5 id="若总体的k阶矩mu_kexk存在当nrightarrowinfty时样本的k阶矩frac1n-sum_i1n-x_ik-stackrelplongrightarrow总体的k阶矩mu_kexk">若总体的k阶矩&lt;span class="math inline">\(\mu_k=E(X^k)\)&lt;/span>存在，当&lt;span class="math inline">\(n\rightarrow\infty\)&lt;/span>时，样本的k阶矩&lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n} X_{i}^{k}\)&lt;/span> &lt;span class="math inline">\(\stackrel{P}{\longrightarrow}\)&lt;/span>总体的k阶矩&lt;span class="math inline">\(\mu_k=E(X^k)\)&lt;/span>&lt;/h5>
&lt;p>&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 独立且与 &lt;span class="math inline">\(X\)&lt;/span> 同分布,所以 &lt;span class="math inline">\(X_{1}^{k}, X_{2}^{k}, \cdots, X_{n}^{k}\)&lt;/span>独立且与 &lt;span class="math inline">\(X^{k}\)&lt;/span> 同分布. 故有&lt;span class="math inline">\(E\left(X_{1}^{k}\right)=E\left(X_{2}^{k}\right)=\cdots=E\left(X_{n}^{k}\right)=\mu_{k}\)&lt;/span> 继而由辛钦大数定律知道&lt;span class="math inline">\(A_{k}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{k} \stackrel{P}{\longrightarrow} \mu_{k}, \quad k=1,2, \cdots\)&lt;/span>&lt;/p>
&lt;h5 id="样本矩的函数依概率收敛于总体矩的函数glefta_1-a_2-cdots-a_kright-stackrelplongrightarrow-gleftmu_1-mu_2-cdots-mu_kright">样本矩的函数依概率收敛于总体矩的函数&lt;span class="math inline">\(g\left(A_{1}, A_{2}, \cdots, A_{k}\right) \stackrel{P}{\longrightarrow} g\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right)\)&lt;/span>&lt;/h5>
&lt;p>由上一条性质&lt;span class="math inline">\(A_{k}=\frac{1}{n} \sum_{i=1}^{n} X_{i}^{k} \stackrel{P}{\longrightarrow} \mu_{k}, \quad k=1,2, \cdots\)&lt;/span>， 再根据依概率收敛的序列的性质， 立即可知&lt;span class="math inline">\(g\left(A_{1}, A_{2}, \cdots, A_{k}\right) \stackrel{P}{\longrightarrow} g\left(\mu_{1}, \mu_{2}, \cdots, \mu_{k}\right)\)&lt;/span>&lt;/p>
&lt;p>即（当&lt;span class="math inline">\(n\rightarrow\infty\)&lt;/span>时）样本各阶矩的函数，依概率收敛于总体相应各阶矩的函数。&lt;/p>
&lt;p>这是后面矩估计法的理论依据。&lt;/p>
&lt;h3 id="经验分布函数总体分布的进一步了解">经验分布函数：总体分布的进一步了解&lt;/h3>
&lt;p>我们还可以作出与总体分布函数 &lt;span class="math inline">\(F(x)\)&lt;/span> 相应的统计量 经验分布函数.&lt;/p>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是总体 &lt;span class="math inline">\(F\)&lt;/span> 的一个样本,用S( &lt;span class="math inline">\(x\)&lt;/span> ) &lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;\infty\)&lt;/span> 表示 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 中不大于 &lt;span class="math inline">\(x\)&lt;/span> 的随机变量的个数. 定义经验分布 函数&lt;span class="math inline">\(F_{n}(x)=\frac{1}{n} S(x),-\infty&amp;lt;x&amp;lt;\infty\)&lt;/span>&lt;/p>
&lt;p>例如，设总体 &lt;span class="math inline">\(F\)&lt;/span> 具有一个样本值 &lt;span class="math inline">\(1,2,3,\)&lt;/span> 则经验分布函数 &lt;span class="math inline">\(F_{3}(x)\)&lt;/span> 的观察值为: &lt;span class="math inline">\(F_{3}(x)=\left\{\begin{array}{ll}0, &amp;amp; \text { 若 } x&amp;lt;1, \\ \frac{1}{3}, &amp;amp; \text { 若 } 1 \leqslant x&amp;lt;2, \\ \frac{2}{3}, &amp;amp; \text { 若 } 2 \leqslant x&amp;lt;3, \\ 1, &amp;amp; \text { 若 } x \geqslant 3 .\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>对于经验分布函数 &lt;span class="math inline">\(F_{n}(x),\)&lt;/span> 格里汶科 (Glivenko)在 1933 年证明了以下的结果 :&lt;strong>对于任一实数 &lt;span class="math inline">\(x,\)&lt;/span> 当 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span> 时 &lt;span class="math inline">\(F_{n}(x)\)&lt;/span> 以概率 1 一致收敛于分布函数 &lt;span class="math inline">\(F(x)\)&lt;/span>,&lt;/strong> 即&lt;span class="math inline">\(P\left\{\lim _{n \rightarrow \infty} \sup _{-\infty&amp;lt;x&amp;lt;\infty}\left|F_{n}(x)-F(x)\right|=0\right\}=1\)&lt;/span>&lt;/p>
&lt;p>因此,对于任一实数 &lt;span class="math inline">\(x\)&lt;/span> 当 &lt;span class="math inline">\(n\)&lt;/span> 充分大时,经验分布函数的任一个观察值 &lt;span class="math inline">\(F_{n}(x)\)&lt;/span> 与总体分布函数 &lt;span class="math inline">\(F(x)\)&lt;/span> 只有微小的差别,从而在实际上可当作 &lt;span class="math inline">\(F(x)\)&lt;/span> 来使用。&lt;/p>
&lt;p>这也是样本的频率分布直方图可以粗略了解总体的分布的原因。&lt;/p>
&lt;h3 id="常用统计量的分布">常用统计量的分布&lt;/h3>
&lt;p>统计量的分布称为抽样分布。 在使用统计量进行统计推断时常需知道它的分布。当总体的分布函数已知时，抽样分布是确定的，然而要求出统计量的精确分布，一般来说是困难的。&lt;/p>
&lt;p>本节介绍来自正态总体的几个常用统计量的分布：&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布、t分布、&lt;span class="math inline">\(F\)&lt;/span> 分布（统计学三大分布）。 样本均值、样本方差的性质，特别是总体服从正态分布情况下样本均值和方差的性质。&lt;/p>
&lt;h4 id="chi2分布">&lt;span class="math inline">\(\chi^{2}\)&lt;/span>分布&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(N(0,1)\)&lt;/span> 的样本,则称统计量&lt;span class="math inline">\(\chi^{2}=X_{1}^{2}+X_{2}^{2}+\cdots+X_{n}^{2}\)&lt;/span>服从自由度为 &lt;span class="math inline">\(n\)&lt;/span> 的 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布,记为 &lt;span class="math inline">\(\chi^{2} \sim \chi^{2}(n) .\)&lt;/span> 此处,自由度是指等式右端包含的独立变量的个数.&lt;/p>
&lt;p>可以看出，&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 是标准正态总体情况下，抽取样本的2阶矩。&lt;/p>
&lt;p>&lt;span class="math inline">\(\chi^{2}(n)\)&lt;/span> 分布的概率密度为&lt;span class="math inline">\(f(y)=\left\{\begin{array}{cl}\frac{1}{2^{n / 2} \Gamma(n / 2)} y^{n / 2-1} \mathrm{e}^{-y / 2}, &amp;amp; y&amp;gt;0 \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\chi^{2}(n)\)&lt;/span> 分布密度函数的图形：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215010843386.png" alt="" />&lt;figcaption>image-20201215010843386&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的性质： 1）&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布可用&lt;span class="math inline">\(\Gamma\)&lt;/span>分布&lt;a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref">&lt;sup>4&lt;/sup>&lt;/a>表述：&lt;span class="math inline">\(\chi^{2}=\sum_{i=1}^{n} X_{i}^{2} \sim \Gamma\left(\frac{n}{2}, 2\right)\)&lt;/span> 2）&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的可加性&lt;a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref">&lt;sup>5&lt;/sup>&lt;/a>：设 &lt;span class="math inline">\(\chi_{1}^{2} \sim \chi^{2}\left(n_{1}\right), \chi_{2}^{2} \sim \chi^{2}\left(n_{2}\right),\)&lt;/span> 并且 &lt;span class="math inline">\(\chi_{1}^{2}, \chi_{2}^{2}\)&lt;/span> 相互独立,则有&lt;span class="math inline">\(\chi_{1}^{2}+\chi_{2}^{2} \sim \chi^{2}\left(n_{1}+n_{2}\right)\)&lt;/span> 3）&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的数学期望与方差&lt;a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref">&lt;sup>6&lt;/sup>&lt;/a>：若 &lt;span class="math inline">\(\chi^{2} \sim \chi^{2}(n),\)&lt;/span> 则有&lt;span class="math inline">\(E\left(\chi^{2}\right)=n, \quad D\left(\chi^{2}\right)=2 n\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的分位点： 对于给定的正数 &lt;span class="math inline">\(\alpha, 0&amp;lt;\alpha&amp;lt;1,\)&lt;/span> 称满足条件&lt;span class="math inline">\(P\left\{\chi^{2}&amp;gt;\chi_{\alpha}^{2}(n)\right\}=\int_{\chi_{a}^{2}(n)}^{\infty} f(y) \mathrm{d} y=\alpha\)&lt;/span>的点 &lt;span class="math inline">\(\chi_{a}^{2}(n)\)&lt;/span> 为 &lt;span class="math inline">\(\chi^{2}(n)\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215012807799.png" alt="" />&lt;figcaption>image-20201215012807799&lt;/figcaption>
&lt;/figure>
&lt;p>当n比较小（n&amp;lt;40）时，&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的&lt;span class="math inline">\(\alpha\)&lt;/span>分位点 &lt;span class="math inline">\(\chi_{a}^{2}(n)\)&lt;/span> 的值通过查表获得； 当n比较大时，近似有&lt;span class="math inline">\(\chi_{a}^{2}(n) \approx \frac{1}{2}\left(z_{\alpha}+\sqrt{2 n-1}\right)^{2}\)&lt;/span>，其中 &lt;span class="math inline">\(z_{a}\)&lt;/span> 是标准正态分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点。&lt;/p>
&lt;h4 id="t分布">t分布&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X \sim N(0,1), Y \sim \chi^{2}(n),\)&lt;/span> 且 &lt;span class="math inline">\(X, Y\)&lt;/span> 相互独立,则称随机变量&lt;span class="math inline">\(t=\frac{X}{\sqrt{Y / n}}\)&lt;/span>服从自由度为 &lt;span class="math inline">\(n\)&lt;/span> 的 &lt;span class="math inline">\(t\)&lt;/span> 分布. 记为 &lt;span class="math inline">\(t \sim t(n)\)&lt;/span>.&lt;span class="math inline">\(t\)&lt;/span> 分布又称学生氏( Student)分布.&lt;/p>
&lt;p>&lt;span class="math inline">\(t(n)\)&lt;/span>分布的概率密度函数：&lt;span class="math inline">\(h(t)=\frac{\Gamma[(n+1) / 2]}{\sqrt{\pi n} \Gamma(n / 2)}\left(1+\frac{t^{2}}{n}\right)^{-(n+1) / 2},-\infty&amp;lt;t&amp;lt;\infty\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(t(n)\)&lt;/span>分布的概率密度图像：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215013424394.png" alt="" />&lt;figcaption>image-20201215013424394&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(t(n)\)&lt;/span>分布的性质： 1）概率密度&lt;span class="math inline">\(h(t)\)&lt;/span> 的图形关于 &lt;span class="math inline">\(t=0\)&lt;/span> 对称 2）概率密度&lt;span class="math inline">\(\lim _{n \rightarrow \infty} h(t)=\frac{1}{\sqrt{2 \pi}} \mathrm{e}^{-t^{2} / 2}\)&lt;/span>，即当 &lt;span class="math inline">\(n\)&lt;/span> 足够大时 &lt;span class="math inline">\(t\)&lt;/span> 分布近似于 &lt;span class="math inline">\(N\)&lt;/span> (0,1)分布。（注意n较小时，与标准正态分布相差较大）&lt;/p>
&lt;p>t分布的分位点： 对于给定的 &lt;span class="math inline">\(\alpha, 0&amp;lt;\alpha&amp;lt;1\)&lt;/span>,称满足条件&lt;span class="math inline">\(P\left\{t&amp;gt;t_{\alpha}(n)\right\}=\int_{t_{\alpha}(n)}^{\infty} h(t) \mathrm{d} t=\alpha\)&lt;/span>的点 &lt;span class="math inline">\(t_{\alpha}(n)\)&lt;/span> 为 &lt;span class="math inline">\(t(n)\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点。 &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215014010426.png" alt="image-20201215014010426" /> 由 &lt;span class="math inline">\(t\)&lt;/span> 分布上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点的定义及概率密度 &lt;span class="math inline">\(h(t)\)&lt;/span> 图形的对称性知&lt;span class="math inline">\(t_{1-\alpha}(n)=-t_{a}(n)\)&lt;/span>。&lt;/p>
&lt;p>当n比较小（n&amp;lt;=45）时，&lt;span class="math inline">\(t\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点可查表获得； 当n比较大时，&lt;span class="math inline">\(t\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点可近似为标准正态分布上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点&lt;/p>
&lt;h4 id="f-分布">&lt;span class="math inline">\(F\)&lt;/span> 分布&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(U \sim \chi^{2}\left(n_{1}\right), V \sim \chi^{2}\left(n_{2}\right),\)&lt;/span> 且 &lt;span class="math inline">\(U, V\)&lt;/span> 相互独立,则称随机变量&lt;span class="math inline">\(F=\frac{U / n_{1}}{V / n_{2}}\)&lt;/span>服从自由度为 &lt;span class="math inline">\(\left(n_{1}, n_{2}\right)\)&lt;/span> 的 &lt;span class="math inline">\(F\)&lt;/span> 分布,记为 &lt;span class="math inline">\(F \sim F\left(n_{1}, n_{2}\right)\)&lt;/span>.&lt;/p>
&lt;p>&lt;span class="math inline">\(F\left(n_{1}, n_{2}\right)\)&lt;/span> 分布的概率密度为&lt;span class="math inline">\(\psi(y)=\left\{\begin{array}{ll}\frac{\Gamma\left[\left(n_{1}+n_{2}\right) / 2\right]\left(n_{1} / n_{2}\right)^{n_{1} / 2} y^{\left(n_{1} / 2\right)-1}}{\Gamma\left(n_{1} / 2\right) \Gamma\left(n_{2} / 2\right)\left[1+\left(n_{1} y / n_{2}\right)\right]^{\left(n_{1}+n_{2}\right) / 2}}, &amp;amp; y&amp;gt;0 \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(F\left(n_{1}, n_{2}\right)\)&lt;/span> 分布的概率密度的图形：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215022653270.png" alt="" />&lt;figcaption>image-20201215022653270&lt;/figcaption>
&lt;/figure>
&lt;p>若 &lt;span class="math inline">\(F \sim F\left(n_{1}, n_{2}\right),\)&lt;/span> 则&lt;span class="math inline">\(\frac{1}{F} \sim F\left(n_{2}, n_{1}\right)\)&lt;/span>&lt;/p>
&lt;p>F分布的分位点：对于给定的 &lt;span class="math inline">\(\alpha, 0&amp;lt;\alpha&amp;lt;1,\)&lt;/span> 称满足条件&lt;span class="math inline">\(P\left\{F&amp;gt;F_{\alpha}\left(n_{1}, n_{2}\right)\right\}=\int_{F_{\alpha}\left(n_{1}, n_{2}\right)}^{\infty} \psi(y) \mathrm{d} y=\alpha\)&lt;/span>的点 &lt;span class="math inline">\(F_{\alpha}\left(n_{1}, n_{2}\right)\)&lt;/span> 为 &lt;span class="math inline">\(F\left(n_{1}, n_{2}\right)\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201215025747653.png" alt="" />&lt;figcaption>image-20201215025747653&lt;/figcaption>
&lt;/figure>
&lt;p>F分布的分位点性质：&lt;span class="math inline">\(F_{1-\alpha}\left(n_{1}, n_{2}\right)=\frac{1}{F_{\alpha}\left(n_{2}, n_{1}\right)}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(F\)&lt;/span> 分布的上 &lt;span class="math inline">\(\alpha\)&lt;/span> 分位点通过查表获取，不在表上的通过上面的性质公式换算。&lt;/p>
&lt;h4 id="样本均值和方差的性质">样本均值和方差的性质&lt;/h4>
&lt;p>&lt;strong>设总体 &lt;span class="math inline">\(X\)&lt;/span> (不管服从什么分布,只要均值和方差存在)&lt;/strong>的均值为 &lt;span class="math inline">\(\mu\)&lt;/span>, 方差为 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span>, $ X_{1}, X_{2}, , X_{n}$ 是来自 &lt;span class="math inline">\(X\)&lt;/span> 的一个样本 &lt;span class="math inline">\(, \bar{X}, S^{2}\)&lt;/span> 分别是样本均值和样本方差, 则&lt;span class="math inline">\(E(\bar{X})=\mu, \quad D(\bar{X})=\sigma^{2} / n\)&lt;/span>,&lt;span class="math inline">\(E\left(S^{2}\right)=\sigma^{2}\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(\begin{aligned} E\left(S^{2}\right) &amp;amp;=E\left[\frac{1}{n-1}\left(\sum_{i=1}^{n} X_{i}^{2}-n \bar{X}^{2}\right)\right]=\frac{1}{n-1}\left[\sum_{i=1}^{n} E\left(X_{i}^{2}\right)-n E\left(\bar{X}^{2}\right)\right] \\ &amp;amp;=\frac{1}{n-1}\left[\sum_{i=1}^{n}\left(\sigma^{2}+\mu^{2}\right)-n\left(\sigma^{2} / n+\mu^{2}\right)\right]=\sigma^{2} \end{aligned}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="正态总体的抽样分布">正态总体的抽样分布&lt;/h4>
&lt;p>&lt;strong>设正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>&lt;/strong>， 由前面章节可知相互独立、服从正态分布的多个随机变量的线性组合仍是正态分布：&lt;span class="math inline">\(C_{1} X_{1}+C_{2} X_{2}+\cdots+C_{n} X_{n} \sim N\left(\sum_{i=1}^{n} C_{i} \mu_{i}, \sum_{i=1}^{n} C_{i}^{2} \sigma_{i}^{2}\right)\)&lt;/span>， 则样本均值&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span>也服从正态分布&lt;span class="math inline">\(\bar{X} \sim N\left(\mu, \sigma^{2} / n\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>设正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>&lt;/strong>， &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 的样本 &lt;span class="math inline">\(, \bar{X}, S^{2}\)&lt;/span> 分别是样本均值和样本方差,则有 1）&lt;span class="math inline">\(\frac{(n-1) S^{2}}{\sigma^{2}} \sim \chi^{2}(n-1)\)&lt;/span> 2）&lt;span class="math inline">\(\bar{X}\)&lt;/span> 与 &lt;span class="math inline">\(S^{2}\)&lt;/span> 相互独立.&lt;/p>
&lt;p>&lt;strong>设正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>&lt;/strong>， &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自总体 &lt;span class="math inline">\(N\left(\mu, \sigma^{2}\right)\)&lt;/span> 的样本 &lt;span class="math inline">\(, \bar{X}, S^{2}\)&lt;/span> 分别是样本均值和样本方差,则有 &lt;span class="math inline">\(\frac{\bar{X}-\mu}{S / \sqrt{n}} \sim t(n-1)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>设正态分布&lt;span class="math inline">\(X \sim N\left(\mu_1, \sigma_1^{2}\right)\)&lt;/span>，正态分布&lt;span class="math inline">\(Y \sim N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>&lt;/strong>， &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 是来自正态总体 &lt;span class="math inline">\(N\left(\mu_1, \sigma_1^{2}\right)\)&lt;/span> 的样本 ,&lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n_{2}}\)&lt;/span>是来自正态总体&lt;span class="math inline">\(N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>的样本， 且这两个样本分别独立。 &lt;span class="math inline">\(\bar{X}=\frac{1}{n_{1}} \sum_{i=1}^{n_{1}} X_{i}\)&lt;/span>，&lt;span class="math inline">\(\bar{Y}=\)&lt;/span>&lt;span class="math inline">\(\frac{1}{n_{2}} \sum_{i=1}^{n_{2}} Y_{i}\)&lt;/span> 分别是这两个样本 的样本均值; &lt;span class="math inline">\(S_{1}^{2}=\frac{1}{n_{1}-1} \sum_{i=1}^{n_{1}}\left(X_{i}-\bar{X}\right)^{2}\)&lt;/span>,$ S_{2}^{2}=$&lt;span class="math inline">\(\frac{1}{n_{2}-1} \sum_{i=1}^{n_{2}}\left(Y_{i}-\bar{Y}\right)^{2}\)&lt;/span> 分别是这两个样本的样本方差,则有 1）&lt;span class="math inline">\(\frac{S_{1}^{2} / S_{2}^{2}}{\sigma_{1}^{2} / \sigma_{2}^{2}} \sim F\left(n_{1}-1, n_{2}-1\right)\)&lt;/span> 2）当 &lt;span class="math inline">\(\sigma_{1}^{2}=\sigma_{2}^{2}=\sigma^{2}\)&lt;/span> 时，&lt;span class="math inline">\(\frac{(\bar{X}-\bar{Y})-\left(\mu_{1}-\mu_{2}\right)}{S_{w} \sqrt{\frac{1}{n_{1}}+\frac{1}{n_{2}}}} \sim t\left(n_{1}+n_{2}-2\right)\)&lt;/span>，其中&lt;span class="math inline">\(S_{w}^{2}=\frac{\left(n_{1}-1\right) S_{1}^{2}+\left(n_{2}-1\right) S_{2}^{2}}{n_{1}+n_{2}-2}, \quad S_{w}=\sqrt{S_{w}^{2}}\)&lt;/span>&lt;/p>
&lt;p>注意：本节所介绍的几个分布（&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布，t分布，F分布），以及样本均值和方差的性质（除了&lt;span class="math inline">\(E(\bar{X})=\mu, \quad D(\bar{X})=\sigma^{2} / n\)&lt;/span>,&lt;span class="math inline">\(E\left(S^{2}\right)=\sigma^{2}\)&lt;/span>），都是在总体为正态分布的假定下得到的。&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>数据资料指所研究对象的某数据指标的观测值，即随机变量的观测值&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2" role="doc-endnote">&lt;p>注意区分数理统计中的总体与概率论中的样本空间的概念。样本空间与总体有何区别？ - robot DDD的回答 - 知乎 https://www.zhihu.com/question/300729716/answer/522207094&lt;a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3" role="doc-endnote">&lt;p>虽然样本&lt;span class="math inline">\(X_1,\cdots,X_n\)&lt;/span>相互独立，但是在计算方差时，&lt;span class="math inline">\(X_1,\cdots,X_n\)&lt;/span>自由度为n-1，因为计算方差是在已知样本均值&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span>的情况下进行的，这也是一条约束。则分配到每个自由度上的概率都是&lt;span class="math inline">\(\frac{1}{n-1}\)&lt;/span>&lt;a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn4" role="doc-endnote">&lt;p>若&lt;span class="math inline">\(X \sim \Gamma(\alpha, \theta)\)&lt;/span>对应的概率密度函数为&lt;span class="math inline">\(f_{X}(x)=\left\{\begin{array}{ll}\frac{1}{\theta^{\alpha} \Gamma(\alpha)} x^{\alpha-1} \mathrm{e}^{-x / \theta}, &amp;amp; x&amp;gt;0 \\ 0, &amp;amp; \text { 其他 }\end{array} \quad \alpha&amp;gt;0, \theta&amp;gt;0\right.\)&lt;/span>。&lt;a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn5" role="doc-endnote">&lt;p>可根据如下性质导出：若随机变量X与Y独立，且&lt;span class="math inline">\(X \sim \Gamma(\alpha, \theta), Y \sim \Gamma(\beta, \theta)\)&lt;/span>，则&lt;span class="math inline">\(X+Y \sim \Gamma(\alpha+\beta, \theta)\)&lt;/span>&lt;a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn6" role="doc-endnote">&lt;p>完全可由&lt;span class="math inline">\(\chi^{2}\)&lt;/span> 的定义+数学期望定义+方差定义导出&lt;a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>概率论与数理统计-概率论-大数定律与中心极限定理</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</link><pubDate>Thu, 03 Dec 2020 07:31:02 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-大数定律与中心极限定理">概率论与数理统计-大数定律与中心极限定理&lt;/h1>
&lt;p>本章介绍概率统计理论中非常重要的两类定理：大数定律和中心极限定理。&lt;/p>
&lt;p>大数定律讨论的是一列随机变量的均值的收敛性问题。（独立、同期望、同方差的随机变量列&lt;span class="math inline">\(\{X_n\}\)&lt;/span>的算数平均依概率收敛于期望&lt;span class="math inline">\(\mu\)&lt;/span>）&lt;/p>
&lt;p>中心极限定理考虑的是一列随机变量和的极限分布问题。（独立、同分布的随机变量列&lt;span class="math inline">\(\{X_n\}\)&lt;/span>的和的分布近似为正态分布）&lt;/p>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;h3 id="依概率收敛">依概率收敛&lt;/h3>
&lt;p>设&lt;span class="math inline">\(X_{1}, X_{2}, \cdots\)&lt;/span>为一随机变量序列，X为一随机变量， 若对任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>，有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|X_{n}-X\right| \geqslant \epsilon\right)=0\)&lt;/span>， 则称&lt;span class="math inline">\(\{x_n\)&lt;/span>}$依概率收敛于X.&lt;/p>
&lt;h3 id="切比雪夫不等式">切比雪夫不等式&lt;/h3>
&lt;h4 id="切比雪夫不等式的提出">切比雪夫不等式的提出&lt;/h4>
&lt;p>19世纪俄国数学家&lt;strong>切比雪夫&lt;/strong>研究统计规律中，论证并&lt;strong>用标准差表达了一个不等式&lt;/strong>，这个不等式&lt;strong>具有普遍的意义&lt;/strong>，被称作切比雪夫定理，其大意是：&lt;/p>
&lt;p>任意一个数据集中，&lt;strong>位于其平均数m个标准差范围内的比例（或部分）总是至少为1－1/m2，&lt;/strong> 其中m为大于1的任意正数。对于m=2，m=3和m=5有如下结果：&lt;/p>
&lt;ul>
&lt;li>所有数据中，至少有3/4（或75%）的数据位于平均数2个标准差范围内。&lt;/li>
&lt;li>所有数据中，至少有8/9（或88.9%）的数据位于平均数3个标准差范围内。&lt;/li>
&lt;li>所有数据中，至少有24/25（或96%)的数据位于平均数5个标准差范围内 。&lt;/li>
&lt;/ul>
&lt;p>换言之, &lt;strong>与平均相差k个标准差以上的值，数目不多于1/k^2&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>与平均相差2个&lt;a href="https://zh.wikipedia.org/wiki/標準差">标准差&lt;/a>以上的值，数目不多于1/4&lt;/li>
&lt;li>与平均相差3个标准差以上的值，数目不多于1/9&lt;/li>
&lt;li>与平均相差5个标准差以上的值，数目不多于1/25&lt;/li>
&lt;/ul>
&lt;h4 id="切比雪夫不等式的数学描述">切比雪夫不等式的数学描述&lt;/h4>
&lt;p>说法一： 设随机变量X的数学期望为&lt;span class="math inline">\(\mu\)&lt;/span>，方差为&lt;span class="math inline">\(\sigma^2\)&lt;/span>， 则对于任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>，有&lt;span class="math inline">\(P(|X-\mu| \geqslant \epsilon) \leqslant \frac{\sigma^{2}}{\epsilon^{2}}\)&lt;/span>&lt;/p>
&lt;p>说法二： 设随机变量X的数学期望为&lt;span class="math inline">\(\mu\)&lt;/span>，方差为&lt;span class="math inline">\(\sigma^2\)&lt;/span>， 则对于任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>，有&lt;span class="math inline">\(P(|X-\mu|&amp;lt;\epsilon) \geqslant 1-\frac{\sigma^{2}}{\epsilon^{2}}\)&lt;/span>&lt;/p>
&lt;p>说法三：（取&lt;span class="math inline">\(\epsilon=k \sigma\)&lt;/span>） 设随机变量X的数学期望为&lt;span class="math inline">\(\mu\)&lt;/span>，方差为&lt;span class="math inline">\(\sigma^2\)&lt;/span>， 则&lt;span class="math inline">\(P(\mu -k\sigma &amp;lt;X&amp;lt;\mu +k\sigma )\geq 1-{\frac {1}{k^{2}}}\)&lt;/span>&lt;/p>
&lt;p>证明: 以下仅证明X是连续型随机变量的情形(X是离散型随机变量类似): 设随机变量X的密度函数为&lt;span class="math inline">\(f(x)\)&lt;/span>,则有 &lt;span class="math inline">\(\begin{aligned} P(|X-\mu| \geqslant \epsilon) &amp;amp;=\int_{|x-\mu| \geqslant \epsilon} f(x) \mathrm{d} x \leqslant \int_{|x-\mu| \geqslant \epsilon} \frac{|x-\mu|^{2}}{\epsilon^{2}} f(x) \mathrm{d} x \\ &amp;amp; \leqslant \frac{1}{\epsilon^{2}} \int_{-\infty}^{+\infty}(x-\mu)^{2} f(x) \mathrm{d} x=\frac{\sigma^{2}}{\epsilon^{2}} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h2 id="大数定律">大数定律&lt;/h2>
&lt;p>参考:https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B 参考:https://baike.baidu.com/item/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B 参考: 参考:https://baike.baidu.com/item/%E8%BE%9B%E9%92%A6%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B 参考:https://zhuanlan.zhihu.com/p/77312635 参考:https://baike.baidu.com/item/%E5%BC%BA%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B&lt;/p>
&lt;p>&lt;strong>大数定律告诉我们能用频率近似代替概率；能用样本均值近似代替总体均值(算数平均值接近期望值)。&lt;/strong> 样本数量越多，则其&lt;a href="https://zh.wikipedia.org/wiki/算术平均值">算术平均值&lt;/a>就有越高的概率接近&lt;a href="https://zh.wikipedia.org/wiki/期望值">期望值&lt;/a>。&lt;/p>
&lt;p>&lt;strong>总结来看，大数定理将属于数理统计的平均值和属于概率论的期望联系在了一起。&lt;/strong>&lt;/p>
&lt;figure>
&lt;img src="https://pic1.zhimg.com/80/v2-610ab422fe593a5058d951343aa74f68_720w.jpg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>大数定律还有强大数定律和弱大数定律之分,这里不做讨论.&lt;/p>
&lt;p>下面介绍大数定律的几个版本.&lt;/p>
&lt;h3 id="切比雪夫大数定律切比雪夫定理揭示样本均值和真实期望的关系">切比雪夫大数定律(切比雪夫定理):揭示样本均值和真实期望的关系&lt;/h3>
&lt;p>设随机变量序列 &lt;span class="math inline">\(\left\{X_{i}\right\}\)&lt;/span> 两两相对独立，且期望存在 &lt;span class="math inline">\(E\left(X_{i}\right)=\mu_{i},\)&lt;/span> 方差存在且有共同有限上界 &lt;span class="math inline">\(D\left(X_{i}\right)=\sigma_{i}^{2}&amp;lt;M,\)&lt;/span> 则对 &lt;span class="math inline">\(\forall \varepsilon&amp;gt;0, \quad \lim _{n \rightarrow+\infty} P\left\{\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\frac{1}{n} \sum_{i=1}^{n} \mu_{i}\right|&amp;lt;\varepsilon\right\}=1\)&lt;/span>&lt;/p>
&lt;h3 id="切比雪夫大数定律的特殊情形">切比雪夫大数定律的特殊情形&lt;/h3>
&lt;p>(设随机变量序列 &lt;span class="math inline">\(\left\{X_{i}\right\}\)&lt;/span> 两两相对独立的前提下) 特别的, 若 &lt;span class="math inline">\(\left\{X_{i}\right\}\)&lt;/span> 有相同的期望 &lt;span class="math inline">\(\mu,\)&lt;/span> 则有 &lt;span class="math inline">\(\lim _{n \rightarrow+\infty} P\left\{\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\mu\right|&amp;lt;\varepsilon\right\}=1\)&lt;/span> 。&lt;/p>
&lt;p>有另一种说法: 设&lt;span class="math inline">\(X_1,X_2,\cdots\)&lt;/span>是相互独立的随机变量(某些材料上是两两独立),且具有相同的数学期望&lt;span class="math inline">\(\mu\)&lt;/span>及相同的方差&lt;span class="math inline">\(\sigma^2\)&lt;/span>, 则对任意&lt;span class="math inline">\(\sigma&amp;gt;0\)&lt;/span>,有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\mu\right| \geqslant \epsilon\right)=0\)&lt;/span>. 即 &lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span> 依概率收敛于 &lt;span class="math inline">\(\mu\)&lt;/span>.&lt;/p>
&lt;blockquote>
&lt;p>证明 取随机变量&lt;span class="math inline">\(X=\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span> 由&lt;span class="math inline">\(E\left[\frac{1}{n} \sum_{i=1}^{n} X_{i}\right]=\mu\)&lt;/span>, &lt;span class="math inline">\(D\left[\frac{1}{n} \sum_{i=1}^{n} X_{i}\right]=\frac{\sigma^{2}}{n}\)&lt;/span> 由切比雪夫不等式可得 &lt;span class="math inline">\(P\left(\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\mu\right| \geqslant \epsilon\right) \leqslant \frac{\sigma^{2}}{n \epsilon^{2}}\)&lt;/span> 令&lt;span class="math inline">\(n\rightarrow\infty\)&lt;/span>即得 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\mu\right| \geqslant \epsilon\right)=0\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>在所给条件下(独立,同期望方差), n个随机变量&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>的算数平均值&lt;span class="math inline">\(\frac{1}{n} \sum_{i=1}^{n} X_{i}\)&lt;/span>当&lt;span class="math inline">\(n\rightarrow\infty\)&lt;/span>时,与它们的共同期望&lt;span class="math inline">\(\mu\)&lt;/span>非常接近.&lt;/p>
&lt;p>&lt;strong>物理上&lt;/strong>,我们经常对某个物理量重复测量n次,并且利用n次测量值的算数平均作为该物理量真实值&lt;span class="math inline">\(\mu\)&lt;/span>的估计.n越大,所得均值越接近真实值&lt;span class="math inline">\(\mu\)&lt;/span>.&lt;/p>
&lt;p>将该公式应用于&lt;strong>抽样调查&lt;/strong>，就会有如下结论：随着&lt;a href="https://baike.baidu.com/item/样本容量">样本容量&lt;/a>n的增加，&lt;a href="https://baike.baidu.com/item/样本">样本&lt;/a>平均数将接近于&lt;a href="https://baike.baidu.com/item/总体">总体&lt;/a>平均数。从而为统计推断中依据样本平均数估计总体平均数提供了理论依据。&lt;/p>
&lt;p>特别需要注意的是，&lt;a href="https://baike.baidu.com/item/切比雪夫">切比雪夫&lt;/a>大数定理并未要求&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>同分布，相较于伯努利大数定律和&lt;a href="https://baike.baidu.com/item/辛钦">辛钦&lt;/a>大数定律更具一般性。&lt;/p>
&lt;h3 id="伯努利大数定律揭示概率与频率的关系">伯努利大数定律:揭示概率与频率的关系&lt;/h3>
&lt;p>设事件A在一次试验中发生的概率为p (0&amp;lt;p&amp;lt;1), 将试验独立进行n次,用&lt;span class="math inline">\(n_A\)&lt;/span>表示事件A发生的次数, 则对任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>,有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|\frac{n_{A}}{n}-p\right| \geqslant \epsilon\right)=0\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明 构造一列随机变量&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>,如下: &lt;span class="math inline">\(X_{i}=\left\{\begin{array}{ll}1, &amp;amp; A \text { 在第i次试验中发生, } \\ 0, &amp;amp; \text { A在第i次试验中不发生. }\end{array}\right.\)&lt;/span> 于是&lt;span class="math inline">\(\frac{n_{A}}{n}=\frac{1}{n} \sum_{i=1}^{n} X_{i}, \quad E\left(X_{i}\right)=p\)&lt;/span> 根据&lt;a href="#切比雪夫大数定律的特殊情形">切比雪夫大数定律的特殊情形&lt;/a>, 可得&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|\frac{n_{A}}{n}-p\right| \geqslant \epsilon\right)=0\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>从定义概率的角度，&lt;strong>揭示了概率与频率的关系&lt;/strong>，当N很大的时候，事件A发生的概率等于A发生的频率。&lt;/p>
&lt;h3 id="辛钦大数定律揭示算术平均值和数学期望的关系">辛钦大数定律:揭示算术平均值和数学期望的关系&lt;/h3>
&lt;p>设一列随机变量&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>相互独立,同分布,且有共同数学期望为&lt;span class="math inline">\(\mu\)&lt;/span>,(同分布隐含了期望相同) 则对于任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>,有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\left|\frac{1}{n} \sum_{i=1}^{n} X_{i}-\mu\right| \geqslant \epsilon\right)=0\)&lt;/span>&lt;/p>
&lt;h2 id="中心极限定理">中心极限定理&lt;/h2>
&lt;p>通俗的讲，中心极限定理表述的是如下结论：在一定条件下，大量相互独立随机变量的和(标准化和）的分布近似为正态分布。&lt;/p>
&lt;p>这里我们主要讨论中心极限定理的两种基本形式。&lt;/p>
&lt;h3 id="林德伯格-莱维lindeberg-levy中心极限定理">林德伯格-莱维(Lindeberg-Levy)中心极限定理&lt;/h3>
&lt;p>说法一：&lt;/p>
&lt;p>设&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>是一系列相互独立且同分布的随机变量，它们的期望和方差分别为&lt;span class="math inline">\(\mu,\sigma^2\)&lt;/span>, 则&lt;span class="math inline">\(Y_{n}=\frac{\sum_{i=1}^{n} X_{i}-n \mu}{\sigma \sqrt{n}}=\frac{\sum_{i=1}^{n} X_{i}-E\left(\sum_{i=1}^{n} X_{i}\right)}{\sqrt{D\left(\sum_{i=1}^{n} X_{i}\right)}}=\frac{X-E(X)}{\sqrt{D(X)}}\)&lt;/span>的分布当&lt;span class="math inline">\(n\rightarrow\infty\)&lt;/span>时趋于正态分布(其中令&lt;span class="math inline">\(X=\sum_{i=1}^{n} X_{i}\)&lt;/span>)， 即对任意实数x，有&lt;span class="math inline">\(P(Y_n\leqslant x)= P\left(\frac{\sum_{i=1}^{n} X_{i}-n \mu}{\sigma \sqrt{n}} \leqslant x\right)=P\left(\frac{X-E(X)}{\sqrt{D(X)}}\leqslant x\right) \rightarrow \Phi(x)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{x} \mathrm{e}^{-\frac{x^{2}}{2}} \mathrm{~d} x, \quad n \rightarrow \infty\)&lt;/span>&lt;/p>
&lt;p>说法二：&lt;/p>
&lt;p>设随机变量 &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span> 独立同分布， &lt;span class="math inline">\(D\left(X_{i}\right)=\sigma^{2} \neq 0(i=1,2, \cdots, n)\)&lt;/span> &lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{i=1}^{n} X_{i}, \zeta_{n}=\frac{\bar{X}-\mu}{\sigma / \sqrt{n}},\)&lt;/span> 则 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\zeta_{n} \leq z\right)=\Phi(z)\)&lt;/span> 其中 &lt;span class="math inline">\(\Phi(z)\)&lt;/span> 是标准正态分布的分布函数。&lt;/p>
&lt;blockquote>
&lt;p>证明 记 &lt;span class="math inline">\(X_{k}-\mu\)&lt;/span> 的特征函数为 &lt;span class="math inline">\(\varphi(t),\)&lt;/span> 根据傅里叶变换样本空间中的褶积（&lt;a href="https://www.matongxue.com/madocs/32/">卷积&lt;/a>）在特征函数空间变为乘积, 因此 &lt;span class="math inline">\(\zeta_{n}\)&lt;/span> 的特征函数为 &lt;span class="math inline">\(\left[\varphi\left(\frac{t}{\sigma \sqrt{n}}\right)\right]^{n}\)&lt;/span>.由于 &lt;span class="math inline">\(E\left(X_{k}\right)=\mu, D\left(X_{k}\right)=\sigma^{2}\)&lt;/span> 故 &lt;span class="math inline">\(\varphi^{\prime}(0)=0, \varphi^{\prime \prime}(0)=-\sigma^{2}\)&lt;/span>.因此 &lt;span class="math inline">\(\varphi(t)=1-\frac{1}{2} \sigma^{2} t^{2}+o\left(t^{2}\right)\)&lt;/span> 所以 &lt;span class="math display">\[
\left[\varphi\left(\frac{t}{\sigma \sqrt{n}}\right)\right]^{n}=\left[1-\frac{1}{2 n} t^{2}+o\left(\frac{t^{2}}{n}\right)\right]^{n} \rightarrow e^{-t^{2} / 2}
\]&lt;/span> 由于 &lt;span class="math inline">\(e^{-t^{2} / 2}\)&lt;/span> 是连续函数, 它对应的分布函数为 &lt;span class="math inline">\(\Phi(Z),\)&lt;/span> 因此由逆极限定理知 &lt;span class="math display">\[
\lim _{n \rightarrow \infty} P\left(\zeta_{n} \leq z\right) \rightarrow \Phi(z)
\]&lt;/span> 定理证毕。&lt;/p>
&lt;/blockquote>
&lt;h3 id="棣莫弗-拉普拉斯de-moivre-laplace中心极限定理">棣莫弗-拉普拉斯(De Moivre-Laplace)中心极限定理&lt;/h3>
&lt;p>该中心极限定理是历史上最早的中心极限定理。&lt;/p>
&lt;p>表述一：&lt;/p>
&lt;p>设随机变量&lt;span class="math inline">\(X_1,X_2,\cdots\)&lt;/span>相互独立且都服从参数为 p(0&amp;lt;p&amp;lt;1) 的0-1分布， 则对任意实数x，有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\frac{\sum_{i=1}^{n} X_{i}-n p}{\sqrt{n p(1-p)}} \leqslant x\right)=\Phi(x)\)&lt;/span>&lt;/p>
&lt;p>表述二：（很明显有&lt;span class="math inline">\(\sum_{i=1}^{n} X_{i} \sim B(n, p)\)&lt;/span>）&lt;/p>
&lt;p>设随机变量&lt;span class="math inline">\(Y_n = \sum_{i=1}^{n} X_{i} \sim B(n, p)\)&lt;/span>, 则对任意实数x，有&lt;span class="math inline">\(\lim _{n \rightarrow \infty} P\left(\frac{Y_{n}-n p}{\sqrt{n p(1-p)}} \leqslant x\right)=\Phi(x)\)&lt;/span>&lt;/p>
&lt;p>表述三：&lt;/p>
&lt;p>若 &lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span> 是 &lt;span class="math inline">\(n\)&lt;/span> 次伯努利实验中事件 &lt;span class="math inline">\(A\)&lt;/span> 出现的次数, 每次试验成功的概率为 &lt;span class="math inline">\(p,\)&lt;/span> 且 &lt;span class="math inline">\(q=1-p,\)&lt;/span> 则对任意有限 区间 &lt;span class="math inline">\([a, b]:\)&lt;/span> &lt;span class="math inline">\(\hat{\text { 令 }} x_{k} \equiv \frac{k-n p}{\sqrt{n p q}},\)&lt;/span> 当 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span> 时 (i) &lt;span class="math inline">\(P(X=k) \rightarrow \frac{1}{\sqrt{n p q}} \cdot \frac{1}{\sqrt{2 \pi}} e^{-\frac{1}{2} x_{\mu_{n}}^{2}}\)&lt;/span> (ii) &lt;span class="math inline">\(P\left(a \leq \frac{X-n p}{\sqrt{n p q}} \leq b\right) \rightarrow \int_{a}^{b} \varphi(x) d x,\)&lt;/span> 其中 &lt;span class="math inline">\(\varphi(x)=\frac{1}{\sqrt{2 \pi}} e^{-\frac{x^{2}}{2}}(-\infty&amp;lt;x&amp;lt;\infty)\)&lt;/span>&lt;/p>
&lt;p>该中心极限定理表明，正态分布是二项分布的极限分布。即当n充分大时，可用正态分布近似计算二项分布的概率。它指出，参数为&lt;em>n&lt;/em>, &lt;em>p&lt;/em>的二项分布以&lt;em>np&lt;/em>为均值、&lt;em>np(1-p)&lt;/em>为方差的正态分布为极限。&lt;/p></description></item><item><title>概率论与数理统计-概率论-随机变量的数字特征</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/</link><pubDate>Fri, 27 Nov 2020 09:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-随机变量的数字特征">概率论与数理统计-随机变量的数字特征&lt;/h1>
&lt;p>随机变量及其概率分布章节，我们讨论了&lt;strong>随机变量的分布函数&lt;/strong>，它完整反映了随机变量（在一定范围内）的概率特性。&lt;/p>
&lt;p>然而很多时候，我们不需要或者很难知道随机变量的完整特性，只需要知道它的某些重要指标。 （比如在调查一群人的身高或者某地居民的收入时，我们经常关心这些量的均值或者个体之间的差异。在碰到多个随机变量时，还需要一些指标来反映这些随机变量之间的关系。）&lt;/p>
&lt;p>与随机变量密切相关的指标统称为&lt;strong>数字特征&lt;/strong>。重要的数字特征有数学期望、方差、协方差、相关系数以及矩等.&lt;/p>
&lt;h2 id="数学期望">数学期望&lt;/h2>
&lt;h3 id="离散型随机变量的数学期望">离散型随机变量的数学期望&lt;/h3>
&lt;h4 id="离散型随机变量的数学期望的定义">离散型随机变量的数学期望的定义&lt;/h4>
&lt;p>设离散型随机变量X的概率分布律为&lt;span class="math inline">\(P\left(X=x_{k}\right)=p\left(x_{k}\right), \quad k=1,2, \cdots\)&lt;/span> 如果无穷级数&lt;span class="math inline">\(\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)&lt;/span>绝对收敛， 则称&lt;span class="math inline">\(\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)&lt;/span>为&lt;strong>（离散型）随机变量X的数学期望&lt;/strong>，简称数学期望或均值， 记作 &lt;span class="math inline">\(E(X)\)&lt;/span>，即&lt;span class="math inline">\(E(X)=\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="常见离散型随机变量的数学期望">常见离散型随机变量的数学期望&lt;/h4>
&lt;h5 id="分布的期望exp">0-1分布的期望&lt;span class="math inline">\(E(X)=p\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>设X服从参数为p的两点分布（0-1分布），即&lt;span class="math inline">\(P(X=0)=1-p, \quad P(X=1)=p, \quad 0&amp;lt;p&amp;lt;1\)&lt;/span> 则&lt;span class="math inline">\(E(X)=1 \times p+0 \times(1-p)=p\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="二项分布x-sim-bn-p的期望exn-p">二项分布&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=n p\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明（方法一）：&lt;/p>
&lt;p>因为&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>，所以&lt;span class="math inline">\(P(X=k)=C_{n}^{k} p^{k}(1-p)^{n-k}, \quad k=0,1,2, \cdots, n\)&lt;/span> 则： &lt;span class="math inline">\(\begin{aligned} E(X) &amp;amp;=\sum_{k=0}^{n} k \mathrm{C}_{n}^{k} p^{k}(1-p)^{n-k}=\sum_{k=0}^{n} \frac{k n !}{k !(n-k) !} p^{k}(1-p)^{n-k} \\ &amp;amp;=n p \sum_{k=1}^{n} \frac{(n-1) !}{(k-1) ![(n-1)-(k-1)] !} p^{k-1}(1-p)^{(n-1)-(k-1)} \\ &amp;amp;=n p \sum_{k=1}^{n} C_{n-1}^{k-1} p^{k-1}(1-p)^{(n-1)-(k-1)} \end{aligned}\)&lt;/span> 令&lt;span class="math inline">\(m=k-1\)&lt;/span>, 则： &lt;span class="math inline">\(\begin{aligned} \sum_{k=1}^{n} \mathrm{C}_{n-1}^{k-1} p^{k-1}(1-p)^{(n-1)-(k-1)} &amp;amp;=\sum_{m=0}^{n-1} \mathrm{C}_{n-1}^{m} p^{m}(1-p)^{(n-1)-m} \\ &amp;amp;=[p+(1-p)]^{n-1} \\ &amp;amp;=1 \end{aligned}\)&lt;/span> 从而&lt;span class="math inline">\(E(X)=n p\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>证明（方法二）： 若&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>，则X可以表示成n个独立的0-1型随机变量的和， 即&lt;span class="math inline">\(X=X_{1}+X_{2}+\cdots+X_{n}\)&lt;/span>，其中&lt;span class="math inline">\(X_{i}=\left\{\begin{array}{ll}1, &amp;amp; \text { 第i次试验中A发生, } \\ 0, &amp;amp; \text { 否则. }\end{array}\right.\)&lt;/span>，&lt;span class="math inline">\(i=1,2, \cdots, n\)&lt;/span> 根据后面期望的性质：&lt;a href="#$E\left(X_%7B1%7D+X_%7B2%7D+\cdots+X_%7Bn%7D\right)=E\left(X_%7B1%7D\right)+E\left(X_%7B2%7D\right)+\cdots+E\left(X_%7Bn%7D\right)$">&lt;span class="math inline">\(E\left(X_{1}+X_{2}+\cdots+X_{n}\right)=E\left(X_{1}\right)+E\left(X_{2}\right)+\cdots+E\left(X_{n}\right)\)&lt;/span>&lt;/a> 有&lt;span class="math inline">\(E(X)=E\left(\sum_{i=1}^{n} X_{i}\right)=\sum_{i=1}^{n} E\left(X_{i}\right)=n p\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="几何分布-x-sim-gp的期望exfrac1p">几何分布 &lt;span class="math inline">\(X \sim G(p)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\frac{1}{p}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>因为 &lt;span class="math inline">\(X \sim G(p),\)&lt;/span> 所以&lt;span class="math inline">\(P(X=k)=(1-p)^{k-1} p, \quad k=1,2, \cdots\)&lt;/span> 则&lt;span class="math inline">\(E(X)=\sum_{k=1}^{\infty} k(1-p)^{k-1} p=p \sum_{k=1}^{\infty} k(1-p)^{k-1}\)&lt;/span>&lt;/p>
&lt;p>根据高等数学幂级数的知识，有如下幂级数的和函数： &lt;span class="math inline">\(\sum_{k=0}^{\infty} x^{k}=\frac{1}{1-x}, \quad|x|&amp;lt;1\)&lt;/span> 根据幂级数的逐项可导性质，有： &lt;span class="math inline">\(\sum_{k=1}^{\infty} k x^{k-1}=\frac{1}{(1-x)^{2}}, \quad|x|&amp;lt;1\)&lt;/span> 取&lt;span class="math inline">\(x=1-p\)&lt;/span>,则： &lt;span class="math inline">\(\sum_{k=1}^{\infty} k(1-p)^{k-1}=\frac{1}{p^{2}}\)&lt;/span> 因此&lt;span class="math inline">\(E(X)=p \sum_{k=1}^{\infty} k(1-p)^{k-1}=\frac{1}{p}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="泊松分布xsim-plambda的期望exlambda">泊松分布&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\lambda\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>因为&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>，则&lt;span class="math inline">\(P(X=k)=\frac{\lambda^{k}}{k !} \mathrm{e}^{-\lambda}, \quad k=0,1,2, \cdots\)&lt;/span> 则&lt;span class="math inline">\(E(X)=\sum_{k=0}^{\infty} k \frac{\lambda^{k} \mathrm{e}^{-\lambda}}{k !}=\lambda \mathrm{e}^{-\lambda} \sum_{k=1}^{\infty} \frac{\lambda^{k-1}}{(k-1) !}=\lambda \mathrm{e}^{-\lambda} \mathrm{e}^{\lambda}=\lambda\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="连续型随机变量的数学期望">连续型随机变量的数学期望&lt;/h3>
&lt;h4 id="连续型随机变量数学期望的定义">连续型随机变量数学期望的定义&lt;/h4>
&lt;p>设连续型随机变量 &lt;span class="math inline">\(X\)&lt;/span> 的密度函数为 &lt;span class="math inline">\(f(x) .\)&lt;/span> 若积分 &lt;span class="math inline">\(\int_{-\infty}^{+\infty} x f(x) \mathrm{d} x\)&lt;/span> 绝对收敛,则称 &lt;span class="math inline">\(\int_{-\infty}^{+\infty} x f(x) \mathrm{d} x\)&lt;/span> 为&lt;strong>连续型随机变量 &lt;span class="math inline">\(X\)&lt;/span> 的数学期望&lt;/strong>, 简称&lt;strong>期望&lt;/strong>或&lt;strong>均值&lt;/strong>, 记作 &lt;span class="math inline">\(E(X),\)&lt;/span> 即&lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} x f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>注意：某些分布的数学期望可能不存在。（密度函数不绝对收敛）&lt;/p>
&lt;h4 id="常见连续型随机变量的数学期望">常见连续型随机变量的数学期望&lt;/h4>
&lt;h5 id="均匀分布x-sim-ua-b的期望exfracab2">均匀分布&lt;span class="math inline">\(X \sim U[a, b]\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\frac{a+b}{2}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>因为&lt;span class="math inline">\(X \sim U[a, b]\)&lt;/span>，所以X的密度函数为： &lt;span class="math inline">\(f(x)=\left\{\begin{array}{ll}\frac{1}{b-a}, &amp;amp; a \leqslant x \leqslant b \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span> 于是： &lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} x f(x) \mathrm{d} x=\int_{a}^{b} \frac{x}{b-a} \mathrm{~d} x=\frac{a+b}{2}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="指数分布x-sim-elambda的期望exfrac1lambda">指数分布&lt;span class="math inline">\(X \sim e(\lambda)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\frac{1}{\lambda}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>因为&lt;span class="math inline">\(X \sim e(\lambda)\)&lt;/span>，所以X的密度函数为&lt;span class="math inline">\(f(x)=\left\{\begin{array}{ll}\lambda \mathrm{e}^{-\lambda x}, &amp;amp; x \geqslant 0 \\ 0, &amp;amp; x&amp;lt;0\end{array}\right.\)&lt;/span> 于是&lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} x f(x) \mathrm{d} x=\int_{0}^{+\infty} x \lambda \mathrm{e}^{-\lambda x} \mathrm{~d} x=\frac{1}{\lambda}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="正态分布x-sim-nleftmu-sigma2right的期望exmu">正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\mu\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>因为&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>，所以X的密度函数为&lt;span class="math inline">\(f(x)=\frac{1}{\sqrt{2 \pi} \sigma} \mathrm{e}^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}, \quad-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span> 于是&lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} x \frac{1}{\sqrt{2 \pi} \sigma} \mathrm{e}^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}} \mathrm{~d} x\)&lt;/span> 令 &lt;span class="math inline">\(t=\frac{x-\mu}{\sigma},\)&lt;/span> 则： &lt;span class="math inline">\(\begin{aligned} E(X) &amp;amp;=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{+\infty}(\sigma t+\mu) \mathrm{e}^{-\frac{t^{2}}{2}} \mathrm{~d} t \\ &amp;amp;=\frac{\mu}{\sqrt{2 \pi}} \int_{-\infty}^{+\infty} \mathrm{e}^{-\frac{t^{2}}{2}} \mathrm{~d} t \\ &amp;amp;=\mu \end{aligned}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="随机变量函数的数学期望">随机变量函数的数学期望&lt;/h3>
&lt;h4 id="随机变量x的函数gx的期望">随机变量X的函数&lt;span class="math inline">\(g(X)\)&lt;/span>的期望&lt;/h4>
&lt;p>很多时候需要计算随机变量X的某个函数&lt;span class="math inline">\(g(X)\)&lt;/span>的期望。&lt;/p>
&lt;p>方法一：自然会想到先求&lt;span class="math inline">\(g(X)\)&lt;/span>的分布，再按期望的定义来求&lt;span class="math inline">\(E[g(X)]\)&lt;/span>.&lt;/p>
&lt;p>方法二：但是很多时候，&lt;span class="math inline">\(g(X)\)&lt;/span>的分布并不容易求出，下面的定理给出另一种方法。&lt;/p>
&lt;blockquote>
&lt;p>定理：设X为一个随机变量，&lt;span class="math inline">\(g(x)\)&lt;/span>为一元函数， 1）如果X为离散型随机变量，分布律为&lt;span class="math inline">\(P\left(X=x_{k}\right)=p\left(x_{k}\right), \quad k=1,2, \cdots\)&lt;/span>， 则&lt;span class="math inline">\(E[g(X)]=\sum_{k=1}^{\infty} g\left(x_{k}\right) p\left(x_{k}\right)\)&lt;/span> 2）如果X为连续性随机变量，密度函数为&lt;span class="math inline">\(f(x)\)&lt;/span>， 则&lt;span class="math inline">\(E[g(X)]=\int_{-\infty}^{+\infty} g(x) f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>这个定理告诉我们，由X的分布即可求出其函数&lt;span class="math inline">\(g(X)\)&lt;/span>的期望，而无需求出&lt;span class="math inline">\(g(X)\)&lt;/span>的分布。&lt;/p>
&lt;h4 id="二维随机变量xy的函数gxy的期望">二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的函数&lt;span class="math inline">\(g(X,Y)\)&lt;/span>的期望&lt;/h4>
&lt;p>类似一维的情况，有两种方法。&lt;/p>
&lt;p>方法一：自然会想到先求&lt;span class="math inline">\(g(X,Y)\)&lt;/span>的分布，再按期望的定义来求&lt;span class="math inline">\(E[g(X,Y)]\)&lt;/span>.&lt;/p>
&lt;p>方法二：但是很多时候，&lt;span class="math inline">\(g(X,Y)\)&lt;/span>的分布并不容易求出，根据下面的定理，由&lt;span class="math inline">\((X,Y)\)&lt;/span>的分布即可直接求出其函数&lt;span class="math inline">\(Z=g(X,Y)\)&lt;/span>的期望&lt;/p>
&lt;blockquote>
&lt;p>定理：设&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维随机变量，&lt;span class="math inline">\(g(x,y)\)&lt;/span>为二元函数。 1）如果&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维离散型随机变量，联合分布律为&lt;span class="math inline">\(P\left(X=x_{i}, Y=y_{j}\right)=p_{i j}, \quad i=1,2, \cdots, \quad j=1,2, \cdots\)&lt;/span>， 则&lt;span class="math inline">\(E[g(X, Y)]=\sum_{i=1}^{\infty} \sum_{j=1}^{\infty} g\left(x_{i}, y_{j}\right) p_{i j}\)&lt;/span> 2）如果&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维离散型随机变量，联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>， 则&lt;span class="math inline">\(E[g(X, Y)]=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} g(x, y) f(x, y) \mathrm{d} x \mathrm{~d} y\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>特别的，我们取&lt;span class="math inline">\(g(X,Y) = X\)&lt;/span>和&lt;span class="math inline">\(g(X,Y)=Y\)&lt;/span>。即已知&lt;span class="math inline">\((X,Y)\)&lt;/span>分布或者密度函数时可求&lt;span class="math inline">\(E(X)\)&lt;/span>和&lt;span class="math inline">\(E(Y)\)&lt;/span>.&lt;/p>
&lt;p>可以按照方法二求解：&lt;/p>
&lt;blockquote>
&lt;p>以二维连续型为例，设联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>，则： &lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} x f(x, y) \mathrm{d} x \mathrm{~d} y\)&lt;/span> &lt;span class="math inline">\(E(Y)=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} y f(x, y) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>当然也可以按照方法一求解：&lt;/p>
&lt;blockquote>
&lt;p>先求X和Y各自的边缘密度&lt;span class="math inline">\(f_X(x)\)&lt;/span>和&lt;span class="math inline">\(f_Y(y)\)&lt;/span>， 再利用&lt;span class="math inline">\(E(X)=\int_{-\infty}^{+\infty} x f_{X}(x) \mathrm{d} x\)&lt;/span>和&lt;span class="math inline">\(E(Y)=\int_{-\infty}^{+\infty} y f_{Y}(y) \mathrm{d} y\)&lt;/span>求解&lt;/p>
&lt;/blockquote>
&lt;h4 id="高维随机变量x_1x_2-cdots-x_n的函数gx_1x_2-cdots-x_n的期望">高维随机变量&lt;span class="math inline">\((X_1,X_2, \cdots, X_n)\)&lt;/span>的函数&lt;span class="math inline">\(g(X_1,X_2, \cdots, X_n)\)&lt;/span>的期望&lt;/h4>
&lt;p>类似二维的情况，有相同的两种方法。并且有类似的定理存在。&lt;/p>
&lt;h3 id="期望的性质">期望的性质&lt;/h3>
&lt;h4 id="ecc">&lt;span class="math inline">\(E(C)=C\)&lt;/span>&lt;/h4>
&lt;p>设C为常数，则&lt;span class="math inline">\(E(C)=C\)&lt;/span>&lt;/p>
&lt;h4 id="ekx-k-ex">&lt;span class="math inline">\(E(kX)= k E(X)\)&lt;/span>&lt;/h4>
&lt;p>设k为常数，X为随机变量，则&lt;span class="math inline">\(E(kX)= k E(X)\)&lt;/span>&lt;/p>
&lt;h4 id="exyexey">&lt;span class="math inline">\(E(X+Y)=E(X)+E(Y)\)&lt;/span>&lt;/h4>
&lt;p>对于随机变量X和Y，有&lt;span class="math inline">\(E(X+Y)=E(X)+E(Y)\)&lt;/span>&lt;/p>
&lt;h4 id="eleftx_1x_2cdotsx_nrighteleftx_1righteleftx_2rightcdotseleftx_nright">&lt;span class="math inline">\(E\left(X_{1}+X_{2}+\cdots+X_{n}\right)=E\left(X_{1}\right)+E\left(X_{2}\right)+\cdots+E\left(X_{n}\right)\)&lt;/span>&lt;/h4>
&lt;p>这是上一条的推论：对于n个随机变量&lt;span class="math inline">\(X_{1}+X_{2}+\cdots+X_{n}\)&lt;/span>，有&lt;span class="math inline">\(E\left(X_{1}+X_{2}+\cdots+X_{n}\right)=E\left(X_{1}\right)+E\left(X_{2}\right)+\cdots+E\left(X_{n}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="随机变量x与y独立rightarrow-ex-yex-ey">随机变量X与Y独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(E(X Y)=E(X) E(Y)\)&lt;/span>&lt;/h4>
&lt;p>设随机变量X和Y独立，则&lt;span class="math inline">\(E(X Y)=E(X) E(Y)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： 二维连续型&lt;span class="math inline">\((X,Y)\)&lt;/span>情况（离散型类似可证） 设&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>, 边缘密度函数微分别&lt;span class="math inline">\(f_X(x)\)&lt;/span>和&lt;span class="math inline">\(f_Y(y)\)&lt;/span>, 由于X和Y独立，则&lt;span class="math inline">\(f(x,y)=f_X(x)f_Y(y)\)&lt;/span>， 则： &lt;span class="math inline">\(\begin{aligned} E(X Y) &amp;amp;=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} x y f(x, y) \mathrm{d} x \mathrm{~d} y \\ &amp;amp;=\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} x y f_{X}(x) f_{Y}(y) \mathrm{d} x \mathrm{~d} y \\ &amp;amp;=\left(\int_{-\infty}^{+\infty} x f_{X}(x) \mathrm{d} x\right)\left(\int_{-\infty}^{+\infty} y f_{Y}(y) \mathrm{d} y\right) \\ &amp;amp;=E(X) E(Y) \end{aligned}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="x_1x_2-cdots-x_n相互独立rightarrow-eleftx_1-x_2-cdots-x_nrighteleftx_1right-eleftx_2right-cdots-eleftx_nright">&lt;span class="math inline">\(X_1,X_2, \cdots, X_n\)&lt;/span>相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(E\left(X_{1} X_{2} \cdots X_{n}\right)=E\left(X_{1}\right) E\left(X_{2}\right) \cdots E\left(X_{n}\right)\)&lt;/span>&lt;/h4>
&lt;p>这是上一条的推论：设n个随机变量&lt;span class="math inline">\(X_1,X_2, \cdots, X_n\)&lt;/span>相互独立，则&lt;span class="math inline">\(E\left(X_{1} X_{2} \cdots X_{n}\right)=E\left(X_{1}\right) E\left(X_{2}\right) \cdots E\left(X_{n}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="方差">方差&lt;/h2>
&lt;p>随机变量的期望反应的是随机变量的均值。除了均值之外，人们还常关心随机变量取值的波动性或者稳定性如何。 衡量波动性的一个简单办法是看随机变量每个可能取值与期望值的差距&lt;span class="math inline">\(|X-E(X)|\)&lt;/span>,很显然这是一个随机变量。 因此想到用&lt;span class="math inline">\(|X-E(X)|\)&lt;/span>的均值&lt;span class="math inline">\(E\left[|X-E(X)|\right]\)&lt;/span>来反映波动性， 但绝对值在数学上比较难处理，因此实际中使用&lt;span class="math inline">\(E\left[X-E(X)\right]^2\)&lt;/span>来&lt;strong>反映随机变量波动性的大小&lt;/strong>，也即反映随机变量稳定性如何，由此引出方差的定义。&lt;/p>
&lt;h3 id="方差的定义与常用公式">方差的定义与常用公式&lt;/h3>
&lt;h4 id="方差的定义dxeleftx-exright2">方差的定义&lt;span class="math inline">\(D(X)=E\left[X-E(X)\right]^2\)&lt;/span>&lt;/h4>
&lt;p>设X为一随机变量，若&lt;span class="math inline">\(E\left[X-E(X)\right]^2\)&lt;/span>存在，则称&lt;span class="math inline">\(E\left[X-E(X)\right]^2\)&lt;/span>为随机变量X的方差，记为&lt;span class="math inline">\(D(X)\)&lt;/span>， 即&lt;span class="math inline">\(D(X)=E\left[X-E(X)\right]^2\)&lt;/span>&lt;/p>
&lt;p>注意：随机变量X的方差&lt;span class="math inline">\(D(X)\)&lt;/span>结果是个数值。&lt;/p>
&lt;h4 id="方差的常用式dxeleftx2right-ex2">方差的常用式&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>证明 利用期望的性质，则 &lt;span class="math inline">\(\begin{aligned} D(X) &amp;amp;=E[X-E(X)]^{2}=E\left\{X^{2}-2 X E(X)+[E(X)]^{2}\right\} \\ &amp;amp;=E\left(X^{2}\right)-2[E(X)]^{2}+[E(X)]^{2} \\ &amp;amp;=E\left(X^{2}\right)-[E(X)]^{2} \end{aligned}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="离散型随机变量的方差">离散型随机变量的方差&lt;/h3>
&lt;p>设离散型随机变量X的概率分布律为&lt;span class="math inline">\(P\left(X=x_{k}\right)=p\left(x_{k}\right), \quad k=1,2, \cdots\)&lt;/span>， 则随机变量X的方差 &lt;span class="math inline">\(D(X)=E\left[X-E(X)\right]^2 \\=\sum_{i=1}^{\infty}\left[x_{i}-E(X)\right]^{2} p\left(x_{i}\right)\)&lt;/span>&lt;/p>
&lt;p>也常利用&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}\)&lt;/span>来计算某些离散型随机变量的方差。&lt;/p>
&lt;h4 id="分布的方差dxp1-p">0-1分布的方差&lt;span class="math inline">\(D(X)=p(1-p)\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>证明 设X服从参数为p的两点分布（0-1分布），&lt;a href="#0-1分布的期望$E(X)=p$">显然&lt;span class="math inline">\(E(X)=p\)&lt;/span>&lt;/a>, 又&lt;span class="math inline">\(E\left(X^{2}\right)=1^{2} \times p+0^{2} \times(1-p)=p\)&lt;/span>， 则&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}=p(1-p)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="二项分布x-sim-bn-p的方差dxn-p1-p">二项分布&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>的方差&lt;span class="math inline">\(D(X)=n p(1-p)\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>证明（要用到后面方差的性质）：&lt;/p>
&lt;p>我们知道&lt;span class="math inline">\(X=X_{1}+X_{2}+\cdots+X_{n}\)&lt;/span>， （参见&lt;a href="#二项分布$X%20\sim%20B(n,%20p)$的期望$E(X)=n%20p$">二项分布&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>期望&lt;span class="math inline">\(E(X)=n p\)&lt;/span>的证明方法二&lt;/a>） 而&lt;a href="#0-1分布的方差$D(X)=p(1-p)$">0-1分布的方差&lt;span class="math inline">\(D(X_i)=p(1-p)\)&lt;/span>&lt;/a>, 又&lt;span class="math inline">\(X_1,X_2, \cdots, X_n\)&lt;/span>相互独立， 于是根据&lt;a href="#随机变量$X_1,X_2,%20\cdots,%20X_n$相互独立$\Rightarrow$%20$D\left(X_%7B1%7D+X_%7B2%7D+\cdots+X_%7Bn%7D\right)=D\left(X_%7B1%7D\right)+D\left(X_%7B2%7D\right)+\cdots+D\left(X_%7Bn%7D\right)$">&lt;span class="math inline">\(X_1,X_2, \cdots, X_n\)&lt;/span>相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(D\left(X_{1}+X_{2}+\cdots+X_{n}\right)=D\left(X_{1}\right)+D\left(X_{2}\right)+\cdots+D\left(X_{n}\right)\)&lt;/span>&lt;/a> 得&lt;span class="math inline">\(D(X)=D\left(\sum_{i=1}^{n} X_{i}\right)=\sum_{i=1}^{n} D\left(X_{i}\right)=n p(1-p)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="泊松分布xsim-plambda的方差dxlambda">泊松分布&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>的方差&lt;span class="math inline">\(D(X)=\lambda\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>我们知道&lt;a href="#泊松分布$X\sim%20P(\lambda)$的期望$E(X)=\lambda$">泊松分布&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>的期望&lt;span class="math inline">\(E(X)=\lambda\)&lt;/span>&lt;/a> 而： &lt;span class="math inline">\(\begin{aligned} E\left(X^{2}\right) &amp;amp;=\sum_{k=0}^{\infty} k^{2} \frac{\lambda^{k}}{k !} \mathrm{e}^{-\lambda}=\sum_{k=1}^{\infty} k \frac{\lambda^{k}}{(k-1) !} \mathrm{e}^{-\lambda} \\ &amp;amp;=\sum_{k=1}^{\infty}[(k-1)+1] \frac{\lambda^{k}}{(k-1) !} \mathrm{e}^{-\lambda} \\ &amp;amp;=\sum_{k=2}^{\infty} \frac{\lambda^{k}}{(k-2) !} \mathrm{e}^{-\lambda}+\sum_{k=1}^{\infty} \frac{\lambda^{k}}{(k-1) !} \mathrm{e}^{-\lambda} \end{aligned}\)&lt;/span> 又有&lt;span class="math inline">\(\sum_{k=1}^{\infty} \frac{\lambda^{k}}{(k-1) !} \mathrm{e}^{-\lambda}=\lambda \cdot\sum_{k=1}^{\infty} \frac{\lambda^{k-1}}{(k-1) !} \mathrm{e}^{-\lambda}=\lambda\)&lt;/span> 以及&lt;span class="math inline">\(\sum_{k=2}^{\infty} \frac{\lambda^{k}}{(k-2) !} \mathrm{e}^{-\lambda}=\lambda^{2} \mathrm{e}^{-\lambda} \sum_{k=2}^{\infty} \frac{\lambda^{k-2}}{(k-2) !}=\lambda^{2} \mathrm{e}^{-\lambda} \mathrm{e}^{\lambda}=\lambda^{2}\)&lt;/span> 所以&lt;span class="math inline">\(E\left(X^{2}\right)=\lambda^{2}+\lambda\)&lt;/span> 则&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}=\lambda\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="连续型随机变量的方差">连续型随机变量的方差&lt;/h3>
&lt;p>设连续型随机变量 &lt;span class="math inline">\(X\)&lt;/span> 的密度函数为 &lt;span class="math inline">\(f(x) .\)&lt;/span> 则随机变量X的方差 &lt;span class="math inline">\(D(X)=\int_{-\infty}^{+\infty}[x-E(X)]^{2} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h4 id="均匀分布x-sim-ua-b的方差dxfracb-a212">均匀分布&lt;span class="math inline">\(X \sim U[a, b]\)&lt;/span>的方差&lt;span class="math inline">\(D(X)=\frac{(b-a)^{2}}{12}\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(X \sim U[a, b]\)&lt;/span>， 前面已求出&lt;span class="math inline">\(E(X)=\frac{a+b}{2}\)&lt;/span>， 而&lt;span class="math inline">\(E\left(X^{2}\right)=\int_{a}^{b} \frac{x^{2}}{b-a} \mathrm{~d} x=\frac{a^{2}+a b+b^{2}}{3}\)&lt;/span> 从而&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}=\frac{(b-a)^{2}}{12}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="指数分布x-sim-elambda的方差dxfrac1lambda2">指数分布&lt;span class="math inline">\(X \sim e(\lambda)\)&lt;/span>的方差&lt;span class="math inline">\(D(X)=\frac{1}{\lambda^{2}}\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>因为&lt;span class="math inline">\(X \sim e(\lambda)\)&lt;/span>， 前面已经求得&lt;span class="math inline">\(E(X)=\frac{1}{\lambda}\)&lt;/span>， 而随机变量函数&lt;span class="math inline">\(X^2\)&lt;/span>的期望&lt;span class="math inline">\(E\left(X^{2}\right)=\int_{0}^{+\infty} x^{2} \lambda \mathrm{e}^{-\lambda x} \mathrm{~d} x=\frac{2}{\lambda^{2}}\)&lt;/span> 从而&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}=\frac{1}{\lambda^{2}}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="正态分布x-sim-nleftmu-sigma2right的方差dxsigma2">正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>的方差&lt;span class="math inline">\(D(X)=\sigma^{2}\)&lt;/span>&lt;/h4>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>， 前面已求出&lt;span class="math inline">\(E(X)=\mu\)&lt;/span>， 而&lt;span class="math inline">\(E\left(X^{2}\right)=\int_{-\infty}^{+\infty} x^{2} \frac{1}{\sqrt{2 \pi} \sigma} \mathrm{e}^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}} \mathrm{~d} x\)&lt;/span>， 令&lt;span class="math inline">\(t=\frac{x-\mu}{\sigma}\)&lt;/span>，利用分部积分法容易求得&lt;span class="math inline">\(E\left(X^{2}\right)=\sigma^{2}+\mu^{2}\)&lt;/span>，&lt;/p>
&lt;p>从而&lt;span class="math inline">\(D(X)=E\left(X^{2}\right)-[E(X)]^{2}=\sigma^{2}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="方差的性质">方差的性质&lt;/h3>
&lt;p>方差就具有如下一些重要性质（设所涉及的随机变量的方差均存在）&lt;/p>
&lt;h4 id="dc0">&lt;span class="math inline">\(D(C)=0\)&lt;/span>&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(C\)&lt;/span> 为一常数, &lt;span class="math inline">\(X\)&lt;/span> 为一随机变量, 则&lt;span class="math inline">\(D(C)=0\)&lt;/span>&lt;/p>
&lt;h4 id="dk-xk2-dx">&lt;span class="math inline">\(D(k X)=k^{2} D(X)\)&lt;/span>&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(k\)&lt;/span> 为一常数, &lt;span class="math inline">\(X\)&lt;/span> 为一随机变量, 则&lt;span class="math inline">\(D(k X)=k^{2} D(X)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(D(k X)=E\left(k^{2} X^{2}\right)-[E(k X)]^{2}\\=k^{2} E\left(X^{2}\right)-k^{2}[E(X)]^{2}\\=k^{2} D(X)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="随机变量x与y相互独立rightarrow-dxydxdy">随机变量X与Y相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(D(X+Y)=D(X)+D(Y)\)&lt;/span>&lt;/h4>
&lt;p>对随机变量 &lt;span class="math inline">\(X\)&lt;/span> 和 &lt;span class="math inline">\(Y\)&lt;/span> 相互独立, 则&lt;span class="math inline">\(D(X+Y)=D(X)+D(Y)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(\begin{aligned} D(X+Y) &amp;amp;=E(X+Y)^{2}-[E(X+Y)]^{2} \\ &amp;amp;=E\left(X^{2}+2 X Y+Y^{2}\right)-\left\{[E(X)]^{2}+2 E(X) E(Y)+[E(Y)]^{2}\right\} \\ &amp;amp;=E\left(X^{2}\right)-[E(X)]^{2}+E\left(Y^{2}\right)-[E(Y)]^{2}+2[E(X Y)-E(X) E(Y)] \\ &amp;amp;=D(X)+D(Y)+2[E(X Y)-E(X) E(Y)] \end{aligned}\)&lt;/span> X与Y相互独立，由&lt;a href="#随机变量X与Y独立$\Rightarrow$%20$E(X%20Y)=E(X)%20E(Y)$">随机变量X与Y独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(E(X Y)=E(X) E(Y)\)&lt;/span>&lt;/a>可知 &lt;span class="math inline">\(E(X Y)-E(X) E(Y)=0\)&lt;/span>， 从而&lt;span class="math inline">\(D(X+Y)=D(X)+D(Y)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="随机变量x_1x_2-cdots-x_n相互独立rightarrow-dleftx_1x_2cdotsx_nrightdleftx_1rightdleftx_2rightcdotsdleftx_nright">随机变量&lt;span class="math inline">\(X_1,X_2, \cdots, X_n\)&lt;/span>相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(D\left(X_{1}+X_{2}+\cdots+X_{n}\right)=D\left(X_{1}\right)+D\left(X_{2}\right)+\cdots+D\left(X_{n}\right)\)&lt;/span>&lt;/h4>
&lt;p>这是上一条的推论。&lt;/p>
&lt;h2 id="常见随机变量分布的期望与方差汇总">常见随机变量分布的期望与方差汇总&lt;/h2>
&lt;h3 id="常见离散型随机变量的分布">常见离散型随机变量的分布&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>离散型随机变量的分布&lt;/th>
&lt;th>期望&lt;/th>
&lt;th>方差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>0-1分布&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=p\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=p(1-p)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>二项分布&lt;span class="math inline">\(X \sim B(n, p)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=n p\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=n p(1-p)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>泊松分布&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=\lambda\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=\lambda\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>几何分布 &lt;span class="math inline">\(X \sim G(p)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=\frac{1}{p}\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="常见连续型随机变量的分布">常见连续型随机变量的分布&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>连续型随机变量的分布&lt;/th>
&lt;th>期望&lt;/th>
&lt;th>方差&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>均匀分布&lt;span class="math inline">\(X \sim U[a, b]\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=\frac{a+b}{2}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=\frac{(b-a)^{2}}{12}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>指数分布&lt;span class="math inline">\(X \sim e(\lambda)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=\frac{1}{\lambda}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=\frac{1}{\lambda^{2}}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>正态分布&lt;span class="math inline">\(X \sim N\left(\mu, \sigma^{2}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(E(X)=\mu\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(D(X)=\sigma^{2}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="协方差与相关系数">协方差与相关系数&lt;/h2>
&lt;p>期望反映了一个随机变量的平均取值， 方差反映了一个随机变量的波动大小。&lt;/p>
&lt;p>有时还需要描述两个随机变量之间的相互关系，这就需要引入协方差和相关系数的概念。&lt;/p>
&lt;h3 id="协方差的定义">协方差的定义&lt;/h3>
&lt;p>设随机交量 &lt;span class="math inline">\(X\)&lt;/span> 和 &lt;span class="math inline">\(Y\)&lt;/span> 的期望都存在, 且 &lt;span class="math inline">\(E(X Y)\)&lt;/span> 也存在, 我们称&lt;span class="math inline">\(E[(X-E(X))(Y-E(Y)]]\)&lt;/span> 为 &lt;span class="math inline">\(X\)&lt;/span> 和 &lt;span class="math inline">\(Y\)&lt;/span> 的&lt;strong>协方差&lt;/strong>, 记为 &lt;span class="math inline">\(\operatorname{Cov}(X, Y),\)&lt;/span> 即&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=E[(X-E(X))(Y-E(Y))]\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>分析一下协方差的意义： 如果协方差为正，说明&lt;span class="math inline">\(X-E(X)\)&lt;/span>和&lt;span class="math inline">\(Y-E(Y)\)&lt;/span>倾向于同时为正或者同时为负，即X大于均值E(X)时，Y往往大于均值E(Y)，X与Y变化趋势比较一致。 如果协方差为负，说明&lt;span class="math inline">\(X-E(X)\)&lt;/span>和&lt;span class="math inline">\(Y-E(Y)\)&lt;/span>倾向于有相反的变化趋势。 因此，&lt;strong>协方差一定程度上反映了两个随机变量之间的联系&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>除了上面协方差的定义式，协方差的计算也常用公式&lt;a href="#$\operatorname%7BCov%7D(X,%20Y)=E(X%20Y)-E(X)%20E(Y)$">&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)\)&lt;/span>&lt;/a>&lt;/p>
&lt;h3 id="协方差的性质">协方差的性质&lt;/h3>
&lt;p>协方差有如下性质&lt;/p>
&lt;h4 id="operatornamecovx-yoperatornamecovy-x">&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=\operatorname{Cov}(Y, X)\)&lt;/span>&lt;/h4>
&lt;h4 id="operatornamecovx-c0">&lt;span class="math inline">\(\operatorname{Cov}(X, C)=0\)&lt;/span>&lt;/h4>
&lt;p>设C为常数，X为随机变量，则&lt;span class="math inline">\(\operatorname{Cov}(X, C)=0\)&lt;/span>&lt;/p>
&lt;h4 id="operatornamecova-xb-y-za-operatornamecovx-zb-operatornamecovy-z">&lt;span class="math inline">\(\operatorname{Cov}(a X+b Y, Z)=a \operatorname{Cov}(X, Z)+b \operatorname{Cov}(Y, Z)\)&lt;/span>&lt;/h4>
&lt;p>设a,b为常数，X,Y,Z为随机变量，则&lt;span class="math inline">\(\operatorname{Cov}(a X+b Y, Z)=a \operatorname{Cov}(X, Z)+b \operatorname{Cov}(Y, Z)\)&lt;/span>&lt;/p>
&lt;h4 id="operatornamecovx-yex-y-ex-ey">&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)\)&lt;/span>&lt;/h4>
&lt;p>此公式由定义式变形而来。这条公式也时计算协方差时的常用公式&lt;/p>
&lt;h4 id="随机变量x与y相互独立rightarrow-operatornamecovx-y0">随机变量X与Y相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(\operatorname{Cov}(X, Y)=0\)&lt;/span>&lt;/h4>
&lt;p>这算是上一条的推论： X与Y相互独立，则&lt;span class="math inline">\(E(X Y)=E(X) E(Y)\)&lt;/span>, 根据上一条性质&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)\)&lt;/span> 可知&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=0\)&lt;/span>&lt;/p>
&lt;h4 id="dxydxdy2-operatornamecovx-y">&lt;span class="math inline">\(D(X+Y)=D(X)+D(Y)+2 \operatorname{Cov}(X, Y)\)&lt;/span>&lt;/h4>
&lt;h3 id="相关系数的定义">相关系数的定义&lt;/h3>
&lt;p>从协方差的定义可以看出，协方差&lt;span class="math inline">\(\operatorname{Cov}(X, Y)\)&lt;/span>是有量纲的量，它的量纲等于X与Y的乘积。 如果X及Y的量纲改变，那么其数值就会改变，进而协方差&lt;span class="math inline">\(\operatorname{Cov}(X, Y)\)&lt;/span>的数值也会发生较大的变化。 这样用协方差&lt;span class="math inline">\(\operatorname{Cov}(X, Y)\)&lt;/span>来刻画X与Y的关系就不方便了。为了客服这个困难，引进随机变量之间的相关系数的概念。&lt;/p>
&lt;p>&lt;strong>定义&lt;/strong>：设随机变量X，Y的方差&lt;span class="math inline">\(D(X)\)&lt;/span>与&lt;span class="math inline">\(D(Y)\)&lt;/span>均为正， 称&lt;span class="math inline">\(\frac{\operatorname{Cov}(X, Y)}{\sqrt{D(X) D(Y)}}\)&lt;/span>为X与Y的&lt;strong>相关系数&lt;/strong>，记为&lt;span class="math inline">\(\rho_{XY}\)&lt;/span>, 即&lt;span class="math inline">\(\rho_{X Y}=\frac{\operatorname{Cov}(X, Y)}{\sqrt{D(X) D(Y)}}\)&lt;/span>&lt;/p>
&lt;p>不难验证，X和Y的相关系数是X和Y标准化[^1]后的随机变量的协方差： &lt;span class="math inline">\(\rho_{X Y}=\operatorname{Cov}\left(\frac{X-E(X)}{\sqrt{D(X)}}, \frac{Y-E(Y)}{\sqrt{D(Y)}}\right)\)&lt;/span>&lt;/p>
&lt;p>[^ 1]: 注意区分&lt;a href="https://zhuanlan.zhihu.com/p/93350539">一般的无量纲化&lt;/a>操作，以及&lt;a href="https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E5%8C%96%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F">随机变量的标准化&lt;/a>&lt;/p>
&lt;h3 id="相关系数的性质">相关系数的性质&lt;/h3>
&lt;h4 id="leftrho_x-yright-leqslant-1">&lt;span class="math inline">\(\left|\rho_{X Y}\right| \leqslant 1\)&lt;/span>&lt;/h4>
&lt;p>设&lt;span class="math inline">\(\rho_{X Y}\)&lt;/span>是随机变量X与Y的相关系数，则&lt;span class="math inline">\(\left|\rho_{X Y}\right| \leqslant 1\)&lt;/span>&lt;/p>
&lt;h4 id="leftrho_x-yright-1-leftrightarrow-yaxb-a-neq-0">&lt;span class="math inline">\(\left|\rho_{X Y}\right| = 1 \Leftrightarrow Y=aX+b (a \neq 0)\)&lt;/span>&lt;/h4>
&lt;p>设&lt;span class="math inline">\(\rho_{X Y}\)&lt;/span>是随机变量X与Y的相关系数，&lt;span class="math inline">\(\left|\rho_{X Y}\right| = 1\)&lt;/span>的充分必要条件是&lt;span class="math inline">\(P(Y=aX+b)=1, (a \neq 0)\)&lt;/span>, 且&lt;span class="math inline">\(\rho_{X Y}=\left\{\begin{array}{ll}1, &amp;amp; a&amp;gt;0 \\ -1, &amp;amp; a&amp;lt;0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>从上面两条性质可以看出，相关系数刻画了随机变量之间的线性相关性； 当&lt;span class="math inline">\(\rho_{X Y}\)&lt;/span>越接近1时，X与Y的正线性相关性越明显；当&lt;span class="math inline">\(\rho_{X Y}\)&lt;/span>越接近-1时，X与Y的负线性相关性就越明显； 当&lt;span class="math inline">\(\rho_{X Y}\)&lt;/span>越接近0时，X与Y的线性相关性就越弱，当&lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>我们也称X与Y不相关。&lt;/p>
&lt;h4 id="随机变量x与y相互独立rightarrow-rho_x-y0">随机变量X与Y相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>&lt;/h4>
&lt;p>我们知道&lt;a href="#随机变量X与Y相互独立$\Rightarrow$%20$\operatorname%7BCov%7D(X,%20Y)=0$">随机变量X与Y相互独立&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(\operatorname{Cov}(X, Y)=0\)&lt;/span>&lt;/a>， 从而&lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>&lt;/p>
&lt;p>注意：&lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>，并不能得到X与Y独立的结论。&lt;/p>
&lt;h3 id="常见二维随机变量的相关系数">常见二维随机变量的相关系数&lt;/h3>
&lt;h4 id="xy服从圆盘均匀分布时的相关系数rho_x-y0">&lt;span class="math inline">\((X,Y)\)&lt;/span>服从圆盘均匀分布时的相关系数&lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>&lt;/h4>
&lt;p>二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>服从圆盘&lt;span class="math inline">\(x^{2}+y^{2} \leqslant 1\)&lt;/span>均匀分布时， 联合密度函数为&lt;span class="math inline">\(f(x, y)=\left\{\begin{array}{ll}\frac{1}{\pi}, &amp;amp; x^{2}+y^{2} \leqslant 1 \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span>， 则： &lt;span class="math inline">\(E(X Y)=\iint_{x^{2}+y^{2} \leqslant 1} \frac{x y}{\pi} \mathrm{d} x \mathrm{~d} y=\frac{1}{\pi} \int_{-1}^{1} \mathrm{~d} x \int_{-\sqrt{1-x^{2}}}^{\sqrt{1-x^{2}}} x y \mathrm{~d} y=0\)&lt;/span> &lt;span class="math inline">\(E(X)=\iint_{x^{2}+y^{2} \leqslant 1} \frac{x}{\pi} \mathrm{d} x \mathrm{~d} y=\frac{1}{\pi} \int_{-1}^{1} \mathrm{~d} x \int_{-\sqrt{1-x^{2}}}^{\sqrt{1-x^{2}}} x \mathrm{~d} y=0\)&lt;/span> 同理可得&lt;span class="math inline">\(E(Y)=0\)&lt;/span> 于是&lt;span class="math inline">\(\operatorname{Cov}(X, Y)=E(X Y)-E(X) E(Y)=0\)&lt;/span> 从而&lt;span class="math inline">\(\rho_{X Y}=0\)&lt;/span>&lt;/p>
&lt;h4 id="二维正态分布x-y-sim-nleftmu_1-mu_2-sigma_12-sigma_22-rhoright时的相关系数rho_x-yrho">二维正态分布&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>时的相关系数&lt;span class="math inline">\(\rho_{X Y}=\rho\)&lt;/span>&lt;/h4>
&lt;p>&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right),\)&lt;/span> 上一章&lt;a href="./概率论与数理统计-随机变量及其概率分布#二维连续型随机变量的正态分布">二维连续型随机变量的正态分布&lt;/a>有结论：若&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>，则&lt;span class="math inline">\(X \sim N\left(\mu_{1}, \sigma_{1}^{2}\right), Y \sim N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>。 上一章&lt;a href="./概率论与数理统计-随机变量及其概率分布#连续型二维随机变量$(X,Y)$，求随机函数$Z=X+Y$的分布">求随机函数&lt;span class="math inline">\(Z=X+Y\)&lt;/span>的分布&lt;/a>还有结论：若&lt;span class="math inline">\(X \sim N\left(\mu_{1}, \sigma_{1}^{2}\right), Y \sim N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>，且X与Y独立，则&lt;span class="math inline">\(X+Y \sim N\left(\mu_{1}+\mu_{2}, \sigma_{1}^{2}+\sigma_{2}^{2}\right)\)&lt;/span>。 由这两条结论以及一维正态分布的期望和方差，立即可知： &lt;span class="math inline">\(E(X)=\mu_{1}, E(Y)=\mu_{2}, D(X)=\sigma_{1}^{2}, D(Y)=\sigma_{2}^{2}\)&lt;/span> 于是协方差为： &lt;span class="math inline">\(\begin{aligned} \operatorname{Cov}(X, Y) &amp;amp;=\frac{\sigma_{1} \sigma_{2}}{2 \pi \sqrt{1-\rho^{2}}} \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} u_{1} u_{2} \mathrm{e}^{-\frac{u_{1}^{2}-2 \rho u_{1} u_{2}+u_{2}^{2}}{2\left(1-\rho^{2}\right)}} \mathrm{d} u_{1} \mathrm{~d} u_{2} \\ &amp;amp;=\frac{\sigma_{1} \sigma_{2}}{2 \pi \sqrt{1-\rho^{2}}} \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} u_{1} u_{2} \mathrm{e}^{-\frac{1}{2}\left[\frac{\left(u_{1}-\rho u_{2}\right)^{2}}{1-\rho^{2}}+u_{2}^{2}\right]} \mathrm{d} u_{1} \mathrm{~d} u_{2} \end{aligned}\)&lt;/span> 再作变量代换&lt;span class="math inline">\(t_{1}=\frac{u_{1}-\rho u_{2}}{\sqrt{1-\rho^{2}}}, t_{2}=u_{2}\)&lt;/span>，则： &lt;span class="math inline">\(\begin{aligned} \operatorname{Cov}(X, Y) &amp;amp;=\frac{\sigma_{1} \sigma_{2} \rho}{2 \pi} \int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} t_{2}^{2} \mathrm{e}^{-\frac{1}{2}\left(t_{1}^{2}+t_{2}^{2}\right)} \mathrm{d} t_{1} \mathrm{~d} t_{2} \\ &amp;amp;=\sigma_{1} \sigma_{2} \rho \end{aligned}\)&lt;/span> 从而&lt;span class="math inline">\(\rho_{X Y}=\rho\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>上面得到了结论：二维正态分布&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>，相关系数&lt;span class="math inline">\(\rho_{X Y}=\rho\)&lt;/span> 而上一章有结论：&lt;a href="./概率论与数理统计-随机变量及其概率分布#二维正态分布$(X,%20Y)%20\sim%20N\left(\mu_%7B1%7D,%20\mu_%7B2%7D,%20\sigma_%7B1%7D%5E%7B2%7D,%20\sigma_%7B2%7D%5E%7B2%7D,%20\rho\right)$中X与Y独立$\Leftrightarrow$%20$\rho%20=%200$">二维正态分布&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>中X与Y独立&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\rho = 0\)&lt;/span>&lt;/a>， 结合可得结论二维正态分布&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>中X与Y独立&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 相关系数&lt;span class="math inline">\(\rho_{XY} = 0\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h2 id="矩与协方差矩阵">矩与协方差矩阵&lt;/h2>
&lt;h3 id="随机变量x的k阶原点矩">随机变量X的k阶原点矩&lt;/h3>
&lt;p>设X是随机变量，若&lt;span class="math inline">\(\mu_{k}=E\left(X^{k}\right), \quad k=1,2, \cdots\)&lt;/span>存在，则称它为X的k阶原点矩。&lt;/p>
&lt;h3 id="随机变量x的k阶中心矩">随机变量X的k阶中心矩&lt;/h3>
&lt;p>设X是随机变量，若&lt;span class="math inline">\(\nu_{k}=E\left[(X-E(X))^{k}\right], \quad k=1,2,3, \cdots\)&lt;/span>存在，则称它为X的k阶中心矩。&lt;/p>
&lt;p>X的二阶中心矩即为X的方差&lt;span class="math inline">\(D(X)\)&lt;/span>&lt;/p>
&lt;h3 id="随机变量x与y的kl阶混合原点矩">随机变量X与Y的&lt;span class="math inline">\(k+l\)&lt;/span>阶混合原点矩&lt;/h3>
&lt;p>设X和Y是随机变量，若&lt;span class="math inline">\(E\left(X^{k} Y^{l}\right), \quad k, l=1,2, \cdots\)&lt;/span>存在，则称它为X与Y的&lt;span class="math inline">\(k+l\)&lt;/span>阶混合原点矩。&lt;/p>
&lt;h3 id="随机变量x与y的kl阶混合中心矩">随机变量X与Y的&lt;span class="math inline">\(k+l\)&lt;/span>阶混合中心矩&lt;/h3>
&lt;p>设X和Y是随机变量，若&lt;span class="math inline">\(E\left[(X-E(X))^{k}(Y-E(Y))^{l}\right], \quad k, l=1,2, \cdots\)&lt;/span>存在，则称它为X与Y的&lt;span class="math inline">\(k+l\)&lt;/span>阶混合中心矩。&lt;/p>
&lt;p>X和Y的协方差&lt;span class="math inline">\(\operatorname{Cov}(X, Y)\)&lt;/span>就是X和Y的二阶混合中心矩。&lt;/p>
&lt;h3 id="协方差矩阵">协方差矩阵&lt;/h3>
&lt;p>设n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的二阶混合中心矩（两两的协方差）： &lt;span class="math inline">\(c_{i j}=\operatorname{Cov}\left(X_{i}, X_{j}\right)=E\left[\left(X_{i}-E\left(X_{i}\right)\right)\left(X_{j}-E\left(X_{j}\right)\right)\right], \quad i, j=1,2, \cdots,n\)&lt;/span> 都存在， 则称矩阵&lt;span class="math inline">\(\boldsymbol{C}=\left(\begin{array}{cccc}c_{11} &amp;amp; c_{12} &amp;amp; \cdots &amp;amp; c_{1 n} \\ c_{21} &amp;amp; c_{22} &amp;amp; \cdots &amp;amp; c_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ c_{n 1} &amp;amp; c_{n 2} &amp;amp; \cdots &amp;amp; c_{n n}\end{array}\right)\)&lt;/span> 为n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的协方差矩阵&lt;/p>
&lt;h3 id="期望向量">期望向量&lt;/h3>
&lt;p>设n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的每一个分量&lt;span class="math inline">\(X_{i}(i=1,2, \cdots,n)\)&lt;/span>的期望&lt;span class="math inline">\(E(X_i)\)&lt;/span>都存在， 则称向量&lt;span class="math inline">\(\mu=\left(\begin{array}{c}\mu_{1} \\ \mu_{2} \\ \vdots \\ \mu_{n}\end{array}\right)=\left(\begin{array}{c}E\left(X_{1}\right) \\ E\left(X_{2}\right) \\ \vdots \\ E\left(X_{n}\right)\end{array}\right)\)&lt;/span> 为n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的期望向量。&lt;/p>
&lt;h3 id="协方差矩阵的应用n维正态分布">协方差矩阵的应用：n维正态分布&lt;/h3>
&lt;h4 id="二维正态分布的矩阵表示法">二维正态分布的矩阵表示法&lt;/h4>
&lt;p>先回忆&lt;a href="./概率论与数理统计-随机变量及其概率分布#二维连续型随机变量的正态分布">二维正态分布&lt;/a>：其联合密度函数为： &lt;span class="math inline">\(\begin{aligned} f(x, y)=&amp;amp; \frac{1}{2 \pi \sigma_{1} \sigma_{2} \sqrt{1-\rho^{2}}} \\ &amp;amp; \times \exp \left\{-\frac{1}{2\left(1-\rho^{2}\right)}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}-2 \rho \frac{\left(x-\mu_{1}\right)\left(y-\mu_{2}\right)}{\sigma_{1} \sigma_{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}\right]\right\} \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>我们想把指数部分写成矩阵形式， 首先我们记&lt;span class="math inline">\(\boldsymbol{x}=\left(\begin{array}{l}x_{1} \\ x_{2}\end{array}\right)\)&lt;/span> 有了&lt;a href="#期望向量">期望向量&lt;/a>和&lt;a href="#协方差矩阵">协方差矩阵&lt;/a>的概念， 我们可得&lt;span class="math inline">\((X_1,Y)\)&lt;/span>的期望向量与协方差： &lt;span class="math inline">\(\boldsymbol{\mu}=\left(\begin{array}{l}\mu_{1} \\ \mu_{2}\end{array}\right)\)&lt;/span>， &lt;span class="math inline">\(\boldsymbol{C}=\left(\begin{array}{ll}c_{11} &amp;amp; c_{12} \\ c_{21} &amp;amp; c_{22}\end{array}\right)=\left(\begin{array}{cc}\sigma_{1}^{2} &amp;amp; \rho \sigma_{1} \sigma_{2} \\ \rho \sigma_{1} \sigma_{2} &amp;amp; \sigma_{2}^{2}\end{array}\right)\)&lt;/span> 而C的行列式，逆矩阵分别为： &lt;span class="math inline">\(|\boldsymbol{C}|=\sigma_{1}^{2} \sigma_{2}^{2}\left(1-\rho^{2}\right)\)&lt;/span>， &lt;span class="math inline">\(C^{-1}=\frac{1}{\sigma_{1}^{2} \sigma_{2}^{2}\left(1-\rho^{2}\right)}\left(\begin{array}{cc}\sigma_{2}^{2} &amp;amp; -\rho \sigma_{1} \sigma_{2} \\ -\rho \sigma_{1} \sigma_{2} &amp;amp; \sigma_{1}^{2}\end{array}\right)\)&lt;/span> 通过简单计算可知&lt;span class="math inline">\((X_1,Y)\)&lt;/span>的联合密度可写成 &lt;span class="math inline">\(f\left(x_{1}, x_{2}\right)=(2 \pi)^{-\frac{2}{2}}|C|^{-\frac{1}{2}} \exp \left\{-\frac{1}{2}(x-\mu)^{\mathrm{T}} C^{-1}(x-\mu)\right\}\)&lt;/span>&lt;/p>
&lt;h4 id="n维正态分布的矩阵表示法">n维正态分布的矩阵表示法&lt;/h4>
&lt;p>沿用上述形式，可以给出n维正态分布的定义：&lt;/p>
&lt;p>若有n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的联合密度函数维： &lt;span class="math inline">\(f\left(x_{1}, x_{2}, \cdots, x_{n}\right)=(2 \pi)^{-\frac{n}{2}}|C|^{-\frac{1}{2}} \exp \left\{-\frac{1}{2}(x-\mu)^{\mathrm{T}} C^{-1}(x-\mu)\right\}\)&lt;/span> 其中&lt;span class="math inline">\(\boldsymbol{x}=\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right)\)&lt;/span>，&lt;span class="math inline">\(\mu\)&lt;/span> 及 &lt;span class="math inline">\(C\)&lt;/span> 分别表示 &lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span> 的期望向量及协方差矩阵， 则称n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>服从&lt;strong>n维正态分布&lt;/strong>。&lt;/p>
&lt;p>服从n维正态分布的随机变量也称n维正态随机变量。&lt;/p>
&lt;h4 id="n维正态分布的性质">n维正态分布的性质&lt;/h4>
&lt;ol type="1">
&lt;li>n维正态随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的每个分量&lt;span class="math inline">\(X_{i}(i=1,2, \cdots,n)\)&lt;/span>都服从一维正态分布。&lt;/li>
&lt;li>n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>服从n维正态分布&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>的任意线性组合&lt;span class="math inline">\(\sum_{i=1}^{n} l_{i} X_{i}\)&lt;/span>服从一维正态分布（其中 &lt;span class="math inline">\(l_{1}, l_{2}, \cdots, l_{n}\)&lt;/span> 不全为零 ）&lt;/li>
&lt;li>若n维随机变量&lt;span class="math inline">\(\left(X_{1}, X_{2}, \cdots, X_{n}\right)\)&lt;/span>服从n维正态分布，则“&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>相互独立”等价于“&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>两两不相关”&lt;/li>
&lt;/ol>
&lt;h2 id="随机变量的特征函数">随机变量的特征函数&lt;/h2>
&lt;p>参考：https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0_(%E6%A6%82%E7%8E%87%E8%AE%BA) 参考：https://www.zhihu.com/question/23686709/answer/376439033&lt;/p>
&lt;p>随机变量的分布函数和特征函数一体两面。特征函数是随机变量的分布的不同表示形式。&lt;/p>
&lt;p>随机变量的特征函数是对其分布函数做傅里叶变换得到的函数，是用傅里叶变换的方法，从频域（概率论中对应的是矩）的角度分析（随机变量的概率）函数。（从这个角度讲，特征函数应该放到概率分布章节，但是这里要用到矩的知识，所以放到了这一章。&lt;/p>
&lt;h3 id="特征函数的定义">特征函数的定义&lt;/h3>
&lt;p>在概率论中, 任何随机变量的特征函数 (缩写：ch.f, 复数形式: ch.f’s) 完全定义了它的概率分布。在实直线上, 它由以下公式给出, 其中 &lt;span class="math inline">\(X\)&lt;/span> 是任何具有该分布的随机变 量: &lt;span class="math display">\[
\varphi_{X}(t)=\mathrm{E}\left(e^{i t X}\right)
\]&lt;/span> 其中t是一个实数, i是虚数单位, E表示期望值。&lt;/p>
&lt;p>如果&lt;span class="math inline">\(F_X\)&lt;/span>是&lt;a href="https://zh.wikipedia.org/wiki/累积分布函数">累积分布函数&lt;/a>，那么特征函数由&lt;a href="https://zh.wikipedia.org/w/index.php?title=黎曼-斯蒂尔切斯积分&amp;amp;action=edit&amp;amp;redlink=1">黎曼-斯蒂尔切斯积分&lt;/a>给出： &lt;span class="math display">\[
\mathrm{E}\left(e^{i t X}\right)=\int_{-\infty}^{\infty} e^{i t x} d F_{X}(x)
\]&lt;/span> 在概率密度函数 &lt;span class="math inline">\(f_{X}\)&lt;/span> 存在的情况下 &lt;span class="math inline">\(,\)&lt;/span> 该公式就变为 &lt;span class="math display">\[
\mathrm{E}\left(e^{i t X}\right)=\int_{-\infty}^{\infty} e^{i t x} f_{X}(x) d x
\]&lt;/span> 如果&lt;em>X&lt;/em>是一个&lt;a href="https://zh.wikipedia.org/wiki/向量空间">向量&lt;/a>值随机变量，我们便取自变量&lt;em>t&lt;/em>为向量，&lt;em>tX&lt;/em>为&lt;a href="https://zh.wikipedia.org/wiki/数量积">数量积&lt;/a>。&lt;/p>
&lt;h3 id="特征函数的意义">特征函数的意义&lt;/h3>
&lt;p>随机变量&lt;span class="math inline">\(X\)&lt;/span>的特征函数定义为：&lt;span class="math inline">\(\varphi_{X}(t)=\mathrm{E}\left(e^{i t X}\right)\)&lt;/span>&lt;/p>
&lt;p>为什么这么定义呢？&lt;/p>
&lt;h4 id="从随机变量的数字特征来看">从随机变量的数字特征来看&lt;/h4>
&lt;p>首先，&lt;span class="math inline">\(e^{i t X}\)&lt;/span>的泰勒展开为：&lt;span class="math inline">\(e^{i t X}=1+\frac{i t X}{1}-\frac{t^{2} X^{2}}{2 !}+\cdots+\frac{(i t)^{n} X^{n}}{n !}\)&lt;/span> 代入可以推出： &lt;span class="math inline">\(\begin{aligned} \varphi_{X}(t) &amp;amp;=E\left[e^{i t X}\right] \\ &amp;amp;=E\left(1+\frac{i t X}{1}-\frac{t^{2} X^{2}}{2 !}+\cdots+\frac{(i t)^{n} X^{n}}{n !}\right) \\ &amp;amp;=E(1)+E\left(\frac{i t X}{1}\right)-E\left(\frac{t^{2} X^{2}}{2 !}\right)+\cdots+E\left(\frac{(i t)^{n} X^{n}}{n !}\right) \end{aligned}\)&lt;/span> &lt;span class="math inline">\(\LARGE=1+\frac{i t \overbrace{E[X]}^{\text{一阶矩}}}{1}-\frac{t^{2} \overbrace{E\left[X^{2}\right]}^{\text{二阶矩}}}{2 !}+\cdots+\frac{(i t)^{n} \overbrace{E\left[X^{n}\right]}^{\text{n阶矩}}}{n !}\)&lt;/span>&lt;/p>
&lt;p>说明特征函数包含了分布函数的所有矩，也就是包含了分布函数的所有（数字）特征。&lt;/p>
&lt;p>我们对概念做定义时，是通过抽象出其必须的属性，把具有相同属性的内容当作同一个概念。比如，有生命的物体，称为生物；有生命的、可以运动的、可观测的生物，称为动物；哺乳的动物称为哺乳动物。 数学分析中，根据泰勒定理把各阶导数都相同的两个函数认为是同一个函数。 类似的，概率论中，两个随机变量的各种指标/数字特征（期望、方差、偏态、各阶矩）都相同，它们应该是同一种分布。&lt;/p>
&lt;h4 id="从傅里叶变换傅里叶分析的角度来看">从傅里叶变换（傅里叶分析）的角度来看&lt;/h4>
&lt;p>随机变量&lt;span class="math inline">\(X\)&lt;/span>的特征函数定义为：&lt;span class="math inline">\(\varphi_{X}(t)=\mathrm{E}\left(e^{i t X}\right)\)&lt;/span>&lt;/p>
&lt;p>如果&lt;span class="math inline">\(F_X\)&lt;/span>是&lt;a href="https://zh.wikipedia.org/wiki/累积分布函数">累积分布函数&lt;/a>，那么特征函数由&lt;a href="https://zh.wikipedia.org/w/index.php?title=黎曼-斯蒂尔切斯积分&amp;amp;action=edit&amp;amp;redlink=1">黎曼-斯蒂尔切斯积分&lt;/a>给出： &lt;span class="math display">\[
\mathrm{E}\left(e^{i t X}\right)=\int_{-\infty}^{\infty} e^{i t x} d F_{X}(x)
\]&lt;/span> 在概率密度函数 &lt;span class="math inline">\(f_{X}\)&lt;/span> 存在的情况下 &lt;span class="math inline">\(,\)&lt;/span> 该公式就变为 &lt;span class="math display">\[
\mathrm{E}\left(e^{i t X}\right)=\int_{-\infty}^{\infty} e^{i t x} f_{X}(x) d x
\]&lt;/span> 而对概率密度函数 &lt;span class="math inline">\(f_{X}\)&lt;/span> 作傅里叶变换的公式为： &lt;span class="math display">\[
F(t)=\int_{-\infty}^{\infty} f_X(x) e^{-i t x} d x
\]&lt;/span> 可见随机变量&lt;span class="math inline">\(X\)&lt;/span>的&lt;strong>特征函数&lt;/strong>&lt;span class="math inline">\(\varphi_{X}(t)\)&lt;/span>&lt;strong>与&lt;/strong> 随机变量&lt;span class="math inline">\(X\)&lt;/span>的&lt;strong>概率密度函数 &lt;span class="math inline">\(f_{X}\)&lt;/span>的傅里叶变换&lt;/strong> &lt;strong>共轭&lt;/strong>： &lt;span class="math display">\[
\varphi_{X}(t)=\overline{F(t)}
\]&lt;/span> 也就是说，特征函数&lt;span class="math inline">\(\varphi_{X}(t)\)&lt;/span>是密度函数&lt;span class="math inline">\(f_X(x)\)&lt;/span>的共轭傅里叶变换，这里&lt;strong>共轭影响不大&lt;/strong>，&lt;strong>可以看作傅里叶变换&lt;/strong>来理解。&lt;/p>
&lt;p>即特征函数相当于在频域分析分布函数。&lt;/p>
&lt;blockquote>
&lt;p>注：&lt;/p>
&lt;p>&lt;strong>傅里叶级数&lt;/strong>：&lt;span class="math inline">\(\tilde{x}(t)=\sum_{k=-\infty}^{+\infty} a_{k} e^{j k w_{0} t}\)&lt;/span> 其中&lt;span class="math inline">\(a_{k}=\frac{1}{T} \int_{-T / 2}^{T / 2} \tilde{x}(t) e^{-j k \omega_{0} t} d t\)&lt;/span>&lt;/p>
&lt;p>傅里叶级数适用于周期信号中，将周期推广到&lt;span class="math inline">\(\infty\)&lt;/span>,就变成了傅里叶变换。&lt;/p>
&lt;p>&lt;strong>傅里叶变换&lt;/strong>（结论）：&lt;span class="math inline">\(x(t)==\frac{1}{2 \pi} \int_{-\infty}^{+\infty} X(j \omega) e^{j \omega t} d \omega(7)\)&lt;/span> 其中，傅里叶级数的包络&lt;span class="math inline">\(X(j \omega)=\int_{-\infty}^{+\infty} x(t) e^{-j \omega t} d t\)&lt;/span>&lt;/p>
&lt;p>进一步阅读：无穷级数章节。 进一步阅读：&lt;a href="https://www.zhihu.com/question/21665935">傅里叶级数和傅里叶变换是什么关系？&lt;/a> 进一步阅读：&lt;a href="https://www.zhihu.com/question/21665935/answer/49282739">傅里叶级数和傅里叶变换是什么关系？ - Jason Huang的回答 - 知乎&lt;/a> 进一步阅读：&lt;a href="https://www.matongxue.com/madocs/473/">如何通俗地理解傅立叶变换？&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>特征函数的意义的章节内容参考了马同学的博客：https://www.matongxue.com/madocs/742/，以下是他网页的嵌入iframe显示：&lt;/p>
&lt;iframe height="400" scrolling="yes" title="马同学的博客：如何理解统计中的特征函数？" src="https://www.matongxue.com/madocs/742/" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">
&lt;/iframe></description></item><item><title>数学分支的总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="数学分支的总结">数学分支的总结&lt;/h1>
&lt;p>参考：&lt;a href="https://yuanwangphd.wordpress.com/2006/02/07/关于数学分支的总结zz/">关于数学分支的总结(zz)&lt;/a>&lt;/p>
&lt;p>基础数学：&lt;/p>
&lt;p>&lt;strong>数论：&lt;/strong>古典数论 解析数论，代数数论，超越数论, 模型式与模函数论&lt;/p>
&lt;p>&lt;strong>代数学：&lt;/strong>线性代数 群论, 群表示论, 李群, 李代数, 代数群, 典型群, 同调代数, 代数K理论, Kac-Moody代数, 环论, 代数, 体, 格, 序结构. 域论和多项式 拓扑群 矩阵论 向量代数 张量代数&lt;/p>
&lt;p>&lt;strong>几何学：&lt;/strong>（整体，局部）微分几何, 代数几何, 流形上的分析, 黎曼流形与洛仑兹流形, 齐性空间与对称空间, 调和映照, 子流形理论, 杨–米尔斯场与纤维丛理论, 辛流形. 凸几何与离散几何 欧氏几何 非欧几何 解析几何&lt;/p>
&lt;p>&lt;strong>拓扑学：&lt;/strong>微分拓扑, 代数拓扑, 低维流形, 同伦论, 奇点与突变理论, 点集拓扑. 流形和胞腔复形 大范围分析,微分拓扑 同调论 复流形&lt;/p>
&lt;p>&lt;strong>函数论：&lt;/strong> 函数逼近论.&lt;/p>
&lt;p>&lt;strong>泛函分析：（&lt;/strong>非）线性泛函分析, 算子理论, 算子代数, 差分与泛函方程, 广义函数. 变分法，积分变换 积分方程&lt;/p>
&lt;p>&lt;strong>微分方程：&lt;/strong>泛函微分方程, 特征与谱理论及其反问题, 定性理论, 稳定性理论、分支理论,混沌理论, 奇摄动理论,动力系统, 常微分方程 非线性椭圆(和抛物)方程,偏微分方程, 微局部分析与一般偏微分算子理论, 调混合型及其它带奇性的方程, 非线性发展方程和无穷维动力系统.&lt;/p>
&lt;p>&lt;strong>数学物理：&lt;/strong>规范场论, 引力场论的经典理论与量子理论, 孤立子理论.&lt;/p>
&lt;p>&lt;strong>概率论：&lt;/strong>马氏过程, 随机过程, 随机分析, 随机场, 鞅论, 极限理论, 平稳过程, 概率论 统计学;&lt;/p>
&lt;p>&lt;strong>数理逻辑与数学基础：&lt;/strong>递归论, 模型论, 证明论, 公理集合证, 数理逻辑 范畴论&lt;/p>
&lt;p>&lt;strong>组合数学：&lt;/strong>组合计数, 图论.&lt;/p>
&lt;p>&lt;strong>分析学：&lt;/strong>序列、级数、可求和性 微积分 实变函数 抽象测度论 逼近与展开 特殊函数（单，多）复变函数论,调和分析, Fourier分析&lt;/p>
&lt;p>应用数学：&lt;/p>
&lt;p>&lt;strong>边缘学科&lt;/strong>：系统论;控制论 运筹学, 位势论&lt;/p>
&lt;p>&lt;strong>计算数学与科学工程计算：&lt;/strong>偏微分方程数值计算，初边值问题数值解法，非线性微分方程及其数值解法，边值问题数值解法，有限元、边界元数值方法，变分不等式的数值方法，辛几何差分方法，数理方程反问题的数值解法，常微分方程数值解法及其应用，二点边值问题, STIFF问题研究, 奇异性问题, 代数微分方程, 不确定性的数学理论, 分形论.大型稀疏矩阵求解, 代数特征值问题及其反问题, 非线性代数方程, 一般线性代数方程组求解, 快速算法.&lt;/p>
&lt;p>&lt;strong>函数逼近：&lt;/strong>多元样条, 多元逼近, 曲面拟合, 有理逼近, 散乱数据插值.&lt;/p></description></item><item><title>数学物理方法总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="数学物理方法总结">数学物理方法总结&lt;/h1>
&lt;h2 id="坐标变换">坐标变换&lt;/h2>
&lt;p>&lt;a href="https://blog.csdn.net/qq_38476684/article/details/103776254">直角坐标、柱坐标、球坐标变换&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wenku.baidu.com/view/a2e72a41b307e87101f696ce.html">矢量的坐标变换/三种常用坐标系中的矢量场&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wenku.baidu.com/view/f33b62d576eeaeaad1f330c9.html">柱坐标系、球坐标系与直角坐标系之间单位矢量的转换&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/50491649">不同坐标系下基矢量的关系&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/u013102281/article/details/70800631">拉普拉斯算子从笛卡尔坐标系到圆柱坐标系下的推导过程&lt;/a>&lt;/p></description></item><item><title>最优化问题总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="最优化问题总结">最优化问题总结&lt;/h1>
&lt;h2 id="最优化问题概述">最优化问题概述&lt;/h2>
&lt;p>参考：https://zhuanlan.zhihu.com/p/22801652&lt;/p>
&lt;h4 id="最优化问题的引出">最优化问题的引出&lt;/h4>
&lt;p>以下都是最优化问题的例子： 上班怎么选择乘车路线，才能舒服又快速的到达公司；旅游如何选择航班和宾馆，既省钱又能玩的开心； 跳槽应该选择哪家公司，钱多、事少、离家近，前台妹子颜值高；买房子应该选在哪里，交通发达有学区，生活便利升值快。&lt;/p>
&lt;p>可以看出，上面所有的问题都面临&lt;strong>无数的选择&lt;/strong>， 我们会根据自己的偏好对&lt;strong>每个选择打一个不同的分数&lt;/strong>，再从所有的选择中&lt;strong>找出最优的一个&lt;/strong>。这个寻求最优解的过程其实就是&lt;strong>最优化问题&lt;/strong>。&lt;/p>
&lt;p>我们要打的分数就称为&lt;strong>目标函数&lt;/strong>。&lt;/p>
&lt;p>最优化问题往往还要面临一定的&lt;strong>约束条件&lt;/strong>，比如对旅行路线的选择，总花费和出发、到达时间就构成了约束条件，对买房子的选择，离公司的路程、总价也可能构成约束条件。我们选择的最优解也必须满足这些约束条件。&lt;/p>
&lt;h4 id="最优化问题的定义">最优化问题的定义&lt;/h4>
&lt;p>最优化问题就可以定义为： 在给定的约束条件下， 选择最优的参数和方案，来使得目标函数最大化/最小化的问题。&lt;/p>
&lt;p>最优化问题的数学形式是：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-3155975431728d1c463ebcaf33c61b12_720w.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>这里可以看到最优化问题的三个基本要素：&lt;/p>
&lt;ul>
&lt;li>目标函数: 用来衡量结果的好坏&lt;/li>
&lt;li>参数值：未知的因子，需要通过数据来确定。&lt;/li>
&lt;li>约束条件：需要满足的限制条件&lt;/li>
&lt;/ul>
&lt;h4 id="最优化问题的分类">最优化问题的分类&lt;/h4>
&lt;h5 id="按约束条件分类">按约束条件分类&lt;/h5>
&lt;p>根据约束条件的种类，最优化问题可以分成以下种类：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-18c60861acb2a1c64a818e3b46bef900_720w.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h5 id="按目标函数分类">按目标函数分类&lt;/h5>
&lt;p>而根据目标函数的状态， 最优化问题又可以分成：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-3a021e3eb0e87462bcfa7e6dccc30dde_720w.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h5 id="按解法分类解法的选择">按解法分类（解法的选择）&lt;/h5>
&lt;p>在实际的工作中，我们如何来选择最优化问题的解法呢？&lt;/p>
&lt;p>基本的依据有以下几点：&lt;/p>
&lt;ul>
&lt;li>目标函数是否连续可导&lt;/li>
&lt;li>目标函数的形式，是否为线性函数或者二次函数&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-55679e26c7aee891eae6e47caec432ad_720w.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>对应上图：&lt;/p>
&lt;ul>
&lt;li>离散最优化方法： 主要用于求解目标函数不连续或者不可导的情况，典型的解法有爬山法、模拟退火、遗传算法和蚁群算法等。&lt;/li>
&lt;li>线性规划和二次规划：运筹学的重要研究内容，适用于目标函数是线性或二次函数的形式。&lt;/li>
&lt;li>连续最优化方法： 适用于逻辑回归、SVM、神经网络等机器学习问题，主要方法包括梯度下降、牛顿法和拟牛顿法。&lt;/li>
&lt;/ul>
&lt;h2 id="离散最优化">离散最优化&lt;/h2>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/%E6%95%B4%E6%95%B0%E8%A7%84%E5%88%92">百度百科：整数规划&lt;/a> 参考：&lt;a href="https://zhuanlan.zhihu.com/p/34533871">知乎：运筹学发展概况（上）&lt;/a> 参考：&lt;a href="https://zhuanlan.zhihu.com/p/34913286">知乎：运筹学发展概况（中）&lt;/a>&lt;/p>
&lt;p>最优化问题似乎自然地分成两类：一类是&lt;a href="https://baike.baidu.com/item/连续变量/10707410">连续变量&lt;/a>的问题，另一类是&lt;a href="https://baike.baidu.com/item/离散变量/8443404">离散变量&lt;/a>的问题。具有离散变量的问题，我们称它为组合的(和离散最优化、整数规划常常混用，实际上范围稍稍有点不同）。在连续变量的问题里，一般地是求一组实数，或者一个函数；在组合问题里，是从一个&lt;a href="https://baike.baidu.com/item/无限集/5017054">无限集&lt;/a>或者可数无限集里寻找一个对象——典型地是一个整数，一个集合，一个排列，或者一个图。一般地，这两类问题有相当不同的特色，并且求解它们的方法也是很不同的。&lt;/p>
&lt;h3 id="整数优化">整数优化&lt;/h3>
&lt;p>数规划是指规划中的变量（全部或部分）限制为&lt;a href="https://baike.baidu.com/item/整数/1293937">整数&lt;/a>&lt;/p>
&lt;p>包括组合优化、0-1优化。。。&lt;/p>
&lt;p>而&lt;a href="https://baike.baidu.com/item/组合最优化">组合最优化&lt;/a>通常都可表述为整数规划问题。&lt;/p>
&lt;h3 id="组合优化">组合优化&lt;/h3>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96">组合优化百度百科&lt;/a> 参考：&lt;a href="https://zhuanlan.zhihu.com/p/27429666">知乎：离散/整数/组合/非凸优化概述及其在AI的应用&lt;/a>&lt;/p>
&lt;p>组合优化是20 世纪60 年代逐渐发展起来的一个&lt;strong>交叉学科分支&lt;/strong>，它的研究对象是有限集合上的极值问题。&lt;/p>
&lt;p>组合优化与图论、组合学、数理逻辑等有密切关系，在计算机科学、信息科学、管理科学和生命科学等学科有广泛的应用。&lt;/p>
&lt;p>组合优化的一个理论基础是计算复杂性理论（NP-完备理论），据此组合优化可以分为两类：P-问题类和NP-难问题类；属于前者的问题有多项式时间算法，属于后者的问题一般认为不存在多项式时间算法，通常采用穷举法、&lt;a href="https://link.zhihu.com/?target=http%3A//yunchouxue.cn/key/%e5%90%af%e5%8f%91%e5%bc%8f%e7%ae%97%e6%b3%95/">启发式算法&lt;/a>和近似算法等方法求解。&lt;/p>
&lt;p>通俗的讲，我把组合优化理解为，在组合优化种可能性里找出最优的方案。组合优化是整数规划的子集。的确，绝大多数组合优化问题都可以被建模成（混合）整数规划模型来求解。但是似乎学术圈更多地把组合优化与图（&lt;strong>Graph&lt;/strong>）优化以及网络流（&lt;strong>Network Flow&lt;/strong>）优化联系在一起，并且&lt;strong>最终目标不在精确解，而是近似解&lt;/strong>。&lt;/p>
&lt;p>一个组合优化问题由3 部分构成：已知条件的输入，可行解的描述，目标函数的定义。&lt;/p>
&lt;p>经典的组合优化问题包括网络流、旅行商、排序、装箱、着色、覆盖、最短网络等等。&lt;/p>
&lt;h4 id="np-完备理论">NP-完备理论&lt;/h4>
&lt;p>参考：https://www.ixueshu.com/download/f21b7d05519c59112c66aded1d019c63318947a18e7f9386.html 参考：https://zhuanlan.zhihu.com/p/143003261 参考：https://blog.csdn.net/weixin_42528077/article/details/82779896&lt;/p>
&lt;p>计算复杂性理论，又称NP-完备理论。&lt;/p>
&lt;p>在计算机领域，组合优化就是要找到适用于计算机的计算方法，这样的方法就是&lt;strong>算法&lt;/strong>。&lt;/p>
&lt;p>在数值计算理论可知，当变量的个数增加时，多项式函数比指数函数增加的速度慢很多。基于这个事实，人们认为只有计算复杂性是多项式函数的（精确的）算法才是&lt;strong>有效的算法&lt;/strong>。&lt;/p>
&lt;p>在理论计算机科学中，人们把具有有效算法的问题称为P类问题（polynomial）。&lt;/p>
&lt;h5 id="p-问题easy-to-find">&lt;strong>P 问题(easy to find)&lt;/strong>&lt;/h5>
&lt;blockquote>
&lt;p>all problems solvable, deterministically, in polynomial time 译：多项式时间内可解决的问题(当然在多项式时间是可验证的)&lt;/p>
&lt;/blockquote>
&lt;h5 id="np-问题esay-to-check">&lt;strong>NP 问题(esay to check)&lt;/strong>&lt;/h5>
&lt;blockquote>
&lt;p>non-deterministic Polynomial time 译：非确定性多项式时间可解决的问题&lt;/p>
&lt;/blockquote>
&lt;p>举几个例子来加深印象：&lt;/p>
&lt;p>&lt;strong>计算1-1000的连续整数之和&lt;/strong>：这个问题就比较简单，无论是编程还是使用高斯求和公式都可以在有限可接受的时间内完成，这种算是P类问题。&lt;/p>
&lt;p>&lt;strong>计算地球上所有原子个数之和&lt;/strong>：这个问题就很困难甚至无解，但是现在有个答案是300个，显然是错的，所以很容易验证但不容易求解，这种算NP类问题。&lt;/p>
&lt;p>看到这里我们get了一个&lt;strong>非常重要的概念(敲黑板划重点)&lt;/strong>：P类问题是可以在多项式时间内解决并验证的一类问题，NP类问题是可以多项式时间验证但是不确定能否在多项式时间内解决的一类问题。&lt;/p>
&lt;h5 id="多项式时间">&lt;strong>多项式时间&lt;/strong>&lt;/h5>
&lt;figure>
&lt;img src="https://pic1.zhimg.com/80/v2-74c69f514541f380a6e775e82316accc_720w.jpg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h5 id="约化的概念">&lt;strong>“约化”的概念&lt;/strong>&lt;/h5>
&lt;ul>
&lt;li>问题A可以约化为问题B：可以采用解决问题B的方法解决问题A；或者说，问题A可以转化为问题B。（如：一元二次方程的解法可以用来解一元一次方程，只要令二次项系数a=0即可）&lt;/li>
&lt;li>问题A可以约化为问题B 的直观意义：B的时间复杂度高于或者等于A的时间复杂度。也就是说，问题A不比问题B难。&lt;/li>
&lt;li>约化具有传递性：如果问题A可约化为问题B，问题B可约化为问题C，则问题A一定可约化为问题C。&lt;/li>
&lt;li>约化的标准概念：如果能找到这样一个变化法则（要求该变化法则为至多多项式时间复杂度），对任意一个程序A的输入，都能按这个法则变换成程序B的输入，使两程序的输出相同，那么我们说，问题A可约化为问题B。&lt;/li>
&lt;/ul>
&lt;h5 id="np-完全问题npc问题">&lt;strong>NP-完全问题（NPC问题）&lt;/strong>&lt;/h5>
&lt;p>一个问题约化为另一个问题，时间复杂度增加了，问题的应用范围也增大了。通过对某些问题的不断约化，我们能够不断寻找复杂度更高，但应用范围更广的算法来代替复杂度虽然低，但只能用于很小的一类问题的算法。&lt;/p>
&lt;p>如果从某一个NP问题开始不断向上约化，不断找到能“通吃”若干小NP问题的一个稍复杂的大NP问题，那么最后是否有可能找到一个时间复杂度最高，并且能“通吃”所有的 NP问题的这样一个超级NP问题？&lt;/p>
&lt;p>&lt;strong>NPC问题&lt;/strong>：存在这样一个NP问题，所有的NP问题都可以约化成它。这种问题不只一个，它有很多个，它是一类问题。这一类问题就是NPC 问题。&lt;/p>
&lt;p>&lt;strong>NPC问题的定义&lt;/strong>：同时满足下面两个条件的问题就是NPC问题：首先，它得是一个NP问题；然后，所有的NP问题都可以约化到它。&lt;/p>
&lt;p>NPC问题的证明：先证明它至少是一个NP问题，再证明其中一个已知的NPC问题能约化到它（由约化的传递性，则NPC问题定义的第二条也得以满足）&lt;/p>
&lt;h5 id="np-hard问题">&lt;strong>NP-hard问题&lt;/strong>&lt;/h5>
&lt;p>NP-hard问题满足NPC问题定义的第二条而不满足第一条。NP-hard问题的范围比NP问题要广。&lt;/p>
&lt;p>NP-hard问题同样难以找到多项式时间复杂度的算法，但它也不一定是NP问题（只是所有的NP问题都可以约化到它）。&lt;/p></description></item><item><title>概率论与数理统计-数理统计-方差分析与回归分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-数理统计-方差分析与回归分析">概率论与数理统计-数理统计-方差分析与回归分析&lt;/h1>
&lt;p>//TODO&lt;/p>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/回归分析">https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90&lt;/a> 参考：概率论与数理统计.浙大第四版&lt;/p>
&lt;p>方差分析和回归分析都是数理统计中具有广泛应用的内容. 本章对它们的 最基本部分作一介绍.&lt;/p>
&lt;p>（本章节最好直接阅读教材，这里总结并不到位。这里引入了许多统计量的分布，证明参见：概率论与数理统计.浙大第四版）&lt;/p>
&lt;h2 id="单因素试验的方差分析">单因素试验的方差分析&lt;/h2>
&lt;p>在科学试验和生产实践中，影响一事物的因素往往是很多的。 例如，在化工生产中，有原料成分、原料剂量、催化剂、反应温度、压力溶液浓度、反应时间、机器设备及操作人员的水平等因素每一因素的改变都有可能影响产品的数量和质量。 有些因素影响较大，有些较小。为了使生产过程得以稳定，保证优质、高产就&lt;strong>有必要找出对产品质量有显著影响的那些因素&lt;/strong>.为此，我们需进行试验。 &lt;strong>方差分析就是根据试验的结果进行分析，鉴别各个有关因素对试验结果影响的有效方法&lt;/strong>.&lt;/p>
&lt;h3 id="单因素试验">单因素试验&lt;/h3>
&lt;p>在试验中，我们将要考察的指标称为&lt;strong>试验指标&lt;/strong>（对应随机变量）。影响试验指标的条件称为&lt;strong>因素&lt;/strong>.（随机变量的参数，作为自变量看待） 因素可分为两类， 一类是人们可以控制的（可控因素）； 一类是人们不能控制的（不可控因素）。例如，反应温度、原料剂量、溶液浓度等是可以控制的，而测量误差、气象条件等一般是难以控制的。以下我们所说的因素都是指可控因素。 因素所处的状态，称为该&lt;strong>因素的水平&lt;/strong>（见下述各例）。 如果在一项试验的过程中只有一个因素在改变称为&lt;strong>单因素试验&lt;/strong>，如果多于一个因素在改变称为&lt;strong>多因素试验&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>例子 设有三台机器,用来生产规格相同的铝合金薄板. 取样,测量薄板的 厚度精确至千分之一厘米.得结果： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225000929380.png" alt="image-20201225000929380" />&lt;/p>
&lt;p>这里，试验的指标是薄板的厚度。机器为因素，不同的三台机器就是这个因素的三个不同的水平。 我们假定除机器这一因素外，材料的规格、操作人员的水平等其他条件都相同。这是单因素试验。 试验的目的是为了考察各台机器所生产的薄板的厚度有无显著的差异，即考察机器这一因素对厚度有无显著的影响。 如果厚度有显著差异，就表明机器这一因素对厚度的影响是显著的&lt;/p>
&lt;/blockquote>
&lt;p>本节仅限于讨论单因素试验.&lt;/p>
&lt;h3 id="方差分析法">方差分析法&lt;/h3>
&lt;blockquote>
&lt;p>在实际中试验的指标往往要受到一种或多种因素的影响。方差分析就是通过对试验数据进行分析，检验方差相同的多个（多于两个）正态总体的均值是否相等，用以判断各因素对试验指标的影响是否显著。方差分析按影响试验指标的因素的个数分为单因素方差分析、双因素方差分析和多因素方差分析，本章只介绍前面两种。&lt;/p>
&lt;/blockquote>
&lt;p>在上面例子中,我们在因素的每一个水平下进行独立试验,其结果是一个样本. 表中数据可&lt;strong>看成&lt;/strong>来自&lt;strong>三个不同总体&lt;/strong>(每个水平对应一个总体)的样本值. 将各个总体的均值依次记为 &lt;span class="math inline">\(\mu_{1}, \mu_{2}, \mu_{3}\)&lt;/span>. 上面的例子的问题是：机器这一因素对厚度的影响是显著？按题意&lt;strong>需检验假设&lt;/strong>： &lt;span class="math inline">\(H_{0}: \mu_{1}=\mu_{2}=\mu_{3}\)&lt;/span> &lt;span class="math inline">\(H_{1}: \mu_{1}, \mu_{2}, \mu_{3}\)&lt;/span> 不全相等.&lt;/p>
&lt;p>现在进而假设各总体均为正态变量,且各总体的方差相等,但参数均未知. 那么 这是一个检验同方差的多个正态总体均值是否相等的问题.&lt;/p>
&lt;p>下面所要讨论的方差分析法,就是解决这类问题（检验同方差的多个正态总体均值是否相等）的一种统计方法.&lt;/p>
&lt;h4 id="单因素试验方差分析的数学模型与假设检验问题">单因素试验方差分析的数学模型与假设检验问题&lt;/h4>
&lt;p>现在开始讨论单因素试验的方差分析. 设因素 &lt;span class="math inline">\(A\)&lt;/span> 有 &lt;span class="math inline">\(s\)&lt;/span> 个水平 &lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{s},\)&lt;/span> 在水平 &lt;span class="math inline">\(A_{j}(j=1,2, \cdots, s)\)&lt;/span> 下,进行 &lt;span class="math inline">\(n_{j}\left(n_{j} \geqslant 2\right)\)&lt;/span> 次独立试验,得到如下图表的结果： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225002130712.png" alt="image-20201225002130712" />&lt;/p>
&lt;p>我们&lt;strong>假定&lt;/strong> : 各个水平 &lt;span class="math inline">\(A_{j}(j=1,2, \cdots, s)\)&lt;/span> 下的样本 &lt;span class="math inline">\(X_{1 j}, X_{2 j}, \cdots, X_{n_{j} j}\)&lt;/span> 来自具有相同方差 &lt;span class="math inline">\(\sigma^{2},\)&lt;/span> 均值分别为 &lt;span class="math inline">\(\mu_{j}(j=1,2, \cdots, s)\)&lt;/span> 的正态总体 &lt;span class="math inline">\(N\left(\mu_{j}, \sigma^{2}\right), \mu_{j}\)&lt;/span> 与 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 未知. 且设不同水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 下的样本之间相互独立.&lt;/p>
&lt;p>由于 &lt;span class="math inline">\(X_{i j} \sim N\left(\mu_{j}, \sigma^{2}\right),\)&lt;/span> 即有 &lt;span class="math inline">\(X_{i j}-\mu_{j} \sim N\left(0, \sigma^{2}\right),\)&lt;/span> 故 &lt;span class="math inline">\(X_{i j}-\mu_{j}\)&lt;/span> 可看成是随机误差. 记 &lt;span class="math inline">\(X_{i j}-\mu_{j}=\varepsilon_{i j},\)&lt;/span> 则 &lt;span class="math inline">\(X_{i j}\)&lt;/span> 可写成： &lt;span class="math inline">\(\left.\begin{array}{l}X_{i j}=\mu_{j}+\varepsilon_{i j} \\ \varepsilon_{i j} \sim N\left(0, \sigma^{2}\right), \text { 各 } \varepsilon_{i j} \text { 独立 }, \\ i=1,2, \cdots, n_{j}, j=1,2, \cdots, s,\end{array}\right\}\)&lt;/span>， 其中 &lt;span class="math inline">\(\mu_{j}\)&lt;/span> 与 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 均为未知参数. 上式称为&lt;strong>单因素试验方差分析的数学模型&lt;/strong>. 这是本节的&lt;strong>研究对象&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>方差分析的任务&lt;/strong>是对于以上模型： 1）检验 &lt;span class="math inline">\(s\)&lt;/span> 个总体 &lt;span class="math inline">\(N\left(\mu_{1}, \sigma^{2}\right), \cdots, N\left(\mu_{s}, \sigma^{2}\right)\)&lt;/span> 的均值是否相等,即检验假设： &lt;span class="math inline">\(H_{0}: \mu_{1}=\mu_{2}=\cdots=\mu_{s}\)&lt;/span> &lt;span class="math inline">\(H_{1}: \mu_{1}, \mu_{2}, \cdots, \mu_{s}\)&lt;/span> 不全相等. 2）作出未知参数 &lt;span class="math inline">\(\mu_{1}, \mu_{2}, \cdots, \mu_{s}, \sigma^{2}\)&lt;/span> 的估计.&lt;/p>
&lt;p>一些记号： 为了更好地讨论以上方差分析,我们将 &lt;span class="math inline">\(\mu_{1}, \mu_{2}, \cdots, \mu_{s}\)&lt;/span> 的加权平均值&lt;span class="math inline">\(\frac{1}{n} \sum_{j=1}^{s} n_{j} \mu_{j}\)&lt;/span> 记为 &lt;span class="math inline">\(\mu,\)&lt;/span> 即&lt;span class="math inline">\(\mu=\frac{1}{n} \sum_{j=1}^{s} n_{j} \mu_{j}\)&lt;/span>，其中 &lt;span class="math inline">\(n=\sum_{j=1}^{s} n_{j}, \mu\)&lt;/span> 称为&lt;strong>总平均&lt;/strong>. 再引入&lt;span class="math inline">\(\delta_{j}=\mu_{j}-\mu, \quad j=1,2, \cdots, s\)&lt;/span>，此时有 &lt;span class="math inline">\(n_{1} \delta_{1}+n_{2} \delta_{2}+\cdots+n_{s} \delta_{s}=0, \delta_{j}\)&lt;/span> 表示&lt;strong>水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 下的总体平均值与总平均的差异&lt;/strong>,习惯上将 &lt;span class="math inline">\(\delta_{j}\)&lt;/span> 称为&lt;strong>水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 的效应&lt;/strong>.&lt;/p>
&lt;p>有了上面的记号，&lt;strong>单因素试验方差分析的数学模型&lt;/strong>可以改写成如下形式： &lt;span class="math inline">\(\left.\begin{array}{l}X_{i j}=\mu+\delta_{j}+\varepsilon_{i j} \\ \varepsilon_{i j} \sim N\left(0, \sigma^{2}\right), \text { 各 } \varepsilon_{i j} \text { 独立 } \\ i=1,2, \cdots, n_{j}, j=1,2, \cdots, s \\ \sum_{j=1}^{s} n_{j} \delta_{j}=0\end{array}\right\}\)&lt;/span>&lt;/p>
&lt;p>有了上面的记号，假设检验问题也可以描述成如下形式： &lt;span class="math inline">\(H_{0}: \delta_{1}=\delta_{2}=\cdots=\delta_{s}=0\)&lt;/span> &lt;span class="math inline">\(H_{1}: \delta_{1}, \delta_{2}, \cdots, \delta_s\text {, 不全为零 } .\)&lt;/span>&lt;/p>
&lt;h4 id="平方和的分解">平方和的分解&lt;/h4>
&lt;p>下面我们从平方和的分解着手,导出假设上面检验问题的检验统计量.&lt;/p>
&lt;p>引入&lt;strong>总偏差平方和&lt;/strong>：&lt;span class="math inline">\(S_{T}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}\right)^{2}\)&lt;/span>， 其中&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span>是数据的总平均. &lt;span class="math inline">\(\mathrm{S}_{\mathrm{T}}\)&lt;/span> 能&lt;strong>反映全部试验数据之间的差异&lt;/strong>,因此 &lt;span class="math inline">\(S_{T}\)&lt;/span> 又称为总变差.&lt;/p>
&lt;p>记&lt;strong>水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 下的样本平均值&lt;/strong>为 &lt;span class="math inline">\(\bar{X}_{\cdot j},\)&lt;/span> 即&lt;span class="math inline">\(\bar{X}_{\cdot j}=\frac{1}{n_{j}} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span>&lt;/p>
&lt;p>则可以改写&lt;strong>总偏差平方和&lt;/strong>&lt;span class="math inline">\(S_{T}\)&lt;/span>： &lt;span class="math inline">\(\begin{aligned} S_{T} &amp;amp;=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left[\left(X_{i j}-\bar{X}_{\cdot j}\right)+\left(\bar{X}_{\cdot j}-\bar{X}\right)\right]^{2} \\ &amp;amp;=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)^{2}+\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}+2 \sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)\left(\bar{X}_{\cdot j}-\bar{X}\right) \end{aligned}\)&lt;/span> 注意到上式第三项(即交叉项): &lt;span class="math inline">\(2 \sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)\left(\bar{X}_{\cdot j}-\bar{X}\right)\)&lt;/span> &lt;span class="math inline">\(\quad=2 \sum_{i j}^{s}\left(\bar{X}_{\cdot j}-\bar{X}\right)\left[\sum_{i j}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)\right]=2 \sum\left(\bar{X}_{\cdot j}-\bar{X}\right)\left(\sum_{i j}-n_{j} \bar{X}_{\cdot j}\right)=0\)&lt;/span>&lt;/p>
&lt;p>平方和分解式：我们将&lt;strong>总偏差平方和&lt;/strong>&lt;span class="math inline">\(S_{T}\)&lt;/span>分解成为：&lt;span class="math inline">\(S_{T}=S_{E}+S_{A}\)&lt;/span>， 其中&lt;span class="math inline">\(S_{E}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)^{2}\)&lt;/span>，&lt;span class="math inline">\(S_{E}\)&lt;/span> 的各项 &lt;span class="math inline">\(\left(X_{i j}-\bar{X}_{\cdot j}\right)^{2}\)&lt;/span> 表示&lt;strong>在水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 下,样本观察值与样本均值的差异&lt;/strong> 这是由随机误差所引起的. &lt;span class="math inline">\(S_{E}\)&lt;/span> 叫做&lt;strong>误差平方和&lt;/strong>.&lt;span class="math inline">\(,\)&lt;/span> &lt;span class="math inline">\(S_{A}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}=\sum_{j=1}^{s} n_{j}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}=\sum_{j=1}^{s} n_{j} \bar{X}_{\cdot j}^{2}-n \bar{X}^{2}\)&lt;/span>，&lt;span class="math inline">\(S_{A}\)&lt;/span> 的各项 &lt;span class="math inline">\(n_{j}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}\)&lt;/span> 表示 &lt;strong>&lt;span class="math inline">\(A_{j}\)&lt;/span> 水平下的样本平均值与数据总平均的差异&lt;/strong>,这是由水平 &lt;span class="math inline">\(A_{j}\)&lt;/span> 的效应的差异以及随机误差引起的. &lt;span class="math inline">\(S_{A}\)&lt;/span> 叫做因素 &lt;span class="math inline">\(A\)&lt;/span> 的&lt;strong>效应平方和&lt;/strong>.&lt;/p>
&lt;h4 id="s_e-s_a-的统计特性">&lt;span class="math inline">\(S_{E}, S_{A}\)&lt;/span> 的统计特性&lt;/h4>
&lt;p>为了引出上面检验问题的检验统计量,我们依次来讨论 &lt;span class="math inline">\(S_{E}, S_{A}\)&lt;/span> 的一些统计特性. &lt;span class="math inline">\(S_{E}=\sum_{i=1}^{n_{1}}\left(X_{i 1}-\bar{X}_{\cdot 1}\right)^{2}+\cdots+\sum_{i=1}^{n_{s}}\left(X_{i s}-\bar{X}_{\cdot s}\right)^{2}\)&lt;/span>&lt;/p>
&lt;p>注意每个j列都是一个正态总体总体 &lt;span class="math inline">\(N\left(\mu_{j}, \sigma^{2}\right)\)&lt;/span>， 于是有&lt;span class="math inline">\(\frac{\sum_{i=1}^{n_{j}}\left(X_{i j}-\bar{X}_{\cdot j}\right)^{2}}{\sigma^{2}} \sim \chi^{2}\left(n_{j}-1\right)\)&lt;/span>&lt;/p>
&lt;p>各列（各总体）互相独立，故&lt;span class="math inline">\(S_{E}\)&lt;/span>式中各平方和相互独立. 由 &lt;span class="math inline">\(\chi^{2}\)&lt;/span> 分布的可加性知&lt;span class="math inline">\(\frac{S_{E}}{\sigma^{2}} \sim \chi^{2}\left(\sum_{i=1}^{s}\left(n_{j}-1\right)\right)\)&lt;/span>, 即：&lt;span class="math inline">\(\frac{S_{E}}{\sigma^{2}} \sim \chi^{2}(n-s)\)&lt;/span>，&lt;/p>
&lt;p>由上式还可知&lt;span class="math inline">\(S_{E}\)&lt;/span> 的自由度为 &lt;span class="math inline">\(n-s,\)&lt;/span> 且有&lt;span class="math inline">\(E\left(S_{E}\right)=(n-s) \sigma^{2}\)&lt;/span>&lt;/p>
&lt;p>下面讨论 &lt;span class="math inline">\(\mathrm{S}_{A}\)&lt;/span> 的统计特性, &lt;span class="math inline">\(S_{A}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}=\sum_{j=1}^{s} n_{j}\left(\bar{X}_{\cdot j}-\bar{X}\right)^{2}=\sum_{j=1}^{s} n_{j} \bar{X}_{\cdot j}^{2}-n \bar{X}^{2}\)&lt;/span>， 我们看到 &lt;span class="math inline">\(\mathrm{S}_{A}\)&lt;/span> 是 &lt;span class="math inline">\(s\)&lt;/span> 个变量 &lt;span class="math inline">\(\sqrt{n_{j}}\left(\bar{X}_{\cdot j}-\bar{X}\right)(j=1\)&lt;/span>, &lt;span class="math inline">\(2, \cdots, s)\)&lt;/span> 的平方和， 它们之间仅有一个线性约束条件：&lt;span class="math inline">\(\sum_{j=1}^{s} \sqrt{n_{j}}\left[\sqrt{n_{j}}\left(\bar{X}_{\cdot j}-\bar{X}\right)\right]=\sum_{j=1}^{s} n_{j}\left(\bar{X}_{\cdot j}-\bar{X}\right)=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}-n \bar{X}=0\)&lt;/span>， 故知 &lt;span class="math inline">\(S_{A}\)&lt;/span> 的自由度是 &lt;span class="math inline">\(s-1 .\)&lt;/span>&lt;/p>
&lt;p>由&lt;span class="math inline">\(\mu=\frac{1}{n} \sum_{j=1}^{s} n_{j} \mu_{j}\)&lt;/span>，&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span>，以及&lt;span class="math inline">\(X_{ij}\)&lt;/span>的独立性， 知&lt;span class="math inline">\(\bar{X} \sim N\left(\mu, \frac{\sigma^{2}}{n}\right)\)&lt;/span>&lt;/p>
&lt;p>可求得： &lt;span class="math inline">\(\begin{aligned} E\left(S_{A}\right) &amp;amp;=E\left[\sum_{j=1}^{s} n_{j} \bar{X}_{\cdot j}^{2}-n \bar{X}^{2}\right]=\sum_{j=1}^{s} n_{j} E\left(\bar{X}_{\cdot j}^{2}\right)-n E\left(\bar{X}^{2}\right) \\ &amp;amp;=\sum_{j=1}^{s} n_{j}\left[\frac{\sigma^{2}}{n_{j}}+\left(\mu+\delta_{j}\right)^{2}\right]-n\left(\frac{\sigma^{2}}{n}+\mu^{2}\right) \\ &amp;amp;=(s-1) \sigma^{2}+2 \mu \sum_{j=1}^{s} n_{j} \delta_{j}+n \mu^{2}+\sum_{j=1}^{s} n_{j} \delta_{j}^{2}-n \mu^{2} \end{aligned}\)&lt;/span> 由改写后的单因素试验方差分析的数学模型可知&lt;span class="math inline">\(\sum_{j=1}^{s} n_{j} \delta_{j}=0\)&lt;/span>， 即得&lt;span class="math inline">\(E\left(S_{A}\right)=(s-1) \sigma^{2}+\sum_{j=1}^{s} n_{j} \delta_{j}^{2}\)&lt;/span>。&lt;/p>
&lt;p>进一步还可以证明 &lt;span class="math inline">\(S_{A}\)&lt;/span> 与 &lt;span class="math inline">\(S_{E}\)&lt;/span> 独立,且当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时，&lt;span class="math inline">\(\frac{S_{A}}{\sigma^{2}} \sim \chi^{2}(s-1)\)&lt;/span>&lt;/p>
&lt;h4 id="假设检验问题的拒绝域">假设检验问题的拒绝域&lt;/h4>
&lt;p>现在我们可以来确定原假设检验问题的拒绝域了.&lt;/p>
&lt;p>由&lt;span class="math inline">\(E\left(S_{A}\right)=(s-1) \sigma^{2}+\sum_{j=1}^{s} n_{j} \delta_{j}^{2}\)&lt;/span>知, 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时，&lt;span class="math inline">\(E\left(\frac{S_{A}}{s-1}\right)=\sigma^{2}\)&lt;/span>。 即 &lt;span class="math inline">\(\frac{S_{A}}{s-1}\)&lt;/span> 是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计. 而当 &lt;span class="math inline">\(H_{1}\)&lt;/span> 为真时 &lt;span class="math inline">\(, \sum_{j=1}^{s} n_{j} \delta_{j}^{2}&amp;gt;0,\)&lt;/span> 此时&lt;span class="math inline">\(E\left(\frac{S_{A}}{s-1}\right)=\sigma^{2}+\frac{1}{s-1} \sum_{j=1}^{s} n_{j} \delta_{j}^{2}&amp;gt;\sigma^{2}\)&lt;/span>&lt;/p>
&lt;p>由&lt;span class="math inline">\(E\left(S_{E}\right)=(n-s) \sigma^{2}\)&lt;/span>知， &lt;span class="math inline">\(E\left(\frac{S_{E}}{n-s}\right)=\sigma^{2}\)&lt;/span>， 即不管 &lt;span class="math inline">\(H_{0}\)&lt;/span> 是否为真 &lt;span class="math inline">\(, \frac{S_{E}}{n-s}\)&lt;/span> 都是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计.&lt;/p>
&lt;p>综上所述,分式 &lt;span class="math inline">\(F=\frac{S_{A} /(s-1)}{S_{E} /(n-s)}\)&lt;/span> 的分子与分母独立, 分母 &lt;span class="math inline">\(\frac{S_{E}}{n-s}\)&lt;/span> 不论 &lt;span class="math inline">\(H_{0}\)&lt;/span> 是否为真,其数学期望总是 &lt;span class="math inline">\(\sigma^{2} .\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时,分子的数学期望为 &lt;span class="math inline">\(\sigma^{2},\)&lt;/span> 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 不真时， 由&lt;span class="math inline">\(E\left(\frac{S_{A}}{s-1}\right)=\sigma^{2}+\frac{1}{s-1} \sum_{j=1}^{s} n_{j} \delta_{j}^{2}&amp;gt;\sigma^{2}\)&lt;/span>知分子的取值有偏大的趋势. 故知原检验问题的拒绝域具有形式&lt;span class="math inline">\(F=\frac{S_{A} /(s-1)}{S_{E} /(n-s)} \geqslant k\)&lt;/span>&lt;/p>
&lt;p>其中 &lt;span class="math inline">\(k\)&lt;/span> 由预先给定的显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 确定. &lt;span class="math inline">\(\frac{S_{E}}{\sigma^{2}} \sim \chi^{2}(n-s)\)&lt;/span>，&lt;span class="math inline">\(\frac{S_{A}}{\sigma^{2}} \sim \chi^{2}(s-1)\)&lt;/span>，以及&lt;span class="math inline">\(S_{E}\)&lt;/span> 与 &lt;span class="math inline">\(S_{A}\)&lt;/span> 的独立性知, 当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时，&lt;span class="math inline">\(\frac{S_{A} /(s-1)}{S_{E} /(n-s)}=\frac{S_{A} / \sigma^{2}}{s-1} / \frac{S_{E} / \sigma^{2}}{n-s} \sim F(s-1, n-s)\)&lt;/span> 由此得原检验问题的拒绝域为&lt;span class="math inline">\(F=\frac{S_{A} /(s-1)}{S_{E} /(n-s)} \geqslant F_{\alpha}(s-1, n-s)\)&lt;/span>&lt;/p>
&lt;p>上述分析的结果可排成下面图表的形式,称为&lt;strong>方差分析表&lt;/strong>： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225013652933.png" alt="image-20201225013652933" /> 图表中 &lt;span class="math inline">\(\bar{S}_{A}=S_{A} /(s-1), \bar{S}_{E}=S_{E} /(n-s)\)&lt;/span> 分别称为 &lt;span class="math inline">\(S_{A}, S_{E}\)&lt;/span> 的&lt;strong>均方&lt;/strong>. 另外,因在&lt;span class="math inline">\(S_{T}\)&lt;/span> 中 &lt;span class="math inline">\(n\)&lt;/span> 个变量 &lt;span class="math inline">\(X_{i j}-\bar{X}\)&lt;/span> 之间仅满足一个约束条件&lt;span class="math inline">\(\bar{X}=\frac{1}{n} \sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span>,故 &lt;span class="math inline">\(S_{T}\)&lt;/span> 的自由度为 &lt;span class="math inline">\(n-1 .\)&lt;/span>&lt;/p>
&lt;p>在实际中,我们可以按以下较简便的公式来计算 &lt;span class="math inline">\(S_{T}, S_{A}\)&lt;/span> 和 &lt;span class="math inline">\(S_{E}\)&lt;/span>. 记： &lt;span class="math inline">\(T_{\cdot j}=\sum_{i=1}^{n_{j}} X_{i j}, j=1,2, \cdots, s\)&lt;/span> &lt;span class="math inline">\(T_{\cdot \cdot}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span> 即有： &lt;span class="math inline">\(\left.\begin{array}{l}S_{T}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}^{2}-n \bar{X}^{2}=\sum_{j=1}^{s} \sum_{i=1}^{n_{j}} X_{i j}^{2}-\frac{T^{2}}{n} \\ S_{A}=\sum_{j=1}^{s} n_{j} \bar{X}_{\cdot j}^{2}-n \bar{X}^{2}=\sum_{j=1}^{s} \frac{T_{\cdot j}^{2}}{n_{j}}-\frac{T_{\cdots}^{2}}{n} \\ S_{E}=S_{T}-S_{A}\end{array}\right\}\)&lt;/span>&lt;/p>
&lt;h4 id="未知参数的估计">未知参数的估计&lt;/h4>
&lt;p>上面已讲到过,不管 &lt;span class="math inline">\(H_{0}\)&lt;/span> 是否为真，&lt;span class="math inline">\(\hat{\sigma}^{2}=\frac{S_{E}}{n-s}\)&lt;/span>，是 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计. 由&lt;span class="math inline">\(\bar{X} \sim N\left(\mu, \frac{\sigma^{2}}{n}\right)\)&lt;/span>，&lt;span class="math inline">\(\bar{X}_{\cdot j}=\frac{1}{n_{j}} \sum_{i=1}^{n_{j}} X_{i j}\)&lt;/span>，知： &lt;span class="math inline">\(E(\bar{X})=\mu\)&lt;/span>， &lt;span class="math inline">\(E\left(\bar{X}_{\cdot j}\right)=\frac{1}{n_{j}} \sum_{i=1}^{n_{j}} E\left(X_{i j}\right)=\mu_{j}, j=1,2, \cdots, s\)&lt;/span> 故 &lt;span class="math inline">\(\hat{\mu}=\bar{X}, \quad \hat{\mu}_{j}=\bar{X}_{\cdot j}\)&lt;/span> 分别是 &lt;span class="math inline">\(\mu, \mu_{j}\)&lt;/span> 的无偏估计.&lt;/p>
&lt;p>又若拒绝 &lt;span class="math inline">\(H_{0},\)&lt;/span> 这意味着效应 &lt;span class="math inline">\(\delta_{1}, \delta_{2}, \cdots, \delta_{s}\)&lt;/span> 不全为零. 由于&lt;span class="math inline">\(\delta_{j}=\mu_{j}-\mu, \quad j=1,2, \cdots, s\)&lt;/span>， 知 &lt;span class="math inline">\(\hat{\delta}_{j}=\bar{X}_{\cdot j}-\bar{X}\)&lt;/span> 是 &lt;span class="math inline">\(\delta_{j}\)&lt;/span> 的无偏估计. 此时还有关系式&lt;span class="math inline">\(\sum_{j=1}^{s} n_{j} \hat{\delta}_{j}=\sum_{j=1}^{s} n_{j} \bar{X}_{\cdot j}-n \bar{X}=0\)&lt;/span> 当拒绝 &lt;span class="math inline">\(H_{0}\)&lt;/span> 时,常需要作出两总体 &lt;span class="math inline">\(N\left(\mu_{j}, \sigma^{2}\right)\)&lt;/span> 和 &lt;span class="math inline">\(N\left(\mu_{k}, \sigma^{2}\right), j \neq k\)&lt;/span> 的均值差 &lt;span class="math inline">\(\mu_j-\mu_{k}=\delta_{j}-\delta_{k}\)&lt;/span> 的区间估计。做法如下： 由于&lt;span class="math inline">\(E\left(\bar{X}_{\cdot j}-\bar{X}_{\cdot k}\right)=\mu_{j}-\mu_{k}\)&lt;/span>，&lt;span class="math inline">\(D\left(\bar{X}_{\cdot j}-\bar{X}_{\cdot k}\right)=\sigma^{2}\left(\frac{1}{n_{j}}+\frac{1}{n_{k}}\right)\)&lt;/span>， 且&lt;span class="math inline">\(\bar{X}_{\cdot j}-\bar{X}_{\cdot k} \frac{\vdash_{\sigma} \hat{\sigma}^{2}}{=} S_{E} /(n-s)\)&lt;/span> 独立. 于是&lt;span class="math inline">\(\frac{\left(\bar{X}_{\cdot j}-\bar{X}_{\cdot k}\right)-\left(\mu_{j}-\mu_{k}\right)}{\bar{S}_{E}\left(\frac{1}{n_{j}}+\frac{1}{n_{k}}\right)}\)&lt;/span> &lt;span class="math inline">\(\quad=\frac{\left(\bar{X}_{\cdot j}-\bar{X}_{\cdot k}\right)-\left(\mu_{j}-\mu_{k}\right)}{\sigma \sqrt{1 / n_{j}+1 / n_{k}}} / \sqrt{\frac{S_{E}}{\sigma^{2}} /(n-s)} \sim t(n-s)\)&lt;/span> 据此得均值差 &lt;span class="math inline">\(\mu_{j}-\mu_{k}=\delta_{j}-\delta_{k}\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为： &lt;span class="math inline">\(\left(\bar{X}_{\cdot j}-\bar{X}_{\cdot k} \pm t_{a / 2}(n-s) \sqrt{\bar{S}_{E}\left(\frac{1}{n_{j}}+\frac{1}{n_{k}}\right)}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="双因素试验的方差分析">双因素试验的方差分析&lt;/h2>
&lt;p>//TODO&lt;/p>
&lt;h2 id="一元线性回归">一元线性回归&lt;/h2>
&lt;p>在客观世界中普遍存在着变量之间的关系变量之间的关系。一般来说可分为确定性的与非确定性的两种。 &lt;strong>确定性关系&lt;/strong>是指变量之间的关系可以用函数关系来表达的。 另一种&lt;strong>非确定性的关系&lt;/strong>即所谓&lt;strong>相关关系&lt;/strong>。例如人的身高与体重之间存在着关系，一般来说，人高一些，体重要重一些，但同样高度的人，体重往往不相同。人的血压与年龄之间也存在着关系，但同年龄的人的血压往往不相同。气象中的温度与湿度之间的关系也是这样。这是因为我们涉及的变量（如体重、血压、湿度）是随机变量，上面所说的变量关系是非确定性的回归分析是研究相关关系的一种数学工具。它能帮助我们从一个变量取得的值去估计另一变量所取的值。&lt;/p>
&lt;h3 id="一元线性回归模型">一元线性回归模型&lt;/h3>
&lt;p>设随机变量 &lt;span class="math inline">\(Y\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 之间存在着某种相关关系. 这里, &lt;span class="math inline">\(x\)&lt;/span> 是可以控制或可以精确观察的变量,如年龄、试验时的温度、施加的压力、电压与时间等.换句话说我 们可以随意指定 &lt;span class="math inline">\(n\)&lt;/span> 个值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n} .\)&lt;/span> 因此我们干脆不把 &lt;span class="math inline">\(x\)&lt;/span> 看成是随机变量,而 将它当作普通的变量. 本章中我们只讨论这种情况.&lt;/p>
&lt;p>设&lt;strong>随机变量 Y（因变量）与普通变量 &lt;span class="math inline">\(x\)&lt;/span> (自变量) 之间存在着相关关系&lt;/strong>,由于 &lt;span class="math inline">\(Y\)&lt;/span>是随机变量,对于 &lt;span class="math inline">\(x\)&lt;/span> 的各个确定值,Y 有它 的分布如下图： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225102334470.png" alt="image-20201225102334470" /> （图中 &lt;span class="math inline">\(C_{1}, C_{2}\)&lt;/span> 分别是 &lt;span class="math inline">\(x_{1}\)&lt;/span>,&lt;span class="math inline">\(x_{2}\)&lt;/span> 处 &lt;span class="math inline">\(Y\)&lt;/span> 的概率密度曲线 &lt;span class="math inline">\() .\)&lt;/span> 用 &lt;span class="math inline">\(F(y \mid x)\)&lt;/span> 表示 当 &lt;span class="math inline">\(x\)&lt;/span> 取确定的 &lt;span class="math inline">\(x\)&lt;/span> 值时,所对应的 &lt;span class="math inline">\(Y\)&lt;/span> 的分布函数，如果我们掌握了 &lt;span class="math inline">\(F(y \mid x)\)&lt;/span> 随着 &lt;span class="math inline">\(x\)&lt;/span> 的 取值而变化的规律,那么就能完全掌握 Y与 &lt;span class="math inline">\(x\)&lt;/span> 之间的关系了. 然而这样做&lt;strong>往往比较复杂&lt;/strong>.&lt;/p>
&lt;p>作为一种近似,我们&lt;strong>转而去考察 &lt;span class="math inline">\(Y\)&lt;/span> 的数学期望&lt;/strong>,若 &lt;span class="math inline">\(Y\)&lt;/span> 的数学期望 &lt;span class="math inline">\(E(Y)\)&lt;/span> 存在,则其值随 &lt;span class="math inline">\(x\)&lt;/span> 的取值而定，&lt;strong>它是 &lt;span class="math inline">\(x\)&lt;/span> 的函 数&lt;/strong>. 将这一函数记为 &lt;span class="math inline">\(\mu_{Y \mid x}\)&lt;/span> 或 &lt;span class="math inline">\(\mu(x)\)&lt;/span>,称为 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>回归函数&lt;/strong>（如上图中所示）. 这样， 我们就&lt;strong>将讨论 &lt;span class="math inline">\(Y\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的相关关系的问题转换为讨论 &lt;span class="math inline">\(E(Y)=\mu(x)\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的函数关系&lt;/strong>了.&lt;/p>
&lt;p>我们知道,若 &lt;span class="math inline">\(\eta\)&lt;/span> 是一个随机变量,则 &lt;span class="math inline">\(E\left[(\eta-c)^{2}\right]\)&lt;/span> 作为 &lt;span class="math inline">\(c\)&lt;/span> 的函数,在 &lt;span class="math inline">\(c=E(\eta)\)&lt;/span> 时 &lt;span class="math inline">\(E\left[(\eta-c)^{2}\right]\)&lt;/span> 达到踏小(参见第四章习题第 17 题). 这表明在一切 &lt;span class="math inline">\(x\)&lt;/span> 的函数中以 回归函数 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 作为 &lt;span class="math inline">\(Y\)&lt;/span> 的近似,其均方误差 &lt;span class="math inline">\(E\left[(Y-\mu(x))^{2}\right]\)&lt;/span> 为最小. 因此,作为一 种近似,为了研究 &lt;span class="math inline">\(Y\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的关系转而去研究 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的关系是合适的.&lt;/p>
&lt;p>在实际问题中,回归函数 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 一般是未知的, &lt;strong>回归分析的任务&lt;/strong>是在于根据 试验数据去估计回归函数,讨论有关的点估计、区间估计、假设检验等问题. 特别重要的是对随机变量 &lt;span class="math inline">\(Y\)&lt;/span> 的观察值作出点预测和区间预测.&lt;/p>
&lt;p>我们对于 &lt;span class="math inline">\(x\)&lt;/span> 取定一组不完全相同的值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n},\)&lt;/span> 设 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 分别是 在 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 处对 &lt;span class="math inline">\(Y\)&lt;/span> 的独立观察结果,称&lt;span class="math inline">\(\left(x_{1}, Y_{1}\right),\left(x_{2}, Y_{2}\right), \cdots,\left(x_{n}, Y_{n}\right)\)&lt;/span>是一个样本 , 对应的样本值记为&lt;span class="math inline">\(\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{n}, y_{n}\right)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>注意：这里 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 是相互独立的随机变量,但一般未必同分布，为方便计,也称 &lt;span class="math inline">\(\left(x_{1}, Y_{1}\right),\left(x_{2},\right.\)&lt;/span> &lt;span class="math inline">\(\left.Y_{2}\right), \cdots,\left(x_{n}, Y_{n}\right)\)&lt;/span> 是一个样本.&lt;/p>
&lt;/blockquote>
&lt;p>我们首先要解决的问题是如何利用样本来估计 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的回归函数 &lt;span class="math inline">\(\mu(x) .\)&lt;/span> 为此,首先需要推测 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 的形式. 在一些问题中,我们可以由专业知识知道 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 的形式. 否则 &lt;span class="math inline">\(,\)&lt;/span> 可将每对观察值 &lt;span class="math inline">\(\left(x_{i}, y_{i}\right)\)&lt;/span> 在直角坐标系中描出它的相应的点(如下例子图所示)，这种图称为&lt;strong>散点图&lt;/strong>. 散点图可以帮助我们粗略地看出 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 的 形式.&lt;/p>
&lt;blockquote>
&lt;p>例子： 为研究某一化学反应过程中,温度 &lt;span class="math inline">\(x\left({ }^{\circ} \mathrm{C}\right)\)&lt;/span> 对产品得率 &lt;span class="math inline">\(Y(\%)\)&lt;/span> 的影响，测得数据如下： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225112853528.png" alt="image-20201225112853528" /> 这里自变量 &lt;span class="math inline">\(x\)&lt;/span> 是普通变量, &lt;span class="math inline">\(Y\)&lt;/span> 是随机变 量.画出散点图如下图所示. 由图大致看出 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 具有线性函数 &lt;span class="math inline">\(a+b x\)&lt;/span> 的形 式. &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225112557356.png" alt="image-20201225112557356" />&lt;/p>
&lt;/blockquote>
&lt;p>设 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的回归函数为 &lt;span class="math inline">\(\mu(x) .\)&lt;/span> 利 用样本来估计 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 的问题称为求 &lt;span class="math inline">\(Y\)&lt;/span> 关 于 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>回归问题&lt;/strong>. 特别,若 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 为线性 函数 &lt;span class="math inline">\(: \mu(x)=a+b x,\)&lt;/span> 此时估计 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 的 问题称为求&lt;strong>一元线性回归问题&lt;/strong>. 本节只讨论这个问题.&lt;/p>
&lt;p>我们假设对于 &lt;span class="math inline">\(x\)&lt;/span> (在某个区间内) 的每一个值有&lt;span class="math inline">\(Y \sim N\left(a+b x, \sigma^{2}\right)\)&lt;/span>， 其中 &lt;span class="math inline">\(a, b\)&lt;/span> 及 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 都是不依赖于 &lt;span class="math inline">\(x\)&lt;/span> 的未知参数. 记 &lt;span class="math inline">\(\varepsilon=Y-(a+b x)\)&lt;/span>,对 &lt;span class="math inline">\(Y\)&lt;/span> 作这样的正态假设,相当于假设： &lt;span class="math inline">\(Y=a+b x+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>， 其中未知参数 &lt;span class="math inline">\(a, b\)&lt;/span> 及 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 都不依赖于 &lt;span class="math inline">\(x .\)&lt;/span> (3. 2 ) 称为&lt;strong>一元线性回归模型&lt;/strong>,其中 &lt;span class="math inline">\(b\)&lt;/span> 称为&lt;strong>回归系数&lt;/strong>.&lt;/p>
&lt;p>上面的一元线性回归模型表明，因变量 &lt;span class="math inline">\(Y\)&lt;/span> 由两部分组成,一部分是 &lt;span class="math inline">\(x\)&lt;/span> 的线性函数 &lt;span class="math inline">\(a+b x,\)&lt;/span> 另一部分 &lt;span class="math inline">\(\varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span> 是随机误差,是人们不可控制的.&lt;/p>
&lt;h3 id="a-b-的估计">&lt;span class="math inline">\(a, b\)&lt;/span> 的估计&lt;/h3>
&lt;p>现用&lt;strong>最大似然估计法来估计未知参数 &lt;span class="math inline">\(a, b .\)&lt;/span>&lt;/strong>&lt;/p>
&lt;p>取 &lt;span class="math inline">\(x\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个不全相同的值 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 作独立试验,得到样本 &lt;span class="math inline">\(\left(x_{1}, Y_{1}\right),\left(x_{2},\right.\left.Y_{2}\right), \cdots,\left(x_{n}, Y_{n}\right) .\)&lt;/span> 由一元线性回归模型得&lt;span class="math inline">\(Y_{i}=a+b x_{i}+\varepsilon_{i}, \varepsilon_{i} \sim N\left(0, \sigma^{2}\right),\)&lt;/span> 各 &lt;span class="math inline">\(\varepsilon_{i}\)&lt;/span> 相互独立. 也即 &lt;span class="math inline">\(Y_{i} \sim N\left(a+b x_{i}, \sigma^{2}\right), i=1,2, \cdots, n .\)&lt;/span>&lt;/p>
&lt;p>由 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 的独立性, 知 &lt;span class="math inline">\(Y_{1},\)&lt;/span>&lt;span class="math inline">\(Y_{2}, \cdots, Y_{n}\)&lt;/span> 的联合密度为： &lt;span class="math inline">\(\begin{aligned} L &amp;amp;=\prod_{i=1}^{n} \frac{1}{\sigma \sqrt{2 \pi}} \exp \left[-\frac{1}{2 \sigma^{2}}\left(y_{i}-a-b x_{i}\right)^{2}\right] \\ &amp;amp;=\left(\frac{1}{\sigma \sqrt{2 \pi}}\right)^{n} \exp \left[-\frac{1}{2 \sigma^{2}} \sum_{i=1}^{n}\left(y_{i}-a-b x_{i}\right)^{2}\right] \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>对于任意一组观察值 &lt;span class="math inline">\(y_{1}, y_{2}, \cdots, y_{n},\)&lt;/span> 联合密度函数L就是样本的似然函数. 显然,要 &lt;span class="math inline">\(L\)&lt;/span> 取最大值,只要L式右端方括弧中的平方和部分为最小,即&lt;strong>只需函数&lt;span class="math inline">\(Q(a, b)=\sum_{i=1}^{n}\left(y_{i}-a-b x_{i}\right)^{2}\)&lt;/span>取最小值&lt;/strong>。 取 &lt;span class="math inline">\(Q\)&lt;/span> 分别关于 &lt;span class="math inline">\(a, b\)&lt;/span> 的偏导数,并令它们等于零： &lt;span class="math inline">\(\left.\begin{array}{l}\frac{\partial Q}{\partial a}=-2 \sum_{i=1}^{n}\left(y_{i}-a-b x_{i}\right)=0 \\ \frac{\partial Q}{\partial b}=-2 \sum_{i=1}^{n}\left(y_{i}-a-b x_{i}\right) x_{i}=0\end{array}\right\}\)&lt;/span> 得方程组（称为正规方程组）： &lt;span class="math inline">\(\left\{\begin{array}{l}n a+\left(\sum_{i=1}^{n} x_{i}\right) b=\sum_{i=1}^{n} y_{i} \\ \left(\sum_{i=1}^{n} x_{i}\right) a+\left(\sum_{i=1}^{n} x_{i}^{2}\right) b=\sum_{i=1}^{n} x_{i} y_{i}\end{array}\right.\)&lt;/span> 由于 &lt;span class="math inline">\(x_{i}\)&lt;/span> 不全相同,正规方程组的系数行列式： &lt;span class="math inline">\(\left|\begin{array}{cc}n &amp;amp; \sum_{i=1}^{n} x_{i} \\ \sum_{i=1}^{n} x_{i} &amp;amp; \sum_{i=1}^{n} x_{i}^{2}\end{array}\right|=n \sum_{i=1}^{n} x_{i}^{2}-\left(\sum_{i=1}^{n} x_{i}\right)^{2}=n \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2} \neq 0\)&lt;/span> 于是正规方程组有唯一的一组解. 解得 &lt;span class="math inline">\(b, a\)&lt;/span> 的最大似然估计值为 &lt;span class="math inline">\(\left.\begin{array}{l}\hat{b}=\frac{n \sum_{i=1}^{n} x_{i} y_{i}-\left(\sum_{i=1}^{n} x_{i}\right)\left(\sum_{i=1}^{n} y_{i}\right)}{n \sum_{i=1}^{n} x_{i}^{2}-\left(\sum_{i=1}^{n} x_{i}\right)^{2}}=\frac{\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)}{\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}} \\ \hat{a}=\frac{1}{n} \sum_{i=1}^{n} y_{i}-\frac{\hat{b}}{n} \sum_{i=1}^{n} x_{i}=\bar{y}-\hat{b} \bar{x}\end{array}\right\}\)&lt;/span> 其中 &lt;span class="math inline">\(\bar{x}=\frac{1}{n} \sum_{i=1}^{n} x_{i}, \quad \bar{y}=\frac{1}{n} \sum_{i=1}^{n} y_{i}\)&lt;/span>&lt;/p>
&lt;p>为了理解和计算的方便，引入以下记号： &lt;span class="math inline">\(\left.\begin{array}{l}S_{x x}=\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}=\sum_{i=1}^{n} x_{i}^{2}-\frac{1}{n}\left(\sum_{i=1}^{n} x_{i}\right)^{2} \\ S_{y y}=\sum_{i=1}^{n}\left(y_{i}-\bar{y}\right)^{2}=\sum_{i=1}^{n} y_{i}^{2}-\frac{1}{n}\left(\sum_{i=1}^{n} y_{i}\right)^{2} \\ S_{x y}=\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)=\sum_{i=1}^{n} x_{i} y_{i}-\frac{1}{n}\left(\sum_{i=1}^{n} x_{i}\right)\left(\sum_{i=1}^{n} y_{i}\right)\end{array}\right\}\)&lt;/span> 这样a，b的估计可以简记为： &lt;span class="math inline">\(\left.\begin{array}{l}\hat{b}=\frac{S_{x y}}{S_{x x}} \\ \hat{a}=\bar{y}-\hat{b} \bar{x}\end{array}\right\}\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>注意：如果 Y不且正态变量,可直接用&lt;span class="math inline">\(Q(a, b)=\sum_{i=1}^{n}\left(y_{i}-a-b x_{i}\right)^{2}\)&lt;/span>估计 &lt;span class="math inline">\(a, b,\)&lt;/span> 使 &lt;span class="math inline">\(Y\)&lt;/span> 的观察值 &lt;span class="math inline">\(y_{i}\)&lt;/span> 与 &lt;span class="math inline">\(a+b x_{i}\)&lt;/span> 偏差的平方和 &lt;span class="math inline">\(Q (a,b)\)&lt;/span>为最小.这种方法叫&lt;strong>最小二乘法&lt;/strong>,它是求经验公式的一种常用方法. 若 &lt;span class="math inline">\(Y\)&lt;/span> 是正态变量,则最小二乘法与最大似然估计法给出相同的结果.&lt;/p>
&lt;/blockquote>
&lt;p>在得到 &lt;span class="math inline">\(a, b\)&lt;/span> 的估计 &lt;span class="math inline">\(\hat{a}, \hat{b}\)&lt;/span> 后，对于给定的 &lt;span class="math inline">\(x,\)&lt;/span> 我们就取 &lt;span class="math inline">\(\hat{a}+\hat{b} x\)&lt;/span> 作为回归函数 &lt;span class="math inline">\(\mu(x)=a+b x\)&lt;/span> 的估计, 即 &lt;span class="math inline">\(\mu(x)=\hat{a}+\hat{b} x\)&lt;/span>,称为 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>经验回归函数&lt;/strong>. 记 &lt;span class="math inline">\(\hat{a}+\hat{b} x\)&lt;/span> &lt;span class="math inline">\(=\hat{y},\)&lt;/span> 方程&lt;span class="math inline">\(\hat{y}=\hat{a}+\hat{b} x\)&lt;/span>称为 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>经验回归方程&lt;/strong>,简称&lt;strong>回归方程&lt;/strong>,其图形称为&lt;strong>回归直线&lt;/strong>.&lt;/p>
&lt;p>将 &lt;span class="math inline">\(\hat{a}\)&lt;/span> 的表达式代入&lt;span class="math inline">\(\hat{y}=\hat{a}+\hat{b} x\)&lt;/span>,则回归方程可写成&lt;span class="math inline">\(\hat{y}=\bar{y}+\hat{b}(x-\bar{x})\)&lt;/span>， 这表明,对于样本值 &lt;span class="math inline">\(\left(x_{1}, y_{1}\right),\left(x_{2}, y_{2}\right), \cdots,\left(x_{n}, y_{n}\right),\)&lt;/span> 回归直线通过散点图的几何中心 &lt;span class="math inline">\((\bar{x}, \bar{y})\)&lt;/span>.&lt;/p>
&lt;h3 id="sigma2-的估计">&lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的估计&lt;/h3>
&lt;p>由&lt;span class="math inline">\(Y=a+b x+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>可知： &lt;span class="math inline">\(E\left\{[Y-(a+b x)]^{2}\right\}=E\left(\varepsilon^{2}\right)=D(\varepsilon)+[E(\varepsilon)]^{2}=\sigma^{2}\)&lt;/span>&lt;/p>
&lt;p>这表示 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 愈小,以回归函数 &lt;span class="math inline">\(\mu(x)=a+b x\)&lt;/span> 作为 &lt;span class="math inline">\(Y\)&lt;/span> 的近似导致的均方误差就愈小. 这样,利用回归函数 &lt;span class="math inline">\(\mu(x)=a+b x\)&lt;/span> 去研究随机变量 &lt;span class="math inline">\(Y\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的关系就愈有效. 然而 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 是未知的,因而我们需要利用样本去估计 &lt;span class="math inline">\(\sigma^{2} .\)&lt;/span> 为了估计 &lt;span class="math inline">\(\sigma^{2},\)&lt;/span> 先引入下述残差平方和.&lt;/p>
&lt;p>记 &lt;span class="math inline">\(\hat{y}_{i}=\left.\hat{y}\right|_{x=x_{i}}=\hat{a}+\hat{b} x_{i},\)&lt;/span> 称&lt;span class="math inline">\(y_{i}-\hat{y}_{i}\)&lt;/span> 为 &lt;span class="math inline">\(x_{i}\)&lt;/span> 处的&lt;strong>残差&lt;/strong>. 平方和&lt;span class="math inline">\(Q_{e}=\sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}=\sum_{i=1}^{n}\left(y_{i}-\hat{a}-\hat{b} x_{i}\right)^{2}\)&lt;/span>称为&lt;strong>残差平方和&lt;/strong>. 它是经验回归函数在 &lt;span class="math inline">\(x_{i}\)&lt;/span> 处的函数值 &lt;span class="math inline">\(\mu\left(x_{i}\right)=\hat{a}+\hat{b} x_{i}\)&lt;/span> 与 &lt;span class="math inline">\(x_{i}\)&lt;/span> 处的观察值 &lt;span class="math inline">\(y_{i}\)&lt;/span> 的 偏差的平方和. &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225124345680.png" alt="image-20201225124345680" /> 为了计算 &lt;span class="math inline">\(Q_{e},\)&lt;/span> 我们将 &lt;span class="math inline">\(Q_{e}\)&lt;/span> 作如下的分解 : &lt;span class="math inline">\(\begin{aligned} Q_{e}=&amp;amp; \sum_{i=1}^{n}\left(y_{i}-\hat{y}_{i}\right)^{2}=\sum_{i=1}^{n}\left[y_{i}-\bar{y}-\hat{b}\left(x_{i}-\bar{x}\right)\right]^{2} \\=&amp;amp; \sum_{i=1}^{n}\left(y_{i}-\bar{y}\right)^{2}-2 \hat{b} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right) \\ &amp;amp;+(\hat{b})^{2} \sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)^{2}=S_{y y}-2 \hat{b} S_{x y}+(\hat{b})^{2} S_{x x} \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>由b的估计&lt;span class="math inline">\(\left.\begin{array}{l}\hat{b}=\frac{S_{x y}}{S_{x x}} \\ \hat{a}=\bar{y}-\hat{b} \bar{x}\end{array}\right\}\)&lt;/span>，将&lt;span class="math inline">\(\hat{b}\)&lt;/span>代入&lt;span class="math inline">\(Q_e\)&lt;/span>得：&lt;/p>
&lt;p>&lt;span class="math inline">\(Q_{e}=S_{y y}-\hat{b} S_{x y}\)&lt;/span>&lt;/p>
&lt;p>在 &lt;span class="math inline">\(S_{x y}, S_{x y}\)&lt;/span> 的表达式式中,将 &lt;span class="math inline">\(y_{i}\)&lt;/span> 改为 &lt;span class="math inline">\(Y_{i}\)&lt;/span>&lt;span class="math inline">\((i=1,2, \cdots, n),\)&lt;/span> 并把它们分别记为 &lt;span class="math inline">\(S_{Y Y}, S_{x Y},\)&lt;/span> 即&lt;span class="math inline">\(S_{Y Y}=\sum_{i=1}^{n}\left(Y_{i}-\bar{Y}\right)^{2}, S_{x Y}=\sum_{i=1}^{n}\left(x_{i}-\bar{x}\right)\left(Y_{i}-\bar{Y}\right)\)&lt;/span>&lt;/p>
&lt;p>则残差平方和 &lt;span class="math inline">\(Q_{e}\)&lt;/span> 的相应的统计量(仍记为 &lt;span class="math inline">\(\left.Q_{e}\right)\)&lt;/span> 为&lt;span class="math inline">\(Q_{e}=S_{Y Y}-\hat{b} S_{x Y}\)&lt;/span>&lt;/p>
&lt;p>残差平方和 &lt;span class="math inline">\(Q_{e}\)&lt;/span> 服从分布&lt;span class="math inline">\(\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>， 于是&lt;span class="math inline">\(E\left(\frac{Q_{e}}{\sigma^{2}}\right)=n-2\)&lt;/span> 即知 &lt;span class="math inline">\(E\left(Q_{e} /(n-2)\right)=\sigma^{2} .\)&lt;/span> 这样就得到了 &lt;span class="math inline">\(\sigma^{2}\)&lt;/span> 的无偏估计量 :&lt;span class="math inline">\(\widehat{\sigma}^{2}=\frac{Q_{e}}{n-2}=\frac{1}{n-2}\left(S_{Y Y}-\hat{b} S_{x Y}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="线性假设的显著性检验">线性假设的显著性检验&lt;/h3>
&lt;p>在以上的讨论中,我们假定 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的回归 &lt;span class="math inline">\(\mu(x)\)&lt;/span> 具有形式 &lt;span class="math inline">\(a+b x\)&lt;/span>, 在处理实际问题时 &lt;span class="math inline">\(, \mu(x)\)&lt;/span> 是否为 &lt;span class="math inline">\(x\)&lt;/span> 的线性函数,首先要根据有关专业知识和实践来判断， 其次就要根据实际观察得到的数据运用假设检验的方法来判断. 这就是说,求得的线性回归方程是否具有实用价值,一般来说,需要经过假设检验才能确定. 若线性假设&lt;span class="math inline">\(Y=a+b x+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>符合实际,则 &lt;span class="math inline">\(b\)&lt;/span> 不应为零,因为若 &lt;span class="math inline">\(b=0,\)&lt;/span> 则 &lt;span class="math inline">\(E(Y)=\mu(x)\)&lt;/span> 就不依赖于 &lt;span class="math inline">\(x\)&lt;/span> 了. 因此我们需要检验假设&lt;span class="math inline">\(\begin{array}{ll}H_{0}: &amp;amp; b=0 \\ H_{1}: &amp;amp; b \neq 0\end{array}\)&lt;/span>， 我们使用 &lt;span class="math inline">\(t\)&lt;/span> 检验法来进行检验. 我们有&lt;span class="math inline">\(\hat{b} \sim N\left(b, \sigma^{2} / S_{x x}\right)\)&lt;/span>。 又由&lt;span class="math inline">\(\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>，&lt;span class="math inline">\(\hat{\sigma}^{2}=\frac{Q_{e}}{n-2}=\frac{1}{n-2}\left(S_{Y Y}-\hat{b} S_{x Y}\right)\)&lt;/span>， 知&lt;span class="math inline">\(\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}}=\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>&lt;/p>
&lt;p>且 &lt;span class="math inline">\(\hat{b}\)&lt;/span> 与 &lt;span class="math inline">\(Q_{e}\)&lt;/span> 独立，故有&lt;span class="math inline">\(\frac{\hat{b}-b}{\sqrt{\sigma^{2} / S_{x x}}} / \sqrt{\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}} /(n-2)} \sim t(n-2)\)&lt;/span> 即&lt;span class="math inline">\(\frac{\hat{b}-b}{\hat{\sigma}} \sqrt{S_{x x}} \sim t(n-2)\)&lt;/span>&lt;/p>
&lt;p>当 &lt;span class="math inline">\(H_{0}\)&lt;/span> 为真时 &lt;span class="math inline">\(b=0,\)&lt;/span> 此时&lt;span class="math inline">\(t=\frac{\hat{b}}{\hat{\sigma}} \sqrt{S_{x x}} \sim t(n-2)\)&lt;/span>。 且 &lt;span class="math inline">\(E(\hat{b})=b=0,\)&lt;/span> 即得 &lt;span class="math inline">\(H_{0}\)&lt;/span> 的&lt;strong>拒绝域&lt;/strong>为&lt;span class="math inline">\(|t|=\frac{|\hat{b}|}{\hat{\sigma}} \sqrt{S_{x x}} \geqslant t_{a / 2}(n-2)\)&lt;/span>，此处 &lt;span class="math inline">\(\alpha\)&lt;/span> 为显著性水平.&lt;/p>
&lt;p>当假设 &lt;span class="math inline">\(H_{0}: b=0\)&lt;/span> 被拒绝时,认为回归效果是显著的,反之,就认为回归效果 不显著. 回归效果不显著的原因可能有如下几种： &lt;span class="math inline">\(1^{\circ}\)&lt;/span> 影响 &lt;span class="math inline">\(Y\)&lt;/span> 取值的,除 &lt;span class="math inline">\(x\)&lt;/span> 及随机误差外还有其他不可忽略的因素. &lt;span class="math inline">\(2^{\circ} E(Y)\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 的关系不是线性的,而存在着其他的关系. &lt;span class="math inline">\(3^{\circ} Y\)&lt;/span> 与 &lt;span class="math inline">\(x\)&lt;/span> 不存在关系.&lt;/p>
&lt;p>因此需要进一步的分析原因,分别处理.&lt;/p>
&lt;h3 id="系数-b-的置信区间">系数 &lt;span class="math inline">\(b\)&lt;/span> 的置信区间&lt;/h3>
&lt;p>当回归效果显著时,我们常需要对系数 &lt;span class="math inline">\(b\)&lt;/span> 作区间估计. 事实上,可由&lt;span class="math inline">\(\frac{\hat{b}-b}{\hat{\sigma}} \sqrt{S_{x x}} \sim t(n-2)\)&lt;/span>得到 &lt;span class="math inline">\(b\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为&lt;span class="math inline">\(\left(\hat{b} \pm t_{a / 2}(n-2) \times \frac{\hat{\sigma}}{\sqrt{S_{x x}}}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="回归函数-muxab-x-函数值的点估计和置信区间">回归函数 &lt;span class="math inline">\(\mu(x)=a+b x\)&lt;/span> 函数值的点估计和置信区间&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(x_{0}\)&lt;/span> 是自变量 &lt;span class="math inline">\(x\)&lt;/span> 的某一指定值. 根据回归方程&lt;span class="math inline">\(\hat{y}=\hat{a}+\hat{b} x\)&lt;/span>，可以用经验回归函数 &lt;span class="math inline">\(\hat{y}=\widehat{\mu(x)}\)&lt;/span> &lt;span class="math inline">\(=\hat{a}+\hat{b} x\)&lt;/span> 在 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的函数值 &lt;span class="math inline">\(\left.\hat{y}_{0}=\mu \widehat{\left(x_{0}\right.}\right)=\hat{a}+\hat{b} x_{0}\)&lt;/span> 作为 &lt;span class="math inline">\(\mu\left(x_{0}\right)=a+b x_{0}\)&lt;/span> 的点估计. 即&lt;span class="math inline">\(\hat{y}_{0}=\mu\left(x_{0}\right)=\hat{a}+\hat{b} x_{0}\)&lt;/span>, 考虑相应的估计量&lt;span class="math inline">\(\hat{Y}_{0}=\hat{a}+\hat{b} x_{0}\)&lt;/span>， 由&lt;span class="math inline">\(\hat{Y}_{0}=\hat{a}+\hat{b} x_{0}=\bar{Y}+\hat{b}\left(x_{0}-\bar{x}\right) \sim N\left(a+b x_{0},\left[\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x r}}\right] \sigma^{2}\right)\)&lt;/span>， 知&lt;span class="math inline">\(E\left(\hat{Y}_{0}\right)=a+b x_{0},\)&lt;/span> 因此这一估计量是无偏的.&lt;/p>
&lt;p>下面来求 &lt;span class="math inline">\(\mu\left(x_{0}\right)\)&lt;/span>&lt;span class="math inline">\(=a+b x_{0}\)&lt;/span> 的置信区间. 由&lt;span class="math inline">\(\hat{Y}_{0}=\hat{a}+\hat{b} x_{0}=\bar{Y}+\hat{b}\left(x_{0}-\bar{x}\right) \sim N\left(a+b x_{0},\left[\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x r}}\right] \sigma^{2}\right)\)&lt;/span>， 知&lt;span class="math inline">\(\frac{\hat{Y}_{0}-\left(a+b x_{0}\right)}{\sigma \sqrt{\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} \sim N(0,1)\)&lt;/span>&lt;/p>
&lt;p>由&lt;span class="math inline">\(\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>，&lt;span class="math inline">\(\hat{\sigma}^{2}=\frac{Q_{e}}{n-2}=\frac{1}{n-2}\left(S_{Y Y}-\hat{b} S_{x Y}\right)\)&lt;/span>， 知&lt;span class="math inline">\(\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}}=\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>&lt;/p>
&lt;p>若 &lt;span class="math inline">\(Y_{0}=a+b x_{0}+\varepsilon_{0}\)&lt;/span> 与 &lt;span class="math inline">\(Y_{1}, \cdots, Y_{n}\)&lt;/span> 独立,则 &lt;span class="math inline">\(Y_{0}, \hat{Y}_{0}, Q_e\)&lt;/span> 相互独立. 由上述结论知 &lt;span class="math inline">\(Q_{e}, \hat{Y}_{0}\)&lt;/span> 相互独立. 于是&lt;span class="math inline">\(\frac{\hat{Y}_{0}-\left(a+b x_{0}\right)}{\sigma \sqrt{\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} / \sqrt{\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}} /(n-2)} \sim t(n-2)\)&lt;/span> 即&lt;span class="math inline">\(\frac{\hat{Y}_{0}-\left(a+b x_{0}\right)}{\hat{\sigma} \sqrt{\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} \sim t(n-2)\)&lt;/span>&lt;/p>
&lt;p>于是得到 &lt;span class="math inline">\(\mu\left(x_{0}\right)=a+b x_{0}\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的置信区间为&lt;span class="math inline">\(\left(\hat{Y}_{0} \pm t_{\alpha / 2}(n-2) \hat{\sigma} \sqrt{\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}\right)\)&lt;/span>, 或即&lt;span class="math inline">\(\left(\hat{a}+\hat{b} x_{0} \pm t_{a / 2}(n-2) \hat{\sigma} \sqrt{\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}\right)\)&lt;/span> 这一置信区间的长度是 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的函数,它随 &lt;span class="math inline">\(\left|x_{0}-\bar{x}\right|\)&lt;/span> 的增加而增加 &lt;span class="math inline">\(,\)&lt;/span> 当 &lt;span class="math inline">\(x_{0}=\bar{x}\)&lt;/span> 时为 最短.&lt;/p>
&lt;h3 id="y-的观察值的点预测和预测区间">&lt;span class="math inline">\(Y\)&lt;/span> 的观察值的点预测和预测区间&lt;/h3>
&lt;p>若我们对指定点 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 处因变量 &lt;span class="math inline">\(Y\)&lt;/span> 的观察值 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 感兴趣,然而我们在 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 处并未进行观察或者暂时无法观察. 经验回归函数的一个重要应用是,可利用它对因变量 &lt;span class="math inline">\(Y\)&lt;/span> 的新观察值 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 进行点预测或区间预测. 若 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 是在 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 处对 &lt;span class="math inline">\(Y\)&lt;/span> 的观察结果,可知它满足 :&lt;span class="math inline">\(Y_{0}=a+b x_{0}+\varepsilon_{0}, \quad \varepsilon_{0} \sim N\left(0, \sigma^{2}\right)\)&lt;/span> 随机误差 &lt;span class="math inline">\(\varepsilon_{0}\)&lt;/span> 可正也可负,其值无法预料,我们就用 &lt;span class="math inline">\(x_{0}\)&lt;/span> 处的经验回归函数值&lt;span class="math inline">\(\hat{Y}_{0}=\mu\left(x_{0}\right)=\hat{a}+\hat{b} x_{0}\)&lt;/span>作为 &lt;span class="math inline">\(Y_{0}=a+b x_{0}+\varepsilon_{0}\)&lt;/span> 的点预测.&lt;/p>
&lt;p>下面来求 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 的预测区间.&lt;/p>
&lt;p>因 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 是将要做的一次独立试验的结果,因此它与已经得到的试验的结果&lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 相互独立. 由这样a，b的估计&lt;span class="math inline">\(\left.\begin{array}{l}\hat{b}=\frac{S_{x y}}{S_{x x}} \\ \hat{a}=\bar{y}-\hat{b} \bar{x}\end{array}\right\}\)&lt;/span>知 &lt;span class="math inline">\(\hat{b}\)&lt;/span> 是 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 的线性组合, 故 &lt;span class="math inline">\(\hat{Y}_{0}=\)&lt;/span>&lt;span class="math inline">\(\bar{Y}+\hat{b}\left(x_{0}-\bar{x}\right)\)&lt;/span> 是 &lt;span class="math inline">\(Y_{1}, Y_{2}, \cdots, Y_{n}\)&lt;/span> 的线性组合,故 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 与 &lt;span class="math inline">\(\hat{Y}_{0}\)&lt;/span> 相互独立. 由 &lt;span class="math inline">\(Y_{0}=a+b x_{0}+\varepsilon_{0}, \quad \varepsilon_{0} \sim N\left(0, \sigma^{2}\right)\)&lt;/span>和&lt;span class="math inline">\(\hat{Y}_{0}=\hat{a}+\hat{b} x_{0}=\bar{Y}+\hat{b}\left(x_{0}-\bar{x}\right) \sim N\left(a+b x_{0},\left[\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{s x}}\right] \sigma^{2}\right)\)&lt;/span>, 得&lt;span class="math inline">\(\hat{Y}_{0}-Y_{0} \sim N\left(0,\left[1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}\right] \sigma^{2}\right)\)&lt;/span>， 即&lt;span class="math inline">\(\frac{\hat{Y}_{0}-Y_{0}}{\sigma \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} \sim N(0,1)\)&lt;/span>&lt;/p>
&lt;p>再由&lt;span class="math inline">\(\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}}=\frac{Q_{e}}{\sigma^{2}} \sim \chi^{2}(n-2)\)&lt;/span>，及 &lt;span class="math inline">\(Y_{0}, \hat{Y}_{0}, Q_{.}\)&lt;/span> 的相互独立性 知&lt;span class="math inline">\(\frac{\hat{Y}_{0}-Y_{0}}{\sigma \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} / \sqrt{\frac{(n-2) \hat{\sigma}^{2}}{\sigma^{2}} /(n-2)} \sim t(n-2)\)&lt;/span> 即&lt;span class="math inline">\(\frac{\hat{Y}_{0}-Y_{0}}{\hat{\sigma} \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} \sim t(n-2)\)&lt;/span>&lt;/p>
&lt;p>于是对于给定的置信水平 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 有&lt;span class="math inline">\(P\left\{\frac{\left|\hat{Y}_{0}-Y_{0}\right|}{\hat{\sigma} \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}} \leqslant t_{a / 2}(n-2)\right\}=1-\alpha\)&lt;/span> 或&lt;span class="math inline">\(P\left\{\hat{Y}_{0}-t_{a / 2}(n-2) \hat{\sigma} \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}&amp;lt;Y_{0}\right.\)&lt;/span>&lt;span class="math inline">\(\left.&amp;lt;\hat{Y}_{0}+t_{a / 2}(n-2) \hat{\sigma} \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}\right\}=1-\alpha\)&lt;/span>&lt;/p>
&lt;p>则区间&lt;span class="math inline">\(\left(\hat{Y}_{0} \pm t_{a / 2}(n-2) \hat{\sigma} \sqrt{1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}}\right)\)&lt;/span>， 即&lt;span class="math inline">\(\left(\hat{a}+\hat{b} x_{0} \pm t_{a / 2}(n-2) \hat{\sigma} \sqrt{\left.1+\frac{1}{n}+\frac{\left(x_{0}-\bar{x}\right)^{2}}{S_{x x}}\right)}\right.\)&lt;/span>称为&lt;span class="math inline">\(Y_{0}\)&lt;/span> 的置信水平为 &lt;span class="math inline">\(1-\alpha\)&lt;/span> 的预测区间.&lt;/p>
&lt;p>这一预测区间的长度是 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的函数,它随 &lt;span class="math inline">\(\left|x_{0}-\bar{x}\right|\)&lt;/span> 的增加而增加. 当 &lt;span class="math inline">\(x_{0}=\bar{x}\)&lt;/span> 时为最短. 将上面得区间与回归函数&lt;span class="math inline">\(\mu\left(x_{0}\right)=a+b x_{0}\)&lt;/span> 的置信区间比较， 知道在相同的置信水平下,回归函数值 &lt;span class="math inline">\(\mu\left(x_{0}\right)\)&lt;/span> 的置信区间要比 &lt;span class="math inline">\(Y_{0}\)&lt;/span> 的预测区间要 短. 这是因为 &lt;span class="math inline">\(Y_{0}=a+b x_{0}+\varepsilon_{0}\)&lt;/span> 比 &lt;span class="math inline">\(\mu\left(x_{0}\right)=a+b x_{0}\)&lt;/span> 多了一项 &lt;span class="math inline">\(\varepsilon_{0}\)&lt;/span> 的缘故.&lt;/p>
&lt;h3 id="可化为一元线性回归的例子">可化为一元线性回归的例子&lt;/h3>
&lt;p>以上讨论了一元线性回归问题,在实际中常会遇到更为复杂的回归问题,但 在某些情况下,可以通过适当的变量变换,可以将它化成一元线性回归来处理. 下面介绍几种常见的可转化为一元线性回归的模型.&lt;/p>
&lt;h4 id="yalpha-mathrmebeta-x-cdot-varepsilon-quad-ln-varepsilon-sim-nleft0-sigma2right">&lt;span class="math inline">\(Y=\alpha \mathrm{e}^{\beta x} \cdot \varepsilon, \quad \ln \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/h4>
&lt;p>其中 &lt;span class="math inline">\(\alpha, \beta, \sigma^{2}\)&lt;/span> 是与 &lt;span class="math inline">\(x\)&lt;/span> 无关的未知参数.&lt;/p>
&lt;p>将 &lt;span class="math inline">\(Y=\alpha \mathrm{e}^{-\beta x} \cdot \varepsilon\)&lt;/span> 两边取对数,得&lt;span class="math inline">\(\ln Y=\ln \alpha+\beta x+\ln \varepsilon\)&lt;/span> 令 &lt;span class="math inline">\(\ln Y=Y^{\prime}, \ln \alpha=a, \beta=b, x=x^{\prime}, \ln \varepsilon=\varepsilon^{\prime},\)&lt;/span> 上面的对数式可转化为一元线性回归模型：&lt;span class="math inline">\(Y^{\prime}=a+b x^{\prime}+\varepsilon^{\prime}, \quad \varepsilon^{\prime} \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="yalpha-xbeta-cdot-varepsilon-quad-ln-varepsilon-sim-nleft0-sigma2right">&lt;span class="math inline">\(Y=\alpha x^{\beta} \cdot \varepsilon, \quad \ln \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/h4>
&lt;p>其中 &lt;span class="math inline">\(\alpha, \beta, \sigma^{2}\)&lt;/span> 是与 &lt;span class="math inline">\(x\)&lt;/span> 无关的未知参数.&lt;/p>
&lt;p>将 &lt;span class="math inline">\(Y=\alpha x^{\beta} \cdot \varepsilon\)&lt;/span> 两边取对数,得&lt;span class="math inline">\(\ln Y=\ln \alpha+\beta \ln x+\ln \varepsilon\)&lt;/span> 令 &lt;span class="math inline">\(\ln Y=Y^{\prime}, \ln \alpha=a, \beta=b, \ln x=x^{\prime}, \ln \varepsilon=\varepsilon^{\prime},\)&lt;/span> 上面的对数式可转化为一元线性回归模型：&lt;span class="math inline">\(Y^{\prime}=a+b x^{\prime}+\varepsilon^{\prime}, \quad \varepsilon^{\prime} \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="yalphabeta-hxvarepsilon-quad-varepsilon-sim-nleft0-sigma2right">&lt;span class="math inline">\(Y=\alpha+\beta h(x)+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/h4>
&lt;p>其中 &lt;span class="math inline">\(\alpha, \beta, \sigma^{2}\)&lt;/span> 是与 &lt;span class="math inline">\(x\)&lt;/span> 无关的未知参数. &lt;span class="math inline">\(h(x)\)&lt;/span> 是 &lt;span class="math inline">\(x\)&lt;/span> 的已知函数 &lt;span class="math inline">\(,\)&lt;/span> 令 &lt;span class="math inline">\(\alpha=a, \beta=b, h(x)\)&lt;/span> &lt;span class="math inline">\(=x^{\prime},\)&lt;/span> 可转化为一元线性回归模型：&lt;span class="math inline">\(Y=a+b x^{\prime}+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>&lt;/p>
&lt;p>若在原模型下，例如在原模型 下，对于 &lt;span class="math inline">\((x, Y)\)&lt;/span> 有样本 &lt;span class="math inline">\(\left(x_{1}, y_{1}\right),\left(x_{2},\right.\)&lt;/span> &lt;span class="math inline">\(\left.y_{2}\right), \cdots,\left(x_{n}, y_{n}\right)\)&lt;/span> 就相当于在新模型下有样本 &lt;span class="math inline">\(\left(x_{1}^{\prime}, y_{1}\right),\left(x_{2}^{\prime}, y_{2}\right), \cdots,\left(x_{n}^{\prime},\right.\)&lt;/span>&lt;span class="math inline">\(\left.y_{n}\right),\)&lt;/span> 其中 &lt;span class="math inline">\(x_{i}^{\prime}=h\left(x_{i}\right) .\)&lt;/span> 于是就能利用上节的方法来估计 &lt;span class="math inline">\(a, b\)&lt;/span> 或对 &lt;span class="math inline">\(b\)&lt;/span> 作假设检验,或对 &lt;span class="math inline">\(Y\)&lt;/span> 进行预测. 在得到 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x^{\prime}\)&lt;/span> 的回归方程后,再将原自变量 &lt;span class="math inline">\(x\)&lt;/span> 代回,就得到&lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的回归方程,它的图形是一条曲线,也称为&lt;strong>曲线回归方程&lt;/strong>.&lt;/p>
&lt;p>之前所讨论的&lt;strong>一元线性回归模型&lt;/strong>是&lt;span class="math inline">\(Y=a+b x+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>。 一般情况,&lt;strong>一元回归模型&lt;/strong>为&lt;span class="math inline">\(Y=\mu\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{p}\right)+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>，其中 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{p}, \sigma^{2}\)&lt;/span> 是与 &lt;span class="math inline">\(x\)&lt;/span> 无关的未知参数.&lt;/p>
&lt;p>如果回归函数 &lt;span class="math inline">\(\mu\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{p}\right)\)&lt;/span> 是参数 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{p}\)&lt;/span> 的线性函数 &lt;span class="math inline">\((\)&lt;/span> 不必是 &lt;span class="math inline">\(x\)&lt;/span>的线性函数 &lt;span class="math inline">\()\)&lt;/span>,则称该一元回归模型为&lt;strong>线性回归模型&lt;/strong>; 若 &lt;span class="math inline">\(\mu\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{p}\right)\)&lt;/span> 是 &lt;span class="math inline">\(\theta_{1}, \theta_{2}, \cdots, \theta_{p}\)&lt;/span>的非线性函数,则称为&lt;strong>非线性回归模型&lt;/strong>.&lt;/p>
&lt;p>上面提到的模型&lt;span class="math inline">\(Y=\alpha+\beta h(x)+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>是线性回归模型， 而模型&lt;span class="math inline">\(Y=\alpha \mathrm{e}^{\beta x} \cdot \varepsilon, \quad \ln \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>以及&lt;span class="math inline">\(Y=\alpha x^{\beta} \cdot \varepsilon, \quad \ln \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>都不是线性回归模型,但是它们都能经过变量变换转化为线 性回归模型. 又如&lt;span class="math inline">\(Y=\theta_{1} \mathrm{e}^{\theta_{2} x}+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>它是非线性回归模型. 它不能经过变量变换将它转化为线性回归模型,称为&lt;strong>本 质的非线性回归模型&lt;/strong>, 又如&lt;span class="math inline">\(Y=\left(\theta_{1}+\theta_{2} x+\theta_{3} x^{2}\right)^{-1}+\varepsilon \quad(\)&lt;/span> Holliday 模型 &lt;span class="math inline">\(),\)&lt;/span> 又如&lt;span class="math inline">\(Y=\frac{\theta_{1}}{1+\exp \left(\theta_{2}-\theta_{3}^{x}\right)}+\varepsilon \quad(\)&lt;/span> Logistic 模型 &lt;span class="math inline">\(),\)&lt;/span> 都是本质的非线性回归模型. 非线性回归模型的解法参见《近代非线性回归分析》(韦博成,南京 : 东南大学出版社,1989).&lt;/p>
&lt;h2 id="多元线性回归">多元线性回归&lt;/h2>
&lt;p>在实际问题中,随机变量 &lt;span class="math inline">\(Y\)&lt;/span> 往往与多个普通变量 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{p} \quad(p&amp;gt;1)\)&lt;/span> 有关. 对于自变量 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{p}\)&lt;/span> 的一组确定的值,Y有它的分布. 若 &lt;span class="math inline">\(Y\)&lt;/span> 的数学期望存在,则它是 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{p}\)&lt;/span> 的函数,记为 &lt;span class="math inline">\(\mu_{Y \mid x_{1}}, x_{2}, \cdots, x_{p}\)&lt;/span> 或 &lt;span class="math inline">\(\mu\left(x_{1}, x_{2}, \cdots, x_{p}\right),\)&lt;/span> 它就是 &lt;span class="math inline">\(Y\)&lt;/span> 关于 &lt;span class="math inline">\(x\)&lt;/span> 的回归函数. 我们感兴趣的是 &lt;span class="math inline">\(\mu\left(x_{1}, x_{2}, \cdots, x_{p}\right)\)&lt;/span> 是 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{p}\)&lt;/span> 的线性函 数的情况.&lt;/p>
&lt;p>在这里,仅讨论下述多元线性回归模型 :&lt;span class="math inline">\(Y=b_{0}+b_{1} x_{1}+\cdots+b_{p} x_{p}+\varepsilon, \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span> 其中 &lt;span class="math inline">\(b_{0}, b_{1}, \cdots, b_{p}, \sigma^{2}\)&lt;/span> 都是与 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{p}\)&lt;/span> 无关的未知参数.&lt;/p>
&lt;p>设&lt;span class="math inline">\(\left(x_{11}, x_{12}, \cdots, x_{1 p}, y_{1}\right), \cdots,\left(x_{n 1}, x_{n 2}, \cdots, x_{n p}, y_{n}\right)\)&lt;/span>是一个样本.&lt;/p>
&lt;p>和一元线性回归的情况一样,我们用最大似然估计法来估计参数. 即取 &lt;span class="math inline">\(\hat{b}_{0}, \hat{b}_{1}, \cdots, \hat{b}_{p}\)&lt;/span> 使当 &lt;span class="math inline">\(b_{0}=\hat{b}_{0}, b_{1}=\hat{b}_{1}, \cdots, b_{p}=\hat{b}_{p}\)&lt;/span> 时&lt;span class="math inline">\(Q=\sum_{i=1}^{n}\left(y_{i}-b_{0}-b_{1} x_{i 1}-\cdots-b_{p} x_{i p}\right)^{2}\)&lt;/span>达到最小.&lt;/p>
&lt;p>求 &lt;span class="math inline">\(Q\)&lt;/span> 分别关于 &lt;span class="math inline">\(b_{0}, b_{1}, \cdots, b_{p}\)&lt;/span> 的偏导数,并令它们等于实,得： &lt;span class="math inline">\(\left.\begin{array}{r}\frac{\partial Q}{\partial b_{0}}=-2 \sum_{i=1}^{n}\left(y_{i}-b_{0}-b_{1} x_{i 1}-\cdots-b_{p} x_{i p}\right)=0, \\ \frac{\partial Q}{\partial b_{j}}=-2 \sum_{i=1}^{n}\left(y_{i}-b_{0}-b_{1} x_{i 1}-\cdots-b_{p} x_{i j}\right) x_{i j}=0, \\ j=1,2, \cdots, p .\end{array}\right\}\)&lt;/span>&lt;/p>
&lt;p>化简得： &lt;span class="math inline">\(\left.\begin{array}{l}b_{0} n+b_{1} \sum_{i=1}^{n} x_{i 1}+b_{2} \sum_{i=1}^{n} x_{i 2}+\cdots+b_{p} \sum_{i=1}^{n} x_{i p}=\sum_{i=1}^{n} y_{i} \\ b_{0} \sum_{i=1}^{n} x_{i 1}+b_{1} \sum_{i=1}^{n} x_{i 1}^{2}+b_{2} \sum_{i=1}^{n} x_{i 1} x_{i 2}+\cdots+b_{p} \sum_{i=1}^{n} x_{i 1} x_{i p}=\sum_{i=1}^{n} x_{i 1} y_{i} \\ \vdots \\ b_{0} \sum_{i=1}^{n} x_{i p}+b_{1} \sum_{i=1}^{n} x_{i_{i}} x_{i 1}+b_{2} \sum_{i=1}^{n} x_{i p} x_{i 2}+\cdots+b_{p} \sum_{i=1}^{n} x_{i_{p}}^{2}=\sum_{i=1}^{n} x_{i p} y_{i} .\end{array}\right\}\)&lt;/span> 称为&lt;strong>正规方程组&lt;/strong>. 为了求解的方便,常要将上方程组写成矩阵的形式.&lt;/p>
&lt;p>为此，引入矩阵： &lt;span class="math inline">\(\boldsymbol{X}=\left(\begin{array}{ccccc}1 &amp;amp; x_{11} &amp;amp; x_{12} &amp;amp; \cdots &amp;amp; x_{1 p} \\ 1 &amp;amp; x_{2 i} &amp;amp; x_{22} &amp;amp; \cdots &amp;amp; x_{2 p} \\ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ 1 &amp;amp; x_{n 1} &amp;amp; x_{n 2} &amp;amp; \cdots &amp;amp; x_{n p}\end{array}\right), \boldsymbol{Y}=\left[\begin{array}{c}y_{1} \\ y_{2} \\ \vdots \\ y_{n}\end{array}\right), \boldsymbol{B}=\left(\begin{array}{c}b_{0} \\ b_{1} \\ \vdots \\ b_{p}\end{array}\right) .\)&lt;/span>&lt;/p>
&lt;p>而有： &lt;span class="math inline">\(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}=\left(\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 1 \\ x_{11} &amp;amp; x_{21} &amp;amp; \cdots &amp;amp; x_{n 1} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ x_{1 p} &amp;amp; x_{2 p} &amp;amp; \cdots &amp;amp; x_{n p}\end{array}\right)\left(\begin{array}{ccccc}1 &amp;amp; x_{11} &amp;amp; x_{12} &amp;amp; \cdots &amp;amp; x_{1 p} \\ 1 &amp;amp; x_{21} &amp;amp; x_{22} &amp;amp; \cdots &amp;amp; x_{2 p} \\ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ 1 &amp;amp; x_{n 1} &amp;amp; x_{n 2} &amp;amp; \cdots &amp;amp; x_{n p}\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(\begin{array}{cccc}n &amp;amp; \sum_{i=1}^{n} x_{i 1} &amp;amp; \cdots &amp;amp; \sum_{i=1}^{n} x_{i p} \\ \sum_{i=1}^{n} x_{i 1} &amp;amp; \sum_{i=1}^{n} x_{i 1}^{2} &amp;amp; \cdots &amp;amp; \sum_{i=1}^{n} x_{i 1} x_{i p} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ \sum_{i=1}^{n} x_{i p} &amp;amp; \sum_{i=1}^{n} x_{i p} x_{i 1} &amp;amp; \cdots &amp;amp; \sum_{i=1}^{n} x_{i p}^{2}\end{array}\right),\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{Y}=\left(\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 1 \\ x_{11} &amp;amp; x_{21} &amp;amp; \cdots &amp;amp; x_{n 1} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ x_{1 p} &amp;amp; x_{2 p} &amp;amp; \cdots &amp;amp; x_{n p}\end{array}\right)\left(\begin{array}{c}y_{1} \\ y_{2} \\ \vdots \\ y_{n}\end{array}\right)=\left(\begin{array}{c}\sum_{i=1}^{n} y_{i} \\ \sum_{i=1}^{n} x_{i 1} y_{i} \\ \vdots \\ \sum_{i=1}^{n} x_{i p} y_{i}\end{array}\right) .\)&lt;/span>&lt;/p>
&lt;p>于是正规方程组可以写成： &lt;span class="math inline">\(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X B}=\boldsymbol{X}^{\mathrm{T}} \boldsymbol{Y}\)&lt;/span>&lt;/p>
&lt;p>上式两边左乘 &lt;span class="math inline">\(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\)&lt;/span> 的逆矩阵 &lt;span class="math inline">\(\left(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\right)^{-1}\)&lt;/span> (设&lt;span class="math inline">\(\left(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\right)^{-1}\)&lt;/span> 存在 &lt;span class="math inline">\()\)&lt;/span> 解得： &lt;span class="math inline">\(\hat{\boldsymbol{B}}=\left(\begin{array}{c}\hat{b}_{0} \\ \hat{b}_{1} \\ \vdots \\ \hat{b}_{p}\end{array}\right)=\left(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\right)^{-1} \mathbf{X}^{\mathrm{T}} \boldsymbol{Y}\)&lt;/span> 这就是我们需要求的 &lt;span class="math inline">\(\left(b_{0}, b_{1}, \cdots, b_{p}\right)^{\mathrm{T}}\)&lt;/span> 的最大似然估计.&lt;/p>
&lt;p>我们取&lt;span class="math inline">\(\hat{b}_{0}+\hat{b}_{1} x_{1}+\cdots+\hat{b}_{p} x_{p} \stackrel{\text { 记成 }}{=}\hat{y}\)&lt;/span>作为 &lt;span class="math inline">\(\mu\left(x_{1}, x_{2}, \cdots, x_{p}\right)=b_{0}+b_{1} x_{1}+\cdots+b_{p} x_{p}\)&lt;/span> 的估计. 方程&lt;span class="math inline">\(\hat{y}=\hat{b}_{0}+\hat{b}_{1} x_{1}+\cdots+\hat{b}_{p} x_{p}\)&lt;/span>称为 &lt;strong>&lt;span class="math inline">\(p\)&lt;/span> 元经验线性回归方程&lt;/strong>,简称&lt;strong>回归方程&lt;/strong>.&lt;/p>
&lt;blockquote>
&lt;p>例子 下面给出了某种产品每件平均单价 &lt;span class="math inline">\(Y\)&lt;/span> (元) 与批量 &lt;span class="math inline">\(x\)&lt;/span> (件) 之间的关系的一组数据： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225165628628.png" alt="image-20201225165628628" /> 画出散点图： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225165659292.png" alt="image-20201225165659292" /> 我们选取模型&lt;span class="math inline">\(Y=b_{0}+b_{1} x+b_{2} x^{2}+\varepsilon, \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>来拟合它。&lt;/p>
&lt;p>现在来求它的回归方程： 令 &lt;span class="math inline">\(x_{1}=x, x_{2}=x^{2}\)&lt;/span>，则模型可以写成&lt;span class="math inline">\(Y=b_{0}+b_{1} x_{1}+b_{2} x_{2}+\varepsilon, \quad \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>， 这是一个二元线性回归模型。 现在有： &lt;span class="math inline">\(\boldsymbol{X}=\left(\begin{array}{lll}1 &amp;amp; 20 &amp;amp; 400 \\ 1 &amp;amp; 25 &amp;amp; 625 \\ 1 &amp;amp; 30 &amp;amp; 900 \\ 1 &amp;amp; 35 &amp;amp; 1 &amp;amp; 225 \\ 1 &amp;amp; 40 &amp;amp; 1 &amp;amp; 600 \\ 1 &amp;amp; 50 &amp;amp; 2 &amp;amp; 500 \\ 1 &amp;amp; 60 &amp;amp; 3 &amp;amp; 600 \\ 1 &amp;amp; 65 &amp;amp; 4 &amp;amp; 225 \\ 1 &amp;amp; 70 &amp;amp; 4 &amp;amp; 900 \\ 1 &amp;amp; 75 &amp;amp; 5 &amp;amp; 625 \\ 1 &amp;amp; 80 &amp;amp; 6 &amp;amp; 400 \\ 1 &amp;amp; 90 &amp;amp; 8 &amp;amp; 100\end{array}\right), \boldsymbol{Y}=\left(\begin{array}{l}1.81 \\ 1.70 \\ 1.65 \\ 1.55 \\ 1.48 \\ 1.40 \\ 1.30 \\ 1.26 \\ 1.24 \\ 1.21 \\ 1.20 \\ 1.18\end{array}\right), \boldsymbol{B}=\left[\begin{array}{l}b_{0} \\ b_{1} \\ b_{2}\end{array}\right) .\)&lt;/span> 经计算： &lt;span class="math inline">\(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}=\left(\begin{array}{ccc}12 &amp;amp; 640 &amp;amp; 40100 \\ 640 &amp;amp; 40100 &amp;amp; 2779000 \\ 40100 &amp;amp; 2779000 &amp;amp; 204 702 500\end{array}\right)\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201225170109081.png" alt="image-20201225170109081" /> &lt;span class="math inline">\(\Delta=1.41918 \times 10^{11}\)&lt;/span>， 得正规方程组的解： &lt;span class="math inline">\(\hat{\boldsymbol{B}}=\left(\begin{array}{l}\hat{b}_{0} \\ \hat{b}_{1} \\ \hat{b}_{2}\end{array}\right)=\left(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\right)^{-1} \boldsymbol{X}^{\mathrm{T}} \boldsymbol{Y}=\left(\boldsymbol{X}^{\mathrm{T}} \boldsymbol{X}\right)^{-1} \quad\left(\begin{array}{l}16.98 \\ 851.3 \\ 51162\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(\begin{array}{lll}2.198 266 29 \\ -0.022 522 36 \\ 0.000 125 07\end{array}\right)\)&lt;/span> 于是得到回归方程为&lt;span class="math inline">\(\hat{y}=2.19826629-0.02252236 x+0.00012507 x^{2} .\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>像一元线性回归一样,多元线性回归模型&lt;span class="math inline">\(Y=b_{0}+b_{1} x_{1}+\cdots+b_{p} x_{p}+\varepsilon, \varepsilon \sim N\left(0, \sigma^{2}\right)\)&lt;/span>往往是一种假定,为了考察这一假定是否符合实际观察结果,还需进行以下的假设检验 : &lt;span class="math inline">\(H_{0}: \quad b_{1}=b_{2}=\cdots=b_{p}=0\)&lt;/span> &lt;span class="math inline">\(\mathrm{H}_{1}: b_{i}\)&lt;/span> 不全为零 若在显著性水平 &lt;span class="math inline">\(\alpha\)&lt;/span> 下拒绝 &lt;span class="math inline">\(H_{0} .\)&lt;/span> 我们就认为回归效果是显著的.&lt;/p>
&lt;p>另外,也与一元线性回归一样,多元线性回归方程的一个重要应用是确定给定点 &lt;span class="math inline">\(\left(x_{01}, x_{02}, \cdots, x_{0 p}\right)\)&lt;/span> 处对应的 &lt;span class="math inline">\(Y\)&lt;/span> 的观察值的预测区间.&lt;/p>
&lt;p>最后我们指出，在实际问题中，与Y有关的因素往往很多，如果将它们都取作自变量必然会导致所得到的回归方程很庞大。 实际上，有些自变量对Y的影响很小，如果将这些自变量剔除，不但能使回归方程较为简洁，便于应用，且能明确哪些因素（即自变量）的改变对Y有显著的影响，从而使人们对事物有进一步的认识。 通常可用&lt;strong>逐步回归法&lt;/strong>达到这一目的。 上述关于模型的线性假设的检验、观察值的预测区间、逐步回归等内容，读者可参阅华东师范大学出版社出版的《回归分析及其试验设计》一书&lt;/p>
&lt;p>在实际中，需要考虑的影响Y的因素较多，即自变量的个数较多。因此要求解一个多元线性回归的问题，计算工作量是相当大的，这就需要借助于计算机来进行计算。&lt;/p></description></item><item><title>概率论与数理统计-概率论-随机事件与概率</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-随机事件与概率">概率论与数理统计-随机事件与概率&lt;/h1>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;h5 id="现象">现象&lt;/h5>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E7%8E%B0%E8%B1%A1/2808631">现象&lt;/a>&lt;/p>
&lt;p>现象是&lt;a href="https://baike.baidu.com/item/事物/1693084">事物&lt;/a>表现出来的，能被人感觉到的一切&lt;a href="https://baike.baidu.com/item/情况/1392364">情况&lt;/a>。现象是人能够看到、听到、闻到、触摸到的。&lt;/p>
&lt;p>按照是否有自然属性来分，现象可分为自然现象和&lt;a href="https://baike.baidu.com/item/社会现象/6139891">社会现象&lt;/a>。 按照现象的结果是否唯一来分，现象可分为确定性现象和&lt;strong>随机现象&lt;/strong>。&lt;/p>
&lt;p>概率统计研究的主要目标是&lt;strong>随机现象&lt;/strong>，即现象的结果有多种可能，且事先无法准确预测将会发生哪种结果。&lt;/p>
&lt;h5 id="随机试验">随机试验&lt;/h5>
&lt;p>对&lt;strong>随机现象&lt;/strong>进行&lt;strong>一次观察&lt;/strong>，称为一次随机试验（试验）&lt;/p>
&lt;blockquote>
&lt;p>概率论中将满足下面三个条件的试验称为随机试验，简称试验：&lt;/p>
&lt;ol type="1">
&lt;li>可在相同的条件下重复进行；&lt;/li>
&lt;li>每次试验的结果不止一个&lt;/li>
&lt;li>试验之前不能确定哪一个结果会发生，但所有的结果是明确可知的&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h5 id="样本点">样本点&lt;/h5>
&lt;p>随机试验中每一个可能发生的结果（现象观察到的结果），称为一个样本点。一般记作&lt;span class="math inline">\(\omega\)&lt;/span>&lt;/p>
&lt;h5 id="样本空间">样本空间&lt;/h5>
&lt;p>随机试验中所有可能发生的结果，即所有的样本点，称为样本空间。一般记作&lt;span class="math inline">\(\Omega= \{\omega\}\)&lt;/span>.&lt;/p>
&lt;p>随机事件&lt;/p>
&lt;p>样本空间的任意子集,都称为随机事件（事件）。&lt;/p>
&lt;h6 id="特殊事件不可能事件与必然事件">特殊事件(不可能事件与必然事件)&lt;/h6>
&lt;p>不可能事件：不含样本点的事件（不含任何元素），称为不可能事件。用集合的语言描述为空集&lt;span class="math inline">\(\varnothing\)&lt;/span>&lt;/p>
&lt;p>必然事件：包含样本空间所有样本点的事件（包含所有可能的结果，因此该事件一定会发生），称为必然事件。用集合的语言描述为样本空间全集&lt;span class="math inline">\(\Omega\)&lt;/span>&lt;/p>
&lt;h6 id="事件的发生">事件的发生&lt;/h6>
&lt;p>若事件A中的某个样本点在随机试验中出现（某个样本点被观测到），称为事件A发生。 即事件A中某个样本点被观测到&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>事件A发生&lt;/p>
&lt;h3 id="事件的关系与运算">事件的关系与运算&lt;/h3>
&lt;p>经常要用简单事件表示一些复杂事件（尤其是研究概率的过程中）。 因此需要讨论使事件的关系与运算。&lt;/p>
&lt;p>这里的事件用集合来表示，所以实际上是集合的关系与运算。&lt;/p>
&lt;h5 id="包含关系a-subset-b">包含关系&lt;span class="math inline">\(A \subset B\)&lt;/span>&lt;/h5>
&lt;p>定义:&lt;strong>A发生导致B发生&lt;/strong>,称:&lt;strong>B包含A&lt;/strong>,或称A被B包含.记&lt;span class="math inline">\(A \subset B\)&lt;/span>.集合论：A的元素必属于B。图示：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/截图_20191229034638.png" alt="" />&lt;figcaption>B包含A&lt;/figcaption>
&lt;/figure>
&lt;p>（定义，称，记，集合论，图）&lt;/p>
&lt;h5 id="相等关系ab">相等关系A=B&lt;/h5>
&lt;p>&lt;span class="math inline">\(B \subset A, B \subset A\)&lt;/span>，则A=B&lt;/p>
&lt;h5 id="互斥关系a-bvarnothing">互斥关系&lt;span class="math inline">\(A B=\varnothing\)&lt;/span>&lt;/h5>
&lt;p>在试验中，事件A与B不能同时发生，即&lt;span class="math inline">\(A B=\varnothing\)&lt;/span>，则称A，B互为&lt;strong>互斥事件&lt;/strong>&lt;/p>
&lt;p>设&lt;span class="math inline">\(A_1, A_2, \cdots, A_n\)&lt;/span>是一组事件， 若它们两两互斥(都是互斥事件)， 且它们的并等于样本空间（&lt;span class="math inline">\(\cup_{i=1}^{n} A_i = \Omega\)&lt;/span>）， 称这组事件构成&lt;strong>一个互不相容的完备事件组&lt;/strong>（完备事件组）&lt;/p>
&lt;h5 id="对立关系">对立关系&lt;/h5>
&lt;p>每次事件中，“事件A不发生”的事件称为事件A的对立事件或者逆事件。记为&lt;span class="math inline">\(\bar{A}\)&lt;/span>。&lt;/p>
&lt;p>性质： &lt;span class="math inline">\((1) A+A=\Omega\)&lt;/span> &lt;span class="math inline">\((2) A \bar{A}=\varnothing\)&lt;/span>&lt;/p>
&lt;p>由定义可知：&lt;strong>对立事件一定是互斥事件，但互斥事件不一定是对立事件&lt;/strong>&lt;/p>
&lt;h5 id="事件的和">事件的和&lt;/h5>
&lt;p>事件的和，也称事件的并，记作 &lt;span class="math inline">\(A \cup B\)&lt;/span>或&lt;span class="math inline">\(A+B\)&lt;/span>&lt;/p>
&lt;p>性质： &lt;span class="math inline">\((1) A \subset A \cup B, B \subset A \cup B\)&lt;/span> &lt;span class="math inline">\((2) A \cap(A \cup B)=A, \quad B \cap(A \cup B)=B\)&lt;/span> &lt;span class="math inline">\((3) A \cup A=A\)&lt;/span>&lt;/p>
&lt;h5 id="事件的差">事件的差&lt;/h5>
&lt;p>A-B表示事件A发生而事件B不发生&lt;/p>
&lt;p>性质： &lt;span class="math inline">\((1) A-B \subset A\)&lt;/span> &lt;span class="math inline">\((2)(A-B) \cup A=A, \quad(A-B) \cup B=A \cup B\)&lt;/span> &lt;span class="math inline">\((3)(A-B) \cap A=A-B,(A-B) \cap B=\varnothing\)&lt;/span>&lt;/p>
&lt;h5 id="事件的积交ab">事件的积（交）AB&lt;/h5>
&lt;p>&lt;span class="math inline">\(A \cap B\)&lt;/span>或AB，表示事件A与B同时发生&lt;/p>
&lt;p>性质： &lt;span class="math inline">\((1) A \cap B \subseteq A, \quad A \cap B \subset B\)&lt;/span> &lt;span class="math inline">\((2)(A \cap B) \cup A=A, \quad(A \cap B) \cup B=B\)&lt;/span> &lt;span class="math inline">\((3) A \cap A=A\)&lt;/span>&lt;/p>
&lt;h5 id="事件的运算律">事件的运算律&lt;/h5>
&lt;p>与集合的运算律相似&lt;/p>
&lt;p>&lt;strong>交换律&lt;/strong>：&lt;span class="math inline">\(A \cup B=B \cup A, A B=B A\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>结合律&lt;/strong>：&lt;span class="math inline">\((A \cup B) \cup C=A \cup(B \cup C), \quad(A \cap B) \cap C=A \cap(B \cap C)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>分配律&lt;/strong>：&lt;span class="math inline">\((A \cup B) C=(A C) \cup(B C), \quad A \cup(B C)=(A \cup B)(A \cup C)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>摩根律&lt;/strong>：&lt;/p>
&lt;p>&lt;span class="math inline">\(\overline{A_{1} \cup A_{2}}=\bar{A}_{1} \cap \bar{A}_{2}, \overline{A_{1} \cap A_{2}}=\bar{A}_{1} \cup \bar{A}_{2}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>减法满足&lt;/strong>：&lt;span class="math inline">\(A-B=A \bar{B}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>增补性质&lt;/strong>：&lt;span class="math inline">\(A= (AB) \cup (A\bar{B})\)&lt;/span>&lt;/p>
&lt;h3 id="事件的概率">事件的概率&lt;/h3>
&lt;h4 id="概率的定义">概率的定义&lt;/h4>
&lt;p>前面讨论了随机事件的概念与性质，自然地，人们关心随机事件发生的可能性。&lt;/p>
&lt;h5 id="频率fracn_an">频率&lt;span class="math inline">\(\frac{n_A}{n}\)&lt;/span>&lt;/h5>
&lt;p>在一定条件下试验进行n次，若事件A发生&lt;span class="math inline">\(n_A\)&lt;/span>次，则称&lt;strong>事件A发生的频率&lt;/strong>为&lt;span class="math inline">\(\frac{n_A}{n}\)&lt;/span>&lt;/p>
&lt;h5 id="概率的定义统计定义">概率的定义（统计定义）&lt;/h5>
&lt;p>对于随机现象，当试验次数n增大时，事件A的&lt;strong>频率&lt;/strong>总逐渐&lt;strong>趋近于一个确定的常数&lt;/strong>（大数定理将给出更严格的解释），我们就用这个常数来反映事件A发生的可能性大小，并把这个常数称为&lt;strong>事件A发生的概率&lt;/strong>，记为&lt;span class="math inline">\(P(A)\)&lt;/span>。&lt;/p>
&lt;p>概率的这个通俗定义，即为概率的统计定义。&lt;/p>
&lt;p>概率统计定义的作用：人们往往用n较大时事件A的频率&lt;span class="math inline">\(\frac{n_A}{n}\)&lt;/span>作为事件A发生的概率&lt;span class="math inline">\(P(A)\)&lt;/span>的近似。 概率统计定义的缺陷： 不能作为概率论严格的理论基础； 对于一些无法或很难大量重复的试验，无法适用； 统计定义中“确定的常数”不够明确。&lt;/p>
&lt;h5 id="概率的定义公理化定义">概率的定义（公理化定义）&lt;/h5>
&lt;p>设随机试验E的样本空间为&lt;span class="math inline">\(\Omega\)&lt;/span>，则称满足下列条件的事件集的函数&lt;span class="math inline">\(P(*)\)&lt;/span>为概率：&lt;/p>
&lt;ol type="1">
&lt;li>非负性：对于任意事件A，&lt;span class="math inline">\(P(A) \geqslant 0\)&lt;/span>；&lt;/li>
&lt;li>规范性：对于必然事件&lt;span class="math inline">\(\Omega\)&lt;/span>， &lt;span class="math inline">\(P(\Omega)=1\)&lt;/span>；&lt;/li>
&lt;li>可列可加性：设&lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{n} \cdots\)&lt;/span>为两两互不相容的事件，即&lt;span class="math inline">\(A_{i} A_{j}=\varnothing(i \neq j, i, j=1,2, \cdots)\)&lt;/span>，则&lt;/li>
&lt;/ol>
&lt;p>&lt;span class="math inline">\(P\left(\bigcup_{k=1}^{\infty} A_{k}\right)=\sum_{k=1}^{\infty} P\left(A_{k}\right)\)&lt;/span>&lt;/p>
&lt;p>即将满足以上三种属性的集函数，定义为随机事件的概率。&lt;/p>
&lt;h4 id="概率的性质">概率的性质&lt;/h4>
&lt;h5 id="不可能事件的概率pvarnothing0">不可能事件的概率&lt;span class="math inline">\(P(\varnothing)=0\)&lt;/span>&lt;/h5>
&lt;h5 id="必然事件的概率pomega-1">必然事件的概率&lt;span class="math inline">\(P(\Omega) = 1\)&lt;/span>&lt;/h5>
&lt;h5 id="对立事件的概率pbara1-pa">对立事件的概率&lt;span class="math inline">\(P(\bar{A})=1-P(A)\)&lt;/span>&lt;/h5>
&lt;h5 id="一般事件概率的减法">一般事件，概率的减法：&lt;/h5>
&lt;p>&lt;span class="math inline">\(P(A-B)=P(A\bar{B}) = P(A)-P(A B)\)&lt;/span>&lt;/p>
&lt;h5 id="包含事件概率的减法">包含事件，概率的减法：&lt;/h5>
&lt;p>若事件A，B满足&lt;span class="math inline">\(A \subset B\)&lt;/span>，则&lt;span class="math inline">\(P(A-B)=P(A)-P(B)\)&lt;/span> （且&lt;span class="math inline">\(P(A) \le P(B)\)&lt;/span>）&lt;/p>
&lt;h5 id="一般事件概率的加法">一般事件，概率的加法：&lt;/h5>
&lt;p>&lt;span class="math inline">\(P(A \cup B)=P(A)+P(B)-P(A B)\)&lt;/span>; &lt;span class="math inline">\(P(A \cup B \cup C)=P(A)+P(B)+P(C)-P(A B)-P(B C)-P(A C)+P(A B C)\)&lt;/span>; … &lt;span class="math inline">\(P\left(\bigcup_{i=1}^{n} A_{i}\right)=\sum_{i=1}^{n} P\left(A_{i}\right)-\sum_{i \in i&amp;lt;j \leq n} P\left(A_{i} A_{j}\right)+\sum_{1 \leq i \leq j&amp;lt;k \leq n} P\left(A_{i} A_{j} A_{k}\right)+\cdots+(-1)^{m-1} P\left(A_{1} A_{2} \cdots A_{m}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="有限个两两互斥事件概率的加法">有限个两两互斥事件，概率的加法：&lt;/h5>
&lt;p>若事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>两两互斥，则&lt;span class="math inline">\(P\left(\bigcup_{i=1}^{n} A_{i}\right)=\sum_{i=1}^{n} P\left(A_{i}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="古典概率模型与几何概率模型">古典概率模型与几何概率模型&lt;/h4>
&lt;h5 id="古典概率模型">古典概率模型&lt;/h5>
&lt;p>古典概率模型是一种最简单的概率模型，是具有如下特征的概率模型： 1.试验的样本空间&lt;span class="math inline">\(\Omega\)&lt;/span>中只包含有限个样本点，&lt;span class="math inline">\(\Omega=\{\omega_1,\omega_2,\cdots,\omega_N\}\)&lt;/span> 2.每个样本点发生的可能性相同，即&lt;span class="math inline">\(P(\omega_1)=P(\omega_2)=\cdots=P(\omega_N)=\frac{1}{N}\)&lt;/span>&lt;/p>
&lt;p>在古典概率模型中，设样本空间&lt;span class="math inline">\(\Omega\)&lt;/span>有N个样本点，事件&lt;span class="math inline">\(A \subset \Omega\)&lt;/span>,且A中含有k个样本点，则显然有&lt;span class="math inline">\(P(A) = \frac{k}{N}\)&lt;/span>&lt;/p>
&lt;h6 id="抽样问题和抽奖问题">抽样问题和抽奖问题&lt;/h6>
&lt;p>从一堆物品中，连续抽取k次，每次抽取的结果不放回去，这种抽取方式称为&lt;strong>无放回抽样&lt;/strong>。 从一堆物品中，每次抽取一个，观察后放回，重复进行k次，这种抽取方式称为&lt;strong>有放回抽样&lt;/strong>。&lt;/p>
&lt;p>无放回抽样（抽奖）的公平性：彩票盒中n张彩票，k张有奖，n个人依次抽取一张（不放回），每个人中奖概率都是&lt;span class="math inline">\(\frac{k}{n}\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明：&lt;/p>
&lt;p>每个人依次抽取一张，有&lt;span class="math inline">\(n!\)&lt;/span>种取法；&lt;/p>
&lt;p>考虑第j个人中奖的取法数： 在第j个位置安排一张中奖彩票，有k种取法， 剩下的&lt;span class="math inline">\((n-1)\)&lt;/span>张彩票在余下位置作全排列，有&lt;span class="math inline">\((n-1)!\)&lt;/span>种取法， 则第j人中奖的取法数有&lt;span class="math inline">\(k(n-1)!\)&lt;/span>种&lt;/p>
&lt;p>则第j个人中奖的概率为&lt;span class="math inline">\(P(A_j) = \frac{k(n-1)!}{n!}=\frac{k}{n}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="盒子装球问题">盒子装球问题&lt;/h6>
&lt;p>将n个球随机放入N个盒子中(&lt;span class="math inline">\(n\le N\)&lt;/span>)，盒子容量不限，则每个盒子中至多有一个球的概率&lt;span class="math inline">\(P(A) = \frac{A_N^n}{N^n}\)&lt;/span>。&lt;/p>
&lt;blockquote>
&lt;p>证明&lt;/p>
&lt;p>每个球都可以放入N个盒子中的任意一个盒子，共&lt;span class="math inline">\(N^n\)&lt;/span>种放法，且每种放法是等可能的。&lt;/p>
&lt;p>每个盒子至多有一个球有&lt;span class="math inline">\(A_N^n\)&lt;/span>种放法。&lt;/p>
&lt;p>则每个盒子中至多有一个球的概率为&lt;span class="math inline">\(P(A) = \frac{A_N^n}{N^n}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>实际应用：n个人生日各不相同的概率（对应于n个球放入N=365个盒子中，要求每个盒子至多装一个球的问题）&lt;/p>
&lt;h5 id="几何概率模型">几何概率模型&lt;/h5>
&lt;p>几何概率模型是具有如下两个特征的概率模型： 1.随即现象的样本空间&lt;span class="math inline">\(\Omega\)&lt;/span>是直线（平面、三维空间）的某部分区域，其长度（面积、体积）用&lt;span class="math inline">\(S_\Omega\)&lt;/span>表示 2.&lt;span class="math inline">\(\Omega\)&lt;/span>的任何子集A的概率与A的长度（面积、体积）&lt;span class="math inline">\(S_A\)&lt;/span>成正比，而与A的位置、形状无关&lt;/p>
&lt;p>不难得到&lt;span class="math inline">\(P(A) = \frac{S_A}{S_\Omega}\)&lt;/span>&lt;/p>
&lt;h6 id="约会问题">约会问题&lt;/h6>
&lt;p>约会问题是几何概率模型的一个例子&lt;/p>
&lt;h4 id="条件概率">条件概率&lt;/h4>
&lt;h5 id="条件概率的定义">条件概率的定义&lt;/h5>
&lt;p>设A，B是两个事件，且&lt;span class="math inline">\(P(A)&amp;gt;0\)&lt;/span>，称&lt;span class="math inline">\(P(B | A)=\frac{P(A B)}{P(A)}\)&lt;/span>为在事件A发生的条件下事件B发生的概率&lt;/p>
&lt;h5 id="概率的乘法">概率的乘法&lt;/h5>
&lt;p>由条件概率的定义，可知： &lt;span class="math inline">\(P(AB) = P(A)\cdot P(B|A)\)&lt;/span>&lt;/p>
&lt;h5 id="全概率公式">全概率公式&lt;/h5>
&lt;p>定义：设样本空间为&lt;span class="math inline">\(\Omega\)&lt;/span>,事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>构成一个完备事件组，且&lt;span class="math inline">\(P(A_i) &amp;gt; 0 (i = 1,2,\cdots,n)\)&lt;/span>. 则对任意事件&lt;span class="math inline">\(B \subset \Omega\)&lt;/span>，有&lt;span class="math inline">\(P(B)=\sum_{i=1}^n P(A_i) P(B|A_i)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： 事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>构成一个完备事件组，则&lt;span class="math inline">\(B=\bigcup_{i=1}^n A_i B\)&lt;/span> 由&lt;span class="math inline">\(A_1 B, A_2 B, \cdots , A_n B\)&lt;/span>两两互斥，根据概率的加法与乘法， &lt;span class="math inline">\(P(B)=P\left(\bigcup_{i=1}^{n} A_{i} B\right)=\sum_{i=1}^n P(A_i) P(B|A_i)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>很多场合下，直接计算某事件B的概率不容易，而在各个不同条件下&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>下，B发生的概率&lt;span class="math inline">\(P(A_i) P(B|A_i)\)&lt;/span>容易知道，那么全概率公式求&lt;span class="math inline">\(P(B)\)&lt;/span>是很好的方法。&lt;/p>
&lt;h5 id="贝叶斯公式">贝叶斯公式&lt;/h5>
&lt;p>与全概率公式相反，贝叶斯公式常用于根据观察到的结果来推断各种原因（或途径）发生的可能性的大小。即用来求某事件B发生的条件下，&lt;span class="math inline">\(A_i\)&lt;/span>发生的概率&lt;span class="math inline">\(P(A_i|B)\)&lt;/span>.&lt;/p>
&lt;p>定义：：设样本空间为&lt;span class="math inline">\(\Omega\)&lt;/span>,事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>构成一个完备事件组，B为一事件，且&lt;span class="math inline">\(P(B)&amp;gt;0,P(A_i) &amp;gt; 0 (i = 1,2,\cdots,n)\)&lt;/span>. 则有&lt;span class="math inline">\(P(A_i|B)=\frac{P(A_i) P(B|A_i)}{\sum_{j=1}^n P(A_j) P(B|A_j)}\)&lt;/span>，其中&lt;span class="math inline">\(i=1,2,\cdots,n\)&lt;/span>&lt;/p>
&lt;p>实际上，可以从概率的乘法公式以及全概率公式出发，来以及贝叶斯公式： &lt;span class="math inline">\(P(A_i B) \\= P(A_i) P(B|A_i) \\= P(B) P(A_i|B) = \sum_{j=1}^n P(A_j) P(B|A_j) \cdot P(A_i |B)\)&lt;/span>&lt;/p>
&lt;h4 id="事件的独立性">事件的独立性&lt;/h4>
&lt;p>前面讨论了条件概率&lt;span class="math inline">\(P(B|A)\)&lt;/span>，一般来说&lt;span class="math inline">\(P(B|A) \neq P(B)\)&lt;/span>. 但很多时候，确实有&lt;span class="math inline">\(P(B|A) = P(B)\)&lt;/span>，即A的发生并不影响B发生的概率（也叫B对A是独立的）。 而若&lt;span class="math inline">\(P(B|A) = P(B)\)&lt;/span>的时候，由条件概率乘法公式&lt;span class="math inline">\(P(AB) = P(A)P(B|A) = P(B)P(A|B)\)&lt;/span>可知，有&lt;span class="math inline">\(成立P(A|B) = P(A)\)&lt;/span>，即B的发生并不影响A发生的概率（也叫A对B也是独立的）&lt;/p>
&lt;h5 id="两事件相互独立的定义">两事件相互独立的定义&lt;/h5>
&lt;p>定义：设A，B是两个事件，若有等式&lt;span class="math inline">\(P(A B)=P(A) P(B)\)&lt;/span>，则称A与B互相独立。&lt;/p>
&lt;h5 id="两事件相互独立的性质">两事件相互独立的性质&lt;/h5>
&lt;p>若事件A与B独立，则A与&lt;span class="math inline">\(\bar{B}\)&lt;/span>也独立&lt;/p>
&lt;blockquote>
&lt;p>证明：&lt;/p>
&lt;p>A与B独立，即有&lt;span class="math inline">\(P(A B)=P(A) P(B)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} P(A \bar{B}) &amp;amp;=P(A-A B) \\ &amp;amp;=P(A)-P(A B) \\ &amp;amp;=P(A)-P(A) P(B) \\ &amp;amp;=P(A)(1-P(B)) \\ &amp;amp;=P(A) P(\bar{B}) \end{aligned}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>显然,若四对事件A与B，A与&lt;span class="math inline">\(\bar{B}\)&lt;/span>，&lt;span class="math inline">\(\bar{A}\)&lt;/span>与B，&lt;span class="math inline">\(\bar{A}\)&lt;/span>与&lt;span class="math inline">\(\bar{B}\)&lt;/span>中有一对独立，则其他三对也对立。&lt;/p>
&lt;h5 id="多事件两两独立">多事件两两独立&lt;/h5>
&lt;p>一般的，设&lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{n}\)&lt;/span>是n个事件，如果对于任意&lt;span class="math inline">\(k\left(k_{k} \leqslant n\right)\)&lt;/span>和任意&lt;span class="math inline">\(1 \leqslant i_{1}&amp;lt;i_{2}&amp;lt;\cdots&amp;lt;i_{k} \leqslant n\)&lt;/span>，具有等式&lt;span class="math inline">\(P\left(A_{i_{1}} A_{i_{2}} \cdots A_{i_{k}}\right)=P\left(A_{i_{1}}\right) P\left(A_{i_{2}}\right) \cdots P\left(A_{i_{k}}\right)\)&lt;/span>，则称&lt;span class="math inline">\(A_{1}, A_{2}, \cdots, A_{n}\)&lt;/span>为两两独立的事件&lt;/p>
&lt;h5 id="多事件相互独立">多事件相互独立&lt;/h5>
&lt;p>设&lt;span class="math inline">\(A_1,A_2,A_3\)&lt;/span>是3个事件，若同时满足下面4个等式：&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} P\left(A_{1} A_{2}\right) &amp;amp;=P\left(A_{1}\right) P\left(A_{2}\right) \\ P\left(A_{2} A_{3}\right) &amp;amp;=P\left(A_{2}\right) P\left(A_{3}\right) \\ P\left(A_{1} A_{3}\right) &amp;amp;=P\left(A_{1}\right) P\left(A_{3}\right) \\ P\left(A_{1} A_{2} A_{3}\right) &amp;amp;=P\left(A_{1}\right) P\left(A_{2}\right) P\left(A_{3}\right) \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>则称&lt;span class="math inline">\(A_1,A_2,A_3\)&lt;/span>三个事件相互独立。&lt;/p>
&lt;p>注意：前三个等式表示3个事件两两独立，说明三个事件相互独立比两两独立要强。&lt;/p>
&lt;p>对于n个事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>，若其中&lt;span class="math inline">\(k(2\le k \le n)\)&lt;/span>个事件乘积的概率等于这k个事件概率的乘积，称&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>相互独立。&lt;/p>
&lt;h6 id="n个相互独立事件的并">n个相互独立事件的并&lt;/h6>
&lt;p>设n个事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>相互独立，则 &lt;span class="math inline">\(\begin{aligned} P\left(\bigcup_{i=1}^{n} A_{i}\right) &amp;amp;=1-P\left(\overline{\bigcup_{i=1}^{n} A_{i}}\right) \\ &amp;amp;=1-P\left(\bigcap_{i=1}^{n} \overline{A_{i}}\right) \\ &amp;amp;=1-\prod_{i=1}^{n} P\left(\overline{A_{i}}\right) \\ &amp;amp;=1-\prod_{i=1}^{n}\left[1-P\left(A_{i}\right)\right] \end{aligned}\)&lt;/span>&lt;/p>
&lt;h6 id="n个相互对立事件分成两组分别作集合运算运算结果保持独立">n个相互对立事件，分成两组，分别作集合运算，运算结果保持独立&lt;/h6>
&lt;p>设n个事件&lt;span class="math inline">\(A_1,A_2,\cdots,A_n\)&lt;/span>相互独立， 现将它们分成两组， 比如&lt;span class="math inline">\(A_1,A_2,\cdots,A_k\)&lt;/span>为一组，并对&lt;span class="math inline">\(A_1,A_2,\cdots,A_k\)&lt;/span>作任意的集合运算，将所得新事件记为B； &lt;span class="math inline">\(A_{k+1},A_{k+2},\cdots,A_n\)&lt;/span>为另一组，并对&lt;span class="math inline">\(A_{k+1},A_{k+2},\cdots,A_n\)&lt;/span>作任意的集合运算，将所得新事件记为C； 则B与C独立。&lt;/p>
&lt;h5 id="独立试验序列">独立试验序列&lt;/h5>
&lt;p>把某试验独立重复的进行n次。 在每次试验中，只关心事件A发生与否，并设每次试验中A发生的概率均为&lt;span class="math inline">\(p(0&amp;lt;p&amp;lt;1)\)&lt;/span>，而且每次的试验结果相互独立。 这样的n次重复试验称为&lt;strong>n重独立试验序列&lt;/strong>，也称&lt;strong>n重伯努利试验&lt;/strong>。&lt;/p>
&lt;p>n重伯努利试验中，我们关心的事件A可能发生的次数为&lt;span class="math inline">\(0,1,\cdots,n\)&lt;/span>，并且A恰好发生&lt;span class="math inline">\(k(k=0,1,\cdots,n)\)&lt;/span>次的概率为&lt;span class="math inline">\(P_{n}(k)=\mathrm{C}_{n}^{k} p^{k}(1-p)^{n-k}\)&lt;/span>&lt;/p>
&lt;p>容易验证：&lt;span class="math inline">\(\sum_{k=0}^{n} \mathrm{C}_{n}^{k} p^{k}(1-p)^{n-k}=[p+(1-p)]^{n}=1\)&lt;/span>&lt;/p></description></item><item><title>概率论与数理统计-概率论-随机变量及其分布</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="概率论与数理统计-随机变量及其分布">概率论与数理统计-随机变量及其分布&lt;/h1>
&lt;h2 id="一维随机变量与分布函数">（一维）随机变量与分布函数&lt;/h2>
&lt;h3 id="随机变量的概念">随机变量的概念&lt;/h3>
&lt;h4 id="随机变量的引入">随机变量的引入&lt;/h4>
&lt;p>对于不同的随机现象， 有些随机现象的结果（样本点）往往是一个某个数量指标，可以用实数来表示（比如色子掷出点数）； 有些随机现象的结果（样本点）没有数量特征，只标记某种属性（比如硬币抛出正反面，公司某年是盈是亏）。&lt;/p>
&lt;p>对于没有数量特征的样本点，我们可以人为引入数字来标记结果。 这样，每个随机现象的结果（或者说每次随机试验的结果），都有一个实数与之对应。&lt;/p>
&lt;h4 id="随机变量的定义">随机变量的定义&lt;/h4>
&lt;p>设试验的样本空间为&lt;span class="math inline">\(\Omega\)&lt;/span>，如果对于每个&lt;strong>样本点&lt;/strong>&lt;span class="math inline">\(\omega \in \Omega\)&lt;/span>，都有一个&lt;strong>实数&lt;/strong>&lt;span class="math inline">\(X(\omega)\)&lt;/span>与之&lt;strong>对应&lt;/strong>，则称&lt;span class="math inline">\(X(\omega)\)&lt;/span>为随机变量。&lt;/p>
&lt;p>注意：随机变量&lt;span class="math inline">\(X(\omega)\)&lt;/span>常简写为X 。但是，随机变量实际上是个因变量，对应的自变量是样本空间中的样本点。 注意：随机变量常用大写英文字母X,Y,Z等，或者希腊字母&lt;span class="math inline">\(\xi,\eta,\zeta\)&lt;/span>等表示。&lt;/p>
&lt;h4 id="落在某范围的随机变量可以表示随机事件">落在某范围的随机变量可以表示随机事件&lt;/h4>
&lt;p>有了随机变量，随机事件（样本空间的子集）就可以用随机变量的区间来描述。 即随机事件可以用随机变量落在某个范围内来表示。&lt;/p>
&lt;p>例如，抛掷硬币3次，用X表示正面朝上的次数， 随机事件”至少有两次正面朝上“可以写为&lt;span class="math inline">\(\{\omega | X(\omega) \ge 2\}\)&lt;/span>，一般直接简写为&lt;span class="math inline">\(\{ X \ge 2\}\)&lt;/span>&lt;/p>
&lt;h3 id="随机变量的分布函数">随机变量的分布函数&lt;/h3>
&lt;p>在随机事件章节，我们讨论过随机事件发生的概率。 我们已经知道随机事件可以用随机变量落在某个范围来表示， 则我们&lt;strong>可以用随机变量描述事件的概率&lt;/strong>，即随机变量落在某个范围内的概率，引入随机变量的（概率）分布函数。&lt;/p>
&lt;h4 id="随机变量的分布函数定义">随机变量的分布函数定义&lt;/h4>
&lt;p>设X是一个随机变量，称&lt;span class="math inline">\(F(x)=P(X \le x) , -\infty &amp;lt; x &amp;lt; +\infty\)&lt;/span>为随机变量X的分布函数。&lt;/p>
&lt;p>注意：&lt;span class="math inline">\(F(x)\)&lt;/span>的定义域是实数集&lt;span class="math inline">\(R\)&lt;/span>，对于每个实数x，&lt;span class="math inline">\(F(X)\)&lt;/span>表示随机变量小于等于x的概率，显然&lt;span class="math inline">\(0\le x \le 1\)&lt;/span>&lt;/p>
&lt;h4 id="随机变量的分布函数的性质">随机变量的分布函数的性质&lt;/h4>
&lt;p>下面列出的是&lt;strong>任何随机变量的分布函数的共性&lt;/strong>。之后还会单独讨论离散型随机变量和连续性随机变量的特性。&lt;/p>
&lt;h5 id="f-inftylim_-infty-fx-0-finftylim_infty-fx-1">&lt;span class="math inline">\(F(-\infty)=\lim_{-\infty} F(x) = 0, F(+\infty)=\lim_{+\infty} F(x) = 1\)&lt;/span>&lt;/h5>
&lt;h5 id="paxle-b-fb---fa">&lt;span class="math inline">\(P(a&amp;lt;X\le b) = F(b) - F(a)\)&lt;/span>&lt;/h5>
&lt;p>因为&lt;span class="math inline">\(\{a &amp;lt; X \le b\} = \{ X \le b\} - \{X \le a\}\)&lt;/span> 所以随机变量X落在区间&lt;span class="math inline">\((a,b]\)&lt;/span>的概率为：&lt;span class="math inline">\(P(a&amp;lt;X\le b) = P(b) - P(a) = F(b) - F(a)\)&lt;/span>&lt;/p>
&lt;h5 id="若ab则fale-fb">若&lt;span class="math inline">\(a&amp;lt;b\)&lt;/span>，则&lt;span class="math inline">\(F(a)\le F(b)\)&lt;/span>&lt;/h5>
&lt;p>对任意实数&lt;span class="math inline">\(a&amp;lt;b\)&lt;/span>，有&lt;span class="math inline">\(F(a)\le F(b)\)&lt;/span>，即&lt;strong>&lt;span class="math inline">\(F(x)\)&lt;/span>单调不减&lt;/strong>&lt;/p>
&lt;h5 id="fa-fa">&lt;span class="math inline">\(F(a+) = F(a)\)&lt;/span>&lt;/h5>
&lt;p>对任意实数&lt;span class="math inline">\(a \in R\)&lt;/span>，有&lt;span class="math inline">\(F(a+) = F(a)\)&lt;/span>，即&lt;strong>&lt;span class="math inline">\(F(x)\)&lt;/span>右连续&lt;/strong>。 其中&lt;span class="math inline">\(F(a+) = \lim_{x\rightarrow a+} F(x)\)&lt;/span>&lt;/p>
&lt;h5 id="pxa-lim_xrightarrow-a--fx-fa-">&lt;span class="math inline">\(P(X&amp;lt;a) =\lim_{x\rightarrow a-} F(x) = F(a-)\)&lt;/span>&lt;/h5>
&lt;h5 id="pxafa-fa-">&lt;span class="math inline">\(P(X=a)=F(a)-F(a-)\)&lt;/span>&lt;/h5>
&lt;h2 id="一维离散型随机变量及其分布">（一维）离散型随机变量及其分布&lt;/h2>
&lt;h4 id="离散型随机变量">离散型随机变量&lt;/h4>
&lt;p>所有可能的取值是有限多个或者可列多个的随机变量称为&lt;strong>离散型随机变量&lt;/strong>。比如多次抛硬币抛出正面朝上的次数、网站一天的访问次数等； 与之相对，&lt;strong>连续性随机变量&lt;/strong>的取值会充满某个实数区间。比如产品的使用寿命等。&lt;/p>
&lt;h4 id="离散型随机变量的概率分布">离散型随机变量的概率分布&lt;/h4>
&lt;p>设离散型随机变量X的所有可能取值为&lt;span class="math inline">\(x_1,x_2,\cdots,\)&lt;/span>而X取各个可能值的概率为&lt;span class="math inline">\(P(X=x_k) = p(x_k), k = 1,2, \cdots\)&lt;/span>,称为离散型随机变量X的概率分布或者概率分布律（列），简称概率分布律（列）。&lt;/p>
&lt;h4 id="离散型随机变量的概率分布的性质">离散型随机变量的概率分布的性质&lt;/h4>
&lt;h5 id="px_k-ge-0-k12cdots">&lt;span class="math inline">\(p(x_k) \ge 0, k=1,2,\cdots\)&lt;/span>&lt;/h5>
&lt;h5 id="sum_k-px_k-1">&lt;span class="math inline">\(\sum_k p(x_k) = 1\)&lt;/span>&lt;/h5>
&lt;p>离散型随机变量X的分布函数为&lt;span class="math inline">\(F(x) = P(X \le x) = \sum_{x_k \le x} p(x_k)\)&lt;/span>&lt;/p>
&lt;h4 id="常见的离散型随机变量的分布">常见的离散型随机变量的分布&lt;/h4>
&lt;h5 id="分布xsim-b">0-1分布&lt;span class="math inline">\(X\sim B\)&lt;/span>&lt;/h5>
&lt;p>随机现象：只有两种可能结果的随机现象。用随机变量X来描述随机现象的结果。&lt;/p>
&lt;p>随机变量X取值：只可能取0或1两个值 随机变量X的（概率）分布律：&lt;span class="math inline">\(P(X=0) = 1 - p, P(X=1) = p\)&lt;/span>&lt;/p>
&lt;p>举例：比如如检查结果是否合格，新生儿性别，贷款能否按时归还等&lt;/p>
&lt;h5 id="二项分布xsim-bnp">二项分布&lt;span class="math inline">\(X\sim B(n,p)\)&lt;/span>&lt;/h5>
&lt;p>随机现象/试验：n重伯努利试验（n重独立重复试验）。 设每次试验中事件A发生的概率为p，用随机变量X来表示n重伯努利试验中A发生的次数。&lt;/p>
&lt;p>随机变量X取值：&lt;span class="math inline">\(k=0,1,\cdots,n\)&lt;/span> 随机变量X的（概率）分布律：&lt;span class="math inline">\(P(X=k) = C_n^k p^k (1-p)^{n-k}\)&lt;/span> 称随机变量X服从参数为n和p的二项分布，记为&lt;span class="math inline">\(X\sim B(n,p)\)&lt;/span>&lt;/p>
&lt;h5 id="泊松分布xsim-plambda">泊松分布&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>&lt;/h5>
&lt;p>随机现象/试验：n重伯努利试验（n重独立重复试验）， 设每次试验中事件A发生的概率为p，用随机变量X来表示n重伯努利试验中A发生的次数。 &lt;strong>要求&lt;/strong>n比较大，np趋于一个合适的值（&lt;span class="math inline">\(n\rightarrow +\infty, np \rightarrow \lambda\)&lt;/span>）&lt;/p>
&lt;p>随机变量X取值：&lt;span class="math inline">\(k=0,1,\cdots\)&lt;/span> 随机变量X的（概率）分布律：&lt;span class="math inline">\(P(X=k) = \frac{\lambda^k}{k!} e^{-\lambda}\)&lt;/span> 称随机变量X服从参数为n和p的二项分布，记为&lt;span class="math inline">\(X\sim P(\lambda)\)&lt;/span>&lt;/p>
&lt;p>应用：一段离散时间内电话呼叫次数、车站到达人数、网站访问人数、放射性物质放射粒子数等&lt;/p>
&lt;blockquote>
&lt;p>当n比较大，np趋于一个合适的值（&lt;span class="math inline">\(n\rightarrow +\infty, np \rightarrow \lambda\)&lt;/span>，一般&lt;span class="math inline">\(\lambda \le 10\)&lt;/span>）时，随机变量X的分布由二项分布自然变为泊松分布， 即&lt;span class="math inline">\(\lim_{n\rightarrow +\infty, np \rightarrow \lambda} C_n^k p^k (1-p)^{n-k} = \frac{\lambda^k}{k!} e^{-\lambda}\)&lt;/span> 这个规律叫做泊松定理。&lt;a href="https://baike.baidu.com/item/%E6%B3%8A%E6%9D%BE%E5%AE%9A%E7%90%86">泊松定理及其证明&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h5 id="超几何分布xsim-hnmn">超几何分布&lt;span class="math inline">\(X\sim H(n,M,N)\)&lt;/span>&lt;/h5>
&lt;p>随机现象/试验：古典概率模型的无放回抽样， 用随机变量X表示抽出的次品/奖品数&lt;/p>
&lt;p>随机变量X取值：&lt;span class="math inline">\(k=0,1,\cdots, n\)&lt;/span> 随机变量X的（概率）分布律：&lt;span class="math inline">\(P(X=k) = \frac{C_M^k C_{N-M}^{n-k}}{C_N^n}\)&lt;/span> 其中n,M,N都是正整数，且&lt;span class="math inline">\(n\le N, M \le N\)&lt;/span>，称X服从超几何分布，记为&lt;span class="math inline">\(X\sim H(n,M,N)\)&lt;/span>&lt;/p>
&lt;p>应用：常用在产品的质量检测中。例如，一批产品共N个，其中有M个次品。从中任取n个，则取出的n个产品中的次品数X服从超几何分布&lt;/p>
&lt;blockquote>
&lt;p>性质：设随机变量X服从超几何分布（&lt;span class="math inline">\(X\sim H(n,M,N)\)&lt;/span>）， 则当&lt;span class="math inline">\(N\rightarrow \infty\)&lt;/span>时，X近似服从二项分布&lt;span class="math inline">\(X\sim B(n,p)\)&lt;/span>。 即&lt;span class="math inline">\(\frac{C_M^k C_{N-M}^{n-k}}{C_N^n} \approx C_n^k p^k (1-p)^{n-k}\)&lt;/span> (&lt;span class="math inline">\(N\rightarrow \infty\)&lt;/span>)&lt;/p>
&lt;p>说明当一批产品的总数N很大，而抽取的样品数n远小于N时，不放回抽样（取出的次品数服从超几何分布）与有放回抽样（取出的次品数服从二项分布）差别不大&lt;/p>
&lt;/blockquote>
&lt;h5 id="几何分布xsim-gp">几何分布&lt;span class="math inline">\(X\sim G(p)\)&lt;/span>&lt;/h5>
&lt;p>随机现象/试验：n重伯努利试验（n重独立重复试验）， 设每次试验中事件A发生的概率为p，直到事件A发生为止，用随机变量X来表示所需的试验次数。&lt;/p>
&lt;p>随机变量X取值：&lt;span class="math inline">\(k=0,1,\cdots, n\)&lt;/span> 随机变量X的（概率）分布律：&lt;span class="math inline">\(P(X=k) = (1-p)^{k-1} p\)&lt;/span> 称随机变量X服从参数为p的几何分布，记为&lt;span class="math inline">\(X\sim G(p)\)&lt;/span>&lt;/p>
&lt;h2 id="一维连续型随机变量及其分布">（一维）连续型随机变量及其分布&lt;/h2>
&lt;h3 id="连续型随机变量概率分布及其密度函数">连续型随机变量、概率分布及其密度函数&lt;/h3>
&lt;h4 id="连续型随机变量与其概率分布">连续型随机变量与其概率分布&lt;/h4>
&lt;p>介绍离散型随机变量时，有简单说明&lt;strong>连续性随机变量&lt;/strong>，它的取值会充满某个实数区间。比如产品的使用寿命等。&lt;/p>
&lt;p>与离散型随机变量的分布函数相一致，连续型随机变量的&lt;strong>分布函数&lt;/strong>为&lt;span class="math inline">\(F(x) = P(X\le x)\)&lt;/span>.&lt;/p>
&lt;h4 id="概率密度函数">概率密度函数&lt;/h4>
&lt;p>连续型随机变量X的取值会充满某个区间，可以引入概率密度函数的概念：&lt;/p>
&lt;p>设随机变量X的分布函数为&lt;span class="math inline">\(F(x)\)&lt;/span>，若存在可积函数&lt;span class="math inline">\(f(x) \ge 0\)&lt;/span>使得对于&lt;strong>任意实数x&lt;/strong>，都有概率分布函数&lt;span class="math inline">\(F(x) = \int_{-\infty}^x f(t)dt\)&lt;/span>，则称X为&lt;strong>连续型变量&lt;/strong>，&lt;span class="math inline">\(f(x)\)&lt;/span>称为X的&lt;strong>概率密度函数&lt;/strong>，简称密度函数，常记作&lt;span class="math inline">\(X\sim f(x)\)&lt;/span>&lt;/p>
&lt;p>直观的，连续型随机变量X的分布函数等于区间&lt;span class="math inline">\((-\infty,x)\)&lt;/span>上曲线&lt;span class="math inline">\(y=f(x)\)&lt;/span>之下的阴影部分面积&lt;/p>
&lt;h4 id="连续型随机变量的分布函数与密度函数的性质">连续型随机变量的分布函数与密度函数的性质&lt;/h4>
&lt;h5 id="finfty-int_-inftyinfty-fx-dx-1">&lt;span class="math inline">\(F(+\infty) = \int_{-\infty}^{+\infty} f(x) dx = 1\)&lt;/span>&lt;/h5>
&lt;h5 id="对任意实数ab有paxle-b-int_ab-fx-dx">对任意实数&lt;span class="math inline">\(a&amp;lt;b\)&lt;/span>有&lt;span class="math inline">\(P(a&amp;lt;X\le b) = \int_a^b f(x) dx\)&lt;/span>&lt;/h5>
&lt;h5 id="fx处处连续且对于任意实数a有pxa-0">&lt;span class="math inline">\(F(x)\)&lt;/span>处处连续，且对于任意实数a有&lt;span class="math inline">\(P(X=a) = 0\)&lt;/span>&lt;/h5>
&lt;p>推广：&lt;span class="math inline">\(P(a\le X \le b) = P(a \le X &amp;lt;b) = P( a&amp;lt; X &amp;lt;b)\)&lt;/span>&lt;/p>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>连续，则&lt;span class="math inline">\(F^\prime(x) = f(x)\)&lt;/span>&lt;/p>
&lt;h3 id="常见的连续型随机变量及其分布与密度函数">常见的连续型随机变量及其分布与密度函数&lt;/h3>
&lt;h4 id="均匀分布xsim-uab">均匀分布&lt;span class="math inline">\(X\sim U(a,b)\)&lt;/span>&lt;/h4>
&lt;p>若连续型随机变量X的密度函数为 &lt;span class="math inline">\(f(x)=\left\{\begin{array}{ll}\frac{1}{b-a}, &amp;amp; a \leqslant x \leqslant b \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span> 则称X服从区间&lt;span class="math inline">\([a,b]\)&lt;/span>上的均匀分布，记作&lt;span class="math inline">\(X\sim U(a,b)\)&lt;/span>&lt;/p>
&lt;p>对应的随机变量X的分布函数为 &lt;span class="math inline">\(F(x)=\left\{\begin{array}{ll}0, &amp;amp; x&amp;lt;a \\ \frac{x-a}{b-a}, &amp;amp; a \leqslant x \leqslant b \\ 1, &amp;amp; x&amp;gt;b\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>应用：实际中，很多观测取正（或精确导小数点后某一位）所产生的误差，零件的实际尺寸和规定尺寸之间的误差都常用均匀分布来描述&lt;/p>
&lt;h4 id="指数分布xsim-elambda">指数分布&lt;span class="math inline">\(X\sim e(\lambda)\)&lt;/span>&lt;/h4>
&lt;h5 id="指数分布的定义">指数分布的定义&lt;/h5>
&lt;p>设连续型随机变量X的密度函数为 &lt;span class="math inline">\(f(x)=\left\{\begin{array}{ll}\lambda \mathrm{e}^{-\lambda x}, &amp;amp; x \geqslant 0 \\ 0, &amp;amp; \text { 其他 }\end{array}\right.\)&lt;/span>，其中&lt;span class="math inline">\(\lambda &amp;gt;0\)&lt;/span>为常数， 则称X服从参数为&lt;span class="math inline">\(\lambda\)&lt;/span>的指数分布，记作&lt;span class="math inline">\(X\sim e(\lambda)\)&lt;/span>&lt;/p>
&lt;p>对应的X的分布函数为 &lt;span class="math inline">\(F(x)=\left\{\begin{array}{ll}1-\mathrm{e}^{-\lambda x}, &amp;amp; x \geqslant 0 \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span> 应用：是常用的”寿命“分布之一，比如电子产品或者元件的使用寿命，也常用来描述间隔时间、服务时间等的分布，如相邻两次电话铃响的间隔时间，在某个服务系统中接受服务的时间等。&lt;/p>
&lt;h5 id="指数分布的无记忆性">指数分布的无记忆性&lt;/h5>
&lt;p>指数分布具有所谓的的”无记忆性“： 即对任意的&lt;span class="math inline">\(s,t\ge 0\)&lt;/span>有&lt;span class="math inline">\(P(X&amp;gt;s+t \mid X&amp;gt;t)=P(X&amp;gt;s)\)&lt;/span>&lt;/p>
&lt;h4 id="正态分布xsim-nmusigma2">正态分布&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span>&lt;/h4>
&lt;h5 id="正态分布的概念">正态分布的概念&lt;/h5>
&lt;p>设随机变量X的密度函数为 &lt;span class="math inline">\(f(x)=\frac{1}{\sqrt{2 \pi} \sigma} \mathrm{e}^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}}\)&lt;/span>，&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>，其中&lt;span class="math inline">\(\mu, \sigma(\sigma&amp;gt;0)\)&lt;/span>为常数， 则称X服从参数为&lt;span class="math inline">\(\mu\)&lt;/span>和&lt;span class="math inline">\(\sigma\)&lt;/span>的正态分布或者高斯分布，记为&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span>&lt;/p>
&lt;p>正态分布的密度函数特点： 密度函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>的图像呈钟形曲线， &lt;span class="math inline">\(y=f(x)\)&lt;/span>关于直线&lt;span class="math inline">\(x=\mu\)&lt;/span>对称， &lt;span class="math inline">\(y=f(x)\)&lt;/span>在&lt;span class="math inline">\(x=\mu\)&lt;/span>处取得最大值&lt;span class="math inline">\(\frac{1}{\sqrt{2 \pi} \sigma}\)&lt;/span> &lt;span class="math inline">\(y=f(x)\)&lt;/span>在&lt;span class="math inline">\(x=\mu\pm\sigma\)&lt;/span>处出现两个拐点， x轴是&lt;span class="math inline">\(y=f(x)\)&lt;/span>的水平渐近线。&lt;/p>
&lt;p>&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span>，正态分布函数为 &lt;span class="math inline">\(F(x)=\frac{1}{\sqrt{2 \pi} \sigma} \int_{-\infty}^{x} \mathrm{e}^{-\frac{(x-\mu)^{2}}{2 \sigma^{2}}} \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>应用：正态分布在理论和应用中都占有重要的地位。实际中很多随机变量都服从或近似服从正态分布。比如人的身高、体重、测量误差、考试成绩、气体分子的运动位移等等。&lt;/p>
&lt;h5 id="正态分布的性质">正态分布的性质&lt;/h5>
&lt;h6 id="标准正态分布">标准正态分布&lt;/h6>
&lt;p>当&lt;span class="math inline">\(\mu=0,\sigma=1\)&lt;/span>时，&lt;span class="math inline">\(N(0,1)\)&lt;/span>称为标准正态分布。 标准正态分布&lt;span class="math inline">\(N(0,1)\)&lt;/span>的密度函数分别用&lt;span class="math inline">\(\varphi(x)\)&lt;/span>和&lt;span class="math inline">\(\Phi(x)\)&lt;/span>表示： &lt;span class="math inline">\(\varphi(x)=\frac{1}{\sqrt{2 \pi}} \mathrm{e}^{-\frac{x^{2}}{2}}\)&lt;/span> &lt;span class="math inline">\(\Phi(x)=\frac{1}{\sqrt{2 \pi}} \int_{-\infty}^{x} \mathrm{e}^{-\frac{x^{2}}{2}} \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h6 id="标准正态分布的密度函数varphix关于y轴对称">标准正态分布的密度函数&lt;span class="math inline">\(\varphi(x)\)&lt;/span>关于y轴对称&lt;/h6>
&lt;p>标准正态分度密度函数&lt;span class="math inline">\(\varphi(x)\)&lt;/span>关于y轴对称，不难得到对应分布函数&lt;span class="math inline">\(\Phi(x)\)&lt;/span>的性质： &lt;span class="math inline">\(\Phi(0)=\frac{1}{2}\)&lt;/span> &lt;span class="math inline">\(\Phi(-x)=1-\Phi(x)\)&lt;/span>&lt;/p>
&lt;h6 id="一般正态分布与标准正态分布的分布函数之间的关系">一般正态分布与标准正态分布的分布函数之间的关系&lt;/h6>
&lt;p>设随机变量X服从一般正态分布：&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span>，分布函数为&lt;span class="math inline">\(F(x)\)&lt;/span>, 则有&lt;span class="math inline">\(F(x)=\Phi\left(\frac{x-\mu}{\sigma}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="一维随机变量函数的分布">（一维）随机变量函数的分布&lt;/h2>
&lt;p>在很多问题中，我们关心的某个随机变量并不容易直接观测或者统计出来，但它却和某个（某些）容易观测统计的随机变量密切相关。 比如我们容易观测一批圆形零件的直径X，所以X的分布情况容易获得，而我们关心的时面积&lt;span class="math inline">\(Y=\pi\left(\frac{X}{2}\right)^2\)&lt;/span>的分布。&lt;/p>
&lt;p>下面讨论的内容就是如何由已知的随机变量X的分布，求出X的某个函数&lt;span class="math inline">\(Y=g(X)\)&lt;/span>的分布（Y也是随机变量）&lt;/p>
&lt;h3 id="离散型随机变量函数的分布">离散型随机变量函数的分布&lt;/h3>
&lt;p>若X时离散型随机变量（即X的取值至多时可列多个），那么它的函数&lt;span class="math inline">\(Y=g(X)\)&lt;/span>显然也是离散型随机变量（因为Y的取值也是至多是可列多个）。由X的分布律不难求出Y的分布律。&lt;/p>
&lt;h3 id="连续型随机变量函数的分布">连续型随机变量函数的分布&lt;/h3>
&lt;p>一般来说，求连续型随机变量X的函数&lt;span class="math inline">\(Y=g(X)\)&lt;/span>的分布，都是由分布函数的定义求出Y的分布函数&lt;span class="math inline">\(F_Y(y) = P(Y\le y)\)&lt;/span>; 这需要将&lt;span class="math inline">\(Y\le y\)&lt;/span>化成与它等价的关于X的不等式，再由X的分布即可求出&lt;span class="math inline">\(F_Y(y)\)&lt;/span>; 若&lt;span class="math inline">\(F_Y(y)\)&lt;/span>可导，则可求出Y的密度函数。&lt;/p>
&lt;h5 id="x的线性函数yaxb的一般解法">X的线性函数&lt;span class="math inline">\(Y=aX+b\)&lt;/span>的一般解法&lt;/h5>
&lt;p>以一个例子来说明：&lt;/p>
&lt;p>例1：已知X的密度函数为&lt;span class="math inline">\(f_X (x)\)&lt;/span>，求&lt;span class="math inline">\(Y=3X+5\)&lt;/span>的密度函数&lt;span class="math inline">\(f_Y(y)\)&lt;/span>&lt;/p>
&lt;p>先求分布函数： &lt;span class="math inline">\(\begin{aligned} F_{Y}(y) &amp;amp;=P(Y \leqslant y)=P(3 X+5 \leqslant y) \\ &amp;amp;=P\left(X \leqslant \frac{y-5}{3}\right) \\ &amp;amp;=F_{X}\left(\frac{y-5}{3}\right) \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>于是Y的密度函数为： &lt;span class="math inline">\(f_{Y}(y)=F_{Y}^{\prime}(y)=\frac{1}{3} f_{X}\left(\frac{y-5}{3}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="已知x的密度函数f_xx求yaxb的密度函数">已知X的密度函数&lt;span class="math inline">\(f_X(x)\)&lt;/span>，求&lt;span class="math inline">\(Y=aX+b\)&lt;/span>的密度函数&lt;/h5>
&lt;p>设X的密度函数&lt;span class="math inline">\(f_X(x)\)&lt;/span>，则&lt;span class="math inline">\(Y=aX+b\)&lt;/span>的密度函数为 &lt;span class="math inline">\(f_{Y}(y)=\frac{1}{|a|} f_{X}\left(\frac{y-b}{a}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="已知xsim-nmusigma2求yaxb的密度函数">已知&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span>，求&lt;span class="math inline">\(Y=aX+b\)&lt;/span>的密度函数&lt;/h5>
&lt;p>设&lt;span class="math inline">\(X\sim N(\mu,\sigma^2),Y=aX+b \quad(a\neq0)\)&lt;/span>，则&lt;span class="math inline">\(Y\sim N(a\mu+b,a^2 \mu^2)\)&lt;/span>&lt;/p>
&lt;p>特别的&lt;span class="math inline">\(X\sim N(\mu,\sigma^2)\)&lt;/span> ，&lt;span class="math inline">\(Y=\frac{X-\mu}{\sigma}\)&lt;/span>，则&lt;span class="math inline">\(Y=\frac{X-\mu}{\sigma} \sim N(0,1)\)&lt;/span>&lt;/p>
&lt;h5 id="ygx在定义域处处可导且不变号时的密度函数">&lt;span class="math inline">\(Y=g(X)\)&lt;/span>在定义域处处可导且不变号时的密度函数&lt;/h5>
&lt;p>设随机变量X的密度函数为&lt;span class="math inline">\(f_X, -\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>， 函数&lt;span class="math inline">\(g(x)\)&lt;/span>在定义域D内处处可导且恒有&lt;span class="math inline">\(g^\prime(x)&amp;gt;0\)&lt;/span>（或恒有&lt;span class="math inline">\(g^\prime(x)&amp;lt;0\)&lt;/span>）， 则&lt;span class="math inline">\(Y=g(X)\)&lt;/span>是连续型随机变量，其密度函数为&lt;span class="math inline">\(f_{Y}(y)=\left\{\begin{array}{ll}f_{X}(h(y))\left|h^{\prime}(y)\right|, &amp;amp; \alpha&amp;lt;y&amp;lt;\beta \\ 0, &amp;amp; \text { 其他 }\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h2 id="n维随机变量及其分布">n维随机变量及其分布&lt;/h2>
&lt;p>前面我们讨论了单个随机变量及其分布。然而也有许多实际问题中往往同时关心多个随机变量。&lt;/p>
&lt;p>比如观察高考同学的数学、物理、英语成绩，就有三个随机变量； 调查某地居民的收入和消费状况，则由两个随机变量； 研究n只股票的价格情况，需要n个随机变量等。&lt;/p>
&lt;h3 id="n维随机变量及其联合分布函数">n维随机变量及其联合分布函数&lt;/h3>
&lt;h4 id="n维随机变量x_1x_2cdotsx_n">n维随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>&lt;/h4>
&lt;p>设随机现象的样本空间为&lt;span class="math inline">\(\Omega\)&lt;/span>，有n个定义在&lt;span class="math inline">\(\Omega\)&lt;/span>上的随机变量&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>，常把&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>称为n为随机变量（也称n维随机向量）。 我们重点讨论二维随机变量，其结果不难推广到n维的情况&lt;/p>
&lt;h4 id="二维随机变量xy的联合分布函数的定义">二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的（联合）分布函数的定义&lt;/h4>
&lt;p>设&lt;span class="math inline">\((X,Y)\)&lt;/span>是二维随机变量， 称二元函数&lt;span class="math inline">\(F(x, y)=P(X \leqslant x, Y \leqslant y), \quad x, y \in \mathbf{R}\)&lt;/span> 为&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合分布函数。&lt;/p>
&lt;p>对每个&lt;span class="math inline">\((x,y)\in R^2\)&lt;/span>，&lt;span class="math inline">\(F(x,y)\)&lt;/span>表示事件&lt;span class="math inline">\(\{X\le x\}\)&lt;/span>与事件&lt;span class="math inline">\(\{Y\le y\}\)&lt;/span>同时发生的概率&lt;/p>
&lt;h4 id="二维随机变量的联合分布函数的性质">二维随机变量的联合分布函数的性质&lt;/h4>
&lt;p>设&lt;span class="math inline">\(F(x,y)\)&lt;/span>是&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合分布函数，则有如下性质&lt;/p>
&lt;h5 id="二维随机变量xy落在区域abtimescd内的概率">二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>落在区域&lt;span class="math inline">\((a,b]\times(c,d]\)&lt;/span>内的概率&lt;/h5>
&lt;p>&lt;span class="math inline">\(\begin{aligned} &amp;amp;P(a&amp;lt;X \leqslant b, c&amp;lt;Y \leqslant d)\\=&amp;amp; P(X \leqslant b, Y \leqslant d)-P(X \leqslant b, Y \leqslant c) -P(X \leqslant a, Y \leqslant d)+P(X \leqslant a, Y \leqslant c) \\=&amp;amp; F(b, d)-F(b, c)-F(a, d)+F(a, c) \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="固定x或yfxy关于y或x单调不减">固定x（或y），&lt;span class="math inline">\(F(x,y)\)&lt;/span>关于y（或x）单调不减&lt;/h5>
&lt;h5 id="f-infty-ylim-_x-rightarrow-infty-fx-y0">&lt;span class="math inline">\(F(-\infty, y)=\lim _{x \rightarrow-\infty} F(x, y)=0\)&lt;/span>&lt;/h5>
&lt;h5 id="fx-inftylim-_y-rightarrow-infty-fx-y0">&lt;span class="math inline">\(F(x,-\infty)=\lim _{y \rightarrow-\infty} F(x, y)=0\)&lt;/span>&lt;/h5>
&lt;h5 id="finftyinftylim-_x-rightarrowinfty-atop-y-rightarrowinfty-fx-y1">&lt;span class="math inline">\(F(+\infty,+\infty)=\lim _{x \rightarrow+\infty \atop y \rightarrow+\infty} F(x, y)=1\)&lt;/span>&lt;/h5>
&lt;h5 id="可由联合分布函数fx-y求出x和y各自的分布函数边缘分布函数">可由联合分布函数&lt;span class="math inline">\(F(x, y)\)&lt;/span>求出X和Y各自的分布函数（边缘分布函数）&lt;/h5>
&lt;p>X的（边缘）分布函数： &lt;span class="math inline">\(\begin{aligned} F_{X}(x)=P(X \leqslant x) &amp;amp;=P(X \leqslant x, Y \leqslant+\infty) \\ &amp;amp;=F(x,+\infty) \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>Y的（边缘）分布函数： &lt;span class="math inline">\(\begin{aligned} F_{Y}(y)=P(Y \leqslant y) &amp;amp;=P(X \leqslant+\infty, Y \leqslant y) \\ &amp;amp;=F(+\infty, y) \end{aligned}\)&lt;/span>&lt;/p>
&lt;h4 id="n维随机变量x_1x_2cdotsx_n的联合分布函数fleftx_1-x_2-cdots-x_nright">n维随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>的（联合）分布函数&lt;span class="math inline">\(F\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>&lt;/h4>
&lt;p>对任意实数&lt;span class="math inline">\(x_1,x_2,\cdots,x_n\)&lt;/span>，函数&lt;span class="math inline">\(F\left(x_{1}, x_{2}, \cdots, x_{n}\right)=P\left(X_{1} \leqslant x_{1}, X_{2} \leqslant x_{2}, \cdots, X_{n} \leqslant x_{n}\right)\)&lt;/span>称为n维随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>的联合分布函数&lt;/p>
&lt;h3 id="二维离散型随机变量及其分布">二维离散型随机变量及其分布&lt;/h3>
&lt;h4 id="二维离散型随机变量及其分布-1">二维离散型随机变量及其分布&lt;/h4>
&lt;p>若X和Y都是离散型随机变量，则称&lt;span class="math inline">\((X,Y)\)&lt;/span>为&lt;strong>二维离散型随机变量&lt;/strong>&lt;/p>
&lt;p>设&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维离散型随机变量，X的所有可能取值为&lt;span class="math inline">\(x_1,x_2,\cdots\)&lt;/span>，Y的所有可能取值为&lt;span class="math inline">\(y_1,y_2,\cdots\)&lt;/span>， 将&lt;span class="math inline">\(P(X=x_i,Y=y_i) = p_{ij}, \quad i,j = 1,2,\cdots\)&lt;/span>称为二维离散型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的&lt;strong>（联合）概率分布&lt;/strong>，或者&lt;strong>联合概率分布律（列）&lt;/strong>，简称联合分布律（列）。&lt;/p>
&lt;p>二维离散型随机变量的联合分布律也常用联合分布表来描述。&lt;/p>
&lt;h4 id="二维离散型随机变量概率分布性质">二维离散型随机变量概率分布性质&lt;/h4>
&lt;h5 id="p_ij-ge-0">&lt;span class="math inline">\(p_{ij} \ge 0\)&lt;/span>&lt;/h5>
&lt;p>&lt;span class="math inline">\(\sum_i {\sum_j {p_{ij}}} = 1\)&lt;/span>&lt;/p>
&lt;h5 id="可由离散型联合分布求出x和y各自的分布律边缘分布">可由离散型联合分布求出X和Y各自的分布律（边缘分布）&lt;/h5>
&lt;p>X的分布律为： &lt;span class="math inline">\(P\left(X=x_{i}\right)=\sum_{j} P\left(X=x_{i}, Y=y_{j}\right)=\sum_{j} p_{i j} \stackrel{\text { 记为 }}{=} p_{i}\)&lt;/span>&lt;/p>
&lt;p>Y的分布律为： &lt;span class="math inline">\(P\left(Y=y_{j}\right)=\sum_{i} P\left(X=x_{i}, Y=y_{j}\right)=\sum_{i} p_{i j} \stackrel{\text { 记为 }}{\Longrightarrow} p_{\cdot j}\)&lt;/span>&lt;/p>
&lt;h3 id="n维连续型随机变量及其分布">n维连续型随机变量及其分布&lt;/h3>
&lt;h4 id="二维及n维连续型随机变量及其分布和密度函数定义">二维及n维连续型随机变量及其分布和密度函数定义&lt;/h4>
&lt;p>设二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合分布函数为&lt;span class="math inline">\(F(x,y)\)&lt;/span>， 若存在可积函数&lt;span class="math inline">\(f(x,y)\ge 0\)&lt;/span>， 使得对于任意实数x，y，都有&lt;span class="math inline">\(F(x, y)=\int_{-\infty}^{x} \int_{-\infty}^{y} f(s, t) \mathrm{d} s \mathrm{~d} t\)&lt;/span>, 则称&lt;span class="math inline">\((X,Y)\)&lt;/span>为&lt;strong>二维连续型随机变量&lt;/strong>，&lt;span class="math inline">\(f(x,y)\)&lt;/span>称为&lt;span class="math inline">\((X,Y)\)&lt;/span>的&lt;strong>联合密度函数&lt;/strong>，记作&lt;span class="math inline">\(f(x,y)\sim f(x,y)\)&lt;/span>&lt;/p>
&lt;p>类似的，可以定义n维连续性随机变量，以及n维随机变量的联合密度函数&lt;span class="math inline">\(f(x_1,x_2,\cdots,x_n)\)&lt;/span>&lt;/p>
&lt;h4 id="二维连续型随机变量的分布函数和密度函数的性质">二维连续型随机变量的分布函数和密度函数的性质&lt;/h4>
&lt;h5 id="finftyinftyint_-inftyinfty-int_-inftyinfty-fx-y-mathrmd-x-mathrmd-y1">&lt;span class="math inline">\(F(+\infty,+\infty)=\)&lt;/span>&lt;span class="math inline">\(\int_{-\infty}^{+\infty} \int_{-\infty}^{+\infty} f(x, y) \mathrm{d} x \mathrm{~d} y=1\)&lt;/span>&lt;/h5>
&lt;h5 id="px-y-in-giint_g-fx-y-mathrmd-x-mathrmd-y">&lt;span class="math inline">\(P((X, Y) \in G)=\iint_{G} f(x, y) \mathrm{d} x \mathrm{~d} y\)&lt;/span>&lt;/h5>
&lt;p>对任何二维平面上的区域G，有&lt;span class="math inline">\(P((X, Y) \in G)=\iint_{G} f(x, y) \mathrm{d} x \mathrm{~d} y\)&lt;/span>，其中&lt;span class="math inline">\(\iint_G\)&lt;/span>表示在区域G上作二重积分。&lt;/p>
&lt;p>由此性质，我们可以求出二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>落在平面上某个区域的概率。&lt;/p>
&lt;h5 id="f_x-yprime-primex-yfx-y">&lt;span class="math inline">\(F_{x y}^{\prime \prime}(x, y)=f(x, y)\)&lt;/span>&lt;/h5>
&lt;p>&lt;span class="math inline">\(F_{x y}^{\prime \prime}(x, y)=f(x, y)\)&lt;/span>，其中&lt;span class="math inline">\(F_{x y}^{\prime \prime}(x, y)=f(x, y)\)&lt;/span>表示&lt;span class="math inline">\(F(x,y)\)&lt;/span>的二阶混合偏导数。&lt;/p>
&lt;h5 id="由二维连续随机变量的联合密度函数求得x和y各自的边缘分布函数与边缘密度函数">由（二维连续随机变量的）联合密度函数求得X和Y各自的（边缘）分布函数与（边缘）密度函数&lt;/h5>
&lt;p>由（二维连续型随机变量的）联合密度函数 可求得X和Y各自分布函数（又叫边缘分布函数）与各自的密度函数（又叫边缘密度函数）&lt;/p>
&lt;p>根据&lt;a href="#可由联合分布函数$F(x,%20y)$求出X和Y各自的分布函数（边缘分布函数）">联合分布求边缘分布的方法&lt;/a>，&lt;/p>
&lt;p>X的（边缘）分布函数为： &lt;span class="math inline">\(\begin{aligned} F_{X}(x) &amp;amp;=F(x,+\infty) \\ &amp;amp;=\int_{-\infty}^{x} \int_{-\infty}^{+\infty} f(x, y) \mathrm{d} x \mathrm{~d} y \\ &amp;amp;=\int_{-\infty}^{x}\left[\int_{-\infty}^{+\infty} f(x, y) \mathrm{d} y\right] \mathrm{d} x \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>因此X的（边缘）密度函数为： &lt;span class="math inline">\(f_{X}(x)=\int_{-\infty}^{+\infty} f(x, y) \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>同理可得Y的（边缘）密度函数为： &lt;span class="math inline">\(f_{Y}(y)=\int_{-\infty}^{+\infty} f(x, y) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h4 id="n维连续型随机变量的分布函数和密度函数的性质">n维连续型随机变量的分布函数和密度函数的性质&lt;/h4>
&lt;p>大部分是二维情况的简单推广。部分略。&lt;/p>
&lt;h5 id="由n维连续随机变量的联合密度函数求得x和y各自的边缘密度函数">由（n维连续随机变量的）联合密度函数求得X和Y各自的（边缘）密度函数&lt;/h5>
&lt;p>设n维连续型随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>的密度函数为&lt;span class="math inline">\(f(x_1,x_2,\cdots,x_n)\)&lt;/span>, 则可以计算每个&lt;span class="math inline">\(X_i\)&lt;/span>的分布函数（也叫边缘密度函数）。 以&lt;span class="math inline">\(X_1\)&lt;/span>为例，它的（边缘）密度函数为&lt;span class="math inline">\(f_{X_{1}}\left(x_{1}\right)=\int_{-\infty}^{+\infty} \cdots \int_{-\infty}^{+\infty} f\left(x_{1}, x_{2}, \cdots, x_{n}\right) \mathrm{d} x_{2} \cdots \mathrm{d} x_{n}\)&lt;/span>&lt;/p>
&lt;h4 id="几种特殊常见的二维两虚型随机变量的分布">几种特殊（常见）的二维两虚型随机变量的分布&lt;/h4>
&lt;h5 id="二维连续型随机变量的均匀分布">二维连续型随机变量的均匀分布&lt;/h5>
&lt;p>设G是&lt;span class="math inline">\(xOy\)&lt;/span>面上的有界区域，面积为A。 若二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合密度函数为: &lt;span class="math inline">\(f(x, y)=\left\{\begin{array}{ll}\frac{1}{(b-a)(d-c)}, &amp;amp; a \leqslant x \leqslant b, c \leqslant y \leqslant d \\ 0, &amp;amp; \text { 其他. }\end{array}\right.\)&lt;/span> 则称&lt;span class="math inline">\((X,Y)\)&lt;/span>服从区域G上的均匀分布&lt;/p>
&lt;h5 id="二维连续型随机变量的正态分布">二维连续型随机变量的正态分布&lt;/h5>
&lt;p>若二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合密度函数为: &lt;span class="math inline">\(\begin{aligned} f(x, y)=&amp;amp; \frac{1}{2 \pi \sigma_{1} \sigma_{2} \sqrt{1-\rho^{2}}} \\ &amp;amp; \times \exp \left\{-\frac{1}{2\left(1-\rho^{2}\right)}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}-2 \rho \frac{\left(x-\mu_{1}\right)\left(y-\mu_{2}\right)}{\sigma_{1} \sigma_{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}\right]\right\} \end{aligned}\)&lt;/span> &lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty,-\infty&amp;lt;y&amp;lt;+\infty\)&lt;/span> 其中&lt;span class="math inline">\(\mu_{1}, \mu_{2}, \sigma_{1}, \sigma_{2}, \rho\)&lt;/span>都是常数，且&lt;span class="math inline">\(\sigma_{1}&amp;gt;0, \sigma_{2}&amp;gt;0,-1&amp;lt;\rho&amp;lt;1\)&lt;/span> 则称&lt;span class="math inline">\((X,Y)\)&lt;/span>服从参数为&lt;span class="math inline">\(\mu_{1}, \mu_{2}, \sigma_{1}, \sigma_{2}, \rho\)&lt;/span>的二维正态分布，记为&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>&lt;/p>
&lt;p>可以求出X，Y各自的密度函数（边缘密度函数）： &lt;span class="math inline">\(f_{X}(x)=\frac{1}{\sqrt{2 \pi} \sigma_{1}} e^{-\frac{\left(x-\mu_{1}\right)^{2}}{2 \sigma_{1}^{2}}}, \quad-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span> &lt;span class="math inline">\(f_{Y}(y)=\frac{1}{\sqrt{2 \pi} \sigma_{2}} e^{-\frac{\left(y-\mu_{2}\right)^{2}}{2 \sigma_{2}^{2}}}, \quad-\infty&amp;lt;y&amp;lt;+\infty\)&lt;/span>&lt;/p>
&lt;p>可以看出若&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>，则&lt;span class="math inline">\(X \sim N\left(\mu_{1}, \sigma_{1}^{2}\right), Y \sim N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>。 即二维正态分布的边缘分布为对应的一维正态分布。 关于参数&lt;span class="math inline">\(\rho\)&lt;/span>的意义将在协方差和相关系数章节介绍。&lt;/p>
&lt;h3 id="随机变量的独立性">随机变量的独立性&lt;/h3>
&lt;p>事件与概率章节我们讨论了随机事件之间的独立性。 而用落在特定区域的随机变量可以表示随机事件。&lt;/p>
&lt;p>下面我们讨论随机变量之间的独立性。&lt;/p>
&lt;h4 id="二维随机变量xy中随机变量x与y独立的定义">二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>中随机变量X与Y独立的定义&lt;/h4>
&lt;p>设二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的分布函数为&lt;span class="math inline">\(F(x,y)\)&lt;/span>，X和Y各自的分布函数为&lt;span class="math inline">\(F_X(x)\)&lt;/span>和&lt;span class="math inline">\(F_Y(y)\)&lt;/span>. 若对任意的实数x,y有&lt;span class="math inline">\(F(x,y)=F_X(x) F_Y(y)\)&lt;/span>, 则称X与Y独立&lt;/p>
&lt;p>由分布函数的定义知&lt;span class="math inline">\(F(x,y)=F_X(x) F_Y(y)\)&lt;/span>可以写成&lt;span class="math inline">\(P(X\le x, Y \le y) = P(X\le x) P(Y \le y)\)&lt;/span> 因此X与Y独立是指对于任意实数x，y，事件&lt;span class="math inline">\(\{X\le x\}\)&lt;/span>和事件&lt;span class="math inline">\(\{Y\le y\}\)&lt;/span>独立。 由此可看出随机变量的独立性由事件的独立性引申而来。&lt;/p>
&lt;h4 id="二维离散型随机变量xy中x与y独立的等价条件">二维离散型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>中X与Y独立的等价条件&lt;/h4>
&lt;p>如果&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维离散型随机变量，X和Y的取值分别为&lt;span class="math inline">\(x_1,x_2,\cdots\)&lt;/span>和&lt;span class="math inline">\(y_1,y_2,\cdots\)&lt;/span>, 则X与Y独立&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>对于任意的&lt;span class="math inline">\(x_i,y_j\)&lt;/span>，有&lt;span class="math inline">\(P(X = x_i, Y= y_i) = P(X= x_i) P(Y= y_j)\)&lt;/span>&lt;/p>
&lt;h4 id="二维连续型随机变量xy中x与y独立的等价条件">二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>中X与Y独立的等价条件&lt;/h4>
&lt;p>如果&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维连续型随机变量，联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>,边缘密度函数为&lt;span class="math inline">\(f_X(x)\)&lt;/span>和&lt;span class="math inline">\(f_Y(y)\)&lt;/span> 则X与Y独立&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(f(x,y) = f_X(x) f_Y(y)\)&lt;/span>&lt;/p>
&lt;h4 id="二维正态分布x-y-sim-nleftmu_1-mu_2-sigma_12-sigma_22-rhoright中x与y独立leftrightarrow-rho-0">二维正态分布&lt;span class="math inline">\((X, Y) \sim N\left(\mu_{1}, \mu_{2}, \sigma_{1}^{2}, \sigma_{2}^{2}, \rho\right)\)&lt;/span>中X与Y独立&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\rho = 0\)&lt;/span>&lt;/h4>
&lt;p>证明 &lt;span class="math inline">\(\Leftarrow\)&lt;/span>的证明： 设&lt;span class="math inline">\(\rho = 0\)&lt;/span>,则&lt;a href="#二维连续型随机变量的正态分布">二维正态分布的联合密度函数&lt;/a>化为： &lt;span class="math inline">\(\begin{aligned} f(x, y) &amp;amp;=\frac{1}{2 \pi \sigma_{1} \sigma_{2}} \exp \left\{-\frac{1}{2}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}\right]\right\} \\ &amp;amp;=\frac{1}{\sqrt{2 \pi} \sigma_{1}} \mathrm{e}^{-\frac{\left(x-\mu_{1}\right)^{2}}{2 \sigma_{1}^{2}}} \cdot \frac{1}{\sqrt{2 \pi} \sigma_{2}} \mathrm{e}^{-\frac{\left(y-\mu_{2}\right)^{2}}{2 \sigma_{2}^{2}}} \\ &amp;amp;=f_{X}(x) f_{Y}(y) \end{aligned}\)&lt;/span> 则X与Y独立。 &lt;span class="math inline">\(\Rightarrow\)&lt;/span>的证明： 设X与Y独立，则&lt;span class="math inline">\(f(x, y)=f_{X}(x) f_{Y}(y)\)&lt;/span>，又： &lt;span class="math inline">\(\begin{aligned} f(x, y)=&amp;amp; \frac{1}{2 \pi \sigma_{1} \sigma_{2} \sqrt{1-\rho^{2}}} \\ &amp;amp; \times \exp \left\{-\frac{1}{2\left(1-\rho^{2}\right)}\left[\frac{\left(x-\mu_{1}\right)^{2}}{\sigma_{1}^{2}}-2 \rho \frac{\left(x-\mu_{1}\right)\left(y-\mu_{2}\right)}{\sigma_{1} \sigma_{2}}+\frac{\left(y-\mu_{2}\right)^{2}}{\sigma_{2}^{2}}\right]\right\} \end{aligned}\)&lt;/span> &lt;span class="math inline">\(f_{X}(x) f_{Y}(y)=\frac{1}{\sqrt{2 \pi} \sigma_{1}} \mathrm{e}^{-\frac{\left(x-\mu_{1}\right)^{2}}{2 \sigma_{1}^{2}}} \cdot \frac{1}{\sqrt{2 \pi} \sigma_{2}} \mathrm{e}^{-\frac{\left(y-\mu_{2}\right)^{2}}{2 \sigma_{2}^{2}}}\)&lt;/span> 取&lt;span class="math inline">\(x=\mu_1,y=\mu_2\)&lt;/span>计算，易得&lt;span class="math inline">\(\rho = 0\)&lt;/span>&lt;/p>
&lt;h4 id="n维随机变量相互独立的定义">n维随机变量相互独立的定义&lt;/h4>
&lt;p>设n维随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>的联合分布函数&lt;span class="math inline">\(F\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>, &lt;span class="math inline">\(X_i\)&lt;/span>的分布函数（也叫边缘分布函数）为&lt;span class="math inline">\(F_{X_i} (x_i)\)&lt;/span>, 若&lt;span class="math inline">\(F\left(x_{1}, x_{2}, \cdots, x_{n}\right)=F_{X_{1}}\left(x_{1}\right) F_{X_{2}}\left(x_{2}\right) \cdots F_{X_{n}}\left(x_{n}\right)=\prod_{i=1}^{n} F_{X_{i}}\left(x_{i}\right)\)&lt;/span>， 则称&lt;span class="math inline">\(X_1,X_2,\cdots,X_n\)&lt;/span>相互独立。&lt;/p>
&lt;h4 id="n维随机变量相互独立的性质">n维随机变量相互独立的性质&lt;/h4>
&lt;p>设n维随机变量&lt;span class="math inline">\((X_1,X_2,\cdots,X_n)\)&lt;/span>相互独立， 把它们任意分成两组，比如&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{k}\)&lt;/span>作为一组，&lt;span class="math inline">\(X_{k+1}, \cdots, X_{n}\)&lt;/span>作为一组。 由&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{k}\)&lt;/span>作任意运算得到随机变量记为Y， 由&lt;span class="math inline">\(X_{k+1}, \cdots, X_{n}\)&lt;/span>作任意运算的到随机变量记为Z， 则Y与Z相互独立。&lt;/p>
&lt;h3 id="二维随机变量函数的分布">二维随机变量函数的分布&lt;/h3>
&lt;p>前面我们讨论过如何由X的分布求X的某个函数&lt;span class="math inline">\(g(X)\)&lt;/span>的分布。 对于二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>,，我们也常考虑如何根据&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合分布获得由X和Y构造的某个函数&lt;span class="math inline">\(g(X,Y)\)&lt;/span>的分布。&lt;/p>
&lt;p>下面重点讨论如何求&lt;span class="math inline">\(X+Y\)&lt;/span>的分布，至于其他函数可按同样的思路去分析。&lt;/p>
&lt;h4 id="zxy的分布">&lt;span class="math inline">\(Z=X+Y\)&lt;/span>的分布&lt;/h4>
&lt;h5 id="离散型二维随机变量xy求随机函数zxy的分布">离散型二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>，求随机函数&lt;span class="math inline">\(Z=X+Y\)&lt;/span>的分布&lt;/h5>
&lt;p>设&lt;span class="math inline">\((X,Y)\)&lt;/span>为二维离散型随机变量，X的所有可能取值为&lt;span class="math inline">\(x_1,x_2,\cdots\)&lt;/span>，Y的所有可能取值为&lt;span class="math inline">\(y_1,y_2,\cdots\)&lt;/span>， &lt;span class="math inline">\(P(X=x_i,Y=y_i) = p_{ij}, \quad i,j = 1,2,\cdots\)&lt;/span>是二维离散型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的（联合）概率分布&lt;/p>
&lt;p>显然&lt;span class="math inline">\(Z=X+Y\)&lt;/span>也是离散型随机变量。设Z的可能取值为&lt;span class="math inline">\(z_1,z_2,\cdots\)&lt;/span>， 则&lt;span class="math inline">\(P(Z= z_k) = P(X+Y = z_k) = \sum_i P(X=x_i, Y=z_k - x_i)\)&lt;/span> 或者&lt;span class="math inline">\(P\left(Z=z_{k}\right)=\sum_{j} P\left(X=z_{k}-y_{j}, Y=y_{j}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>若&lt;/strong>X与Y独立， 则&lt;span class="math inline">\(P\left(Z=z_{k}\right)=\sum_{i} P\left(X=x_{i}\right) P\left(Y=z_{k}-x_{i}\right)\)&lt;/span> 或者&lt;span class="math inline">\(P\left(Z=z_{k}\right)=\sum_{j} P\left(X=z_{k}-y_{j}\right) P\left(Y=y_{j}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="连续型二维随机变量xy求随机函数zxy的分布">连续型二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>，求随机函数&lt;span class="math inline">\(Z=X+Y\)&lt;/span>的分布&lt;/h5>
&lt;p>为了求&lt;span class="math inline">\(Z=X+Y\)&lt;/span>的密度函数，仍然是先求分布函数，再求导。&lt;/p>
&lt;p>连续型二维随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>, 则Z的分布函数为 &lt;span class="math inline">\(\begin{aligned} F_{Z}(z) &amp;amp;=P(Z \leqslant z)=P(X+Y \leqslant z) \\ &amp;amp;=\iint_{x+y \leqslant z} f(x, y) \mathrm{d} x \mathrm{~d} y \end{aligned}\)&lt;/span> 其中积分区域为二维平面上所有满足&lt;span class="math inline">\(x+y\le z\)&lt;/span>的点&lt;span class="math inline">\((x,y)\)&lt;/span>组成的区域，即直线&lt;span class="math inline">\(x+y=z\)&lt;/span>的左下方区域。&lt;/p>
&lt;p>将二重积分化为累次积分&lt;span class="math inline">\(F_{Z}(z)=\int_{-\infty}^{+\infty} \mathrm{d} x \int_{-\infty}^{z-x} f(x, y) \mathrm{d} y\)&lt;/span> 两边对z求导，得z得密度函数为&lt;span class="math inline">\(f_{Z}(z)=\int_{-\infty}^{+\infty} f(x, z-x) \mathrm{d} x\)&lt;/span> 同理（化为另一种累次积分）最终得&lt;span class="math inline">\(f_{Z}(z)=\int_{-\infty}^{+\infty} f(z-y, y) \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>若&lt;/strong>X与Y独立， 则&lt;span class="math inline">\(f_{Z}(z)=\int_{-\infty}^{+\infty} f_{X}(x) f_{Y}(z-x) \mathrm{d} x\)&lt;/span> 或者&lt;span class="math inline">\(f_{Z}(z)=\int_{-\infty}^{+\infty} f_{X}(z-y) f_{Y}(y) \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>可证明： 若&lt;span class="math inline">\(X \sim N\left(\mu_{1}, \sigma_{1}^{2}\right), Y \sim N\left(\mu_{2}, \sigma_{2}^{2}\right)\)&lt;/span>，且X与Y独立，则&lt;span class="math inline">\(X+Y \sim N\left(\mu_{1}+\mu_{2}, \sigma_{1}^{2}+\sigma_{2}^{2}\right)\)&lt;/span> 并可推广到更一般得情形： 设&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>相互独立，且&lt;span class="math inline">\(X_{i} \sim N\left(\mu_{i}, \sigma_{i}^{2}\right), c_{1}, c_{2}, \cdots, c_{n}\)&lt;/span>是不全为0的数， 则&lt;span class="math inline">\(\sum_{i=1}^{n} c_{i} X_{i} \sim N\left(\sum_{i=1}^{n} c_{i} \mu_{i}, \sum_{i=1}^{n} c_{i}^{2} \sigma_{i}^{2}\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="最大值maxxy与最小值minxy的分布">最大值&lt;span class="math inline">\(max(X,Y)\)&lt;/span>与最小值&lt;span class="math inline">\(min(X,Y)\)&lt;/span>的分布&lt;/h4>
&lt;p>&lt;strong>设随机变量X与Y独立&lt;/strong>，分布函数分别为&lt;span class="math inline">\(F_X(x)\)&lt;/span>及&lt;span class="math inline">\(F_Y(y)\)&lt;/span>&lt;/p>
&lt;h5 id="最大值zmaxxy的分布">最大值&lt;span class="math inline">\(Z=max(X,Y)\)&lt;/span>的分布&lt;/h5>
&lt;p>在X与Y独立的前提下&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} F_{Z}(z) &amp;amp;=P(Z \leqslant z)=P(\max (X, Y) \leqslant z)=P(X \leqslant z, Y \leqslant z) \\ &amp;amp;=P(X \leqslant z) P(Y \leqslant z)=F_{X}(z) F_{Y}(z) \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="最小值zminxy的分布">最小值&lt;span class="math inline">\(Z=min(X,Y)\)&lt;/span>的分布&lt;/h5>
&lt;p>在X与Y独立的前提下&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} F_{Z}(z) &amp;amp;=P(Z \leqslant z)=P(\min (X, Y) \leqslant z) \\ &amp;amp;=1-P[\min (X, Y)&amp;gt;z] \\ &amp;amp;=1-P(X&amp;gt;z, Y&amp;gt;z) \\ &amp;amp;=1-P(X&amp;gt;z) P(Y&amp;gt;z) \\ &amp;amp;=1-[1-P(X \leqslant z)][1-P(Y \leqslant z)] \\&amp;amp;=1-[1-F_X(z)][1-F_Y(z)] \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="推广到n维随机变量的最大值与最小值的分布">推广到n维随机变量的最大值与最小值的分布&lt;/h5>
&lt;p>&lt;strong>设&lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>相互独立&lt;/strong>，&lt;span class="math inline">\(X_i\)&lt;/span>的分布函数为&lt;span class="math inline">\(F_i(x) \quad (i= 1,2,\cdots,n)\)&lt;/span>, &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>的最大值&lt;span class="math inline">\(max(X_{1}, X_{2}, \cdots, X_{n})\)&lt;/span>的分布函数为&lt;span class="math inline">\(F_{\max }(z)=\prod_{i=1}^{n} F_{i}(z)\)&lt;/span> &lt;span class="math inline">\(X_{1}, X_{2}, \cdots, X_{n}\)&lt;/span>的最小值&lt;span class="math inline">\(min(X_{1}, X_{2}, \cdots, X_{n})\)&lt;/span>的分布函数为&lt;span class="math inline">\(F_{\min }(z)=1-\prod_{i=1}^{n}\left[1-F_{i}(z)\right]\)&lt;/span>&lt;/p>
&lt;h3 id="条件分布简介">条件分布简介&lt;/h3>
&lt;p>在事件与概率章节，我们讨论了条件概率。有了随变量，我们可以进一步讨论条件分布。&lt;/p>
&lt;h4 id="二维离散型随机变量xy情形下的条件分布">二维离散型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>情形下的条件分布&lt;/h4>
&lt;p>设有二维离散型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>， 其联合分布函数为&lt;span class="math inline">\(P(X=x_i,Y=y_i) = p_{ij}, \quad i,j = 1,2,\cdots\)&lt;/span>&lt;/p>
&lt;p>X和Y各自的分布律（边缘分布律）为： X的分布律为：&lt;span class="math inline">\(P\left(X=x_{i}\right)=\sum_{j} P\left(X=x_{i}, Y=y_{j}\right)=\sum_{j} p_{i j} \stackrel{\text { 记为 }}{=} p_{i}\)&lt;/span> Y的分布律为：&lt;span class="math inline">\(P\left(Y=y_{j}\right)=\sum_{i} P\left(X=x_{i}, Y=y_{j}\right)=\sum_{i} p_{i j} \stackrel{\text { 记为 }}{\Longrightarrow} p_{\cdot j}\)&lt;/span>&lt;/p>
&lt;p>设&lt;span class="math inline">\(p_j&amp;gt;0\)&lt;/span>，由条件概率公式可得 &lt;span class="math inline">\(P\left(X=x_{i} \mid Y=y_{j}\right)=\frac{P\left(X=x_{i}, Y=y_{j}\right)}{P\left(Y=y_{j}\right)}=\frac{p_{i j}}{p_{ j}}, \quad i=1,2, \cdots\)&lt;/span> 上式称为在&lt;span class="math inline">\(Y=y_i\)&lt;/span>条件下随机变量X的条件分布律&lt;/p>
&lt;p>同理设&lt;span class="math inline">\(p_i&amp;gt;0\)&lt;/span>，由条件概率公式可得 &lt;span class="math inline">\(P\left(Y=y_{j} \mid X=x_{i}\right)=\frac{P\left(X=x_{i}, Y=y_{j}\right)}{P\left(X=x_{i}\right)}=\frac{p_{i j}}{p_{i}}, \quad j=1,2, \cdots\)&lt;/span> 上式称为在&lt;span class="math inline">\(X=x_i\)&lt;/span>条件下随机变量Y的条件分布律&lt;/p>
&lt;h4 id="二维连续型随机变量xy情形下的条件分布">二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>情形下的条件分布&lt;/h4>
&lt;p>设有二维连续型随机变量&lt;span class="math inline">\((X,Y)\)&lt;/span>， 因为对于任意的实数x和y，事件&lt;span class="math inline">\(\{X=x\}\)&lt;/span>和事件&lt;span class="math inline">\(\{Y=y\}\)&lt;/span>的概率都是0，所以不能像离散型那样直接用条件概率公式得到条件分布。 下面我们用取极限的方法导出二维连续型随机变量的条件分布。&lt;/p>
&lt;p>设&lt;span class="math inline">\((X,Y)\)&lt;/span>是二维连续型随机变量， 给定实数y，设对于任意&lt;span class="math inline">\(\epsilon&amp;gt;0\)&lt;/span>，有&lt;span class="math inline">\(P(y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)&amp;gt;0\)&lt;/span> 若对于任意实数x，极限&lt;span class="math inline">\(\lim _{\epsilon \rightarrow 0^{+}} P(X \leqslant x \mid y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)=\lim _{\epsilon \rightarrow 0^{+}} \frac{P(X \leqslant x, y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)}{P(y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)}\)&lt;/span>存在， 则称此极限值为&lt;strong>在条件&lt;span class="math inline">\(Y=y\)&lt;/span>下，随机变量X的条件分布函数&lt;/strong>，记为&lt;span class="math inline">\(F_{X \mid Y}(x \mid y)\)&lt;/span> 或 &lt;span class="math inline">\(P(X \leqslant x \mid Y=y)\)&lt;/span>&lt;/p>
&lt;p>设&lt;span class="math inline">\((X,Y)\)&lt;/span>的联合分布函数为&lt;span class="math inline">\(F(x,y)\)&lt;/span>，联合密度函数为&lt;span class="math inline">\(f(x,y)\)&lt;/span>，边缘分布函数为&lt;span class="math inline">\(F_X(x)\)&lt;/span>和&lt;span class="math inline">\(F_Y(y)\)&lt;/span>，边缘密度函数为&lt;span class="math inline">\(f_X(x)\)&lt;/span>和&lt;span class="math inline">\(f_Y(y)\)&lt;/span>。 若在点&lt;span class="math inline">\((x,y)\)&lt;/span>处，&lt;span class="math inline">\(f(x,y)\)&lt;/span>和&lt;span class="math inline">\(F_Y(y)\)&lt;/span>连续，则： &lt;span class="math inline">\(\begin{aligned} F_{X \mid Y}(x \mid y) &amp;amp;=\lim _{\epsilon \rightarrow 0^{+}} \frac{P(X \leqslant x, y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)}{P(y-\epsilon&amp;lt;Y&amp;lt;y+\epsilon)} \\ &amp;amp;=\lim _{\epsilon \rightarrow 0^{+}} \frac{F(x, y+\epsilon)-F(x, y-\epsilon)}{F_{Y}(y+\epsilon)-F_{Y}(y-\epsilon)} \\ &amp;amp;=\lim _{\epsilon \rightarrow 0^{+}} \frac{[F(x, y+\epsilon)-F(x, y-\epsilon)] / 2 \epsilon}{\left[F_{Y}(y+\epsilon)-F_{Y}(y-\epsilon)\right] / 2 \epsilon} \\ &amp;amp;=\frac{\partial F(x, y)}{\partial y} / \frac{\mathrm{d} F_{Y}(y)}{\mathrm{d} y} \end{aligned}\)&lt;/span> 因为： &lt;span class="math inline">\(\frac{\partial F(x, y)}{\partial y}=\frac{\partial}{\partial y}\left(\int_{-\infty}^{x} \int_{-\infty}^{y} f(s, t) \mathrm{d} s \mathrm{~d} t\right)=\int_{-\infty}^{x} f(s, y) \mathrm{d} s\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d} F_{Y}(y)}{\mathrm{d} y}=f_{Y}(y)\)&lt;/span> 所以在条件&lt;span class="math inline">\(Y=y\)&lt;/span>下，随机变量X的&lt;strong>条件分布函数&lt;/strong>为： &lt;span class="math inline">\(F_{X \mid Y}(x \mid y)=\frac{1}{f_{Y}(y)} \int_{-\infty}^{x} f(s, y) \mathrm{d} s\)&lt;/span>&lt;/p>
&lt;p>在条件&lt;span class="math inline">\(Y=y\)&lt;/span>下，随机变量X的&lt;strong>条件密度函数&lt;/strong>为： &lt;span class="math inline">\(f_{X \mid Y}(x \mid y)=\frac{\mathrm{d}}{\mathrm{d} x}\left(\frac{1}{f_{Y}(y)} \int_{-\infty}^{x} f(s, y) \mathrm{d} s\right)=\frac{f(x, y)}{f_{Y}(y)}\)&lt;/span>&lt;/p>
&lt;p>同理，在条件&lt;span class="math inline">\(X=x\)&lt;/span>下，随机变量Y的条件分布函数为： &lt;span class="math inline">\(F_{Y \mid X}(y \mid x)=\frac{1}{f_{X}(x)} \int_{-\infty}^{y} f(x, t) \mathrm{d} t\)&lt;/span> 随机变量Y的条件密度函数为： &lt;span class="math inline">\(f_{Y \mid X}(y \mid x)=\frac{f(x, y)}{f_{X}(x)}\)&lt;/span>&lt;/p></description></item><item><title>泛函分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="泛函分析">泛函分析&lt;/h1>
&lt;p>参考：&lt;a href="https://zh.wikipedia.org/wiki/泛函分析">维基百科：泛函分析&lt;/a>&lt;/p>
&lt;p>&lt;strong>泛函分析&lt;/strong>（英语：Functional Analysis）是现代&lt;a href="https://zh.wikipedia.org/wiki/数学分析">数学分析&lt;/a>的一个分支，隶属于&lt;a href="https://zh.wikipedia.org/wiki/分析学">分析学&lt;/a>，&lt;strong>其研究的主要对象是&lt;a href="https://zh.wikipedia.org/wiki/函数">函数&lt;/a>构成的&lt;a href="https://zh.wikipedia.org/wiki/函数空间">函数空间&lt;/a>。&lt;/strong>泛函分析历史根源是由对函数空间的研究和对函数的变换（如&lt;a href="https://zh.wikipedia.org/wiki/傅立叶变换">傅立叶变换&lt;/a>等）的性质的研究。这种观点被证明是对&lt;a href="https://zh.wikipedia.org/wiki/微分方程">微分方程&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/积分方程">积分方程&lt;/a>的研究中特别有用。&lt;/p>
&lt;p>使用&lt;a href="https://zh.wikipedia.org/wiki/泛函">泛函&lt;/a>这个词作为表述源自&lt;a href="https://zh.wikipedia.org/wiki/变分法">变分法&lt;/a>，代表&lt;strong>作用于函数的函数&lt;/strong>，这意味着，&lt;strong>一个函数的参数是函数&lt;/strong>。&lt;/p>
&lt;h2 id="赋范线性空间">赋范线性空间&lt;/h2>
&lt;p>从现代观点来看，&lt;strong>泛函分析研究的主要是&lt;a href="https://zh.wikipedia.org/wiki/实数域">实数域&lt;/a>或&lt;a href="https://zh.wikipedia.org/wiki/复数域">复数域&lt;/a>上的&lt;a href="https://zh.wikipedia.org/wiki/完备">完备&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/赋范线性空间">赋范线性空间&lt;/a>。这类空间被称为&lt;a href="https://zh.wikipedia.org/wiki/巴拿赫空间">巴拿赫空间&lt;/a>，巴拿赫空间中最重要的特例被称为&lt;a href="https://zh.wikipedia.org/wiki/希尔伯特空间">希尔伯特空间&lt;/a>，其上的&lt;a href="https://zh.wikipedia.org/wiki/范数">范数&lt;/a>由一个&lt;a href="https://zh.wikipedia.org/wiki/内积">内积&lt;/a>导出。这类空间是&lt;a href="https://zh.wikipedia.org/wiki/量子力学">量子力学&lt;/a>数学描述的基础。更一般的泛函分析也研究&lt;a href="https://zh.wikipedia.org/w/index.php?title=Fréchet空间&amp;amp;action=edit&amp;amp;redlink=1">Fréchet空间&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/拓扑向量空间">拓扑向量空间&lt;/a>等没有定义范数的空间。&lt;/strong>&lt;/p>
&lt;p>泛函分析所研究的一个重要对象是巴拿赫空间和希尔伯特空间上的&lt;a href="https://zh.wikipedia.org/wiki/连续">连续&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/线性算子">线性算子&lt;/a>。这类算子可以导出&lt;a href="https://zh.wikipedia.org/wiki/C*-代数">C*-代数&lt;/a>和其他&lt;a href="https://zh.wikipedia.org/w/index.php?title=算子代数&amp;amp;action=edit&amp;amp;redlink=1">算子代数&lt;/a>的基本概念。&lt;/p>
&lt;h3 id="希尔伯特空间">希尔伯特空间&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/希尔伯特空间">希尔伯特空间&lt;/a>&lt;/p>
&lt;p>希尔伯特空间（&lt;em>Hilbert&lt;/em>）可以利用以下结论完全分类，即对于任意两个希尔伯特空间，若其&lt;a href="https://zh.wikipedia.org/wiki/基">基&lt;/a>的&lt;a href="https://zh.wikipedia.org/wiki/基数">基数&lt;/a>相等，则它们必彼此&lt;a href="https://zh.wikipedia.org/wiki/同构">同构&lt;/a>。对于&lt;a href="https://zh.wikipedia.org/w/index.php?title=有限维&amp;amp;action=edit&amp;amp;redlink=1">有限维&lt;/a>希尔伯特空间而言，其上的&lt;a href="https://zh.wikipedia.org/wiki/连续">连续&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/线性算子">线性算子&lt;/a>即是&lt;a href="https://zh.wikipedia.org/wiki/线性代数">线性代数&lt;/a>中所研究的&lt;a href="https://zh.wikipedia.org/wiki/线性变换">线性变换&lt;/a>。对于&lt;a href="https://zh.wikipedia.org/w/index.php?title=无穷维&amp;amp;action=edit&amp;amp;redlink=1">无穷维&lt;/a>希尔伯特空间而言，其上的任何&lt;a href="https://zh.wikipedia.org/wiki/态射">态射&lt;/a>均可以分解为&lt;a href="https://zh.wikipedia.org/wiki/可数">可数&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/维度">维度&lt;/a>（基的基数为&lt;span class="math inline">\(\displaystyle \aleph _{0}\)&lt;/span>）上的&lt;a href="https://zh.wikipedia.org/wiki/态射">态射&lt;/a>，所以泛函分析主要研究&lt;a href="https://zh.wikipedia.org/wiki/可数">可数&lt;/a>维度上的希尔伯特空间及其态射。希尔伯特空间中的一个尚未完全解决的问题是，是否对于每个希尔伯特空间上的&lt;a href="https://zh.wikipedia.org/wiki/算子">算子&lt;/a>，都存在一个真&lt;a href="https://zh.wikipedia.org/wiki/不变子空间">不变子空间&lt;/a>。该问题在某些特定情况下的答案是肯定的。&lt;/p>
&lt;h3 id="巴拿赫空间">巴拿赫空间&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/巴拿赫空间">巴拿赫空间&lt;/a>&lt;/p>
&lt;p>一般的巴拿赫空间（&lt;em>Banach&lt;/em>）比较复杂，例如没有通用的办法构造其上的一组基。&lt;/p>
&lt;p>对于每个实数&lt;span class="math inline">\(\displaystyle p\)&lt;/span>，如果&lt;span class="math inline">\(\displaystyle p\geq 1\)&lt;/span>，一个巴拿赫空间的例子是“所有&lt;a href="https://zh.wikipedia.org/wiki/绝对值">绝对值&lt;/a>的&lt;span class="math inline">\(\displaystyle p\)&lt;/span>次方的&lt;a href="https://zh.wikipedia.org/wiki/积分">积分&lt;/a>收敛的&lt;a href="https://zh.wikipedia.org/wiki/勒贝格可测">勒贝格可测&lt;/a>函数”所构成的空间。（参看&lt;a href="https://zh.wikipedia.org/wiki/Lp空间">Lp空间&lt;/a>）&lt;/p>
&lt;p>在巴拿赫空间中，相当部分的研究涉及到&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>的概念，即巴拿赫空间上所有&lt;a href="https://zh.wikipedia.org/wiki/连续">连续&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/线性泛函">线性泛函&lt;/a>所构成的空间。&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>的&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>可能与原空间并不&lt;a href="https://zh.wikipedia.org/wiki/同构">同构&lt;/a>，但总可以构造一个从巴拿赫空间到其&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>的&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>的一个&lt;a href="https://zh.wikipedia.org/wiki/单同态">单同态&lt;/a>。&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/微分">微分&lt;/a>的概念可以在巴拿赫空间中得到推广，&lt;a href="https://zh.wikipedia.org/wiki/微分">微分&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/算子">算子&lt;/a>作用于其上的所有函数，一个函数在给定点的微分是一个&lt;a href="https://zh.wikipedia.org/wiki/连续">连续&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/线性映射">线性映射&lt;/a>。&lt;/p>
&lt;h2 id="主要结果和定理">主要结果和定理&lt;/h2>
&lt;p>泛函分析的主要定理包括：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/一致有界定理">一致有界定理&lt;/a>（亦称&lt;a href="https://zh.wikipedia.org/wiki/共鸣定理">共鸣定理&lt;/a>），该定理描述一族&lt;a href="https://zh.wikipedia.org/wiki/有界算子">有界算子&lt;/a>的性质。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/谱定理">谱定理&lt;/a>包括一系列结果，其中最常用的结果给出了希尔伯特空间上&lt;a href="https://zh.wikipedia.org/wiki/正规算子">正规算子&lt;/a>的一个积分表达，该结果在&lt;a href="https://zh.wikipedia.org/wiki/量子力学">量子力学&lt;/a>的数学描述中起到了核心作用。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/哈恩-巴拿赫定理">哈恩-巴拿赫定理&lt;/a>（Hahn-Banach Theorem）研究了如何将一个&lt;a href="https://zh.wikipedia.org/wiki/算子">算子&lt;/a>保&lt;a href="https://zh.wikipedia.org/wiki/范数">范数&lt;/a>地从一个子空间&lt;a href="https://zh.wikipedia.org/w/index.php?title=延拓&amp;amp;action=edit&amp;amp;redlink=1">延拓&lt;/a>到整个空间。另一个相关结果是&lt;a href="https://zh.wikipedia.org/wiki/对偶空间">对偶空间&lt;/a>的非平凡性。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/开映射定理">开映射定理&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/闭图像定理">闭图像定理&lt;/a>。&lt;/li>
&lt;/ul>
&lt;h2 id="泛函分析与选择公理">泛函分析与选择公理&lt;/h2>
&lt;p>泛函分析所研究的大部分&lt;a href="https://zh.wikipedia.org/wiki/空间">空间&lt;/a>都是&lt;a href="https://zh.wikipedia.org/w/index.php?title=无穷维&amp;amp;action=edit&amp;amp;redlink=1">无穷维&lt;/a>的。为了证明&lt;a href="https://zh.wikipedia.org/w/index.php?title=无穷维&amp;amp;action=edit&amp;amp;redlink=1">无穷维&lt;/a>&lt;a href="https://zh.wikipedia.org/wiki/向量空间">向量空间&lt;/a>存在一组基，必须要使用&lt;a href="https://zh.wikipedia.org/wiki/佐恩引理">佐恩引理&lt;/a>（Zorn’s Lemma）。此外，泛函分析中大部分重要定理都构建于&lt;a href="https://zh.wikipedia.org/wiki/哈恩-巴拿赫定理">哈恩-巴拿赫定理&lt;/a>的基础之上，而该定理本身就是&lt;a href="https://zh.wikipedia.org/wiki/选择公理">选择公理&lt;/a>（Axiom of Choice）弱于&lt;a href="https://zh.wikipedia.org/wiki/布尔素理想定理">布尔素理想定理&lt;/a>（Boolean prime ideal theorem）的一个形式。&lt;/p>
&lt;h2 id="泛函分析的研究现状">泛函分析的研究现状&lt;/h2>
&lt;p>泛函分析目前包括以下分支：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/w/index.php?title=软分析&amp;amp;action=edit&amp;amp;redlink=1">软分析&lt;/a>（soft analysis），其目标是将数学分析用&lt;a href="https://zh.wikipedia.org/wiki/拓扑群">拓扑群&lt;/a>、&lt;a href="https://zh.wikipedia.org/w/index.php?title=拓扑环&amp;amp;action=edit&amp;amp;redlink=1">拓扑环&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/拓扑向量空间">拓扑向量空间&lt;/a>的语言表述。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/巴拿赫空间">巴拿赫空间&lt;/a>的&lt;a href="https://zh.wikipedia.org/w/index.php?title=几何结构&amp;amp;action=edit&amp;amp;redlink=1">几何结构&lt;/a>，以Jean Bourgain的一系列工作为代表。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/非交換幾何">非交换几何&lt;/a>，此方向的主要贡献者包括Alain Connes，其部分工作是以George Mackey的&lt;a href="https://zh.wikipedia.org/wiki/遍历论">遍历论&lt;/a>中的结果为基础的。&lt;/li>
&lt;li>与&lt;a href="https://zh.wikipedia.org/wiki/量子力学">量子力学&lt;/a>相关的理论，狭义上被称为&lt;a href="https://zh.wikipedia.org/wiki/数学物理">数学物理&lt;/a>，从更广义的角度来看，如按照Israel Gelfand所述，其包含&lt;a href="https://zh.wikipedia.org/wiki/表示论">表示论&lt;/a>的大部分类型的问题。&lt;/li>
&lt;/ul></description></item><item><title>线性代数-相似矩阵与二次型</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-相似矩阵与二次型">线性代数-相似矩阵与二次型&lt;/h1>
&lt;p>本章主要讨论方阵的特征值与特征向量、方阵的相似对角化和二次型的化简等问题。&lt;/p>
&lt;p>其中涉及向量的内积、长度及正交等知识，下面先介绍这些知识。&lt;/p>
&lt;h2 id="向量的内积长度及正交性">向量的内积、长度及正交性&lt;/h2>
&lt;h3 id="向量的内积">向量的内积&lt;/h3>
&lt;h5 id="向量内积的引入">向量内积的引入&lt;/h5>
&lt;p>在（平面/空间）解析几何中，我们曾引进向量的数量积/内积：&lt;span class="math inline">\(x \cdot y=|x||y| \cos \theta\)&lt;/span>， 然后定义了向量间的夹角余弦与夹角（包括垂直的定义）， 且以互相垂直向量为轴，建立直角坐标系，有（直角坐标系中的）数量积的坐标表示：&lt;span class="math inline">\(\left(x_{1}, x_{2}, x_{3}\right) \cdot\left(y_{1}, y_{2}, y_{3}\right)=x_{1} y_{1}+x_{2} y_{2}+x_{3} y_{3}\)&lt;/span>&lt;/p>
&lt;p>n维向量的内积是数量积的一种推广。但n维向量没有3维向量那样直观的长度和夹角的概念，因此只能按数量积的直角坐标计算公式来推广。并且反过来，利用内积来定义n维向量的长度和夹角。&lt;/p>
&lt;h5 id="向量x与y内积的定义">向量x与y内积的定义&lt;/h5>
&lt;p>设有n维向量： &lt;span class="math inline">\(\boldsymbol{x}=\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right), \boldsymbol{y}=\left(\begin{array}{c}y_{1} \\ y_{2} \\ \vdots \\ y_{n}\end{array}\right)\)&lt;/span> 令&lt;span class="math inline">\([x, y]=x_{1} y_{1}+x_{2} y_{2}+\cdots+x_{n} y_{n}\)&lt;/span> 称[ x, y]为&lt;strong>向量x与y的内积&lt;/strong>&lt;/p>
&lt;p>当x与y都是列向量时， 有&lt;span class="math inline">\([x, y]=x^{T} y\)&lt;/span>&lt;/p>
&lt;p>向量的内积，结果是个实数。&lt;/p>
&lt;h5 id="向量内积的基本性质">向量内积的基本性质&lt;/h5>
&lt;p>（其中 x, y, z 为 n 维向量, &lt;span class="math inline">\(\lambda\)&lt;/span> 为实数）&lt;/p>
&lt;p>&lt;span class="math inline">\([x, y]=[y, x]\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\([\lambda x, y]=\lambda[x, y]\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\([x+y, z]=[x, z]+[y, z]\)&lt;/span>&lt;/p>
&lt;p>当 &lt;span class="math inline">\(\boldsymbol x=\boldsymbol 0\)&lt;/span> 时 &lt;span class="math inline">\(,[\boldsymbol x, \boldsymbol x]=0 ;\)&lt;/span> 当 &lt;span class="math inline">\(\boldsymbol x \neq 0\)&lt;/span> 时 &lt;span class="math inline">\(,[\boldsymbol x, \boldsymbol x]&amp;gt;0\)&lt;/span>&lt;/p>
&lt;h5 id="施瓦茨不等式x-y2-leqslantx-xy-y">施瓦茨不等式&lt;span class="math inline">\([x, y]^{2} \leqslant[x, x][y, y]\)&lt;/span>&lt;/h5>
&lt;p>&lt;span class="math inline">\([x, y]^{2} \leqslant[x, x][y, y]\)&lt;/span>&lt;/p>
&lt;p>（证明见&lt;a href="https://baike.baidu.com/item/%E6%9F%AF%E8%A5%BF%E2%80%94%E6%96%BD%E7%93%A6%E8%8C%A8%E4%B8%8D%E7%AD%89%E5%BC%8F">百度百科：柯西—施瓦茨不等式：实内积空间的情形&lt;/a>）&lt;/p>
&lt;h3 id="向量的长度与夹角">向量的长度与夹角&lt;/h3>
&lt;h5 id="向量长度范数的定义">向量长度（范数）的定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(\|x\|=\sqrt{[x, x]}=\sqrt{x_{1}^{2}+x_{2}^{2}+\cdots+x_{n}^{2}}\)&lt;/span>，&lt;span class="math inline">\(\| x \|\)&lt;/span> 称为 n 维向量 &lt;span class="math inline">\(x\)&lt;/span> 的长度(或范数).&lt;/p>
&lt;p>可见n维向量的长度是通过内积定义的。&lt;span class="math inline">\(\| x \|=1\)&lt;/span>时，称x为单位向量。&lt;/p>
&lt;h5 id="向量长度的性质">向量长度的性质&lt;/h5>
&lt;h6 id="非负性">非负性&lt;/h6>
&lt;p>当 &lt;span class="math inline">\(x \neq 0\)&lt;/span> 时 &lt;span class="math inline">\(,\|x\|&amp;gt;0 ;\)&lt;/span> 当 &lt;span class="math inline">\(x=0\)&lt;/span> 时 &lt;span class="math inline">\(,\|x\|=0\)&lt;/span>&lt;/p>
&lt;h6 id="齐次性">齐次性&lt;/h6>
&lt;p>&lt;span class="math inline">\(\|\lambda x\|=|\lambda|\|x\|\)&lt;/span>&lt;/p>
&lt;h6 id="三角不等式">三角不等式&lt;/h6>
&lt;p>&lt;span class="math inline">\(\|x+y\| \leqslant\|x\|+\|y\|\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： &lt;span class="math inline">\(\|x+y\|^{2}=[x+y, x+y]=[x, x]+2[x, y]+[y, y]\)&lt;/span> 根据&lt;a href="#施瓦茨不等式">施瓦茨不等式&lt;/a>有&lt;span class="math inline">\([x, y] \leqslant \sqrt{[x, x][y, y]}\)&lt;/span> 则&lt;span class="math inline">\(\|x+y\|^{2} \leqslant[x, x]+2 \sqrt{[x, x][y, y]}+[y, y]\)&lt;/span>&lt;span class="math inline">\(=\|x\|^{2}+2\|x\|\|y\|+\|y\|^{2}=(\|x\|+\|y\|)^{2}\)&lt;/span> 即&lt;span class="math inline">\(\|x+y\| \leqslant\|x\|+\|y\|\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="向量x与y夹角的定义">向量x与y夹角的定义&lt;/h5>
&lt;p>根据&lt;a href="#施瓦茨不等式">施瓦茨不等式&lt;/a>有&lt;span class="math inline">\(|[x, y]| \leqslant\|x\|\|y\|\)&lt;/span> 故&lt;span class="math inline">\(\left|\frac{[x, y]}{x\|\| y \|}\right| \leqslant 1 \quad(\)&lt;/span> 当 &lt;span class="math inline">\(\|x\|\|y\| \neq 0\)&lt;/span> 时 &lt;span class="math inline">\()\)&lt;/span> 则&lt;span class="math inline">\(x \neq 0, y \neq 0\)&lt;/span> 时，&lt;span class="math inline">\(\theta=\arccos\frac{[x, y]}{\|x\|\|y\|}\)&lt;/span>称为 n 维向量 x 与 y 的夹角&lt;/p>
&lt;p>可见n维向量之间的夹角也是通过内积定义的。&lt;/p>
&lt;h3 id="向量的正交与正交矩阵">向量的正交与正交矩阵&lt;/h3>
&lt;h4 id="向量正交与向量组正交">向量正交与向量组正交&lt;/h4>
&lt;h5 id="向量x与向量y正交">向量x与向量y正交&lt;/h5>
&lt;p>当&lt;span class="math inline">\([ x, y]=0\)&lt;/span> 时, 称&lt;strong>向量 x 与 y 正交&lt;/strong>. 显然,若 &lt;span class="math inline">\(x=0\)&lt;/span>, 则 &lt;span class="math inline">\(x\)&lt;/span> 与任何向量都正交。若&lt;span class="math inline">\(x\neq 0, y\neq 0\)&lt;/span>，两向量正交也可认为是向量的夹角为&lt;span class="math inline">\(\frac{\pi}{2}\)&lt;/span>。&lt;/p>
&lt;h5 id="向量组正交">向量组正交&lt;/h5>
&lt;p>一组两两都正交的非零向量，称为&lt;strong>正交向量组&lt;/strong>。&lt;/p>
&lt;h5 id="向量组非零且正交rightarrow向量组线性无关">向量组非零且正交&lt;span class="math inline">\(\Rightarrow\)&lt;/span>向量组线性无关&lt;/h5>
&lt;p>定理：若n维向量&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{r}\)&lt;/span>都非零且两两正交&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{r}\)&lt;/span>线性无关&lt;/p>
&lt;blockquote>
&lt;p>证明&lt;/p>
&lt;p>设有&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{r}\)&lt;/span>使&lt;span class="math inline">\(\lambda_{1} a_{1}+\lambda_{2} a_{2}+\cdots+\lambda_{r} a_{r}=0\)&lt;/span> 用&lt;span class="math inline">\(\boldsymbol{a}_{\mathbf{1}}^{\mathrm{T}}\)&lt;/span>左乘上式，因当 &lt;span class="math inline">\(i \geqslant 2\)&lt;/span> 时, &lt;span class="math inline">\(\boldsymbol{a}_{1}^{\mathrm{T}} \boldsymbol{a}_{i}=0\)&lt;/span>，故&lt;span class="math inline">\(\lambda_{1} a_{1}^{T} a_{1}=0\)&lt;/span> 因 &lt;span class="math inline">\(a_{1} \neq 0,\)&lt;/span> 故 &lt;span class="math inline">\(a_{1}^{\mathrm{T}} a_{1}=\left\|a_{1}\right\|^{2} \neq 0\)&lt;/span>。从而必有 &lt;span class="math inline">\(\lambda_{1}=0 .\)&lt;/span> 类似可证 &lt;span class="math inline">\(\lambda_{2}=0, \cdots, \lambda_{r}=0\)&lt;/span> 于是向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性无关.&lt;/p>
&lt;/blockquote>
&lt;h4 id="向量空间的规范正交基">向量空间的规范正交基&lt;/h4>
&lt;p>向量组正交的性质：&lt;a href="#向量组非零且正交$\Rightarrow$向量组线性无关">向量组非零且正交&lt;span class="math inline">\(\Rightarrow\)&lt;/span>向量组线性无关&lt;/a>， 那么考虑相反的情况，如何根据一个线性无关的向量组，如何得到一个等价的正交向量组呢？&lt;/p>
&lt;h5 id="规范正交基的定义">规范正交基的定义&lt;/h5>
&lt;p>设n维向量&lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{r}\)&lt;/span>是向量空间&lt;span class="math inline">\(V\left(V \subset \mathbb{R}^{n}\right)\)&lt;/span>的一个基&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>， 如果&lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{r}\)&lt;/span>两两正交，且都是单位向量， 则称&lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{r}\)&lt;/span>是一个&lt;strong>规范正交基&lt;/strong>。 那么V中的任意向量都可以由 &lt;span class="math inline">\(e_{1}, \cdots, e_{r}\)&lt;/span>表示，表示式为&lt;span class="math inline">\(a=\lambda_{1} e_{1}+\lambda_{2} e_{2}+\cdots+\lambda_{r} e_{r}\)&lt;/span>。&lt;/p>
&lt;h5 id="向量在规范正交基中的坐标的计算">向量在规范正交基中的坐标的计算&lt;/h5>
&lt;p>为求&lt;span class="math inline">\(a=\lambda_{1} e_{1}+\lambda_{2} e_{2}+\cdots+\lambda_{r} e_{r}\)&lt;/span>的系数 &lt;span class="math inline">\(\lambda_{i}(i=1, \cdots, r),\)&lt;/span> 可用 &lt;span class="math inline">\(e_{i}^{\mathrm{T}}\)&lt;/span> 左乘上式,有&lt;span class="math inline">\(e_{i}^{\mathrm{T}} a=\lambda_{i} e_{i}^{\mathrm{T}} e_{i}=\lambda_{i}\)&lt;/span>，即&lt;span class="math inline">\(\lambda_{i}=e_{i}^{T} a=\left[a, e_{i}\right]\)&lt;/span>&lt;/p>
&lt;h5 id="基线性无关向量组的规范正交化">基（线性无关向量组）的规范正交化&lt;/h5>
&lt;p>设&lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span>是向量空间ⅴ的一个基（最大线性无关组），要求ⅴ的一个规范正交基。这也就是要找一组两两正交的单位向量&lt;span class="math inline">\(e_{1}, \cdots, e_{r}\)&lt;/span>，使&lt;span class="math inline">\(e_{1}, \cdots, e_{r}\)&lt;/span>与&lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span>等价。这样的问题，称为把&lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span>规范正交化。&lt;/p>
&lt;h6 id="施密特正交化方法">施密特正交化方法&lt;/h6>
&lt;p>（按以下流程，得一组相互正交的向量组）： &lt;span class="math inline">\(b_{1}=a_{1}\)&lt;/span> &lt;span class="math inline">\(b_{2}=a_{2}-\frac{\left[b_{1}, a_{2}\right]}{\left[b_{1}, b_{1}\right]} b_{1}\)&lt;/span>&lt;br />
（实际上是设&lt;span class="math inline">\(\beta_{2}=\alpha_{2}-k \beta_{1}\)&lt;/span>，并满足 &lt;span class="math inline">\(\beta_{1} \perp\beta_{2}\)&lt;/span> ，即&lt;span class="math inline">\(\left\langle\beta_{2}, \beta_{1}\right\rangle=\left\langle\alpha_{2}, \beta_{1}\right\rangle-k\left\langle\beta_{1}, \beta_{1}\right\rangle=0\)&lt;/span>，解得k） ……… &lt;span class="math inline">\(b_{r}=a_{r}-\frac{\left[b_{1}, a_{r}\right]}{\left[b_{1}, b_{1}\right]} b_{1}-\frac{\left[b_{2}, a_{r}\right]}{\left[b_{2}, b_{2}\right]} b_{2}-\cdots-\frac{\left[b_{r-1}, a_{r}\right]}{\left[b_{r-1}, b_{r-1}\right]} b_{r-1}\)&lt;/span> &lt;a href="https://baike.baidu.com/item/%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96/756386">容易验证&lt;/a>&lt;span class="math inline">\(b_{1}, \cdots, b_{r}\)&lt;/span>两两相互正交，且&lt;span class="math inline">\(b_{1}, \cdots, b_{r}\)&lt;/span>与&lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span>等价。&lt;/p>
&lt;h6 id="单位化">单位化&lt;/h6>
&lt;p>将上面得到的正交向量组,都化为单位向量,就求得了一个规范正交基&lt;/p>
&lt;h4 id="正交矩阵">正交矩阵&lt;/h4>
&lt;h5 id="正交矩阵定义boldsymbolamathrmt-boldsymbolaboldsymbole">正交矩阵定义&lt;span class="math inline">\(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}=\boldsymbol{E}\)&lt;/span>&lt;/h5>
&lt;p>如果 n 阶矩阵 A 满足&lt;span class="math inline">\(\boldsymbol{A}^{\mathrm{T}} \boldsymbol{A}=\boldsymbol{E}\)&lt;/span> &lt;span class="math inline">\(\left(\right.\)&lt;/span> 即 &lt;span class="math inline">\(\left.\boldsymbol{A}^{-1}=\boldsymbol{A}^{\mathrm{T}}\right)\)&lt;/span> 那么称 A 为正交矩阵,简称正交阵。&lt;/p>
&lt;p>也就是说矩阵的行（或列）向量之间点积等于0（向量正交），行（或列）向量与自身的点积等于1（单位向量），所以正交矩阵又有另一种定义：由行之间两两正交、列之间两两正交的单位向量组成的方阵。&lt;/p>
&lt;h5 id="方阵a是正交矩阵leftrightarrowat-a-1">方阵A是正交矩阵&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(A^T =A^{-1}\)&lt;/span>&lt;/h5>
&lt;h5 id="方阵a是正交矩阵leftrightarrowa的列向量组或行向量组是规范正交基">方阵A是正交矩阵&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的列向量组（或行向量组）是规范正交基&lt;/h5>
&lt;p>方阵A是正交矩阵&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的列向量（或行向量）都是单位向量，且两两正交&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的列向量组（或行向量组）是规范正交基&lt;/p>
&lt;blockquote>
&lt;p>方阵A是正交矩阵 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>方阵A用列向量组表示，根据正交矩阵定义有： &lt;span class="math inline">\(\left(\begin{array}{c}a_{1}^{\mathrm{T}} \\ a_{2}^{\mathrm{T}} \\ \vdots \\ a_{n}^{\mathrm{T}}\end{array}\right)\left(a_{1}, a_{2}, \cdots, a_{n}\right)=E\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\left(a_{i}^{T} a_{j}\right)=\left(\delta_{i j}\right)\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{a}_{i}^{\mathrm{T}} a_{j}=\delta_{i j}=\left\{\begin{array}{ll}1, \text { 当 } i=j, &amp;amp; (i, j=1,2, \cdots, n) \\ 0, \text { 当 } i \neq j\end{array}\right.\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的列向量都是单位向量，且两两正交 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>列向量组构成向量空间&lt;span class="math inline">\(\mathbb{R}^{n}\)&lt;/span>的&lt;a href="#规范正交基的定义">规范正交基&lt;/a>&lt;/p>
&lt;p>&lt;span class="math inline">\(\mathbf{A}^{\mathrm{T}} \mathbf{A}=\mathbf{E}\)&lt;/span> 与 &lt;span class="math inline">\(\mathbf{A} \mathbf{A}^{\mathrm{T}}=\mathbf{E}\)&lt;/span>等价，所以，上述结论对于A的行向量也成立&lt;/p>
&lt;/blockquote>
&lt;h5 id="若a是正交阵rightarrowa-1amathrmt也是正交阵且-a1-或-1">若A是正交阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(A^{-1}=A^{\mathrm{T}}\)&lt;/span>也是正交阵,且 &lt;span class="math inline">\(|A|=1\)&lt;/span> 或(-1)&lt;/h5>
&lt;h5 id="若a和b都是正交阵rightarrowab也是正交阵">若A和B都是正交阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>AB也是正交阵&lt;/h5>
&lt;blockquote>
&lt;p>证明： A、B是正交矩阵，根据定义知道AA’=A’A=E, BB’=B’B=E, 那么(AB)(AB)‘=(AB)(B’A’)=ABB’A’=A(BB’)A=AEA’=AA’=E&lt;/p>
&lt;/blockquote>
&lt;h5 id="若a是正交阵rightarrowaxx">若A是正交阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\|Ax\|=\|x\|\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明 若A是正交阵,则&lt;span class="math inline">\(A^T A = E\)&lt;/span> &lt;span class="math inline">\(\|Ax\|= (Ax)^T (Ax) = x^T A^T A x = x^T x = \|x\|\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="正交变换yp-x">正交变换&lt;span class="math inline">\(y=P x\)&lt;/span>&lt;/h5>
&lt;p>若 P 为正交矩阵,则线性变换 &lt;span class="math inline">\(y=P x\)&lt;/span> 称为&lt;strong>正交变换&lt;/strong>.&lt;/p>
&lt;h5 id="设y-px-为正交变换则yx">设y = Px 为正交变换，则&lt;span class="math inline">\(\|y\|=\|x\|\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明：&lt;span class="math inline">\(\|\boldsymbol{y}\|=\sqrt{\boldsymbol{y}^{\mathrm{T}} \boldsymbol{y}}=\sqrt{\boldsymbol{x}^{\mathrm{T}} \boldsymbol{P}^{\mathrm{T}} \boldsymbol{P x}}=\sqrt{\boldsymbol{x}^{\mathrm{T}} \boldsymbol{x}}=\|\boldsymbol{x}\|\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>即正交变换不改变向量的长度（从而保证三角形长度不变）&lt;/p>
&lt;h2 id="方阵的特征值与特征向量">方阵的特征值与特征向量&lt;/h2>
&lt;h4 id="a-xlambda-x中a的特征值与特征向量">&lt;span class="math inline">\(A x=\lambda x\)&lt;/span>中A的特征值与特征向量&lt;/h4>
&lt;p>设 A 是 n 阶矩阵,如果数$&lt;span class="math inline">\(和 n 维**非零**列向量x 使关系式\)&lt;/span>A x=x&lt;span class="math inline">\(成立，(或者\)&lt;/span>(A-E)x=0$成立) 那么，这样的数λ称为矩阵A的&lt;strong>特征值&lt;/strong>，非零向量x称为A的对应于特征值λ的&lt;strong>特征向量&lt;/strong>&lt;/p>
&lt;h4 id="求特征值与特征向量">求特征值与特征向量&lt;/h4>
&lt;p>根据方阵A，&lt;span class="math inline">\(A x=\lambda x\)&lt;/span>&lt;strong>求&lt;/strong>其中的&lt;strong>特征值&lt;/strong>&lt;span class="math inline">\(\lambda\)&lt;/span>与对应的&lt;strong>特征向量&lt;/strong>&lt;span class="math inline">\(x\)&lt;/span>的问题 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>n个未知数n个方程的齐次线性方程组&lt;span class="math inline">\((A-\lambda E) x=0\)&lt;/span>&lt;strong>何时有非零解&lt;/strong>，以及&lt;strong>非零解的求解问题&lt;/strong>&lt;/p>
&lt;p>根据方阵A，&lt;span class="math inline">\(A x=\lambda x\)&lt;/span>&lt;strong>求&lt;/strong>其中的&lt;strong>特征值&lt;/strong>&lt;span class="math inline">\(\lambda\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>n个未知数n个方程的齐次线性方程组&lt;span class="math inline">\((A-\lambda E) x=0\)&lt;/span>有非零解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>系数矩阵行列式=0，即&lt;span class="math inline">\(|A-\lambda E| = 0\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>求矩阵A的特征方程（&lt;strong>特征多项式&lt;/strong>&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref">&lt;sup>2&lt;/sup>&lt;/a>等于0）的解,即（下式中&lt;span class="math inline">\(\lambda\)&lt;/span>的解）： &lt;span class="math inline">\(\left|\begin{array}{cccc}a_{11}-\lambda &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22}-\lambda &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{n n}-\lambda\end{array}\right|=0\)&lt;/span>&lt;/p>
&lt;h5 id="求特征值与特征向量的步骤">求特征值与特征向量的步骤&lt;/h5>
&lt;p>根据上面解方程组的思路,给出求特征值与特征向量的一般方法: 1)由&lt;span class="math inline">\(|A-\lambda E| = 0\)&lt;/span>求特征值&lt;span class="math inline">\(\lambda_i\)&lt;/span>,&lt;a href="#n阶方阵A有n个特征值(含重根)">共n个(含重根)&lt;/a> 2)由&lt;span class="math inline">\((A-\lambda_i E) x=0\)&lt;/span>求基础解系,用基础解系表示处特征向量的通解&lt;/p>
&lt;p>事实上,还可以下面特征值的性质/公式来求解特征值&lt;/p>
&lt;h4 id="特征值的性质">特征值的性质&lt;/h4>
&lt;h5 id="n阶方阵a有n个特征值含重根">n阶方阵A有n个特征值(含重根)&lt;/h5>
&lt;p>根据&lt;a href="#求特征值与特征向量">求特征值与特征向量&lt;/a>的过程(特征多项式&lt;span class="math inline">\(|A-\lambda E|\)&lt;/span>是&lt;span class="math inline">\(\lambda\)&lt;/span>的n次多项式), 可知n阶方阵A有n个特征值(以重根计算)&lt;/p>
&lt;h5 id="特征值之和lambda_1lambda_2cdotslambda_na_11a_22cdotsa_n-n-与特征值之积lambda_1-lambda_2-cdots-lambda_nboldsymbola">特征值之和&lt;span class="math inline">\(\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}\)&lt;/span> 与特征值之积&lt;span class="math inline">\(\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|\boldsymbol{A}|\)&lt;/span>&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{i j}\right)\)&lt;/span> 的特征值为 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> &lt;span class="math inline">\(\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}\)&lt;/span> （特征值之和等于方阵的迹） &lt;span class="math inline">\(\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|\boldsymbol{A}|\)&lt;/span> （特征值之积等于方阵的行列式）&lt;/p>
&lt;blockquote>
&lt;p>证明： 根据 &lt;span class="math inline">\(f(\lambda)=\left(\lambda-\lambda_{1}\right)\left(\lambda-\lambda_{2}\right) \cdots\left(\lambda-\lambda_{n}\right)\)&lt;/span> &lt;span class="math inline">\(=k_0 \lambda^0 + \cdots + k_{n-1} \lambda^{n-1} + k_{n} \lambda^n\)&lt;/span> 显然 $k_0 = &lt;em>{1} &lt;/em>{2} _{n} $, &lt;span class="math inline">\(k_{n-1} = -(\lambda_1 + \lambda_2 + \cdots + \lambda_n)\)&lt;/span>&lt;/p>
又根据 $f()=|E-A|=|
&lt;span class="math display">\[\begin{array}{cccc}\lambda-a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; \lambda-a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; \lambda-a_{n n}\end{array}\]&lt;/span>
&lt;p>| &lt;span class="math inline">\(， 要想产生n-1次项\)&lt;/span>k_{n-1}&lt;sup>{n-1}&lt;span class="math inline">\(,只能由主对角线的乘积\)&lt;/span>(-a_{11})(-a_{22})(-a_{nn})&lt;span class="math inline">\(产生， 且\)&lt;/span>k_{n-1}&lt;/sup>{n-1} = -(a_{11}+a_{22} + + a_{nn})$ 根据行列式的定义：所有不同行不同列的元素乘积组成的项之和， 0次项$k_0 _0 &lt;span class="math inline">\(是排除掉其他幂次后的项，恰好\)&lt;/span>k_0 _0 = |A|$&lt;/p>
&lt;p>综上， &lt;span class="math inline">\(\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}\)&lt;/span> （特征值之和等于方阵的迹） &lt;span class="math inline">\(\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|\boldsymbol{A}|\)&lt;/span> （特征值之积等于方阵的行列式）&lt;/p>
&lt;/blockquote>
&lt;h5 id="lambda是a的特征值rightarrowlambdak是-ak-的特征值">&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征值&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\lambda^k\)&lt;/span>是 &lt;span class="math inline">\(A^k\)&lt;/span> 的特征值&lt;/h5>
&lt;p>即&lt;span class="math inline">\(A x=\lambda x,x\neq 0\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(A^k x=\lambda^k x,x\neq 0\)&lt;/span>&lt;/p>
&lt;h5 id="lambda是a的特征值rightarrowlambdak是-ake-的特征值">&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征值&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\lambda+k\)&lt;/span>是 &lt;span class="math inline">\(A+kE\)&lt;/span> 的特征值​&lt;/h5>
&lt;p>即&lt;span class="math inline">\(A x=\lambda x,x\neq 0\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\((A+kE) x=(\lambda+k) x,x\neq 0\)&lt;/span>&lt;/p>
&lt;h5 id="lambda是a的特征值rightarrowfrac1lambda是a-1的特征值">&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征值&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\frac{1}{\lambda}\)&lt;/span>是&lt;span class="math inline">\(A^{-1}\)&lt;/span>的特征值&lt;/h5>
&lt;p>即&lt;span class="math inline">\(A x=\lambda x,x\neq 0\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(A^{-1} x=\frac{1}{\lambda} x,x\neq 0\)&lt;/span>&lt;/p>
&lt;h5 id="推论a可逆rightarrow特征值非0">推论:A可逆&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征值非0&lt;/h5>
&lt;h5 id="lambda是a的特征值rightarrowfracalambda是a的特征值">&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征值&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\frac{|A|}{\lambda}\)&lt;/span>是&lt;span class="math inline">\(A^{*}\)&lt;/span>的特征值&lt;/h5>
&lt;p>即&lt;span class="math inline">\(A x=\lambda x,x\neq 0\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(A^{*} x=\frac{|A|}{\lambda} x,x\neq 0\)&lt;/span>&lt;/p>
&lt;h5 id="lambda是a的特征值rightarrow特征值多项式varphilambda是对应矩阵多项式varphiboldsymbola的特征值">&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征值&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征值多项式&lt;span class="math inline">\(\varphi(\lambda)\)&lt;/span>是对应矩阵多项式&lt;span class="math inline">\(\varphi(\boldsymbol{A})\)&lt;/span>的特征值&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(\lambda\)&lt;/span> 是方阵 A 的特征值,&lt;/p>
&lt;p>&lt;span class="math inline">\(\lambda^{2}\)&lt;/span> 是 &lt;span class="math inline">\(A^2\)&lt;/span>的特征值, &lt;span class="math inline">\(\lambda^k\)&lt;/span>是 &lt;span class="math inline">\(A^k\)&lt;/span> 的特征值&lt;/p>
&lt;p>&lt;span class="math inline">\(\frac{1}{\lambda}\)&lt;/span> 是 &lt;span class="math inline">\(\boldsymbol{A}^{-1}\)&lt;/span> 的特征值 (当 A 可逆时)&lt;/p>
&lt;blockquote>
&lt;p>推论:当A可逆时,特征值不为0&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span class="math inline">\(\varphi(\lambda)=a_{0}+a_{1} \lambda+\cdots+a_{m} \lambda^{m}\)&lt;/span>是 &lt;span class="math inline">\(\varphi(\boldsymbol{A})=a_{0} \boldsymbol{E}\)&lt;/span>&lt;span class="math inline">\(+a_{1} \boldsymbol{A}+\cdots+a_{n} \boldsymbol{A}^{m}\)&lt;/span>&lt;span class="math inline">\(+a_{1} \boldsymbol{A}+\cdots+a_{n} \boldsymbol{A}^{m}\)&lt;/span>的特征值 (实际上,这里的幂次m可取负数,只要认为&lt;span class="math inline">\(A^{m}=(A^{-1})^n\)&lt;/span>)&lt;/p>
&lt;h5 id="特征值不相等rightarrow特征向量线性无关">特征值不相等&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征向量线性无关&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{m}\)&lt;/span> 是方阵 &lt;span class="math inline">\(A\)&lt;/span> 的 &lt;span class="math inline">\(m\)&lt;/span> 个特征值 &lt;span class="math inline">\(, p_{1}, p_{2}, \cdots, p_{m}\)&lt;/span> 依次是与之对应的特征向量,如果 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{m}\)&lt;/span> 各不相等 ,则 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{m}\)&lt;/span> 线性无关.&lt;/p>
&lt;blockquote>
&lt;p>证明(用数学归纳法证明)&lt;/p>
&lt;p>当m=1时，因特征向量&lt;span class="math inline">\(p_1\neq 0\)&lt;/span>，故只含一个向量的向量组&lt;span class="math inline">\(p_1\)&lt;/span>线性无关.&lt;/p>
&lt;p>假设当 m = k - 1 时结论成立,要证当 m = k 时结论也成立。 假设&lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{k-1}\)&lt;/span>线性无关, 令&lt;span class="math inline">\(x_{1} p_{1}+x_{2} p_{2}+\cdots+x_{k-1} p_{k-1}+x_{k} p_{k}=0\)&lt;/span>, (1) 用A左乘上式，得&lt;span class="math inline">\(x_{1} A p_{1}+x_{2} A p_{2}+\cdots+x_{k-1} A p_{k-1}+x_{k} A p_{k}=0\)&lt;/span> 即&lt;span class="math inline">\(x_{1} \lambda_{1} p_{1}+x_{2} \lambda_{2} p_{2}+\cdots+x_{k-1} \lambda_{k-1} p_{k-1}+x_{k} \lambda_{k} p_{k}=0\)&lt;/span> (2)&lt;/p>
&lt;p>&lt;span class="math inline">\((2) - \lambda_k (1)\)&lt;/span>得&lt;span class="math inline">\(x_{1}\left(\lambda_{1}-\lambda_{k}\right) p_{1}+x_{2}\left(\lambda_{2}-\lambda_{k}\right) p_{2}+\cdots+x_{k-1}\left(\lambda_{k-1}-\lambda_{k}\right) p_{k-1}=0\)&lt;/span> 由于&lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{k-1}\)&lt;/span>线性无关,&lt;span class="math inline">\(x_{i}\left(\lambda_{i}-\lambda_{k}\right)=0(i=1,2, \cdots, k-1),\)&lt;/span> 而 &lt;span class="math inline">\(\lambda_{i}-\lambda_{k} \neq 0\)&lt;/span>&lt;span class="math inline">\((i=1,2, \cdots, k-1)\)&lt;/span>, 于是&lt;span class="math inline">\(x_{i}=0(i=1,2, \cdots, k-1)\)&lt;/span> 代入(2)得&lt;span class="math inline">\(x_{k} p_{k}=0\)&lt;/span>.而&lt;span class="math inline">\(p_{k} \neq 0,\)&lt;/span> 得&lt;span class="math inline">\(x_{k}=0 .\)&lt;/span> 因此, 向量组 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{k}\)&lt;/span> 线性无关.&lt;/p>
&lt;/blockquote>
&lt;h2 id="相似矩阵">相似矩阵&lt;/h2>
&lt;h4 id="矩阵相似boldsymbolp-1-boldsymbola-pboldsymbolb">矩阵相似&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{B}\)&lt;/span>&lt;/h4>
&lt;p>设A,B都是n阶矩阵，若有可逆矩阵P，使&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{B}\)&lt;/span>,则称B是A的&lt;strong>相似矩阵&lt;/strong>，或说矩阵A与B相似. 对A进行运算&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}\)&lt;/span>称为对A进行&lt;strong>相似变换&lt;/strong>， 可逆矩阵P称为把A变成B的&lt;strong>相似变换矩阵&lt;/strong>&lt;/p>
&lt;h4 id="矩阵相似的性质">矩阵相似的性质&lt;/h4>
&lt;h5 id="反身性对称性传递性">反身性对称性传递性&lt;/h5>
&lt;p>矩阵A与A相似&lt;/p>
&lt;p>矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵B与A相似&lt;/p>
&lt;p>矩阵A与B相似,B与C相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵A与C相似&lt;/p>
&lt;h5 id="矩阵a与b相似rightarrow矩阵ake与bke相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A+kE\)&lt;/span>与&lt;span class="math inline">\(B+kE\)&lt;/span>相似&lt;/h5>
&lt;p>注意: 虽然有性质:矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A+kE\)&lt;/span>与&lt;span class="math inline">\(B+kE\)&lt;/span>相似 但是,并没有A的多项式与B的多项式相似的结论!!!&lt;/p>
&lt;h5 id="矩阵a与b相似rightarrow矩阵an与bn相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^n\)&lt;/span>与&lt;span class="math inline">\(B^n\)&lt;/span>相似&lt;/h5>
&lt;p>特别的,矩阵A与&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^n\)&lt;/span>与&lt;span class="math inline">\(\Lambda^n\)&lt;/span>相似&lt;/p>
&lt;h5 id="矩阵a与b相似rightarrowrarb">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(r(A)=r(B)\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明 矩阵A与B相似,即&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{B}\)&lt;/span>, 又P是可逆矩阵,初等变换变换不改变矩阵的秩, 所以&lt;span class="math inline">\(r(A)=r(B)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="定理-n阶矩阵a与b相似rightarrowa与b的特征多项式相同rightarrowa与b的特征值相同">定理: n阶矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征多项式相同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征值相同&lt;/h5>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(|\boldsymbol{B}-\lambda \boldsymbol{E}|=\left|\boldsymbol{P}^{-1} \boldsymbol{A P}-\boldsymbol{P}^{-1}(\lambda \boldsymbol{E}) \boldsymbol{P}\right|=\left|\boldsymbol{P}^{-1}(\boldsymbol{A}-\lambda \boldsymbol{E}) \boldsymbol{P}\right|\)&lt;/span> &lt;span class="math inline">\(=\left|\boldsymbol{P}^{-1}\right||\boldsymbol{A}-\lambda \boldsymbol{E}||\boldsymbol{P}|=|\boldsymbol{A}-\lambda \boldsymbol{E}|\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="推论-n阶矩阵a与对角阵lambda相似rightarrowlambda对角线上的值是boldsymbola-的-n-个特征值">推论: n阶矩阵A与对角阵&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\Lambda\)&lt;/span>对角线上的值是&lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值&lt;/h5>
&lt;p>若 n 阶矩阵 A 与对角阵&lt;span class="math inline">\(\mathbf{\Lambda}=\left(\begin{array}{llll}\lambda_{1} &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; \lambda_{2} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_{n}\end{array}\right)\)&lt;/span>相似,则 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> 即是 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值&lt;/p>
&lt;blockquote>
&lt;p>证明&lt;/p>
&lt;p>因 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> 即是 &lt;span class="math inline">\(\boldsymbol{\Lambda}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值,由矩阵相似的性质：&lt;a href="#定理:%20n阶矩阵A与B相似$\Rightarrow$A与B的特征多项式相同$\Rightarrow$A与B的特征值相同">n阶矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征多项式相同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征值相同&lt;/a>知 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> 也就是A的n个特征值&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似rightarrowab">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(|A|=|B|\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明 根据:&lt;a href="#特征值之和$\lambda_%7B1%7D+\lambda_%7B2%7D+\cdots+\lambda_%7Bn%7D=a_%7B11%7D+a_%7B22%7D+\cdots+a_%7Bn%20n%7D$%20与特征值之积$\lambda_%7B1%7D%20\lambda_%7B2%7D%20\cdots%20\lambda_%7Bn%7D=%7C\boldsymbol%7BA%7D%7C$">特征值之和&lt;span class="math inline">\(\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}\)&lt;/span> 与特征值之积&lt;span class="math inline">\(\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|\boldsymbol{A}|\)&lt;/span>&lt;/a>, 以及定理: &lt;a href="#定理:%20n阶矩阵A与B相似$\Rightarrow$A与B的特征多项式相同$\Rightarrow$A与B的特征值相同">n阶矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征多项式相同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征值相同&lt;/a> 立即可知,若矩阵A与B相似,则&lt;span class="math inline">\(|A|=|B|\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似rightarrowsum-a_iisum-b_ii">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\sum a_{ii}=\sum b_{ii}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明 根据:&lt;a href="#特征值之和$\lambda_%7B1%7D+\lambda_%7B2%7D+\cdots+\lambda_%7Bn%7D=a_%7B11%7D+a_%7B22%7D+\cdots+a_%7Bn%20n%7D$%20与特征值之积$\lambda_%7B1%7D%20\lambda_%7B2%7D%20\cdots%20\lambda_%7Bn%7D=%7C\boldsymbol%7BA%7D%7C$">特征值之和&lt;span class="math inline">\(\lambda_{1}+\lambda_{2}+\cdots+\lambda_{n}=a_{11}+a_{22}+\cdots+a_{n n}\)&lt;/span> 与特征值之积&lt;span class="math inline">\(\lambda_{1} \lambda_{2} \cdots \lambda_{n}=|\boldsymbol{A}|\)&lt;/span>&lt;/a>, 以及定理: &lt;a href="#定理:%20n阶矩阵A与B相似$\Rightarrow$A与B的特征多项式相同$\Rightarrow$A与B的特征值相同">n阶矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征多项式相同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征值相同&lt;/a> 立即可知,若矩阵A与B相似,则矩阵的迹相等&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似rightarrow矩阵at与bt相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^T\)&lt;/span>与&lt;span class="math inline">\(B^T\)&lt;/span>相似&lt;/h5>
&lt;blockquote>
&lt;p>证明 矩阵A与B相似,即&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{B}\)&lt;/span>, 则&lt;span class="math inline">\((\boldsymbol{P}^{-1} \boldsymbol{A P})^T=\boldsymbol{B}^T\)&lt;/span>, 即&lt;span class="math inline">\(\boldsymbol{P}^{T} \boldsymbol{A} {(\boldsymbol{P^{-1}}})^T=\boldsymbol{B}^T\)&lt;/span>, 即&lt;span class="math inline">\(\boldsymbol{P}^{T} \boldsymbol{A} {(\boldsymbol{P^{T}}})^{-1}=\boldsymbol{B}^T\)&lt;/span> 即矩阵&lt;span class="math inline">\(A^T\)&lt;/span>与&lt;span class="math inline">\(B^T\)&lt;/span>相似&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似rightarrow矩阵a-1与b-1相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^{-1}\)&lt;/span>与&lt;span class="math inline">\(B^{-1}\)&lt;/span>相似&lt;/h5>
&lt;blockquote>
&lt;p>证明 矩阵A与B相似,即&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{B}\)&lt;/span>, 则&lt;span class="math inline">\((\boldsymbol{P}^{-1} \boldsymbol{A P})^{-1}=\boldsymbol{B}^{-1}\)&lt;/span>, 即&lt;span class="math inline">\(\boldsymbol{P} \boldsymbol{A}^{-1} \boldsymbol{P^{-1}}=\boldsymbol{B}^{-1}\)&lt;/span>, 令&lt;span class="math inline">\(Q=P^{-1}\)&lt;/span>,则&lt;span class="math inline">\(\boldsymbol{Q}^{-1} \boldsymbol{A}^{-1} \boldsymbol{Q}=\boldsymbol{B}^{-1}\)&lt;/span>, 即矩阵&lt;span class="math inline">\(A^{-1}\)&lt;/span>与&lt;span class="math inline">\(B^{-1}\)&lt;/span>相似&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似rightarrow矩阵a与b相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^*\)&lt;/span>与&lt;span class="math inline">\(B^*\)&lt;/span>相似​&lt;/h5>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(AA^*=A^* A = |A| E\)&lt;/span> 则&lt;span class="math inline">\(A^* = |A| A^{-1}\)&lt;/span> 根据&lt;a href="#矩阵A与B相似$\Rightarrow$$%7CA%7C=%7CB%7C$">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(|A|=|B|\)&lt;/span>&lt;/a>, 以及&lt;a href="#矩阵A与B相似$\Rightarrow$矩阵$A%5E%7B-1%7D$与$B%5E%7B-1%7D$相似">矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A^{-1}\)&lt;/span>与&lt;span class="math inline">\(B^{-1}\)&lt;/span>相似&lt;/a> 得&lt;span class="math inline">\(\boldsymbol{Q}^{-1} \boldsymbol{A}^{-1} \boldsymbol{Q}=\boldsymbol{B}^{-1}\)&lt;/span> 进一步有&lt;span class="math inline">\(\boldsymbol{Q}^{-1} |A|\boldsymbol{A}^{-1} \boldsymbol{Q}=|B| \boldsymbol{B}^{-1}\)&lt;/span> 即&lt;span class="math inline">\(\boldsymbol{Q}^{-1} \boldsymbol{A}^{*} \boldsymbol{Q}=\boldsymbol{B}^{*}\)&lt;/span> 即矩阵&lt;span class="math inline">\(A^*\)&lt;/span>与&lt;span class="math inline">\(B^*\)&lt;/span>相似&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵a与b相似矩阵c与d相似rightarrow矩阵leftbeginarraylla-00-c-endarrayright与leftbeginarrayllb-00-d-endarrayright相似">矩阵A与B相似,矩阵C与D相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(\left(\begin{array}{ll}A &amp;amp; 0\\0 &amp;amp; C \end{array}\right)\)&lt;/span>与&lt;span class="math inline">\(\left(\begin{array}{ll}B &amp;amp; 0\\0 &amp;amp; D \end{array}\right)\)&lt;/span>相似&lt;/h5>
&lt;p>//TODO&lt;/p>
&lt;h4 id="矩阵对角化p-1-a-plambda">矩阵对角化&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;/h4>
&lt;p>对n阶矩阵A，寻求相似变换矩阵P，使&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A} \boldsymbol{P}=\boldsymbol{\Lambda}\)&lt;/span>为对角阵这就称为把矩阵A对角化 (即找与矩阵A相似的对角矩阵)&lt;/p>
&lt;p>注: 根据矩阵相似的&lt;a href="#推论:%20n阶矩阵A与对角阵$\Lambda$相似$\Rightarrow$$\Lambda$对角线上的值是$\boldsymbol%7BA%7D$%20的%20$n$%20个特征值">推论: n阶矩阵A与对角阵&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\Lambda\)&lt;/span>对角线上的值是&lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值&lt;/a>,可见用&lt;span class="math inline">\(\Lambda\)&lt;/span>矩阵求特征值是一种很好的方法,&lt;/p>
&lt;h4 id="矩阵可对角化的充要条件">矩阵可对角化的充要条件&lt;/h4>
&lt;h5 id="p-1-a-plambdaleftrightarrowp可逆且boldsymbola-pboldsymbolp-lambdaleftrightarrowboldsymbola-boldsymbolp_ilambda_i-boldsymbolp_i且boldsymbolp_1-boldsymbolp_2-cdots-boldsymbolp_n线性无关">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>P可逆且&lt;span class="math inline">\(\boldsymbol{A P}=\boldsymbol{P \Lambda}\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i}\)&lt;/span>且&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关&lt;/h5>
&lt;p>即定理: n阶矩阵A与对角阵相似（即A能对角化）&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A有n个线性无关的特征向量&lt;/p>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(&amp;quot;\Rightarrow&amp;quot;\)&lt;/span>的证明:&lt;/p>
&lt;p>若有可逆矩阵 P 使 &lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span> 为对角阵, 即有&lt;span class="math inline">\(A P=P A\)&lt;/span>. 把P用其列向量表示为&lt;span class="math inline">\(\boldsymbol{P}=\left(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\right)\)&lt;/span> 则 &lt;span class="math inline">\(\boldsymbol{A}\left(p_{1}, p_{2}, \cdots, p_{n}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(p_{1}, p_{2}, \cdots, p_{n}\right)\left(\begin{array}{cccc}\lambda_{1} &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; \lambda_{2} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_{n}\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(\lambda_{1} p_{1}, \lambda_{2} p_{2}, \cdots, \lambda_{n} p_{n}\right)\)&lt;/span> 即&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i} \quad(i=1,2, \cdots, n)\)&lt;/span> 又矩阵P可逆,则r(P)=n,对应的列向量组&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关&lt;/p>
&lt;p>&lt;span class="math inline">\(&amp;quot;\Leftarrow&amp;quot;\)&lt;/span>的证明:&lt;/p>
&lt;p>对于矩阵A,根据&lt;a href="#n阶方阵A有n个特征值(含重根)">n阶方阵A有n个特征值(含重根)&lt;/a>,可以找到n个特征值&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span>， 并可对应地求得n个特征向量&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>，(写成列向量),写出n个特征方程&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i} \quad(i=1,2, \cdots, n)\)&lt;/span> 令这n个特征向量构成矩阵&lt;span class="math inline">\(\boldsymbol{P}=\left(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\right)\)&lt;/span> 则&lt;span class="math inline">\(A P=P A\)&lt;/span> 又&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关,则&lt;span class="math inline">\(r\left(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\right)=n\)&lt;/span> 则&lt;span class="math inline">\(r(P)=n\)&lt;/span>,则P可逆, 则有&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="p-1-a-plambdaleftrightarrow矩阵的每个特征值的代数重数等于它的几何重数的矩阵">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵的每个特征值的代数重数等于它的几何重数的矩阵&lt;/h5>
&lt;p>参考:&lt;a href="https://www.cnblogs.com/zhoukui/p/7685318.html">特征多项式、代数重数与几何重数&lt;/a>&lt;/p>
&lt;p>简单的说,&lt;span class="math inline">\(|A-\lambda E|=(\lambda_1-\lambda)^{k_1}\cdots(\lambda_m - \lambda)^{k_m} = 0\)&lt;/span>中,特征值&lt;span class="math inline">\(\lambda_i\)&lt;/span>的重数&lt;span class="math inline">\(k_i\)&lt;/span>称为特征值&lt;span class="math inline">\(\lambda_i\)&lt;/span>的代数重数; &lt;span class="math inline">\((A-\lambda E)x = 0\)&lt;/span>中&lt;span class="math inline">\(\lambda=\lambda_i\)&lt;/span>时,解空间的维数(解的极大线性无关组的个数)特征值&lt;span class="math inline">\(\lambda_i\)&lt;/span>的几何重数.&lt;/p>
&lt;p>实际上,这和上一条性质&lt;a href="#$P%5E%7B-1%7D%20A%20P=\Lambda$$\Leftrightarrow$P可逆且$\boldsymbol%7BA%20P%7D=\boldsymbol%7BP%20\Lambda%7D$$\Leftrightarrow$$\boldsymbol%7BA%7D%20\boldsymbol%7Bp%7D_%7Bi%7D=\lambda_%7Bi%7D%20\boldsymbol%7Bp%7D_%7Bi%7D$且$\boldsymbol%7Bp%7D_%7B1%7D,%20\boldsymbol%7Bp%7D_%7B2%7D,%20\cdots,%20\boldsymbol%7Bp%7D_%7Bn%7D$线性无关">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>P可逆且&lt;span class="math inline">\(\boldsymbol{A P}=\boldsymbol{P \Lambda}\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i}\)&lt;/span>且&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关&lt;/a>是等价的,都是矩阵可对角化的充要条件&lt;/p>
&lt;blockquote>
&lt;p>eg: 不可对角化的例子: &lt;span class="math inline">\(A =\left(\begin{array}{ll}1 &amp;amp; 1\\0 &amp;amp; 1 \end{array}\right)\)&lt;/span> 根据&lt;span class="math inline">\(Ax=\lambda x\)&lt;/span>,即&lt;span class="math inline">\((A-\lambda E) x = 0\)&lt;/span>,确定特征值与特征向量: 令&lt;span class="math inline">\(|A-\lambda E|=\left|\begin{array}{ll}1-\lambda &amp;amp; 1\\0 &amp;amp; 1-\lambda \end{array}\right|=(1-\lambda)^2=0\)&lt;/span> &lt;span class="math inline">\(\lambda=1\)&lt;/span>是二重根,即特征值&lt;span class="math inline">\(\lambda = 1\)&lt;/span>的代数重数为2. 若&lt;span class="math inline">\(\lambda=1\)&lt;/span>, 则&lt;span class="math inline">\((A-\lambda E) x = 0\)&lt;/span>化为&lt;span class="math inline">\(\left(\begin{array}{ll}0 &amp;amp; 1\\0 &amp;amp; 0 \end{array}\right)x= 0\)&lt;/span> 则&lt;span class="math inline">\(r(A-\lambda E)=1\)&lt;/span>, 则&lt;span class="math inline">\(n-r(A-\lambda E)=2-1=1\)&lt;/span>,即方程组&lt;span class="math inline">\(\left(\begin{array}{ll}0 &amp;amp; 1\\0 &amp;amp; 0 \end{array}\right)x= 0\)&lt;/span>解空间的极大线性无关组个数为1 即特征值&lt;span class="math inline">\(\lambda = 1\)&lt;/span>的几何重数为1&lt;/p>
&lt;/blockquote>
&lt;h4 id="矩阵相似对角化性质">矩阵相似对角化性质&lt;/h4>
&lt;h5 id="n阶矩阵a的特征值互不相等rightarrow矩阵a与lambda相似">n阶矩阵A的特征值互不相等&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵A与&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;/h5>
&lt;blockquote>
&lt;p>证明: 由于n阶矩阵A的特征值&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span>互不相等,根据矩阵相似的性质:&lt;a href="#特征值不相等$\Rightarrow$特征向量线性无关">特征值不相等&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征向量线性无关&lt;/a>, 则各特征值对应的特征向量&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关 即&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i}\)&lt;/span>且&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关 根据矩阵对角化充要条件:&lt;a href="#$P%5E%7B-1%7D%20A%20P=\Lambda$$\Leftrightarrow$P可逆且$\boldsymbol%7BA%20P%7D=\boldsymbol%7BP%20\Lambda%7D$$\Leftrightarrow$$\boldsymbol%7BA%7D%20\boldsymbol%7Bp%7D_%7Bi%7D=\lambda_%7Bi%7D%20\boldsymbol%7Bp%7D_%7Bi%7D$且$\boldsymbol%7Bp%7D_%7B1%7D,%20\boldsymbol%7Bp%7D_%7B2%7D,%20\cdots,%20\boldsymbol%7Bp%7D_%7Bn%7D$线性无关">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>P可逆且&lt;span class="math inline">\(\boldsymbol{A P}=\boldsymbol{P \Lambda}\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i}\)&lt;/span>且&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关&lt;/a> 得:&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="boldsymbolp-1-boldsymbola-pboldsymbollambda-rightarrow-varphiboldsymbolaboldsymbolp-varphiboldsymbollambda-boldsymbolp-1">&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{\Lambda}\)&lt;/span> &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(\varphi(\boldsymbol{A})=\boldsymbol{P} \varphi(\boldsymbol{\Lambda}) \boldsymbol{P}^{-1}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明(线性代数矩阵章节曾经证过一次)&lt;/p>
&lt;p>矩阵章节曾证明: 若有可逆矩阵 P 使 P &lt;span class="math inline">\(^{-1} A P=\Lambda\)&lt;/span> 为对角阵 &lt;span class="math inline">\(\boldsymbol{A}=\boldsymbol{P B P}^{-1}\)&lt;/span>,&lt;span class="math inline">\(\boldsymbol{A}^{k}=\boldsymbol{P} \boldsymbol{B}^{k} \boldsymbol{P}^{-1}\)&lt;/span>,&lt;span class="math inline">\(\varphi(\boldsymbol{A})=\boldsymbol{P} \varphi(\boldsymbol{B}) \boldsymbol{P}^{-1}\)&lt;/span>&lt;/p>
&lt;p>特别的:取B为对角阵, 即 P &lt;span class="math inline">\(^{-1} A P=\Lambda\)&lt;/span> 为对角阵, 则有&lt;span class="math inline">\(\varphi(\boldsymbol{A})=\boldsymbol{P} \varphi(\boldsymbol{B}) \boldsymbol{P}^{-1}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="flambda是矩阵a的特征多项式rightarrowfao">&lt;span class="math inline">\(f(\lambda)\)&lt;/span>是矩阵A的特征多项式&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(f(A)=O\)&lt;/span>&lt;/h5>
&lt;p>注: &lt;span class="math inline">\(f(\lambda) = |A-\lambda E|\)&lt;/span>为矩阵A的特征多项式&lt;/p>
&lt;blockquote>
&lt;p>证明(仅证可对角化的情况)&lt;/p>
&lt;p>矩阵可对角化时的情况: A与对角阵相似，即有可逆矩阵P，使&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A P}=\boldsymbol{\Lambda}=\operatorname{diag}\left(\lambda_{1}, \cdots, \lambda_{n}\right)\)&lt;/span>,其中&lt;span class="math inline">\(f\left(\lambda_{i}\right)=0\)&lt;/span> ( 因为&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> 是 &lt;span class="math inline">\(\boldsymbol{\Lambda}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值,根据&lt;a href="#定理:%20n阶矩阵A与B相似$\Rightarrow$A与B的特征多项式相同$\Rightarrow$A与B的特征值相同">定理: n阶矩阵A与B相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征多项式相同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>A与B的特征值相同&lt;/a> 则&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\)&lt;/span> 是A的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值，所以&lt;span class="math inline">\(f\left(\lambda_{i}\right)=0\)&lt;/span> ) 则&lt;span class="math inline">\(f(A)=P f(\Lambda) P^{-1}\)&lt;/span> &lt;span class="math inline">\(=P\left(\begin{array}{ccc}f\left(\lambda_{1}\right) &amp;amp; &amp;amp; \\ &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; f\left(\lambda_{n}\right)\end{array}\right) \boldsymbol{P}^{-1}\)&lt;/span> &lt;span class="math inline">\(=P O P^{-1}=O\)&lt;/span>&lt;/p>
&lt;p>其他情况: //TODO&lt;/p>
&lt;/blockquote>
&lt;h2 id="对称矩阵的对角化">对称矩阵的对角化&lt;/h2>
&lt;h4 id="对称矩阵">对称矩阵&lt;/h4>
&lt;h4 id="实对称矩阵的性质">(实)对称矩阵的性质&lt;/h4>
&lt;h5 id="实对称阵的特征值为实数">实对称阵的特征值为实数&lt;/h5>
&lt;blockquote>
&lt;p>证明 设复数&lt;span class="math inline">\(\lambda\)&lt;/span>为矩阵A的特征值,复向量x为对应的特征向量,即&lt;span class="math inline">\(A x=\lambda x, x \neq 0\)&lt;/span> 设&lt;span class="math inline">\(\bar{\lambda}\)&lt;/span>是&lt;span class="math inline">\(\lambda\)&lt;/span>的共轭复数,&lt;span class="math inline">\(\bar{x}\)&lt;/span>是x的共轭复向量. A 为实矩阵,有 &lt;span class="math inline">\(A=\bar{A}\)&lt;/span>, 故 &lt;span class="math inline">\(A \vec{x}=\)&lt;/span>&lt;span class="math inline">\(\bar{A} \bar{x}=(\overline{A x})=(\overline{\lambda x})=\bar{\lambda} \bar{x}\)&lt;/span> 根据: &lt;span class="math inline">\(\bar{x}^{\top} A x=\bar{x}^{\top}(A x)=\bar{x}^{\top} \lambda x=\lambda x^{\top} x\)&lt;/span> &lt;span class="math inline">\(\overline{\boldsymbol{x}}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{x}=\left(\overline{\boldsymbol{x}}^{\mathrm{T}} \boldsymbol{A}^{\mathrm{T}}\right) \boldsymbol{x}=(\boldsymbol{A} \overline{\boldsymbol{x}})^{\mathrm{T}} \boldsymbol{x}=(\vec{\lambda} \overline{\boldsymbol{x}})^{\mathrm{T}} \boldsymbol{x}=\bar{\lambda} \overline{\boldsymbol{x}}^{\mathrm{T}} \boldsymbol{x}\)&lt;/span> 两式相减,有&lt;span class="math inline">\((\lambda-\bar{\lambda}) \vec{x}^{\top} x=0\)&lt;/span> 又&lt;span class="math inline">\(x \neq 0\)&lt;/span>,所以 &lt;span class="math inline">\(\lambda-\bar{\lambda}=0,\)&lt;/span> 即 &lt;span class="math inline">\(\lambda=\bar{\lambda},\)&lt;/span> 这就说明 &lt;span class="math inline">\(\lambda\)&lt;/span> 是实数&lt;/p>
&lt;/blockquote>
&lt;p>显然,特征值 &lt;span class="math inline">\(\lambda_i\)&lt;/span> 为实数时,齐次线性方程组&lt;span class="math inline">\(\left(A-\lambda_{i} E\right) x=0\)&lt;/span>是实系数方程组, 再根据&lt;span class="math inline">\(\left|\boldsymbol{A}-\lambda_{i} \boldsymbol{E}\right|=0\)&lt;/span>,必有实的基础解系,&lt;strong>对应的特征向量可以取实向量&lt;/strong>&lt;/p>
&lt;h5 id="对称阵a特征值lambda_1-neq-lambda_2rightarrow特征向量p_1p_2正交">对称阵A特征值&lt;span class="math inline">\(\lambda_1 \neq \lambda_2\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征向量&lt;span class="math inline">\(p_1,p_2\)&lt;/span>正交&lt;/h5>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(\lambda_{1} p_{1}=A p_{1}, \lambda_{2} p_{2}=A p_{2}, \lambda_{1} \neq \lambda_{2}\)&lt;/span> &lt;span class="math inline">\(\lambda_{1} p_{1}^{\mathrm{T}}=\left(\lambda_{1} p_{1}\right)^{\mathrm{T}}=\left(A p_{1}\right)^{\mathrm{T}}=p_{1}^{\mathrm{T}} A^{\mathrm{T}}=p_{1}^{\mathrm{T}} A\)&lt;/span> &lt;span class="math inline">\(\lambda_{1} \boldsymbol{p}_{1}^{\mathrm{T}} \boldsymbol{p}_{2}=\boldsymbol{p}_{1}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{p}_{2}=\boldsymbol{p}_{1}^{\mathrm{T}}\left(\lambda_{2} \boldsymbol{p}_{2}\right)=\lambda_{2} \boldsymbol{p}_{1}^{\mathrm{T}} \boldsymbol{p}_{2}\)&lt;/span> 移项得&lt;span class="math inline">\(\left(\lambda_{1}-\lambda_{2}\right) p_{1}^{\mathrm{T}} p_{2}=0\)&lt;/span> 但 &lt;span class="math inline">\(\lambda_{1} \neq \lambda_{2},\)&lt;/span> 故 &lt;span class="math inline">\(p_{1}^{\mathrm{T}} p_{2}=0,\)&lt;/span> 即 &lt;span class="math inline">\(p_{1}\)&lt;/span> 与 &lt;span class="math inline">\(p_{2}\)&lt;/span> 正交&lt;/p>
&lt;/blockquote>
&lt;h5 id="a是对称阵rightarrow存在正交矩阵p使得p-1-a-ppt-a-plambda">A是对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>存在正交矩阵P,使得&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\Lambda\)&lt;/span>&lt;/h5>
&lt;p>证明:&lt;a href="https://www.zhihu.com/question/38801697">知乎:为什么实对称矩阵一定能对角化？&lt;/a>&lt;/p>
&lt;h5 id="a是对称阵lambda是a的特征方程的k重根rightarrow矩阵a---lambda-e-的秩rboldsymbola-lambda-boldsymbolen-k-rightarrow对应特征值lambda恰有-k-个线性无关的特征向量">A是对称阵,&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征方程的k重根&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵&lt;span class="math inline">\(A - \lambda E\)&lt;/span> 的秩&lt;span class="math inline">\(R(\boldsymbol{A}-\lambda \boldsymbol{E})=n-k\)&lt;/span> &lt;span class="math inline">\(\Rightarrow\)&lt;/span>对应特征值&lt;span class="math inline">\(\lambda\)&lt;/span>恰有 &lt;span class="math inline">\(k\)&lt;/span> 个线性无关的特征向量&lt;/h5>
&lt;blockquote>
&lt;p>证明 根据&lt;a href="#A是对称阵$\Rightarrow$存在正交矩阵P,使得$P%5E%7B-1%7D%20A%20P=P%5E%7BT%7D%20A%20P=\Lambda$">A是对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>存在正交矩阵P,使得&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\)&lt;/span>&lt;/a>, 则对称阵 A 与对角阵 &lt;span class="math inline">\(\boldsymbol{\Lambda}=\operatorname{diag}\left(\lambda_{1}, \cdots, \lambda_{n}\right)\)&lt;/span> 相似. 则&lt;span class="math inline">\(\boldsymbol{A}-\lambda \boldsymbol{E}\)&lt;/span>与与 &lt;span class="math inline">\(\boldsymbol{\Lambda}-\lambda \boldsymbol{E}=\operatorname{diag}\left(\lambda_{1}-\lambda, \cdots, \lambda_{n}-\lambda\right)\)&lt;/span> 相似.&lt;/p>
&lt;p>当 &lt;span class="math inline">\(\lambda\)&lt;/span> 是 A 的 &lt;span class="math inline">\(k\)&lt;/span> 重特征根时, &lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{n}\)&lt;/span>中有k个等于 &lt;span class="math inline">\(\lambda,\)&lt;/span> 有 &lt;span class="math inline">\(n-k\)&lt;/span> 个不等于 &lt;span class="math inline">\(\lambda\)&lt;/span>, 则对角阵$ - E&lt;span class="math inline">\(的对角元恰有 k 个等于 0, 则\)&lt;/span>n - k=r( - E)= r( A - E)&lt;span class="math inline">\(, 则\)&lt;/span>n-r( A - E)= k&lt;span class="math inline">\(, 即对应特征值\)&lt;/span> $恰有 k 个线性无关的特征向量&lt;/p>
&lt;/blockquote>
&lt;h5 id="对称阵必可对角化">对称阵必可对角化&lt;/h5>
&lt;p>由: &lt;a href="#对称阵A特征值$\lambda_1%20\neq%20\lambda_2$$\Rightarrow$特征向量$p_1,p_2$正交">对称阵A特征值&lt;span class="math inline">\(\lambda_1 \neq \lambda_2\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征向量&lt;span class="math inline">\(p_1,p_2\)&lt;/span>正交&lt;/a>, &lt;a href="#A是对称阵,$\lambda$是A的特征方程的k重根$\Rightarrow$矩阵$A%20-%20\lambda%20E$%20的秩$R(\boldsymbol%7BA%7D-\lambda%20\boldsymbol%7BE%7D)=n-k$%20$\Rightarrow$对应特征值$\lambda$恰有%20$k$%20个线性无关的特征向量">A是对称阵,&lt;span class="math inline">\(\lambda\)&lt;/span>是A的特征方程的k重根&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\lambda\)&lt;/span>恰有 &lt;span class="math inline">\(k\)&lt;/span> 个线性无关的特征向量&lt;/a> 可知: 对称阵A有n个线性无关的特征向量, 对称阵A的每个特征值的代数重数等于它的几何重数. 根据&lt;a href="#$P%5E%7B-1%7D%20A%20P=\Lambda$$\Leftrightarrow$P可逆且$\boldsymbol%7BA%20P%7D=\boldsymbol%7BP%20\Lambda%7D$$\Leftrightarrow$$\boldsymbol%7BA%7D%20\boldsymbol%7Bp%7D_%7Bi%7D=\lambda_%7Bi%7D%20\boldsymbol%7Bp%7D_%7Bi%7D$且$\boldsymbol%7Bp%7D_%7B1%7D,%20\boldsymbol%7Bp%7D_%7B2%7D,%20\cdots,%20\boldsymbol%7Bp%7D_%7Bn%7D$线性无关">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>P可逆且&lt;span class="math inline">\(\boldsymbol{A P}=\boldsymbol{P \Lambda}\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{p}_{i}=\lambda_{i} \boldsymbol{p}_{i}\)&lt;/span>且&lt;span class="math inline">\(\boldsymbol{p}_{1}, \boldsymbol{p}_{2}, \cdots, \boldsymbol{p}_{n}\)&lt;/span>线性无关&lt;/a>, 则&lt;strong>对称阵A必可对角化&lt;/strong>. (根据&lt;a href="#$P%5E%7B-1%7D%20A%20P=\Lambda$$\Leftrightarrow$矩阵的每个特征值的代数重数等于它的几何重数的矩阵">&lt;span class="math inline">\(P^{-1} A P=\Lambda\)&lt;/span>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵的每个特征值的代数重数等于它的几何重数&lt;/a>也可得出对称阵必可对角化的结论)&lt;/p>
&lt;h4 id="对称矩阵对角化步骤">对称矩阵对角化步骤&lt;/h4>
&lt;p>由 &lt;a href="#对称阵必可对角化">对称阵必可对角化&lt;/a> &lt;a href="#A是对称阵$\Rightarrow$存在正交矩阵P,使得$P%5E%7B-1%7D%20A%20P=P%5E%7BT%7D%20A%20P=\Lambda$">A是对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>存在正交矩阵P,使得&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\Lambda\)&lt;/span>&lt;/a>&lt;/p>
&lt;p>可以给出矩阵对角化的一般步骤:&lt;/p>
&lt;p>1)求出 A 的全部互不相等的特征值 &lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{s},\)&lt;/span> 它们的重数依次为 &lt;span class="math inline">\(k_{1}, \cdots,\)&lt;/span>&lt;span class="math inline">\(k_{s}\left(k_{1}+\cdots+k_{s}=n\right)\)&lt;/span> 2)对每个 &lt;span class="math inline">\(k_{i}\)&lt;/span> 重特征值 &lt;span class="math inline">\(\lambda_{i},\)&lt;/span> 求方程 &lt;span class="math inline">\(\left(A-\lambda_{i} E\right) x=0\)&lt;/span> 的基础解系, 得 &lt;span class="math inline">\(k_{i}\)&lt;/span> 个线性无关的特征向量. 3)它们&lt;a href="#施密特正交化方法">正交化&lt;/a>&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref">&lt;sup>3&lt;/sup>&lt;/a>,单位化,得 &lt;span class="math inline">\(k_{i}\)&lt;/span> 个两两正交的单位特征向量. 4)把这 n 个两两正交的单位特征向量构成正交阵 P，便有&lt;span class="math inline">\(\boldsymbol{P}^{-1} \boldsymbol{A} \boldsymbol{P}=\)&lt;/span>&lt;span class="math inline">\(\boldsymbol{P}^{\mathrm{T}} \boldsymbol{A P}=\boldsymbol{\Lambda}\)&lt;/span>,注意 A 中对角元的排列次序应与 P 中列向量的排列次序相对应 .&lt;/p>
&lt;h2 id="二次型及其标准型">二次型及其标准型&lt;/h2>
&lt;h3 id="二次型的引入">二次型的引入&lt;/h3>
&lt;p>讨论n个变量的二次齐次多项式的化简问题,可以引入二次型.&lt;/p>
&lt;p>以平面解析几何为例，为了便于研究二次曲线:&lt;span class="math inline">\(a x^{2}+b x y+c y^{2}=1\)&lt;/span>的几何性质, 做适当的坐标(旋转)变换: &lt;span class="math inline">\(\left\{\begin{array}{l}x=x^{\prime} \cos \theta-y^{\prime} \sin \theta \\ y=x^{\prime} \sin \theta+y^{\prime} \cos \theta\end{array}\right.\)&lt;/span> 则二次曲线变为标准型:&lt;span class="math inline">\(m x^{\prime 2}+n y^{\prime 2}=1\)&lt;/span> 从代数学的角度看, 坐标变换前二次曲线左边&lt;span class="math inline">\(a x^{2}+b x y+c y^{2}\)&lt;/span>是二次齐次多项式, 坐标变换后曲线左边&lt;span class="math inline">\(m x^{\prime 2}+n y^{\prime 2}\)&lt;/span>是仅含平方项的二次齐次多项式. 通过坐标变换,二次齐次式形式得到化简.&lt;/p>
&lt;h3 id="二次型fboldsymbolxmathrmt-a-x">二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x}\)&lt;/span>&lt;/h3>
&lt;h4 id="二次型定义">二次型定义&lt;/h4>
&lt;p>含有 &lt;span class="math inline">\(n\)&lt;/span> 个变量 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 的二次齐次函数: &lt;span class="math inline">\(f\left(x_{1}, x_{2}, \cdots, x_{n}\right)=a_{11} x_{1}^{2}+a_{22} x_{2}^{2}+\cdots+a_{n n} x_{n}^{2}\)&lt;/span>&lt;span class="math inline">\(+2 a_{12} x_{1} x_{2}+2 a_{13} x_{1} x_{3}+\cdots+2 a_{n-1, n} x_{n-1} x_{n}\)&lt;/span> 称为&lt;strong>二次型&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>取 &lt;span class="math inline">\(a_{j i}=a_{i j}\)&lt;/span>&lt;/strong>,则二次型还可以写成: &lt;span class="math inline">\(f=a_{11} x_{1}^{2}+a_{12} x_{1} x_{2}+\cdots+a_{1 n} x_{1} x_{n}\)&lt;/span>&lt;span class="math inline">\(+a_{21} x_{2} x_{1}+a_{22} x_{2}^{2}+\cdots+a_{2 n} x_{2} x_{n}\)&lt;/span>&lt;span class="math inline">\(+\cdots+a_{n 1} x_{n} x_{1}+a_{n 2} x_{n} x_{2}+\cdots+a_{n n} x_{n}^{2}\)&lt;/span> &lt;span class="math inline">\(=\sum_{i, j=1}^{n} a_{i j} x_{i} x_{j}\)&lt;/span>&lt;/p>
&lt;p>进一步,&lt;strong>利用矩阵&lt;/strong>,二次型还可以表示为: &lt;span class="math inline">\(f=x_{1}\left(a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n}\right)\)&lt;/span>&lt;span class="math inline">\(+x_{2}\left(a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}\right)\)&lt;/span>&lt;span class="math inline">\(+\cdots+x_{n}\left(a_{n 1} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(x_{1}, x_{2}, \cdots, x_{n}\right)\)&lt;/span>&lt;span class="math inline">\(\left(\begin{array}{c}a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n} \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n} \\ \vdots \\ a_{n 1} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(x_{1}, x_{2}, \cdots, x_{n}\right)\left[\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{n n}\end{array}\right]\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\boldsymbol{x}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{x}\)&lt;/span> 其中A是对称阵(因为 &lt;span class="math inline">\(a_{j i}=a_{i j}\)&lt;/span>)&lt;/p>
&lt;p>由上面可知,任给一个二次型，就惟一地确定一个对称阵； 反之，任给一个对称阵，也可惟一地确定一个二次型。 这样，二次型与对称阵之间存在一一对应的关系。 因此，我们把&lt;strong>对称阵A叫做二次型&lt;span class="math inline">\(f\)&lt;/span>的矩阵&lt;/strong>，也把&lt;strong>&lt;span class="math inline">\(f\)&lt;/span>叫做对称阵A的二次型&lt;/strong>, 对称阵A的秩就叫做&lt;strong>二次型f的秩&lt;/strong>&lt;/p>
&lt;h4 id="标准型fboldsymbolymathrmt-lambda-boldsymbol-y">标准型&lt;span class="math inline">\(f=\boldsymbol{y}^{\mathrm{T}} \Lambda \boldsymbol{ y}\)&lt;/span>&lt;/h4>
&lt;p>对于二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x}\)&lt;/span>,若二次型的矩阵A是对角阵, 即f仅含平方项,即&lt;span class="math inline">\(f=\boldsymbol{y}^{\mathrm{T}} \Lambda \boldsymbol{ y}\)&lt;/span>,称这样的二次型为标准型&lt;/p>
&lt;h4 id="规范型">规范型&lt;/h4>
&lt;p>对于标准型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x}\)&lt;/span>(其中A为对角阵), 若对角阵A元素只包含0,+1,-1,称这样的标准型为规范型&lt;/p>
&lt;h3 id="矩阵合同">矩阵合同&lt;/h3>
&lt;h4 id="矩阵合同的引入">矩阵合同的引入&lt;/h4>
&lt;p>矩阵合同概念是在二次型做线性变换过程中产生的.&lt;/p>
&lt;p>对于二次型&lt;span class="math inline">\(f=\boldsymbol{x}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{x}\)&lt;/span>, 记&lt;strong>可逆矩阵&lt;/strong>&lt;span class="math inline">\(C=\left(c_{i j}\right)\)&lt;/span>,作线性变换&lt;span class="math inline">\(x=C y\)&lt;/span> 则有&lt;span class="math inline">\(f=x^{\mathrm{T}} A x=(C y)^{\mathrm{T}} A C y=y^{\mathrm{T}}\left(C^{\mathrm{T}} A C\right) y\)&lt;/span>&lt;/p>
&lt;h4 id="矩阵合同boldsymbolbboldsymbolcmathrmt-boldsymbola-c">矩阵合同&lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}\)&lt;/span>&lt;/h4>
&lt;p>设 A 和 B 是 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵,若有&lt;strong>可逆矩阵 &lt;span class="math inline">\(\boldsymbol{C},\)&lt;/span>&lt;/strong> 使 &lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}\)&lt;/span>,则称&lt;strong>矩阵A 与 &lt;span class="math inline">\(\boldsymbol{B}\)&lt;/span> 合同&lt;/strong>. (注意:这里并没有要求A与B为对称矩阵,则矩阵A与B不一定可以作为二次型的矩阵)&lt;/p>
&lt;p>事实上,矩阵合同一般应用于二次型: 若矩阵A 与&lt;span class="math inline">\(B\)&lt;/span>合同,且A为对称矩阵,则矩阵A可认为是二次型f的矩阵, 矩阵A与B合同指明了各自对应二次型f到g作的线性变换是&lt;span class="math inline">\(x=C y\)&lt;/span>,即&lt;span class="math inline">\(f=f(x)=f(Cy)=g(y)\)&lt;/span>&lt;/p>
&lt;h4 id="矩阵合同的性质">矩阵合同的性质&lt;/h4>
&lt;h5 id="反身性对称性传递性-1">反身性对称性传递性&lt;/h5>
&lt;p>矩阵A与A合同&lt;/p>
&lt;p>矩阵A与B合同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵B与A合同&lt;/p>
&lt;p>矩阵A与B合同,矩阵B与C合同&lt;span class="math inline">\(\Rightarrow\)&lt;/span>矩阵A与C合同&lt;/p>
&lt;h5 id="boldsymbolbboldsymbolcmathrmt-boldsymbola-c且a为对称阵rightarrowb也是对称阵">&lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}\)&lt;/span>且A为对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>B也是对称阵&lt;/h5>
&lt;blockquote>
&lt;p>证明 &lt;span class="math inline">\(\boldsymbol{B}^{\mathrm{T}}=\left(\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{C}\right)^{\mathrm{T}}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A}^{\mathrm{T}} \boldsymbol{C}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A} \boldsymbol{C}=\boldsymbol{B}\)&lt;/span> 即B也是对称阵&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(R(A) = R(B)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明 C是可逆矩阵,则&lt;span class="math inline">\(C^T\)&lt;/span>也是可逆矩阵, 对A作初等变换&lt;span class="math inline">\(\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}=\boldsymbol{B}\)&lt;/span>不改变矩阵的秩, 则&lt;span class="math inline">\(R(A) = R(B)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="boldsymbolbboldsymbolcmathrmt-boldsymbola-c且a与b是实对称阵rightarrow对应二次型的正负惯性指数分别相同">&lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}\)&lt;/span>且A与B是实对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>对应二次型的正负惯性指数分别相同&lt;/h5>
&lt;blockquote>
&lt;p>证明(参考:https://www.jianshu.com/p/0ffe6ef97844) 充分性： 设X,Y是两个实对称矩阵,设他们有相同的惯性指数,则X、Y有相同的规范式A,即存在可逆矩阵C、P使得C’XC=A、P’YP=A即(P^-1)‘C’XC(P^-1)=[C(P^-1)]’X[(p^-1)C]=Y,所以X、Y合同. 必要性： 设X,Y是两个合同的实对称矩阵,即C’XC=Y；有Y与其规范式A合同,即P’YP=A. 所以P’(C’XC)P=A,即(CP)’X(CP)=A,此即表示X也合同于规范式A.所以X、Y有相同的规范式,即有相同的正负惯性指数.&lt;/p>
&lt;/blockquote>
&lt;p>这里涉及到二次型的正负惯性指数概念,以及惯性定理,详见后面&lt;a href="#惯性定理">惯性定理&lt;/a>&lt;/p>
&lt;h5 id="二次型作线性变换rightarrow原二次型的矩阵与现二次型的矩阵合同">二次型作线性变换&lt;span class="math inline">\(\Rightarrow\)&lt;/span>原二次型的矩阵与现二次型的矩阵合同&lt;/h5>
&lt;p>&lt;span class="math inline">\(x^T A x\)&lt;/span>经线性变换&lt;span class="math inline">\(x=Cy\)&lt;/span> (C可逆时) 有&lt;span class="math inline">\(x^T A x = y^T (C^T A C) y = y^T B y\)&lt;/span> 其中二次型的矩阵A与B满足&lt;span class="math inline">\(C^T A C = B\)&lt;/span>且C可逆, 即A与B合同&lt;/p>
&lt;h3 id="二次型化为标准型">二次型化为标准型&lt;/h3>
&lt;p>要使二次型 &lt;span class="math inline">\(f\)&lt;/span> 经可逆变换 &lt;span class="math inline">\(x=C y\)&lt;/span> 变成标准形, 即&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x}=\boldsymbol{y}^{\mathrm{T}} \boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C y}=k_{1} y_{1}^{2}+k_{2} y_{2}^{2}+\cdots+k_{n} y_{n}^{2}\)&lt;/span> &lt;span class="math inline">\(=\boldsymbol{y}^{\mathrm{T}} \Lambda \boldsymbol{ y}\)&lt;/span>&lt;/p>
&lt;h4 id="矩阵合同对角化正交变换对角化对称矩阵对角化使对应二次型化为标准型">(矩阵合同对角化/正交变换对角化/对称矩阵对角化)使对应二次型化为标准型&lt;/h4>
&lt;p>从从二次型的矩阵的角度看,二次型化为标准型的过程对应矩阵&lt;span class="math inline">\(\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}=\boldsymbol{\Lambda}\)&lt;/span>, 问题转化为寻找可逆矩阵&lt;span class="math inline">\(C\)&lt;/span>,使矩阵&lt;span class="math inline">\(\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}=\boldsymbol{\Lambda}\)&lt;/span>, 即矩阵的合同对角化问题.&lt;/p>
&lt;h5 id="定理任意二次型fboldsymbolxmathrmt-a-xleftmathbfamathrmtmathbfaright总能找到正交变换xp-y使f化为标准型fboldsymbolymathrmt-lambda-ylambda_1-y_12lambda_2-y_22cdotslambda_n-y_n2">定理:任意二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x},\left(\mathbf{A}^{\mathrm{T}}=\mathbf{A}\right)\)&lt;/span>,总能找到正交变换&lt;span class="math inline">\(x=P y\)&lt;/span>使&lt;span class="math inline">\(f\)&lt;/span>化为标准型&lt;span class="math inline">\(f=\boldsymbol{y^{\mathrm{T}} \Lambda y}\)&lt;/span>&lt;span class="math inline">\(=\lambda_{1} y_{1}^{2}+\lambda_{2} y_{2}^{2}+\cdots+\lambda_{n} y_{n}^{2}\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>证明: 任意二次型的矩阵A是对称阵, 由对称阵的性质:&lt;a href="#A是对称阵$\Rightarrow$存在正交矩阵P,使得$P%5E%7B-1%7D%20A%20P=P%5E%7BT%7D%20A%20P=\Lambda$">A是对称阵&lt;span class="math inline">\(\Rightarrow\)&lt;/span>存在正交矩阵P,使得&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\Lambda\)&lt;/span>&lt;/a> 则必存在正交矩阵存在正交矩阵P,使得&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\Lambda\)&lt;/span> 即A必可合同对角化, 则二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x}\)&lt;/span>,总能找到正交变换&lt;span class="math inline">\(x=P y\)&lt;/span>使&lt;span class="math inline">\(f\)&lt;/span>化为标准型&lt;span class="math inline">\(f=\boldsymbol{y^{\mathrm{T}} \Lambda y}\)&lt;/span>&lt;span class="math inline">\(=\lambda_{1} y_{1}^{2}+\lambda_{2} y_{2}^{2}+\cdots+\lambda_{n} y_{n}^{2}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="推论任意二次型fboldsymbolxmathrmt-a-xleftmathbfamathrmtmathbfaright总能找到正交变换xc-z使fcz为规范型">推论:任意二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x},\left(\mathbf{A}^{\mathrm{T}}=\mathbf{A}\right)\)&lt;/span>,总能找到正交变换&lt;span class="math inline">\(x=C z\)&lt;/span>使&lt;span class="math inline">\(f(Cz)\)&lt;/span>为规范型&lt;/h5>
&lt;blockquote>
&lt;p>证明: 首先,根据定理:&lt;a href="#定理:任意二次型$f=\boldsymbol%7Bx%5E%7B\mathrm%7BT%7D%7D%20A%20x%7D,\left(\mathbf%7BA%7D%5E%7B\mathrm%7BT%7D%7D=\mathbf%7BA%7D\right)$,总能找到正交变换$x=P%20y$使$f$化为标准型$f=\boldsymbol%7By%5E%7B\mathrm%7BT%7D%7D%20\Lambda%20y%7D$$=\lambda_%7B1%7D%20y_%7B1%7D%5E%7B2%7D+\lambda_%7B2%7D%20y_%7B2%7D%5E%7B2%7D+\cdots+\lambda_%7Bn%7D%20y_%7Bn%7D%5E%7B2%7D$">任意二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x},\left(\mathbf{A}^{\mathrm{T}}=\mathbf{A}\right)\)&lt;/span>,总能找到正交变换&lt;span class="math inline">\(x=P y\)&lt;/span>使&lt;span class="math inline">\(f\)&lt;/span>化为标准型&lt;span class="math inline">\(f(Py)=\boldsymbol{y^{\mathrm{T}} \Lambda y}\)&lt;/span>&lt;/a> 即二次型先正交变换成标准型:&lt;span class="math inline">\(f(\boldsymbol{P y})=\boldsymbol{y}^{\mathrm{T}} \boldsymbol{\Lambda} \boldsymbol{y}=\lambda_{1} y_{1}^{2}+\cdots+\lambda_{n} y_{n}^{2}\)&lt;/span> 设二次型&lt;span class="math inline">\(f\)&lt;/span>的秩为r,即&lt;span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)&lt;/span>中有r个非零值, 不妨设&lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{r}\)&lt;/span>不等于0,&lt;span class="math inline">\(\lambda_{r+1}=\cdots=\lambda_{n}=0\)&lt;/span> 取一个特殊矩阵: &lt;span class="math inline">\(\boldsymbol{K}=\left(\begin{array}{cccc}k_{1} &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; k_{2} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; k_{n}\end{array}\right)\)&lt;/span>,其中&lt;span class="math inline">\(k_{i}=\left\{\begin{array}{cc}\frac{1}{\sqrt{| \lambda_{i}|}},&amp;amp; i \leqslant r \\ 1,&amp;amp;i &amp;gt; r\end{array}\right.\)&lt;/span> 则K可逆, 作线性变换&lt;span class="math inline">\(y=K z\)&lt;/span>, &lt;span class="math inline">\(f(\boldsymbol{P y})\\=f(P K z)\\=z^{\mathrm{T}} K^{\mathrm{T}} P^{\mathrm{T}} A P K z\\=z^{\mathrm{T}} K^{\mathrm{T}} \Lambda K z\\=z^{\mathrm{T}} \Lambda_2 z\)&lt;/span> 其中&lt;span class="math inline">\(\Lambda_2 = \boldsymbol{K}^{\mathrm{T}} \boldsymbol{\Lambda K}=\operatorname{diag}\left(\frac{\lambda_{1}}{\left|\lambda_{1}\right|}, \cdots, \frac{\lambda_{r}}{\mid \lambda_{r}\mid}, 0, \cdots, 0\right)\)&lt;/span> 即通过线性变换&lt;span class="math inline">\(x=PKz=Cz\)&lt;/span>,可将任意二次型&lt;span class="math inline">\(f=\boldsymbol{x^{\mathrm{T}} A x},\left(\mathbf{A}^{\mathrm{T}}=\mathbf{A}\right)\)&lt;/span>,变为规范型, 且注意到P是正交矩阵,&lt;span class="math inline">\(C=PK\)&lt;/span>仍是正交矩阵.&lt;/p>
&lt;/blockquote>
&lt;h5 id="矩阵合同对角化矩阵正交对角化对称矩阵对角化步骤">矩阵合同对角化/矩阵正交对角化/对称矩阵对角化步骤&lt;/h5>
&lt;p>由于二次型的矩阵是对称矩阵, 则寻找可逆矩阵&lt;span class="math inline">\(C\)&lt;/span>,使矩阵&lt;span class="math inline">\(\boldsymbol{C}^{\mathrm{T}} \boldsymbol{A C}=\boldsymbol{\Lambda}\)&lt;/span>的步骤就是&lt;a href="#对称矩阵对角化步骤">对称矩阵的正交对角化步骤&lt;/a>&lt;/p>
&lt;p>正交变换好处是&lt;strong>不改变几何形状&lt;/strong>(参见&lt;a href="#设y%20=%20Px%20为正交变换，则$%7Cy%7C=%7Cx%7C$">正交变换的性质&lt;/a>)&lt;/p>
&lt;h4 id="配方法化二次型为标准型">配方法化二次型为标准型&lt;/h4>
&lt;p>如果不考虑几何形状的的改变,除了正交变换法, 也可以使用配方法来将二次型变换为标准型&lt;/p>
&lt;p>注意:有多种方法可以把二次型转换为标准型,对应有多种可逆的线性变换&lt;/p>
&lt;h5 id="拉格朗日配方法">拉格朗日配方法&lt;/h5>
&lt;p>若二次型中含&lt;span class="math inline">\(x_1\)&lt;/span>的平方项, 先将含&lt;span class="math inline">\(x_1\)&lt;/span>的所有项(包含非平方项)归并起来,配方. 若二次型中含&lt;span class="math inline">\(x_2\)&lt;/span>的平方项, 将剩余项中含&lt;span class="math inline">\(x_2\)&lt;/span>的所有项(包含非平方项)归并起来,配方. … 作线性变换: 将配方之后的平方项内的一次项之和设为为&lt;span class="math inline">\(y_1,y_2,...\)&lt;/span>, 令未出现的&lt;span class="math inline">\(x_i\)&lt;/span>项设为&lt;span class="math inline">\(y_j\)&lt;/span>,&lt;/p>
&lt;blockquote>
&lt;p>eg: 对于二次型&lt;span class="math inline">\(f=x_{1}^{2}+2 x_{2}^{2}+5 x_{3}^{2}+2 x_{1} x_{2}+2 x_{1} x_{3}+6 x_{2} x_{3}\)&lt;/span> 其中含&lt;span class="math inline">\(x_1\)&lt;/span>的平方项,可先将含&lt;span class="math inline">\(x_1\)&lt;/span>的所有项归并起来,配方: &lt;span class="math inline">\(f=\left(x_{1}+x_{2}+x_{3}\right)^{2}-x_{2}^{2}-x_{3}^{2}-2 x_{2} x_{3}+2 x_{2}^{2}+5 x_{3}^{2}+6 x_{2} x_{3}\)&lt;/span> 剩余项中含&lt;span class="math inline">\(x_2\)&lt;/span>的平方项,将剩余项中含&lt;span class="math inline">\(x_2\)&lt;/span>的所有项归并起来,配方: &lt;span class="math inline">\(f=\left(x_{1}+x_{2}+x_{3}\right)^{2}+\left(x_{2}+2 x_{3}\right)^{2}\)&lt;/span> 则作线性变换： &lt;span class="math inline">\(\left\{\begin{array}{ll}y_{1}=x_{1}+&amp;amp;x_{2}+&amp;amp;x_{3} \\ y_{2}= &amp;amp; x_{2}+&amp;amp;2 x_{3} \\ y_{3}=&amp;amp; &amp;amp; x_{3}\end{array}\right.\)&lt;/span> 就将二次型化为了标准型&lt;/p>
&lt;/blockquote>
&lt;p>若二次型中完全不含&lt;span class="math inline">\(x_i\)&lt;/span>的平方项, 可先作一次简单的线性变换,使新的二次型中出现平方项, 然后重新用上面的方法配方&lt;/p>
&lt;blockquote>
&lt;p>eg: 对于二次型&lt;span class="math inline">\(f=2 x_{1} x_{2}+2 x_{1} x_{3}-6 x_{2} x_{3}\)&lt;/span> 其完全不含平方项,无法配方, 可以先作一次简单的线性变换: &lt;span class="math inline">\(\left\{\begin{array}{l}x_{1}=y_{1}+y_{2} \\ x_{2}=y_{1}-y_{2} \\ x_{3}=y_{3}\end{array}\right.\)&lt;/span> 二次型化为:&lt;span class="math inline">\(f=2 y_{1}^{2}-2 y_{2}^{2}-4 y_{1} y_{3}+8 y_{2} y_{3}\)&lt;/span> 其中出现了平方项,可以配方, 配方结果为:&lt;span class="math inline">\(f=2\left(y_{1}-y_{3}\right)^{2}-2\left(y_{2}-2 y_{3}\right)^{2}+6 y_{3}^{2}\)&lt;/span> 作线性变换: &lt;span class="math inline">\(\left\{\begin{array}{l}z_{1}=\sqrt{2}\left(y_{1}-y_{3}\right) \\ z_{2}=\sqrt{2}\left(y_{2}-2 y_{3}\right) \\ z_{3}=\sqrt{6} y_{3}\end{array}\right.\)&lt;/span> 可得规范型:&lt;span class="math inline">\(f=z_{1}^{2}-z_{2}^{2}+z_{3}^{2}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="正定二次型">正定二次型&lt;/h3>
&lt;p>二次型可以化为标准型,显然对应的线性变换不唯一;但是&lt;strong>标准型中所含的项数是一定的&lt;/strong>. 在线性变换为&lt;strong>实变换&lt;/strong>时,不同标&lt;strong>准型中正系数的个数也是一定的&lt;/strong>(从而负系数的个数也是一定的). 此规律总结为如下惯性定理.&lt;/p>
&lt;h4 id="惯性定理">惯性定理&lt;/h4>
&lt;p>设有二次型 &lt;span class="math inline">\(f=x^{\mathrm{T}} A x,\)&lt;/span> 它的秩为 &lt;span class="math inline">\(r\)&lt;/span>, 有两个可逆变换&lt;span class="math inline">\(x=C y\)&lt;/span> 及 &lt;span class="math inline">\(x=P z\)&lt;/span> 使得 &lt;span class="math inline">\(f=k_{1} y_{1}^{2}+k_{2} y_{2}^{2}+\cdots+k_{r} y_{r}^{2} \quad\left(k_{i} \neq 0\right)\)&lt;/span> &lt;span class="math inline">\(f=\lambda_{1} z_{1}^{2}+\lambda_{2} z_{2}^{2}+\cdots+\lambda_{r} z_{r}^{2} \quad\left(\lambda_{i} \neq 0\right)\)&lt;/span> 则 &lt;span class="math inline">\(k_{1}, \cdots, k_{r}\)&lt;/span> 中正数的个数与 &lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{r}\)&lt;/span> 中正数的个数相等&lt;/p>
&lt;p>二次型的标准形中正系数的个数称为二次型的&lt;strong>正惯性指数&lt;/strong>, 二次型的标准形中负系数的个数称为&lt;strong>负惯性指数&lt;/strong>. 若二次型 f 的正惯性指数为 p,秩为 r,则 &lt;span class="math inline">\(f\)&lt;/span> 的规范形便可确定为&lt;span class="math inline">\(f=y_{1}^{2}+\cdots+y_{p}^{2}-y_{p+1}^{2}-\cdots-y_{r}^{2}\)&lt;/span>&lt;/p>
&lt;h4 id="正定二次型-1">正定二次型&lt;/h4>
&lt;p>设有二次型 &lt;span class="math inline">\(f(x)=x^{\mathrm{T}} A x,\)&lt;/span> 如果对任何 &lt;span class="math inline">\(x \neq 0\)&lt;/span>,都有 &lt;span class="math inline">\(f(x)&amp;gt;0\)&lt;/span> (显然&lt;span class="math inline">\(f(0)=0\)&lt;/span>),称&lt;strong>&lt;span class="math inline">\(f\)&lt;/span> 为正定二次型&lt;/strong>,并称对称阵 &lt;strong>A 是正定的&lt;/strong>; 如果对任何 &lt;span class="math inline">\(x \neq 0\)&lt;/span>,都有 &lt;span class="math inline">\(f(x)&amp;lt;0\)&lt;/span> (显然&lt;span class="math inline">\(f(0)=0\)&lt;/span>),称&lt;strong>&lt;span class="math inline">\(f\)&lt;/span> 为负定二次型&lt;/strong>,并称对称阵 &lt;strong>A 是负定的&lt;/strong>;&lt;/p>
&lt;h4 id="二次型正定的充分必要条件">二次型正定的充分必要条件&lt;/h4>
&lt;h5 id="n-元二次型-fxmathrmt-a-x-为正定的leftrightarrow它的标准型的n个系数全为正leftrightarrow它的规范型的n个系数都为1leftrightarrow它的正惯性系数等于n">&lt;span class="math inline">\(n\)&lt;/span> 元二次型 &lt;span class="math inline">\(f=x^{\mathrm{T}} A x\)&lt;/span> 为正定的&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的标准型的n个系数全为正&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的规范型的n个系数都为1&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的正惯性系数等于n&lt;/h5>
&lt;blockquote>
&lt;p>证明 设存在可逆变换&lt;span class="math inline">\(x=C y\)&lt;/span> 使&lt;span class="math inline">\(f(x)=f(C y)=\sum_{i=1}^{n} k_{i} y_{i}^{2}\)&lt;/span>&lt;/p>
&lt;p>充分性: 设 &lt;span class="math inline">\(k_{i}&amp;gt;0(i=1, \cdots, n) .\)&lt;/span> 任给 &lt;span class="math inline">\(x \neq 0,\)&lt;/span> 则 &lt;span class="math inline">\(y=C^{-1} x \neq 0,\)&lt;/span> 故&lt;span class="math inline">\(f(x)=\sum_{i=1}^{n} k_{i} y_{i}^{2}&amp;gt;0\)&lt;/span>&lt;/p>
&lt;p>必要性: 用反证法. 假设$ k_s $, 则当 &lt;span class="math inline">\(y = e_s\)&lt;/span> (单位坐标向置)时, &lt;span class="math inline">\(f(x)=f(Cy)=f\left(C e_{s}\right)=k_{t} \leqslant 0\)&lt;/span> 这与二次型正定矛盾.故&lt;span class="math inline">\(k_s&amp;gt;0\)&lt;/span> 则&lt;span class="math inline">\(k_1,\cdots,k_n\)&lt;/span>都可用反证法证明大于0&lt;/p>
&lt;/blockquote>
&lt;h5 id="推论对称阵a正定leftrightarrowa的特征值全为正">推论:对称阵A正定&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的特征值全为正&lt;/h5>
&lt;blockquote>
&lt;p>证明&lt;/p>
&lt;p>用正交变换法对角化矩阵A,即&lt;span class="math inline">\(P^{-1} A P=P^{T} A P=\Lambda\)&lt;/span>, 则&lt;span class="math inline">\(\Lambda\)&lt;/span>是它的标准型的矩阵,且A与&lt;span class="math inline">\(\Lambda\)&lt;/span>相似.&lt;/p>
&lt;p>根据二次型正定充要条件:&lt;a href="#$n$%20元二次型%20$f=x%5E%7B\mathrm%7BT%7D%7D%20A%20x$%20为正定的$\Leftrightarrow$它的标准型的n个系数全为正$\Leftrightarrow$它的规范型的n个系数都为1$\Leftrightarrow$它的正惯性系数等于n">&lt;span class="math inline">\(n\)&lt;/span> 元二次型 &lt;span class="math inline">\(f=x^{\mathrm{T}} A x\)&lt;/span> 为正定的&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的标准型的n个系数全为正&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的规范型的n个系数都为1&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的正惯性系数等于n&lt;/a>, 对称阵A正定&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>标准型的矩阵&lt;span class="math inline">\(\Lambda\)&lt;/span>的n个对角线元素全为正.&lt;/p>
&lt;p>根据相似矩阵的性质推论: &lt;a href="#推论:%20n阶矩阵A与对角阵$\Lambda$相似$\Rightarrow$$\Lambda$对角线上的值是$\boldsymbol%7BA%7D$%20的%20$n$%20个特征值">n阶矩阵A与对角阵&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;span class="math inline">\(\Rightarrow\)&lt;/span>&lt;span class="math inline">\(\Lambda\)&lt;/span>对角线上的值是&lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 个特征值&lt;/a>,(实际上,从矩阵相似对角化过程来看,此性质应当是充要的) A与&lt;span class="math inline">\(\Lambda\)&lt;/span>相似&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A与&lt;span class="math inline">\(\Lambda\)&lt;/span>特征值相同&lt;/p>
&lt;/blockquote>
&lt;h5 id="赫尔维茨定理对称阵a正定leftrightarrowa-的各阶主子式都为正">赫尔维茨定理:对称阵A正定&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A 的各阶主子式都为正&lt;/h5>
&lt;p>对称阵A正定 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A 的各阶主子式都为正, 即&lt;span class="math inline">\(a_{11}&amp;gt;0\)&lt;/span>,&lt;span class="math inline">\(\left|\begin{array}{ll}a_{11} &amp;amp; a_{12} \\ a_{21} &amp;amp; a_{22}\end{array}\right|&amp;gt;0\)&lt;/span>,&lt;span class="math inline">\(\cdots\)&lt;/span>,&lt;span class="math inline">\(\left|\begin{array}{ccc}a_{11} &amp;amp; \cdots &amp;amp; a_{1 n} \\ \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; \cdots &amp;amp; a_{n n}\end{array}\right|&amp;gt;0\)&lt;/span>&lt;/p>
&lt;p>对称阵A负定 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A的奇数阶主子式为负，而偶数阶主子式为正, 即&lt;span class="math inline">\((-1)^{r}\left|\begin{array}{ccc}a_{11} &amp;amp; \cdots &amp;amp; a_{1 r} \\ \vdots &amp;amp; &amp;amp; \vdots \\ a_{r 1} &amp;amp; \cdots &amp;amp; a_{r r}\end{array}\right|&amp;gt;0(r=1,2, \cdots, n)\)&lt;/span>&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>向量组章节我们介绍过，向量空间的基就是向量空间的极大线性无关组，向量空间中的任意向量都可以用基表示&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2" role="doc-endnote">&lt;p>&lt;span class="math inline">\(|A-\lambda E|\)&lt;/span>是&lt;span class="math inline">\(\lambda\)&lt;/span>的n次多项式，记&lt;span class="math inline">\(f(\lambda) = |A-\lambda E|\)&lt;/span>为矩阵A的特征多项式，有地方也取&lt;span class="math inline">\(f(\lambda) = |\lambda E-A|\)&lt;/span>&lt;a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3" role="doc-endnote">&lt;p>由于&lt;a href="#对称阵A特征值$\lambda_1%20\neq%20\lambda_2$$\Rightarrow$特征向量$p_1,p_2$正交">对称阵A不同特征值的特征向量已保证正交&lt;/a>,只需正交化每个特征值对应的特征向量即可&lt;a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>线性代数-相似矩阵与二次型习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-相似矩阵与二次型习题">线性代数-相似矩阵与二次型习题&lt;/h1>
&lt;h2 id="内积正交的概念">内积,正交的概念&lt;/h2>
&lt;h4 id="内积的概念">内积的概念&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012145035553.png" alt="" />&lt;figcaption>image-20201012145035553&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012145106438.png" alt="" />&lt;figcaption>image-20201012145106438&lt;/figcaption>
&lt;/figure>
&lt;h4 id="正交矩阵的判定与证明">正交矩阵的判定与证明&lt;/h4>
&lt;p>可用正交矩阵的定义&lt;span class="math inline">\(A^T A = E\)&lt;/span>判断, 也可用&lt;span class="math inline">\(A^T=A^{-1}\)&lt;/span>判断, 也可用构成A向量组的向量是否都两两正交,且向量都是单位向量来判断&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012151808714.png" alt="" />&lt;figcaption>image-20201012151808714&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012151832177.png" alt="" />&lt;figcaption>image-20201012151832177&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012153113164.png" alt="" />&lt;figcaption>image-20201012153113164&lt;/figcaption>
&lt;/figure>
&lt;p>略&lt;/p>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012161359690.png" alt="" />&lt;figcaption>image-20201012161359690&lt;/figcaption>
&lt;/figure>
&lt;p>证明： A、B是正交矩阵，根据定义知道AA’=A’A=E, BB’=B’B=E, 那么(AB)(AB)‘=(AB)(B’A’)=ABB’A’=A(BB’)A=AEA’=AA’=E&lt;/p>
&lt;h4 id="线性无关向量组的正交化施密特正交化">线性无关向量组的正交化(施密特正交化)&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012150738793.png" alt="" />&lt;figcaption>image-20201012150738793&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201012150855741.png" alt="" />&lt;figcaption>image-20201012150855741&lt;/figcaption>
&lt;/figure>
&lt;h2 id="特征值与特征向量">特征值与特征向量&lt;/h2>
&lt;h3 id="求特征值与特征向量">求特征值与特征向量&lt;/h3>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201013105735880.png" alt="" />&lt;figcaption>image-20201013105735880&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201013105806041.png" alt="" />&lt;figcaption>image-20201013105806041&lt;/figcaption>
&lt;/figure>
&lt;h3 id="特征值的证明">特征值的证明&lt;/h3>
&lt;h4 id="特征值相同的证明">特征值相同的证明&lt;/h4>
&lt;p>一般根据&lt;span class="math inline">\(Ax=\lambda x, x\neq 0\)&lt;/span>的定义,化为齐次方程组&lt;span class="math inline">\((A-\lambda E)x = 0, x\neq 0\)&lt;/span>, 利用齐次方程组有非零解的条件求特征值, 即用&lt;span class="math inline">\(|A-\lambda E|=0\)&lt;/span>来证明特征值相等.&lt;/p>
&lt;p>也有习题是从&lt;span class="math inline">\(Ax=\lambda x, x\neq 0\)&lt;/span>的定义,直接入手,用矩阵乘法等来做.&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201013110513743.png" alt="" />&lt;figcaption>image-20201013110513743&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018023250370.png" alt="" />&lt;figcaption>image-20201018023250370&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018023455602.png" alt="image-20201018023455602" /> 参考:https://blog.csdn.net/qq_37430422/article/details/106255194&lt;/p>
&lt;h4 id="特征值是给定值的证明">特征值是给定值的证明&lt;/h4>
&lt;p>方法一:直接求 方法二:用特征值的性质求&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201014113240513.png" alt="" />&lt;figcaption>image-20201014113240513&lt;/figcaption>
&lt;/figure>
&lt;p>方法一:&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/6a63f6246b600c33f4533d001a4c510fd8f9a1d4" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>方法二: 首先，（A-2E）（A-E）=0。也就是说A-E的每一列都在A-2E的解空间之内，所以R(A-2E)+R(A-E)&amp;lt;=n。 （这个也可以直接由Sylvester不等式得到。对于任意两个n阶矩阵A和B，必有r(A)+r(B)&amp;lt;=r(AB)+n） 假如R(A-2E)+R(A-E)&amp;lt;n，那就是说A-2E的解空间和A-E的解空间必定有非零交集。也就是说存在列向量x使得（A-2E）x=0且（A-E）x=0，两式相减，就发现Ex=0，所以x只能等于0，矛盾。 所以只能有R(A-2E)+R(A-E)=n&lt;/p>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201014114439288.png" alt="" />&lt;figcaption>image-20201014114439288&lt;/figcaption>
&lt;/figure>
&lt;p>方法一: 当&lt;span class="math inline">\(\lambda=-1\)&lt;/span>时, &lt;span class="math inline">\(|A-\lambda E| = |A+E|\)&lt;/span>, 又A正交(即&lt;span class="math inline">\(AA^T=E\)&lt;/span>, &lt;span class="math inline">\(|A|=-1\)&lt;/span>), 则&lt;span class="math inline">\(|A+E|=|A+AA^T| = |A(E+A^T)| = |A|\cdot |E+A^T| = - |E+A|\)&lt;/span> 即&lt;span class="math inline">\(|A+E|=-|A+E|\)&lt;/span> 则&lt;span class="math inline">\(|A+E|=0\)&lt;/span> 即当&lt;span class="math inline">\(\lambda=-1\)&lt;/span>是A的特征值&lt;/p>
&lt;p>方法二: 符号||既能代表向量（n×1阶）的模，又能代表方阵（n×n阶）的行列式，两个概念不能混淆。 |x|代表向量的模，一般不能直接与|A|这个行列式值相乘得到Ax的模。常数k的话，倒是可以相乘的，即kx的模等于k的模乘向量x的模。 正交矩阵的性质是Ax的模和x的模相等，即|Ax|=|x|（这是因为|Ax|&lt;sup>2=(A&lt;em>x)‘&lt;em>(A&lt;/em>x)=x’&lt;/em>A’&lt;em>A&lt;/em>x=x’&lt;em>(A’&lt;/em>A)&lt;em>x=x’&lt;/em>I&lt;em>x=x’&lt;/em>x=|x|&lt;/sup>2）。由Ax=lamda&lt;em>x，两边取模|x|=|lamda|&lt;/em>|x|，因为|x|非零，因此可以推出|lamda|=1，即正交矩阵的特征值的模是1（包括复数的模）。 这道题的一个正确做法是：A的特征多项式的根即A的特征值，前面已经证明了他们的模都是1，而且复数特征值都是成对共轭地出现（代数基本定理，实系数多项式的复数根都是共轭成对出现），因为行列式等于特征值的乘积，所以 lamda(1)&lt;em>lamda(2)&lt;/em>…*lamda(n)=|A|=-1， 如果lamda里没有-1，那个A的实特征值只能有+1，而且共轭模1的特征值的成对乘积都是+1，所以|A|就应该是+1，而不是-1，这就矛盾了。 https://zhidao.baidu.com/question/513861568.html&lt;/p>
&lt;h6 id="例3-1">例3 !!!!&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019183352818.png" alt="" />&lt;figcaption>image-20201019183352818&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019190938858.png" alt="" />&lt;figcaption>image-20201019190938858&lt;/figcaption>
&lt;/figure>
&lt;p>a=(a1,a2,…,an)T,a1≠0，A=aaT, 所以R(A)&amp;lt;=R(a)&amp;lt;=1 又a1≠0，所以R(A)=1 故A有n-1重0特征值，其非零特征值为a1&lt;sup>2+a2&lt;/sup>2+…+an^2 https://zhidao.baidu.com/question/496459585060051324.html?&amp;amp;mzl=qb_xg_0&amp;amp;word=&lt;/p>
&lt;p>注: R(AB)&amp;lt;=R(A) &lt;span class="math inline">\(\lambda_1+\lambda_2+...+\lambda_n = a_{11}+a_{22}+...+a_{nn}\)&lt;/span>&lt;/p>
&lt;p>有一个特征值是a1&lt;sup>2+a2&lt;/sup>+…+an^2.他的特征向量怎么求: Aα =ααTα = α(αTα) = α(a1&lt;sup>2+a2&lt;/sup>+…+an^2) = (a1&lt;sup>2+a2&lt;/sup>+…+an^2)α&lt;/p>
&lt;p>注意到 &lt;span class="math inline">\(a a^T x=0\)&lt;/span> 与 &lt;span class="math inline">\(ax=0\)&lt;/span> 同解&lt;/p>
&lt;p>所以属于特征值0的特征向量即与向量a正交的非零向量. 不妨设a1≠0, 则ax=0的基础解系为 (-a2/a1, 1,0,0,…,0)^T, (-a3/a1,0,1,…,0)^T, … , (-an/a1,0,0,…,1)^T &lt;span class="math inline">\(A=a a^T\)&lt;/span>的属于特征值0的特征向量即为上述基础解系的非零线性组合 https://zhidao.baidu.com/question/543883728.html&lt;/p>
&lt;h3 id="有相同特征向量的证明">有相同特征向量的证明&lt;/h3>
&lt;p>实际上就是齐次方程组的公共解问题&lt;/p>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201013113109156.png" alt="" />&lt;figcaption>image-20201013113109156&lt;/figcaption>
&lt;/figure>
&lt;blockquote>
&lt;ol type="1">
&lt;li>rank(A)&amp;lt;=rank(A)+rank(B)&amp;lt;n，所以A不是满秩的，所以存在x≠0使得Ax=0，即0是A的一个特征值。同理可证0也是B的一个特征值。所以A与B有公共的特征值0。&lt;/li>
&lt;li>只需证明存在x≠0使得Ax=0且Bx=0，则x同时是A与B对应于特征值0的特征向量。 方法一：Ker(A)={x≠0|Ax=0}和Ker(B)={x≠0|Bx=0}都是R&lt;sup>n的线性子空间，且dimKer(A)=n-rank(A),dimKer(B)=n-rank(B)，所以dimKer(A)+dimKer(B)=2n-(rank(A)+rank(B))&amp;gt;2n-n=n=dimR&lt;/sup>n。所以dim(Ker(A)∩Ker(B))&amp;gt;=dimKer(A)+dimKer(B)-dimR^n&amp;gt;0。再任取Ker(A)∩Ker(B)中的非零元x即可。 方法二：Ax=0且Bx=0当且仅当(A|B)x=0，其中(A|B)为A和B拼成的矩阵。注意到A的列向量空间中的一组基和B的列向量空间中的一组基的并可以组成(A|B)的列向量空间中的一组生成元（未必是基），所以(A|B)的列秩不大于A和B的列秩的和。从而rank(A|B)&amp;lt;=rank(A)+rank(B)&amp;lt;n，得dimKer(A|B)=n-rank(A|B)&amp;gt;0。再任取Ker(A|B)中的非零元x即可。&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/b21c8701a18b87d623479c48080828381f30fd5b" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>参考:https://zhidao.baidu.com/question/149727470.html&lt;/p>
&lt;h2 id="矩阵相似">矩阵相似&lt;/h2>
&lt;h3 id="证明矩阵相似">证明矩阵相似&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018032601047.png" alt="" />&lt;figcaption>image-20201018032601047&lt;/figcaption>
&lt;/figure>
&lt;p>证明: 因为A可逆, 则有&lt;span class="math inline">\(A^{-1} AB A = BA\)&lt;/span> 即AB与BA相似.&lt;/p>
&lt;h3 id="矩阵相似对角化">矩阵相似对角化&lt;/h3>
&lt;h4 id="矩阵可相似对角化的判断">矩阵可相似对角化的判断&lt;/h4>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019121208151.png" alt="" />&lt;figcaption>image-20201019121208151&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019121221653.png" alt="" />&lt;figcaption>image-20201019121221653&lt;/figcaption>
&lt;/figure>
&lt;p>解: (1)用&lt;span class="math inline">\(Ap = \lambda p\)&lt;/span>来求a,b,&lt;span class="math inline">\(\lambda\)&lt;/span> (2)A是3阶方阵,需要判断是否有3个线性无关的特征向量. 先&lt;span class="math inline">\(|A-\lambda E| = 0\)&lt;/span>求特征值,然后求每个特征值对应的解向量,判断每个解空间的秩是否等于特征值的重数.&lt;/p>
&lt;h4 id="利用相似对角化求矩阵的幂多项式及其行列式">利用相似对角化求矩阵的幂,多项式及其行列式&lt;/h4>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018030139496.png" alt="" />&lt;figcaption>image-20201018030139496&lt;/figcaption>
&lt;/figure>
&lt;p>解: 3阶矩阵A有三个不同的特征值,则A有3个互相线性无关的特征向量,则A的秩为3,A可逆. &lt;span class="math inline">\(|A^3-5A^2+7A|\\=|P^{-1} (\Lambda^3-5\Lambda^2+7\Lambda) P|\\=|P^{-1}|\cdot |(\Lambda^3-5\Lambda^2+7\Lambda)|\cdot |P|\\=|(\Lambda^3-5\Lambda^2+7\Lambda)|=18\)&lt;/span>&lt;/p>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018031651293.png" alt="" />&lt;figcaption>image-20201018031651293&lt;/figcaption>
&lt;/figure>
&lt;p>答案:25&lt;/p>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019134757419.png" alt="" />&lt;figcaption>image-20201019134757419&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019134809739.png" alt="" />&lt;figcaption>image-20201019134809739&lt;/figcaption>
&lt;/figure>
&lt;p>解:求特征值,特征向量,拼成&lt;span class="math inline">\(\Lambda\)&lt;/span>对角阵和&lt;span class="math inline">\(P^{-1}A P = \Lambda\)&lt;/span>中的P矩阵&lt;/p>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019144145816.png" alt="" />&lt;figcaption>image-20201019144145816&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019144201944.png" alt="image-20201019144201944" /> 参考:http://www.math110.com/Teaching/MathHome/ExerciseShow?guid=BC2310EA-B16A-4AE6-B196-E21B5BBFE24A&amp;amp;&amp;amp;cguid=20F57A7D-31E7-4B96-B292-922F189144FE&amp;amp;&amp;amp;cname=%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0&lt;/p>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019183706785.png" alt="" />&lt;figcaption>image-20201019183706785&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019183746271.png" alt="" />&lt;figcaption>image-20201019183746271&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根据特征值与特征向量求矩阵">根据特征值与特征向量求矩阵&lt;/h4>
&lt;h5 id="根据特征值与特征向量求一般矩阵">根据特征值与特征向量求一般矩阵&lt;/h5>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019160305450.png" alt="" />&lt;figcaption>image-20201019160305450&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019160316025.png" alt="" />&lt;figcaption>image-20201019160316025&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019160328944.png" alt="" />&lt;figcaption>image-20201019160328944&lt;/figcaption>
&lt;/figure>
&lt;p>解:根据矩阵可相似对角化的充要条件:有n个现象无关的特征向量,可知A一定可相似对角化 &lt;span class="math inline">\(P^{-1}AP = \Lambda\)&lt;/span>,则&lt;span class="math inline">\(A= P \Lambda P^{-1}\)&lt;/span>&lt;/p>
&lt;h5 id="根据特征值与特征向量求对称矩阵">根据特征值与特征向量求对称矩阵&lt;/h5>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019162958112.png" alt="" />&lt;figcaption>image-20201019162958112&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019160316025.png" alt="" />&lt;figcaption>image-20201019160316025&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019163022790.png" alt="" />&lt;figcaption>image-20201019163022790&lt;/figcaption>
&lt;/figure>
解:根据对称矩阵的性质:对称阵A特征值&lt;span class="math inline">\(\lambda_1 \neq \lambda_2\)&lt;/span>&lt;span class="math inline">\(\Rightarrow\)&lt;/span>特征向量&lt;span class="math inline">\(p_1,p_2\)&lt;/span>正交 设&lt;span class="math inline">\(\lambda_3\)&lt;/span>对应的特征向量为&lt;span class="math inline">\(p_3 = (x_1,x_2,x_3)^T\)&lt;/span>,则&lt;span class="math inline">\(p_1^T p_3 = 0, p_2^T p_3=0\)&lt;/span> 则有&lt;span class="math inline">\(\left(\begin{array}{cc}p_1 \\ p_2\end{array}\right) p_3 = O\)&lt;/span> 即$(
&lt;span class="math display">\[\begin{array}{ccc}1 &amp;amp; 2 &amp;amp; 2 \\ 2 &amp;amp; 1 &amp;amp; -2\end{array}\]&lt;/span>
)(
&lt;span class="math display">\[\begin{array}{cc}x_1 \\ x_2\\ x_3\end{array}\]&lt;/span>
) = (
&lt;span class="math display">\[\begin{array}{cc}0 \\ 0\end{array}\]&lt;/span>
&lt;p>) $ 解此方程组,得通解 &lt;span class="math inline">\(x=k\left(\begin{array}{cc}2 \\ -2\\ -1\end{array}\right)\)&lt;/span>,要作为特征向量时,&lt;span class="math inline">\(k \neq 0\)&lt;/span> 可取&lt;span class="math inline">\(p_3 = \left(\begin{array}{cc}2 \\ -2\\ -1\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>接下来:&lt;/p>
&lt;p>对称矩阵一定可以相似对角化&lt;/p>
&lt;p>&lt;span class="math inline">\(P^{-1}AP = \Lambda\)&lt;/span>,则&lt;span class="math inline">\(A= P \Lambda P^{-1}\)&lt;/span>&lt;/p>
&lt;p>…&lt;/p>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019174356855.png" alt="" />&lt;figcaption>image-20201019174356855&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019174406107.png" alt="" />&lt;figcaption>image-20201019174406107&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019174431648.png" alt="image-20201019174431648" /> https://zhidao.baidu.com/question/2075815010174660988.html?qbl=relate_question_1 https://zhidao.baidu.com/question/2272849277510279468.html?qbl=relate_question_0 https://zhidao.baidu.com/question/2075815010174660988.html&lt;/p>
&lt;h4 id="根据可相似对角化求矩阵参数">根据可相似对角化求矩阵参数&lt;/h4>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201018181209472.png" alt="" />&lt;figcaption>image-20201018181209472&lt;/figcaption>
&lt;/figure>
&lt;p>n阶方阵A可对角化等价于方阵有n个线性无关的特征向量，由于不同特征值对应的特征向量必然不相关，故只需要其特征值的k重根有k个线性无关的特征向量。 A的特征值分别为1,1,6，故 R(E - A) = 1，带入可知 x = 3&lt;/p>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019154724021.png" alt="" />&lt;figcaption>image-20201019154724021&lt;/figcaption>
&lt;/figure>
&lt;h4 id="对称矩阵相似对角化正交化">对称矩阵相似对角化/正交化&lt;/h4>
&lt;p>先求特征值,特征向量,用作出与矩阵相似的对角矩阵&lt;span class="math inline">\(\Lambda\)&lt;/span>, 对各特征向量施密特正交化,然后用正交的特征向量拼成对应的可逆矩阵Q,则&lt;span class="math inline">\(Q^{-1} A Q = \Lambda\)&lt;/span>&lt;/p>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019151545448.png" alt="" />&lt;figcaption>image-20201019151545448&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019154818931.png" alt="" />&lt;figcaption>image-20201019154818931&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201019154724021.png" alt="" />&lt;figcaption>image-20201019154724021&lt;/figcaption>
&lt;/figure>
&lt;h2 id="二次型及其矩阵">二次型及其矩阵&lt;/h2>
&lt;h3 id="二次型的矩阵">二次型的矩阵&lt;/h3>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020110244825.png" alt="" />&lt;figcaption>image-20201020110244825&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020110312617.png" alt="" />&lt;figcaption>image-20201020110312617&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020110345941.png" alt="" />&lt;figcaption>image-20201020110345941&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020110400927.png" alt="" />&lt;figcaption>image-20201020110400927&lt;/figcaption>
&lt;/figure>
&lt;h3 id="二次型化为标准型或规范型">二次型化为标准型或规范型&lt;/h3>
&lt;h4 id="正交变换法化为标准型或规范型">正交变换法化为标准型或规范型&lt;/h4>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020112736516.png" alt="" />&lt;figcaption>image-20201020112736516&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020112752438.png" alt="" />&lt;figcaption>image-20201020112752438&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020112807180.png" alt="" />&lt;figcaption>image-20201020112807180&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020113338112.png" alt="" />&lt;figcaption>image-20201020113338112&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020113351116.png" alt="" />&lt;figcaption>image-20201020113351116&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020113537971.png" alt="" />&lt;figcaption>image-20201020113537971&lt;/figcaption>
&lt;/figure>
&lt;h4 id="用配方法化为标准型或规范型">用配方法化为标准型或规范型&lt;/h4>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020193837408.png" alt="" />&lt;figcaption>image-20201020193837408&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020193846165.png" alt="" />&lt;figcaption>image-20201020193846165&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020193857267.png" alt="" />&lt;figcaption>image-20201020193857267&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020193911644.png" alt="" />&lt;figcaption>image-20201020193911644&lt;/figcaption>
&lt;/figure>
&lt;h3 id="二次型的最大值">二次型的最大值&lt;/h3>
&lt;h6 id="例1-17">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020164357986.png" alt="" />&lt;figcaption>image-20201020164357986&lt;/figcaption>
&lt;/figure>
&lt;p>证明:&lt;/p>
&lt;p>二次型&lt;span class="math inline">\(f=x^T A x\)&lt;/span>的矩阵A是对称阵,必可正交对角化: &lt;span class="math inline">\(C^T A C=C^{-1}A C = \left(\begin{array}{cccc}\lambda_{1} &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; \lambda_{2} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_{n}\end{array}\right)=\Lambda\)&lt;/span>,其中&lt;span class="math inline">\(|C| \neq 0\)&lt;/span>,且C是正交阵 即二次型&lt;span class="math inline">\(f=x^T A x= y^T \Lambda y\)&lt;/span>对应的变换为&lt;span class="math inline">\(x=Cy\)&lt;/span> 又根据&lt;span class="math inline">\(\|x\|=1\)&lt;/span>,有&lt;span class="math inline">\(\|\boldsymbol{x}\|=\sqrt{\boldsymbol{x}^{\mathrm{T}} \boldsymbol{x}}=\sqrt{\boldsymbol{y}^{\mathrm{T}} \boldsymbol{C}^{\mathrm{T}} \boldsymbol{C x}}=\sqrt{\boldsymbol{y}^{\mathrm{T}} \boldsymbol{y}}=\|\boldsymbol{y}\|=1\)&lt;/span>, 即&lt;span class="math inline">\(\sqrt{y_{1}^{2}+y_{2}^{2}+\cdots+y_{n}^{2}}=1\)&lt;/span>,即&lt;span class="math inline">\(y_{1}^{2}+y_{2}^{2}+\cdots+y_{n}^{2}=1\)&lt;/span>. 不妨设&lt;span class="math inline">\(\Lambda\)&lt;/span>中最大的特征值为&lt;span class="math inline">\(\lambda_1\)&lt;/span> 则$f=y^T y=(&lt;em>{1} y&lt;/em>{1}&lt;sup>{2}++&lt;em>{n} y&lt;/em>{n}&lt;/sup>{2}) $ &lt;span class="math inline">\(\leqslant \lambda_1(y_{1}^{2}+y_{2}^{2}+\cdots+y_{n}^{2})=\lambda_1\)&lt;/span>&lt;/p>
&lt;h3 id="正定二次型">正定二次型&lt;/h3>
&lt;h4 id="已知正定求参数范围">已知正定求参数范围&lt;/h4>
&lt;p>正定二次型的矩阵,各阶主子式全为正, 负定二次型的矩阵,奇数阶主子式全为负,偶数阶主子式全为正&lt;/p>
&lt;h6 id="例1-18">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020200925531.png" alt="" />&lt;figcaption>image-20201020200925531&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020200934070.png" alt="" />&lt;figcaption>image-20201020200934070&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020201003327.png" alt="" />&lt;figcaption>image-20201020201003327&lt;/figcaption>
&lt;/figure>
&lt;h4 id="判定二次型是否正定或负定">判定二次型是否正定或负定&lt;/h4>
&lt;p>二次型正定,是指二次型的结果必大于0,&lt;/p>
&lt;p>实际上,一般利用二次型正定的充分必要条件:特征值全为正.来判断 这就化为标准型,根据标准型来看&lt;/p>
&lt;h6 id="例1-19">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020201219788.png" alt="" />&lt;figcaption>image-20201020201219788&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020201535522.png" alt="" />&lt;figcaption>image-20201020201535522&lt;/figcaption>
&lt;/figure>
&lt;h4 id="二次型充要条件的证明">二次型充要条件的证明&lt;/h4>
&lt;h6 id="例1-20">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20201020201958651.png" alt="" />&lt;figcaption>image-20201020201958651&lt;/figcaption>
&lt;/figure>
&lt;p>可参考如下定理的证明: &lt;span class="math inline">\(n\)&lt;/span> 元二次型 &lt;span class="math inline">\(f=x^{\mathrm{T}} A x\)&lt;/span> 为正定的&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的标准型的n个系数全为正&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的规范型的n个系数都为1&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>它的正惯性系数等于n&lt;/p>
&lt;blockquote>
&lt;p>证明 设存在可逆变换&lt;span class="math inline">\(x=C y\)&lt;/span> 使&lt;span class="math inline">\(f(x)=f(C y)=\sum_{i=1}^{n} k_{i} y_{i}^{2}\)&lt;/span>&lt;/p>
&lt;p>充分性: 设 &lt;span class="math inline">\(k_{i}&amp;gt;0(i=1, \cdots, n) .\)&lt;/span> 任给 &lt;span class="math inline">\(x \neq 0,\)&lt;/span> 则 &lt;span class="math inline">\(y=C^{-1} x \neq 0,\)&lt;/span> 故&lt;span class="math inline">\(f(x)=\sum_{i=1}^{n} k_{i} y_{i}^{2}&amp;gt;0\)&lt;/span>&lt;/p>
&lt;p>必要性: 用反证法. 假设$ k_s $, 则当 &lt;span class="math inline">\(y = e_s\)&lt;/span> (单位坐标向置)时, &lt;span class="math inline">\(f(x)=f(Cy)=f\left(C e_{s}\right)=k_{t} \leqslant 0\)&lt;/span> 这与二次型正定矛盾.故&lt;span class="math inline">\(k_s&amp;gt;0\)&lt;/span> 则&lt;span class="math inline">\(k_1,\cdots,k_n\)&lt;/span>都可用反证法证明大于0&lt;/p>
&lt;/blockquote></description></item><item><title>高等数学-级数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-级数">高等数学-级数&lt;/h1>
&lt;p>高等数学（数学分析）主要分为两块，微积分与级数。两者都建立在函数的极限理论之上。&lt;/p>
&lt;p>级数是表示函数、研究函数性质以及数值计算的一种工具。函数可以展开成幂级数、三角级数的形式，级数也可以求其对应的和函数，因此把函数展开到级数形式可以研究函数的一些性质，也可以用级数计算函数。&lt;/p>
&lt;p>常数项级数部分主要介绍级数的概念与一般性质。 函数项级数主要介绍幂级数、和三角级数（包括Fourier级数），着重讨论函数展开成幂级数、三角级数的问题，以及函数项级数表示成和函数的问题。&lt;/p>
&lt;h2 id="级数的基本概念与性质">级数的基本概念与性质&lt;/h2>
&lt;h3 id="级数的定义">级数的定义&lt;/h3>
&lt;p>高中我们已经学过数列。&lt;/p>
&lt;p>简单的讲，无穷数列的和，就是&lt;strong>级数&lt;/strong>。记为&lt;span class="math inline">\(\sum_{n=1}^{\infty} a_n\)&lt;/span>。 &lt;strong>级数定义&lt;/strong>：给定一个无穷数列&lt;span class="math inline">\(u_{1}, u_{2}, u_{3}, \cdots, u_{n}, \cdots\)&lt;/span>，则&lt;span class="math inline">\(\sum_{i=1}^{\infty} u_{i}=u_{1}+u_{2}+u_{3}+\cdots+u_{i}+\cdots\)&lt;/span>称为级数，其中的第n项&lt;span class="math inline">\(u_n\)&lt;/span>称为一般项。&lt;/p>
&lt;p>当级数的各项&lt;span class="math inline">\(a_i\)&lt;/span>都是常数时，形成的级数叫&lt;strong>常数项级数&lt;/strong>； 当级数的各项&lt;span class="math inline">\(a_i\)&lt;/span>都是关于x的函数时，形成的级数叫&lt;strong>函数项级数&lt;/strong>。 当级数的各项&lt;span class="math inline">\(a_i\)&lt;/span>都是复数时，形成的级数叫&lt;strong>复数项级数&lt;/strong>；&lt;/p>
&lt;p>类比研究反常积分的过程，研究反常要从正常开始，研究无限要从有限开始。 为了研究无限的级数，我们可以先看有限的部分和（前n项和）。 &lt;span class="math inline">\(S_n = a_1 + a_2 + a_3 + ... + a_n\)&lt;/span>，称为&lt;strong>级数的部分和&lt;/strong>（前n项和）。&lt;/p>
&lt;p>&lt;strong>二重级数&lt;/strong>：给定带有两个下标i和j的无穷数集{aij}(i=1,2,…;j=1,2,…)，称记号a11+a12+…+a21+a22+…+a31+a32+…是二重级数(double series)。记作&lt;span class="math inline">\(\sum_{m=1,n=1}^{\infty} a_{mn}\)&lt;/span>，也可记作&lt;span class="math inline">\(\sum_{m=1}^{\infty} \sum_{n=1}^{\infty} a_{mn}\)&lt;/span>，其中m，n各自独立地取正整数1，2，3，…&lt;/p>
&lt;h3 id="级数的收敛发散和的概念">级数的收敛、发散、和的概念&lt;/h3>
&lt;p>如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n = \lim_{n \rightarrow \infty} S_n = S\)&lt;/span>，称级数$&lt;em>{n=1}^{} a_n &lt;span class="math inline">\(**收敛**于S，这时S又称作级数\)&lt;/span>&lt;/em>{n=1}^{} a_n $的&lt;strong>和&lt;/strong>&lt;/p>
&lt;p>如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>的部分和&lt;span class="math inline">\(\lim_{n \rightarrow \infty} S_n\)&lt;/span>不存在，称级数$_{n=1}^{} a_n $&lt;strong>发散&lt;/strong>。&lt;/p>
&lt;h3 id="级数的性质">级数的性质&lt;/h3>
&lt;h4 id="级数的四则运算性质">级数的四则运算性质&lt;/h4>
&lt;p>级数加减法、乘法，结果的收敛区间取原来两级数的收敛区间&lt;span class="math inline">\((-R_1, R_1)\)&lt;/span>和&lt;span class="math inline">\((-R_2,R_2)\)&lt;/span>中较小的一个. 级数的数乘不改变收敛区间， 级数的除法可能比原来两级数的收敛区间小得多（不做讨论）&lt;/p>
&lt;h5 id="级数的加减法性质逐项相加相减性质">级数的加减法性质（逐项相加、相减性质）&lt;/h5>
&lt;p>&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n \pm \Sigma_{n=1}^{\infty} b_n = \Sigma_{n=1}^{\infty} (a_n \pm b_n)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>收敛级数的加减法&lt;/strong>：如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n = A, \Sigma_{n=1}^{\infty} b_n = B\)&lt;/span>，则&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (a_n \pm b_n) = A \pm B\)&lt;/span>。即两个级数都收敛，和/差一定收敛。&lt;/p>
&lt;p>另外有： 两个级数，一个发散，一个收敛，和/差一定发散。 两个级数，都发散，和/差的敛散性不确定。&lt;/p>
&lt;h5 id="级数的数乘性质">级数的数乘性质&lt;/h5>
&lt;p>如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n = S\)&lt;/span>，则&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} k a_n = kS\)&lt;/span>&lt;/p>
&lt;p>也即&lt;span class="math inline">\(k \neq 0\)&lt;/span>时，数乘级数敛散性不变。&lt;/p>
&lt;h5 id="级数加减数性质改变级数的有限项不改变级数敛散性">级数加减数性质：改变级数的有限项，不改变级数敛散性&lt;/h5>
&lt;p>级数前[添加、减少、改变]有限项，不改变级数的敛散性&lt;/p>
&lt;h5 id="级数的乘法性质柯西乘积">级数的乘法性质：柯西乘积&lt;/h5>
&lt;p>级数的乘法 &lt;span class="math inline">\(\left(\sum_{n=1}^{\infty} u_{n} \right)\cdot \left(\sum_{n=1}^{\infty} v_{n}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>柯西乘积&lt;/strong>：对于级数的乘法，若按“对角线法”排列结果，得&lt;span class="math inline">\(u_{1} v_{1}+\left(u_{1} v_{2}+u_{2} v_{1}\right)+\cdots+\left(u_{1} v_{n}+u_{2} v_{n-1}+\cdots+u_{n} v_{1}\right)+\cdots\)&lt;/span>， 称此结果级数为两级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 和 &lt;span class="math inline">\(\sum_{n=1}^{\infty} v_{n}\)&lt;/span> 的柯西乘积.（上面级数中括号内的作为一项） 注： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200816112052327.png" alt="image-20200816112052327" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200816112121547.png" alt="image-20200816112121547" />&lt;/p>
&lt;h5 id="级数的除法性质">级数的除法性质&lt;/h5>
&lt;p>&lt;span class="math inline">\(\frac{a_{0}+a_{1} x+a_{2} x^{2}+\cdots+a_{n} x^{n}+\cdots}{b_{0}+b_{1} x+b_{2} x^{2}+\cdots+b_{n} x^{n}+\cdots}=c_{0}+c_{1} x+c_{2} x^{2}+\cdots+c_{n} x^{n}+\cdots\)&lt;/span>，将左端分母乘到右边，右端变成级数乘法（柯西乘积），用待定系数法可确定系 数 &lt;span class="math inline">\(c_{0}, c_{1}, c_{2}, \cdots, c_{n}, \cdots,\)&lt;/span>&lt;/p>
&lt;h4 id="级数内添加括号可以提高收敛性">级数内添加括号可以提高收敛性&lt;/h4>
&lt;p>&lt;strong>定理&lt;/strong>：如果级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 收敛, 那么对这级数的项任意加括号后所成的级数$(u_{1}++u_{n_{1}})+(u_{n_{1}+1}++u_{n_{2}})++(u_{n_{k-1}+1}++u_{n_{k}})+$仍收敛，且其和不变.&lt;/p>
&lt;p>（其中每个括号对看作一项） （证明用到：数列极限性质：数列有极限，子列一定有极限）&lt;/p>
&lt;p>&lt;u>原级数收敛，添加括号后的级数（更）收敛&lt;/u> &lt;u>如果级数添加括号后发散，那么原级数（更）发散&lt;/u>&lt;/p>
&lt;p>例1， 级数$ 1 - 1 + 1 - 1 +1 - 1 …&lt;span class="math inline">\(发散，而级数\)&lt;/span> (1 - 1) + (1 - 1) +(1 - 1) …$收敛&lt;/p>
&lt;p>例2，如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>收敛，则&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (a_{2n-1} + a_{2n}) = (a_1 + a_2) + (a_3 + a_4) + ...\)&lt;/span>收敛.&lt;/p>
&lt;h4 id="级数内添加绝对值可以提高发散性">级数内添加绝对值可以提高发散性&lt;/h4>
&lt;h4 id="级数收敛的必要条件lim_n-rightarrow-infty-a_n-0">级数收敛的必要条件（&lt;span class="math inline">\(\lim_{n \rightarrow \infty} a_n = 0\)&lt;/span>）&lt;/h4>
&lt;p>如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>收敛，则&lt;span class="math inline">\(\lim_{n \rightarrow \infty} a_n = 0\)&lt;/span>。反之则不对。&lt;/p>
&lt;p>证明：（无穷级数的证明，一般从有限的部分和证起） &lt;span class="math inline">\(S_n = a_1 + a_2 + a_3 + ... + a_n\)&lt;/span>， 因为&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>收敛，所以&lt;span class="math inline">\(\lim_{n \rightarrow \infty} S_n = S\)&lt;/span> 因为&lt;span class="math inline">\(a_n = S_n - S_{n-1}\)&lt;/span>，则&lt;span class="math inline">\(\lim_{n \rightarrow \infty} a_n = \lim_{n \rightarrow \infty} S_n - \lim_{n \rightarrow \infty} S_{n-1} = S - S = 0\)&lt;/span>。&lt;/p>
&lt;h4 id="级数收敛的充分必要条件柯西审敛原理">级数收敛的充分必要条件（柯西审敛原理）&lt;/h4>
&lt;p>级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 收敛的充分必要条件为 : 对于任意给定 的正数 &lt;span class="math inline">\(\varepsilon,\)&lt;/span> 总存在正整数 &lt;span class="math inline">\(N,\)&lt;/span> 使得当 &lt;span class="math inline">\(n&amp;gt;N\)&lt;/span> 时,对于任意的正整数 &lt;span class="math inline">\(p\)&lt;/span>,都有&lt;span class="math inline">\(\left|u_{n+1}+u_{n+2}+\cdots+u_{n+p}\right|&amp;lt;\varepsilon\)&lt;/span>成立.&lt;/p>
&lt;p>（用级数的和来证明，并用到：数列极限存在的柯西极限存在准则）&lt;/p>
&lt;h2 id="常数项级数">常数项级数&lt;/h2>
&lt;h4 id="常数项级数的定义">常数项级数的定义&lt;/h4>
&lt;p>级数的各项都是常数，则此级数就称为常数项级数。&lt;/p>
&lt;h4 id="两种重要的级数p级数与几何级数">两种重要的级数：p级数与几何级数&lt;/h4>
&lt;p>p级数和几何级数是两类比较重要的级数。其他级数审敛时，常用这两种级数作为参照级数。&lt;/p>
&lt;h5 id="p级数">p级数&lt;/h5>
&lt;p>级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} \frac{1}{n^p}\)&lt;/span>称为p级数。&lt;/p>
&lt;p>当&lt;span class="math inline">\(p&amp;gt;1\)&lt;/span>时，级数&lt;span class="math inline">\(\Sigma \frac{1}{n^p}\)&lt;/span>收敛。 当&lt;span class="math inline">\(p\leq 1\)&lt;/span>时，级数&lt;span class="math inline">\(\Sigma \frac{1}{n^p}\)&lt;/span>发散。&lt;/p>
&lt;p>注：当&lt;span class="math inline">\(p=1\)&lt;/span>时，级数 &lt;span class="math inline">\(\Sigma \frac{1}{n^p}= \frac{1}{n}\)&lt;/span>称为调和级数，此级数发散。（调和级数发散的证明用反证法：假设收敛于和S，证&lt;span class="math inline">\(\lim_{n\rightarrow \infty} S_{2n} - S_{n} = \frac{1}{n+1} + ...+\frac{1}{2n}&amp;gt;\frac{1}{2}\)&lt;/span>，与&lt;span class="math inline">\(\lim_{n\rightarrow \infty} S_{2n} - S_{n} = S - S = 0\)&lt;/span>矛盾）&lt;/p>
&lt;h5 id="几何级数">几何级数&lt;/h5>
&lt;p>级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a q^n (a \neq 0 )\)&lt;/span>称为几何级数&lt;/p>
&lt;p>当&lt;span class="math inline">\(|q|&amp;lt;1\)&lt;/span>时，几何级数$&lt;em>{n=1}^{} a q^n &lt;span class="math inline">\(收敛，收敛于\)&lt;/span>$ 当&lt;span class="math inline">\(|q| \ge 1\)&lt;/span>时，几何级数$&lt;/em>{n=1}^{} a q^n $发散&lt;/p>
&lt;h4 id="正项级数与交错级数">正项级数与交错级数&lt;/h4>
&lt;p>数列各项都是非负常数，由此数列之和构成的级数叫做正项级数； 数列的项正负常数交错，由此数列之和构成的级数叫做交错级数。&lt;/p>
&lt;p>下面单独分节讨论&lt;a href="#常数项级数：正项级数">正项级数&lt;/a>与&lt;a href="#常数项级数：交错级数">交错级数&lt;/a>&lt;/p>
&lt;h3 id="常数项级数正项级数">常数项级数：正项级数&lt;/h3>
&lt;h4 id="正项级数的定义">正项级数的定义&lt;/h4>
&lt;p>&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n \quad (a_n \ge 0, n = 1,2,...)\)&lt;/span>，称为正项级数&lt;/p>
&lt;h4 id="正项级数的性质">正项级数的性质&lt;/h4>
&lt;p>在一般&lt;a href="#级数的性质">级数的性质&lt;/a>的基础上，正项级数还有如下性质：&lt;/p>
&lt;p>正项级数的部分和是随n递增的，即&lt;span class="math inline">\(S_1 \le S_2 \le S_3 ...\)&lt;/span>&lt;/p>
&lt;p>正项级数收敛的&lt;strong>充分必要条件&lt;/strong>：它的部分和数列$ { s_n}&lt;span class="math inline">\(有界. 即：正项级数的\)&lt;/span>S_n&lt;span class="math inline">\(无上界，则\)&lt;/span>&lt;em>{n} S_n = + &lt;span class="math inline">\(，即正项级数\)&lt;/span>&lt;/em>{n=1}^{} a_n&lt;span class="math inline">\(必发散于正无穷。正项级数的\)&lt;/span>S_nM&lt;span class="math inline">\(，则\)&lt;/span>&lt;em>{n} S_n &lt;span class="math inline">\(存在，即正项级数\)&lt;/span>&lt;/em>{n=1}^{} a_n$必收敛。&lt;/p>
&lt;h4 id="正项级数的审敛法">正项级数的审敛法&lt;/h4>
&lt;h5 id="比较审敛法">比较审敛法&lt;/h5>
&lt;h6 id="比较审敛法基本形式">比较审敛法基本形式&lt;/h6>
&lt;p>&lt;span class="math inline">\(a_n \ge 0, b_n \ge 0\)&lt;/span>， 1）当&lt;span class="math inline">\(a_n \le b_n\)&lt;/span>，且&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} b_n\)&lt;/span>收敛，则正项级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>收敛。 2）当&lt;span class="math inline">\(a_n \ge b_n\)&lt;/span>，且&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} b_n\)&lt;/span>发散，则正项级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>发散。&lt;/p>
&lt;p>（推论：&lt;span class="math inline">\(a_n \le k b_n\)&lt;/span>，且&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} b_n\)&lt;/span>收敛，则正项级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>收敛。）&lt;/p>
&lt;p>（都由正项级数收敛的充分必要条件证明）&lt;/p>
&lt;h6 id="比较审敛法极限形式">比较审敛法极限形式&lt;/h6>
&lt;p>&lt;span class="math inline">\(a_n &amp;gt; 0, b_n &amp;gt; 0\)&lt;/span>， 且&lt;span class="math inline">\(\lim_{n \rightarrow \infty} \frac{b_n}{a_n} = l \quad (0\le l&amp;lt;+\infty)\)&lt;/span>，已知正项级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n\)&lt;/span>和的敛散性，则&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} b_n\)&lt;/span>有相同的敛散性。&lt;/p>
&lt;h5 id="比值审敛法达朗贝尔审敛法">比值审敛法（达朗贝尔审敛法）&lt;/h5>
&lt;p>&lt;span class="math inline">\(a_n &amp;gt; 0, \quad \lim_{n \rightarrow \infty} \frac{a_{n+1}}{a_n} = \rho\)&lt;/span> 1）$&amp;lt;1 &lt;span class="math inline">\(时，\)&lt;/span>&lt;em>{n=1}^{} a_n&lt;span class="math inline">\(收敛。 2）\)&lt;/span>&amp;gt;1 &lt;span class="math inline">\(时，\)&lt;/span>&lt;/em>{n=1}^{} a_n&lt;span class="math inline">\(发散。 3）\)&lt;/span> &lt;span class="math inline">\(时，\)&lt;/span>_{n=1}^{} a_n$的敛散性不确定。&lt;/p>
&lt;p>（此方法在含阶乘的级数中好用）&lt;/p>
&lt;h5 id="根值审敛法柯西审敛法">根值审敛法（柯西审敛法）&lt;/h5>
&lt;p>&lt;span class="math inline">\(a_n &amp;gt; 0, \quad \lim_{n \rightarrow \infty} \sqrt[n]{a_n} = \rho\)&lt;/span> 1）$&amp;lt;1 &lt;span class="math inline">\(时，\)&lt;/span>&lt;em>{n=1}^{} a_n&lt;span class="math inline">\(收敛。 2）\)&lt;/span>&amp;gt;1 &lt;span class="math inline">\(时，\)&lt;/span>&lt;/em>{n=1}^{} a_n&lt;span class="math inline">\(发散。 3）\)&lt;/span> &lt;span class="math inline">\(时，\)&lt;/span>_{n=1}^{} a_n$的敛散性不确定。&lt;/p>
&lt;p>（此方法在含n次幂的级数中好用）&lt;/p>
&lt;h5 id="极限审敛法">极限审敛法&lt;/h5>
&lt;p>实际上是与p级数的比较，比较审敛法的极限形式&lt;/p>
&lt;p>设 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 为 正项级数， 1）如果 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} n u_{n}=l&amp;gt;0\left(\right.\)&lt;/span> 或 &lt;span class="math inline">\(\left.\lim _{n \rightarrow \infty} n u_{n}=+\infty\right)\)&lt;/span>，那么级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 发散； 2）如果 &lt;span class="math inline">\(p&amp;gt;1,\)&lt;/span> 而 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} n^{p} u_{n}=l(0 \leqslant l&amp;lt;+\infty)\)&lt;/span>，那么级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 收敛.&lt;/p>
&lt;h3 id="常数项级数交错级数">常数项级数：交错级数&lt;/h3>
&lt;h4 id="交错级数定义">交错级数定义&lt;/h4>
&lt;p>&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (-1)^{n-1} a_n = a_1 - a_2 + a_3 - a_4 ..., \quad a_n &amp;gt;0\)&lt;/span>， 或者&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (-1)^{n} a_n = - a_1 + a_2 - a_3 + a_4 ..., \quad a_n &amp;gt;0\)&lt;/span>， 都称作交错级数&lt;/p>
&lt;p>以上两种交错级数，实际上只差了一个常数&lt;span class="math inline">\(k=-1\)&lt;/span>，由级数性质可知，两级数敛散性相同。&lt;/p>
&lt;h4 id="交错级数的审敛">交错级数的审敛&lt;/h4>
&lt;h5 id="莱布尼兹法leibniz法">莱布尼兹法（Leibniz法）&lt;/h5>
&lt;p>设&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (-1)^{n-1} a_n, \quad a_n &amp;gt;0\)&lt;/span>， 若&lt;span class="math inline">\(\{a_n\}\)&lt;/span>单调递减， 且&lt;span class="math inline">\(\lim_{n \rightarrow \infty} a_n = 0\)&lt;/span>， 则交错级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} (-1)^{n-1} a_n, \quad a_n &amp;gt;0\)&lt;/span>收敛，且收敛位置&lt;span class="math inline">\(S \le a_1\)&lt;/span>，并有余项 &lt;span class="math inline">\(r_{n}\)&lt;/span> 的绝对值 &lt;span class="math inline">\(\left|r_{n}\right| \leqslant u_{n+1}\)&lt;/span>&lt;/p>
&lt;p>eg1：&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} \frac{(-1)^n}{\sqrt{n}}\)&lt;/span>是否收敛？ 由于此交错级数的&lt;span class="math inline">\(a_n = \frac{1}{\sqrt{n}}\)&lt;/span>，随n单调递减， 且&lt;span class="math inline">\(\lim_{n \rightarrow \infty} a_n = 0\)&lt;/span>， 根据莱布尼兹审敛法可知，此交错级数&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} \frac{(-1)^n}{\sqrt{n}}\)&lt;/span>收敛&lt;/p>
&lt;p>Q1：$&lt;em>{n=1}^{} a_n &lt;span class="math inline">\(收敛，\)&lt;/span>&lt;/em>{n=1}^{} a_n^2 &lt;span class="math inline">\(收敛吗？ A1：不一定，比如eg1中交错级数\)&lt;/span>&lt;em>{n=1}^{} &lt;span class="math inline">\(收敛，但是调和级数\)&lt;/span>&lt;/em>{n=1}^{} $发散。&lt;/p>
&lt;p>Q1：&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n \quad (a_n \ge 0)\)&lt;/span>收敛，$&lt;em>{n=1}^{} a_n^2 &lt;span class="math inline">\(收敛吗？ A1：\)&lt;/span>&lt;/em>{n=1}^{} a_n^2 (a_n ) $一定收敛&lt;/p>
&lt;h3 id="条件收敛与绝对收敛">条件收敛与绝对收敛&lt;/h3>
&lt;h4 id="条件收敛定义">条件收敛定义&lt;/h4>
&lt;p>$&lt;em>{n=1}^{} a_n &lt;span class="math inline">\(收敛，而\)&lt;/span>&lt;/em>{n=1}^{} |a_n| &lt;span class="math inline">\(发散，称\)&lt;/span>_{n=1}^{} a_n $条件收敛。&lt;/p>
&lt;p>eg： &lt;span class="math inline">\(1-\frac{1}{2} +\frac{1}{3} -\frac{1}{4} ...\)&lt;/span>收敛， &lt;span class="math inline">\(1 + \frac{1}{2} + \frac{1}{3} + \frac{1}{4}...\)&lt;/span>发散， 称上面的级数条件收敛。&lt;/p>
&lt;h4 id="绝对收敛定义">绝对收敛定义&lt;/h4>
&lt;p>$&lt;em>{n=1}^{} |a_n| &lt;span class="math inline">\(收敛，称\)&lt;/span>&lt;/em>{n=1}^{} a_n $绝对收敛。&lt;/p>
&lt;p>注：级数内取绝对值号可以提高发散性。&lt;/p>
&lt;h4 id="绝对收敛级数的性质">绝对收敛级数的性质&lt;/h4>
&lt;p>（绝对收敛，无绝对值也收敛）如果级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 绝对收敛,那么级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 必定收敛.&lt;/p>
&lt;p>（绝对收敛级数具有可交换性 ）绝对收敛级数经改变项的位置后构成的级数也收敛,且与原级数有相同的和。（在二重级数、柯西乘积到正方形法级数乘积的转换种比较有用）&lt;/p>
&lt;p>（绝对收敛级数的乘法）设级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 和 &lt;span class="math inline">\(\sum_{n=1}^{\infty} v_{n}\)&lt;/span> 都绝对收敛 &lt;span class="math inline">\(.\)&lt;/span> 其和 分别为 &lt;span class="math inline">\(s\)&lt;/span> 和 &lt;span class="math inline">\(\sigma,\)&lt;/span> 则它们的柯西乘积&lt;span class="math inline">\(u_{1} v_{1}+\left(u_{1} v_{2}+u_{2} v_{1}\right)+\cdots+\left(u_{1} v_{n}+u_{2} v_{n-1}+\cdots+u_{n} v_{1}\right)+\cdots\)&lt;/span>也是绝对收敛的,且其和为 &lt;span class="math inline">\(s\sigma\)&lt;/span>&lt;/p>
&lt;p>注意柯西乘积（级数乘法）与二重积分（加法）的区别： &lt;strong>二重级数&lt;/strong>：给定带有两个下标i和j的无穷数集{aij}(i=1,2,…;j=1,2,…)，称记号a11+a12+…+a21+a22+…+a31+a32+…是二重级数(double series)。记作&lt;span class="math inline">\(\sum_{m=1,n=1}^{\infty} a_{mn}\)&lt;/span>，也可记作&lt;span class="math inline">\(\sum_{m=1}^{\infty} \sum_{n=1}^{\infty} a_{mn}\)&lt;/span>，其中m，n各自独立地取正整数1，2，3，… &lt;strong>柯西乘积&lt;/strong>：按“对角线法”排列组成的级数&lt;span class="math inline">\(u_{1} v_{1}+\left(u_{1} v_{2}+u_{2} v_{1}\right)+\cdots+\left(u_{1} v_{n}+u_{2} v_{n-1}+\cdots+u_{n} v_{1}\right)+\cdots\)&lt;/span>为两级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}\)&lt;/span> 和 &lt;span class="math inline">\(\sum_{n=1}^{\infty} v_{n}\)&lt;/span> 的柯西乘积.记作 &lt;span class="math inline">\(\left(\sum_{n=1}^{\infty} u_{n} \right)\cdot \left(\sum_{n=1}^{\infty} v_{n}\right)\)&lt;/span> 注： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200816112052327.png" alt="image-20200816112052327" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200816112121547.png" alt="image-20200816112121547" />&lt;/p>
&lt;h2 id="函数项级数">函数项级数&lt;/h2>
&lt;h3 id="函数项级数的定义">函数项级数的定义&lt;/h3>
&lt;p>级数的项是函数构成的，称此级数为函数项级数。&lt;/p>
&lt;p>&lt;strong>函数项级数定义&lt;/strong>：如果给定一个定义在区间 I 上的函数列&lt;span class="math inline">\(u_{1}(x), u_{2}(x), u_{3}(x), \cdots, u_{n}(x), \cdots,\)&lt;/span>称为定义在区间 I 上的( 函数项)无穷级数,简称( 函数项) 级数.&lt;/p>
&lt;p>&lt;strong>对于每一个确定的值 &lt;span class="math inline">\(x_{0} \in I,\)&lt;/span> 函数项级数成为常数项级数&lt;/strong>&lt;span class="math inline">\(u_{1}\left(x_{0}\right)+u_{2}\left(x_{0}\right)+u_{3}\left(x_{0}\right)+\cdots+u_{n}\left(x_{0}\right)+\cdots\)&lt;/span>。当&lt;span class="math inline">\(x=x_0\)&lt;/span>或者&lt;span class="math inline">\(x\)&lt;/span>暂时看作常数时，级数可看作常数项级数。即常数项级数的性质在函数项级数中仍可用。&lt;/p>
&lt;p>函数项级数可能收敛也可能发散. 如果取&lt;span class="math inline">\(x=x_0\)&lt;/span>时级数收敛, 就称点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 是函数项级数的&lt;strong>收敛点&lt;/strong> ; 如果取&lt;span class="math inline">\(x=x_0\)&lt;/span>时级数发散, 就称点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 是函数项级数的&lt;strong>发散点&lt;/strong>. 函数项级数的收敛点的全体称为它的&lt;strong>收敛域&lt;/strong>, 发散点的全体称为它的&lt;strong>发散域&lt;/strong>.&lt;/p>
&lt;p>依照前面级数的相关概念：&lt;span class="math inline">\(S_n = a_1 + a_2 + a_3 + ... + a_n\)&lt;/span>，称为&lt;strong>级数的部分和&lt;/strong>（前n项和）。如果&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} a_n = \lim_{n \rightarrow \infty} S_n = S\)&lt;/span>，称级数$&lt;em>{n=1}^{} a_n &lt;span class="math inline">\(**收敛**于S，这时S称作级数\)&lt;/span>&lt;/em>{n=1}^{} a_n $的&lt;strong>和&lt;/strong>。 对应于收敛域内的任意一个数 x,函数项级数成为一收剑的常数项级数,因而有一确定的和 s. 这样,在收敛域上, 函数项级数的和是 x 的函数 &lt;span class="math inline">\(s(x)\)&lt;/span>，通常称&lt;span class="math inline">\(s(x)\)&lt;/span> 为函数项级数的&lt;strong>和函数&lt;/strong>&lt;/p>
&lt;h3 id="函数项级数的性质未掌握">函数项级数的性质（未掌握）&lt;/h3>
&lt;p>函数项级数的每项都在区间上连续，函数项级数的和函数&lt;strong>不一定&lt;/strong>在区间上连续。 函数项级数每一项的导数或积分之和 &lt;strong>不一定&lt;/strong>等于和函数的导数或积分。&lt;/p>
&lt;h4 id="函数项级数的一致收敛定义">函数项级数的一致收敛定义&lt;/h4>
&lt;p>设有函数项级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x) .\)&lt;/span> 如果对于任意给定的正数 &lt;span class="math inline">\(\varepsilon,\)&lt;/span> 都存在着一个只依赖于 &lt;span class="math inline">\(\varepsilon\)&lt;/span> 的正整数 &lt;span class="math inline">\(N,\)&lt;/span> 使得当 &lt;span class="math inline">\(n&amp;gt;N\)&lt;/span> 时,对区间 I 上的一切 &lt;span class="math inline">\(x\)&lt;/span>,都有不等式&lt;span class="math inline">\(\left|r_{n}(x)\right|=\left|s(x)-s_{n}(x)\right|&amp;lt;\varepsilon\)&lt;/span>成立,那么称函数项级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在区间 &lt;span class="math inline">\(I\)&lt;/span> 上一致收敛于和 &lt;span class="math inline">\(s(x),\)&lt;/span> 也称函数序列 &lt;span class="math inline">\(\left\{s_{n}(x)\right\}\)&lt;/span> 在区间 &lt;span class="math inline">\(I\)&lt;/span> 上&lt;strong>一致收敛&lt;/strong>于 &lt;span class="math inline">\(s(x) .\)&lt;/span>&lt;/p>
&lt;h4 id="函数项级数一致收敛的充分条件">函数项级数一致收敛的充分条件&lt;/h4>
&lt;p>定理( 魏尔斯特拉斯( Weierstrass ) 判别法 ) &lt;span class="math inline">\(\quad\)&lt;/span> 如果函数项级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在 区间 I 上满足条件 : 1）&lt;span class="math inline">\(\left|u_{n}(x)\right| \leqslant a_{n}(n=1,2,3, \cdots)\)&lt;/span> 2）正项级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} a_{n}\)&lt;/span> 收敛 那么函数项级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在区间 &lt;span class="math inline">\(I\)&lt;/span> 上一致收敛.&lt;/p>
&lt;h4 id="一致收敛的函数项级数的性质">一致收敛的函数项级数的性质&lt;/h4>
&lt;p>定理 1（在区间上各项都连续、且一致连续的级数，其和函数也连续） &lt;span class="math inline">\(\quad\)&lt;/span> 如 果 级 数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 的 各 项区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上 都 连 续，且&lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上一致收敛于 &lt;span class="math inline">\(s(x),\)&lt;/span> 那么 &lt;span class="math inline">\(s(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上也连续.&lt;/p>
&lt;p>定理 2（在区间上各项都连续、且一致连续的级数，逐项可积） &lt;span class="math inline">\(\quad\)&lt;/span> 如 果 级 数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 的 各 项 &lt;span class="math inline">\(u_{n}(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上 连 续，且&lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上一致收敛于 &lt;span class="math inline">\(s(x),\)&lt;/span> 那 么级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上 可 以逐项 积分, 即&lt;span class="math inline">\(\int_{x_{0}}^{x} s(x) \mathrm{d} x=\int_{x_{0}}^{x} u_{1}(x) \mathrm{d} x+\int_{x_{0}}^{x} u_{2}(x) \mathrm{d} x+\cdots+\int_{x_{0}}^{x} u_{n}(x) \mathrm{d} x+\cdots\)&lt;/span>其中 &lt;span class="math inline">\(a \leqslant x_{0}&amp;lt;x \leqslant b,\)&lt;/span> 并且上式右端的级数在[ $.a, b]$ 上也一致收敛。&lt;/p>
&lt;p>定理 3 （在区间上各项都有连续导数、且一致连续的级数，逐项可导）&lt;span class="math inline">\(\quad\)&lt;/span> 如果级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上收敛于和 &lt;span class="math inline">\(s(x)\)&lt;/span>. 它的各项 &lt;span class="math inline">\(u_{n}(x)\)&lt;/span>都具有连续导数 &lt;span class="math inline">\(u_{n}^{\prime}(x),\)&lt;/span> 并且级数 &lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}^{\prime}(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上一致收敛,那 么级数&lt;span class="math inline">\(\sum_{n=1}^{\infty} u_{n}(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上也一致收敛,且可逐项求导,即&lt;span class="math inline">\(s^{\prime}(x)=u_{1}^{\prime}(x)+u_{2}^{\prime}(x)+\cdots+u_{n}^{\prime}(x)+\cdots\)&lt;/span>&lt;/p>
&lt;p>定理 4 （幂级数一定一致连续）&lt;span class="math inline">\(\quad\)&lt;/span> 如果幂级数 &lt;span class="math inline">\(\sum_{n=0}^{\infty} a_{n} x^{n}\)&lt;/span> 的幂级数半径为 &lt;span class="math inline">\(R&amp;gt;0,\)&lt;/span> 那么此级数在( &lt;span class="math inline">\(\left.-R, R\right)\)&lt;/span>内的任一闭区间[ a,b]上一致收敛.&lt;/p>
&lt;p>定理 5 （幂级数可逐项求导，且收敛半径不变）如果幂级数 &lt;span class="math inline">\(\sum_{n=0}^{\infty} a_{n} x^{n}\)&lt;/span> 的收敛半径为 &lt;span class="math inline">\(R&amp;gt;0,\)&lt;/span> 那么其和函数 &lt;span class="math inline">\(s(x)\)&lt;/span> 在&lt;span class="math inline">\((-R, R)\)&lt;/span> 内可导,且有逐项求导公式&lt;span class="math inline">\(s^{\prime}(x)=\left(\sum_{n=0}^{\infty} a_{n} x^{n}\right)^{\prime}=\sum_{n=1}^{\infty} n a_{n} x^{n-1}\)&lt;/span>逐项求导后所得到的幂级数与原级数有相同的收敛半径.&lt;/p>
&lt;h2 id="函数项级数幂级数">函数项级数：幂级数&lt;/h2>
&lt;p>相对于常数项级数，如果级数的项中含有函数，则称为函数项级数。 函数项级数取值，就变成了常数项函数。&lt;/p>
&lt;p>幂级数属于函数项级数，是各项都是常数乘幂函数的函数项级数。&lt;/p>
&lt;h3 id="幂级数的定义">幂级数的定义&lt;/h3>
&lt;p>&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} a_n x^n = a_0 + a_1 x + a_2 x^2 + ...\)&lt;/span> &lt;span class="math inline">\(\Sigma_{n=0}^{\infty} = a_0 + a_1 (x - x_0) + a_2 (x - x_0)^2 + ...\)&lt;/span> 都称为幂级数。第二种可以通过换元变成第一种形式。&lt;/p>
&lt;p>函数项级数取值，就变成了常数项函数。（幂级数属于函数项级数）&lt;/p>
&lt;p>eg：幂级数： &lt;span class="math inline">\(\Sigma_{n=0}^{\infty} a_n x^n = 1 + x + x^2 + ...\)&lt;/span> 取&lt;span class="math inline">\(x = \frac{1}{2}\)&lt;/span>， 则级数变为&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} (\frac{1}{2})^n\)&lt;/span>，级数收敛，即&lt;span class="math inline">\(x=\frac{1}{2}\)&lt;/span>是收敛点； 取&lt;span class="math inline">\(x = 3\)&lt;/span>，则级数变为&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} 3^n\)&lt;/span>，级数发散，即&lt;span class="math inline">\(x=3\)&lt;/span>是发散点。&lt;/p>
&lt;p>函数项级数特别关注使级数收敛的点（收敛点），即所有收敛点的集合（收敛域）&lt;/p>
&lt;h3 id="幂级数的性质">幂级数的性质&lt;/h3>
&lt;p>在一般&lt;a href="#级数的性质">级数的性质&lt;/a>的基础上，幂级数还有如下性质&lt;/p>
&lt;h4 id="阿贝尔定理abel收敛半径的存在性">阿贝尔定理（Abel）：收敛半径的存在性&lt;/h4>
&lt;p>如 果 级 数 &lt;span class="math inline">\(\sum_{n=0}^{\infty} a_{n} x^{n}\)&lt;/span> 在当&lt;span class="math inline">\({x}=x_{0} \quad\left(x_{0} \neq 0\right)\)&lt;/span> 时 收敛，那么适合不等式 I &lt;span class="math inline">\(x|&amp;lt;| x_{0} \mid\)&lt;/span> 的一切 &lt;span class="math inline">\(x\)&lt;/span> 使这幂级数绝对收敛. 反之,如果级数$&lt;em>{n=0}^{} a&lt;/em>{n} x^{n} &lt;span class="math inline">\(在当\)&lt;/span>x = x_{0}$ 时发散，那么适合不等式 | &lt;span class="math inline">\(x|&amp;gt;| x_{0} \mid\)&lt;/span> 的一切 &lt;span class="math inline">\(x\)&lt;/span> 使 这 幂级数发散。&lt;/p>
&lt;p>&lt;strong>推论&lt;/strong>（收敛半径一定存在）：对于幂级数&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} a_n x^n\)&lt;/span>，存在&lt;span class="math inline">\(R \ge 0\)&lt;/span>， 1）当&lt;span class="math inline">\(|x| &amp;lt; R\)&lt;/span>，或者&lt;span class="math inline">\(-R &amp;lt; x &amp;lt; R\)&lt;/span>时，幂级数&lt;strong>绝对收敛&lt;/strong>。 2）当$|x| &amp;gt;R &lt;span class="math inline">\(时，幂级数发散。 3）当\)&lt;/span>|x| = R$时，幂级数的收敛性不确定，需要具体分析。&lt;/p>
&lt;h4 id="收敛半径r的计算定理">收敛半径R的计算定理&lt;/h4>
&lt;p>对于幂级数$_{n=0}^{} a_n x^n $ 若&lt;span class="math inline">\(\lim_{n \rightarrow \infty} \left|\frac{a_{n+1}}{a_n} \right| = \rho\)&lt;/span>或者&lt;span class="math inline">\(\lim_{n \rightarrow \infty} \sqrt[n]{|a_n|} = \rho\)&lt;/span>， 则： 1）当&lt;span class="math inline">\(\rho = 0\)&lt;/span>时，收敛半径&lt;span class="math inline">\(R = + \infty\)&lt;/span> （处处收敛） 2）当&lt;span class="math inline">\(\rho = +\infty\)&lt;/span>时，收敛半径&lt;span class="math inline">\(R = 0\)&lt;/span> （只有收敛点&lt;span class="math inline">\(x=0\)&lt;/span>） 3）当&lt;span class="math inline">\(0&amp;lt;\rho&amp;lt;+\infty\)&lt;/span>时，收敛半径&lt;span class="math inline">\(R = \frac{1}{\rho}\)&lt;/span>&lt;/p>
&lt;p>注：对于收敛域的计算，除了计算收敛半径，还需要讨论一下两个边界是否收敛。&lt;/p>
&lt;p>eg1：&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} n! x^n\)&lt;/span>的收敛半径R、收敛域？ &lt;span class="math inline">\(\lim_{n \rightarrow \infty} \left| \frac{a_{n+1}}{a_n} \right| = \lim_{n \rightarrow \infty} (n+1) = + \infty\)&lt;/span> 则收敛半径R=0，收敛域{0}&lt;/p>
&lt;p>eg2：&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} \frac{x^n}{n!}\)&lt;/span>的收敛半径R、收敛域？ &lt;span class="math inline">\(\lim_{n \rightarrow \infty} \left| \frac{a_{n+1}}{a_n} \right| = \lim_{n \rightarrow \infty} \frac{1}{n+1} = 0\)&lt;/span> 则此幂级数的收敛半径&lt;span class="math inline">\(R=+\infty\)&lt;/span>，收敛域&lt;span class="math inline">\((-\infty, +\infty)\)&lt;/span>&lt;/p>
&lt;p>eg3：$&lt;em>{n=0}^{} $的收敛半径R、收敛域？ $&lt;/em>{n } | | = _{n } {2^{n+1} (n+1)} = $ 则此幂级数收敛半径R=2. 当&lt;span class="math inline">\(x=-2\)&lt;/span>时，级数变为&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} \frac{(-2)^n}{2^n \cdot n} = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{n}\)&lt;/span>，此级数收敛； 当&lt;span class="math inline">\(x=2\)&lt;/span>时，级数变为&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} \frac{2^n}{2^n \cdot n} = \Sigma_{n=0}^{\infty} \frac{1}{n}\)&lt;/span>，此级数发散； 综上，此幂级数的收敛域为&lt;span class="math inline">\([-2,2)\)&lt;/span>&lt;/p>
&lt;h4 id="幂级数的运算性质">幂级数的运算性质&lt;/h4>
&lt;h5 id="级数的四则运算性质-1">&lt;a href="#级数的四则运算性质">级数的四则运算性质&lt;/a>&lt;/h5>
&lt;h5 id="幂级数的分析性质微积分性质">幂级数的分析性质（微积分性质）&lt;/h5>
&lt;p>幂级数$&lt;em>{n=0}^{} a_n x^n, x (-R, R) &lt;span class="math inline">\(，实际上可看作一个x的函数，称\)&lt;/span>S(x) = &lt;/em>{n=0}^{} a_n x^n $为幂级数的和函数。&lt;/p>
&lt;h6 id="幂级数的逐项可导性">幂级数的逐项可导性&lt;/h6>
&lt;p>对于幂级数$&lt;em>{n=0}^{} a_n x^n, x (-R, R) &lt;span class="math inline">\(， 有\)&lt;/span>(&lt;/em>{n=0}^{} a_n x^n )^= S^(x) = &lt;em>{n=0}^{} (a_n x&lt;sup>n)&lt;/sup>= &lt;/em>{n=0}^{} n a_n x^{n-1}$ 且&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} n a_n x^(n-1)\)&lt;/span>的收敛半径仍为R不变。（但是端点处的收敛性可能发生变换，所以收敛域也可能发生变化）&lt;/p>
&lt;h6 id="幂级数的逐项可积性">幂级数的逐项可积性&lt;/h6>
&lt;p>对于幂级数$_{n=0}^{} a_n x^n, x (-R, R) &lt;span class="math inline">\(， 有\)&lt;/span>&lt;em>0^x ( &lt;/em>{n=0}^{} a_n x^n) dx = &lt;em>0^x S(x) dx = &lt;/em>{n=0}^{} &lt;em>0^x a_n x^n dx = &lt;/em>{n=0}^{} x^{n+1}$ 且&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} \frac{a_n}{n+1} x^{n+1}\)&lt;/span>的收敛半径仍为R不变。（但是端点处的收敛性可能发生变换，所以收敛域也可能发生变化）&lt;/p>
&lt;h4 id="幂级数的和函数必连续">幂级数的和函数必连续&lt;/h4>
&lt;p>幂级数 &lt;span class="math inline">\(\sum_{n=0}^{\infty} a_{n} x^{n}\)&lt;/span> 的和函数 &lt;span class="math inline">\(s(x)\)&lt;/span> 在其收敛域 &lt;span class="math inline">\(I\)&lt;/span> 上连续.&lt;/p>
&lt;h3 id="和函数和幂级数的互相变换">和函数和幂级数的互相变换&lt;/h3>
&lt;p>举例说明一下函数和级数的互换， &lt;span class="math inline">\(\Sigma_{n=0}^{\infty} x^n = \frac{1}{1-x}, \quad (-1&amp;lt;x&amp;lt;1)\)&lt;/span>，左边到右边称为&lt;strong>函数项级数求和函数&lt;/strong>。 &lt;span class="math inline">\(\frac{1}{1-x} = \Sigma_{n=0}^{\infty} x^n, \quad (-1&amp;lt;x&amp;lt;1)\)&lt;/span>，左边到右边称为&lt;strong>函数展开成级数&lt;/strong>。&lt;/p>
&lt;h4 id="函数展开成幂级数">函数展开成幂级数&lt;/h4>
&lt;h5 id="直接法公式法泰勒级数麦克劳林级数">直接法（公式法：泰勒级数、麦克劳林级数）&lt;/h5>
&lt;p>根据&lt;strong>泰勒公式&lt;/strong>： 若&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>的邻域内&lt;span class="math inline">\((n+1)\)&lt;/span>阶可导， 则&lt;span class="math inline">\(f(x)\)&lt;/span>可展开到&lt;span class="math inline">\((n+1)\)&lt;/span>阶：&lt;span class="math inline">\(f(x) = P_n (x) + R_n(x)\)&lt;/span> &lt;span class="math inline">\(P_n(x) = f\left(x_{0}\right)+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}\)&lt;/span>是主要部分， 余项可以写成：&lt;span class="math inline">\(R_{n}(x)=\frac{f^{(n+1)}(\xi)}{(n+1) !}\left(x-x_{0}\right)^{n+1}\)&lt;/span>称为拉格朗日余项， 余项也可以写成：&lt;span class="math inline">\(R_{n}(x)=o\left(\left(x-x_{0}\right)^{n}\right)\)&lt;/span>称为皮亚诺余项。&lt;/p>
&lt;p>当&lt;span class="math inline">\(f(x)\)&lt;/span>可展开的阶数&lt;span class="math inline">\((n+1) \rightarrow \infty\)&lt;/span>时，有&lt;strong>泰勒级数的概念&lt;/strong>： 若&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>的邻域内任意阶可导， 则&lt;span class="math inline">\(f(x)\)&lt;/span>可展开为级数： &lt;span class="math inline">\(f(x) = \Sigma_{n=0}^{\infty} \frac{f^{(n)}(x_0)}{n!} (x - x_0)^n \\= f\left(x_{0}\right)+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+...\)&lt;/span>&lt;/p>
&lt;p>定理（&lt;strong>函数能展开称泰勒级数的充分必要条件&lt;/strong>）：设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某一邻域 &lt;span class="math inline">\(U\left(x_{0}\right)\)&lt;/span> 内具有各阶导数 , 则 &lt;span class="math inline">\(f(x)\)&lt;/span> 在该 邻域内能展开成泰勒级数的充分必要条件是在该邻域内 &lt;span class="math inline">\(f(x)\)&lt;/span> 的泰勒公式中的余项 &lt;span class="math inline">\(R_{n}(x)\)&lt;/span> 当 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span> 时的极限为零,即&lt;span class="math inline">\(\lim _{n \rightarrow \infty} R_{n}(x)=0, x \in U\left(x_{0}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>直接法展开成泰勒级数的步骤&lt;/strong>：求函数各阶导，确认任意阶可导；写出泰勒级数，并确认余项趋于零&lt;span class="math inline">\(\lim _{n \rightarrow \infty} R_{n}(x)=0\)&lt;/span>&lt;/p>
&lt;p>当泰勒级数的展开位置&lt;span class="math inline">\(x_0 = 0\)&lt;/span>时，相应的，叫做&lt;strong>麦克劳林级数&lt;/strong>： 若&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0=0\)&lt;/span>的邻域内任意阶可导， 则&lt;span class="math inline">\(f(x)\)&lt;/span>可展开为级数： &lt;span class="math inline">\(f(x) = \Sigma_{n=0}^{\infty} \frac{f^{(n)}(0)}{n!} x^n \\= f\left(0\right)+\frac{f^{\prime}\left(0\right)}{1 !} x +\frac{f^{\prime \prime}\left(0\right)}{2 !}x^{2}+\cdots+\frac{f^{(n)}\left(0\right)}{n !} x^{n}+...\)&lt;/span>&lt;/p>
&lt;h5 id="常见函数的麦克劳林级数">常见函数的麦克劳林级数&lt;/h5>
&lt;table>
&lt;colgroup>
&lt;col style="width: 15%" />
&lt;col style="width: 63%" />
&lt;col style="width: 20%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>函数&lt;/th>
&lt;th>展开成麦克劳林级数（在&lt;span class="math inline">\(x_0=0\)&lt;/span>附近展开成级数）&lt;/th>
&lt;th>收敛域&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(e^x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+x+ \frac{x^2}{2!} + ... + \frac{x^n}{n!} + ..\\ = \Sigma_{n=0}^{\infty} \frac{x^n}{n!}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\sin x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +...\\ = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{(2n+1)!} x^{2n+1}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\cos x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + ... \\ = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{(2n)!} x^{2n}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\frac{1}{1-x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+x+x^2+x^3+... \\ = \Sigma_{n=0}^{\infty} x^n\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\frac{1}{1+x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(= \Sigma_{n=0}^{\infty} (-1)^n x^n\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(ln(1+x)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=x-\frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + ... \\ = \Sigma_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n\)&lt;/span>&lt;br />注意这个级数从n=1开始&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x \le 1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(-ln(1-x)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=x + \frac{x^2}{2} + \frac{x^3}{3} + \frac{x^4}{4} + ... \\ = \Sigma_{n=1}^{\infty} \frac{x^n}{n}\)&lt;/span>&lt;br />注意这个级数从n=1开始&lt;/td>
&lt;td>&lt;span class="math inline">\(-1 \le x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\((1+x)^{m}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+m x+\frac{m(m-1)}{2 !} x^{2}+\cdots+\frac{m(m-1) \cdots(m-n+1)}{n !} x^{n}+\cdots\)&lt;/span>&lt;br />这个展开叫做&lt;strong>二项展开式&lt;/strong>，也是代数学中的二项展开定理&lt;/td>
&lt;td>&lt;span class="math inline">\((-1&amp;lt;x&amp;lt;1)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="间接法借助常用麦克劳林展开逐项可导逐项可积性质">间接法（借助常用麦克劳林展开、逐项可导、逐项可积性质）&lt;/h5>
&lt;h6 id="间接法工具">间接法工具&lt;/h6>
&lt;p>常用函数的麦克劳林展开（在&lt;span class="math inline">\(x_0=0\)&lt;/span>附近展开） 幂级数逐项可导性质 幂级数逐项可积性质&lt;/p>
&lt;p>在&lt;strong>指定位置附近展开成幂级数&lt;/strong>的例题：&lt;/p>
&lt;p>eg1：将&lt;span class="math inline">\(f(x) = \frac{1}{x^2-1}\)&lt;/span>展开成&lt;span class="math inline">\((x-2)\)&lt;/span>的幂级数 （或者说，在&lt;span class="math inline">\(x_0=2\)&lt;/span>附近展开成幂级数） &lt;span class="math inline">\(f(x)=\frac{1}{2} \left(\frac{1}{x-1} -\frac{1}{x+1}\right)\)&lt;/span> &lt;span class="math inline">\(\frac{1}{x-1} = \frac{1}{1+(x-2)}= \Sigma_{n=0}^{\infty} (-1)^n (x-2)^n , \quad (-1&amp;lt;x&amp;lt;3)\)&lt;/span> &lt;span class="math inline">\(\frac{1}{x+1} = \frac{1}{3+(x-2)} = \frac{1}{3} \frac{1}{1+ \frac{x-2}{3}} = \frac{1}{3} \Sigma_{n=0}^{\infty} (-1)^n \left(\frac{x-2}{3}\right)^n = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{3^{n+1}} (x-2)^n, \quad (-1&amp;lt;x&amp;lt;5)\)&lt;/span> 所以&lt;span class="math inline">\(f(x) = \Sigma_{n=0}^{\infty}\frac{(-1)^n}{2} \left(1-\frac{1}{3^{n+1}}\right)(x-2)^n, \quad (1&amp;lt;x&amp;lt;3)\)&lt;/span>&lt;/p>
&lt;p>eg2：&lt;span class="math inline">\(f(x) = \frac{5x-1}{x^2-x-2}\)&lt;/span>展成&lt;span class="math inline">\((x-1)\)&lt;/span>的幂级数（或者说，在&lt;span class="math inline">\(x_0=1\)&lt;/span>附近展开成幂级数） &lt;span class="math inline">\(f(x)=\frac{5x-1}{(x-2)}= \frac{A}{x+1} + \frac{B}{x-2}, \quad \Rightarrow A = 2,B=3\)&lt;/span> &lt;span class="math inline">\(f(x) = 2 \frac{1}{x+1} + 3 \frac{1}{x-2}\)&lt;/span> &lt;span class="math inline">\(\frac{1}{x+1} = \frac{1}{2+(x-1)}= \frac{1}{2} \frac{1}{1+\frac{x-1}{2}} = \frac{1}{2} \Sigma_{n=0}^{\infty} (-1)^n \left(\frac{x-1}{2}\right)^2 = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{2^{n+1}}(x-1)^n, \quad (-1&amp;lt;x&amp;lt;3)\)&lt;/span> &lt;span class="math inline">\(\frac{1}{x-2} = \frac{1}{-1+(x-1)} = - \frac{1}{1-(x-1)} = - \Sigma_{n=0}^{\infty} (x-1)^n , \quad (0&amp;lt;x&amp;lt;2)\)&lt;/span> 所以&lt;span class="math inline">\(f(x) = \Sigma_{n=0}^{\infty} \left[ \frac{(-1)^n}{2^n} - 3 \right] (x-1)^n, \quad (0&amp;lt;x&amp;lt;2)\)&lt;/span>&lt;/p>
&lt;h4 id="幂级数求和函数">幂级数求和函数&lt;/h4>
&lt;h5 id="幂级数求和函数工具">幂级数求和函数工具&lt;/h5>
&lt;p>常见的麦克劳林展开 幂级数逐项可导性质 幂级数逐项可积性质&lt;/p>
&lt;h5 id="类型一sigma_n0infty-pn-xn求和函数">类型一：&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} P(n) x^n\)&lt;/span>求和函数&lt;/h5>
&lt;h6 id="解法">解法&lt;/h6>
&lt;p>幂级数逐项可导性质 麦克劳林级数&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} x^n=\frac{1}{1-x}, \quad (-1&amp;lt;x&amp;lt;1)\)&lt;/span> 麦克劳林级数&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} (-1)^n x^n=\frac{1}{1+x}, \quad(-1&amp;lt;x&amp;lt;1)\)&lt;/span>&lt;/p>
&lt;p>eg1：给定幂级数$_{n=1}^{} n x^{n+1} &lt;span class="math inline">\(,求其和函数\)&lt;/span>S(x)$ 1）先求收敛域： &lt;span class="math inline">\(\lim_{n \rightarrow \infty} \left| \frac{a_{n+1}}{a_n} \right| = 1\)&lt;/span>，得收敛半径&lt;span class="math inline">\(R = 1\)&lt;/span> 当&lt;span class="math inline">\(x = \pm 1\)&lt;/span>时，&lt;span class="math inline">\(n(-1)^{n+1} \nrightarrow 1 (n \rightarrow \infty)\)&lt;/span> 所以收敛域&lt;span class="math inline">\((-1,1)\)&lt;/span> 2）求和函数： &lt;span class="math inline">\(S(x) = \Sigma_{n=1}^{\infty} n x^{n+1} = x^2 \Sigma_{n=1}^{\infty} n x^{n-1}\)&lt;/span> &lt;span class="math inline">\(=x^2 \Sigma_{n=1}^{\infty} (x^n)^{\prime} = x^2 x^2 \left(\Sigma_{n=1}^{\infty} x^n\right)^{\prime}\)&lt;/span> &lt;span class="math inline">\(=x^2 \left(\frac{x}{1-x}\right)^{\prime}\)&lt;/span>&lt;/p>
&lt;p>eg2：$_{n=0}^{} n^2 x^n &lt;span class="math inline">\(， 求\)&lt;/span>S(x)$&lt;/p>
&lt;p>1）先求收敛域 $_{n} | | = 1 $ 则收敛半径&lt;span class="math inline">\(R = 1\)&lt;/span> 当&lt;span class="math inline">\(x= \pm 1\)&lt;/span>时，&lt;span class="math inline">\(n^2 (\pm 1) ^n \nrightarrow 0 (n \rightarrow \infty)\)&lt;/span> 所以收敛域&lt;span class="math inline">\((-1,1)\)&lt;/span> 2）求&lt;span class="math inline">\(S(x)\)&lt;/span> &lt;span class="math inline">\(S(x) = \Sigma_{n=0}^{\infty} n^2 x^n\)&lt;/span> &lt;span class="math inline">\(= \Sigma_{n=1}^{\infty} n^2 x^n\)&lt;/span> &lt;span class="math inline">\(=\Sigma_{n=1}^{\infty} [n(n-1) +n] x^n\)&lt;/span> &lt;span class="math inline">\(=\Sigma_{n=1}^{\infty} n(n-1) x^n + \Sigma_{n=1}^{\infty} n x^n\)&lt;/span> &lt;span class="math inline">\(=x^2 \Sigma_{n=1}^{\infty} n(n-1) x^{n-2} + x\Sigma_{n=1}^{\infty} n x^{n-1}\)&lt;/span> &lt;span class="math inline">\(=x^2 \Sigma_{n=1}^{\infty} (x^n)^{\prime\prime} + x\Sigma_{n=1}^{\infty} (x^n)^{\prime}\)&lt;/span> &lt;span class="math inline">\(=x^2 \left(\Sigma_{n=1}^{\infty} x^n\right)^{\prime\prime} + x \left(\Sigma_{n=1}^{\infty} x^n\right)^{\prime}\)&lt;/span> （这里将括号内的幂级数，看作收敛的几何级数，几何级数的极限为&lt;span class="math inline">\(\frac{a_1}{1-q}\)&lt;/span>） &lt;span class="math inline">\(=x^2 \left(\frac{x^2}{1-x} \right)^{\prime\prime} + x \left(\frac{x}{1-x} \right)^{\prime}\)&lt;/span>&lt;/p>
&lt;h5 id="类型二sigma_n0infty-fracxnpn求和函数">类型二：&lt;span class="math inline">\(\Sigma_{n=0}^{\infty} \frac{x^n}{P(n)}\)&lt;/span>求和函数&lt;/h5>
&lt;h6 id="解法-1">解法&lt;/h6>
&lt;p>麦克劳林级数&lt;span class="math inline">\(ln(1+x) = \Sigma_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n\)&lt;/span>，注意这个级数从n=1开始 &lt;span class="math inline">\((-1&amp;lt;x \le 1)\)&lt;/span> 麦克劳林级数&lt;span class="math inline">\(-ln(1-x) = \Sigma_{n=1}^{\infty} \frac{x^n}{n}\)&lt;/span>注意这个级数从n=1开始 &lt;span class="math inline">\((-1 \le x &amp;lt; 1)\)&lt;/span> 麦消灭分母&lt;/p>
eg1：&lt;span class="math inline">\(\Sigma_{n=1}^{\infty} \frac{x^n}{n(n+1)}\)&lt;/span>,求和函数&lt;span class="math inline">\(S(x)\)&lt;/span> 1）先求收敛域 $&lt;em>{n} | | = 1 $ 此幂级数的收敛半径&lt;span class="math inline">\(R = 1\)&lt;/span> 当&lt;span class="math inline">\(x = \pm 1\)&lt;/span>时，$&lt;/em>{n=1}^{} = _{n=1}^{} = 1 $ （用级数的定义法可证收敛于1：&lt;span class="math inline">\(S_n = \frac{1}{1 \times 2} + \frac{1}{2 \times 3} +... +\frac{1}{n(n+1)}\)&lt;/span>，则&lt;span class="math inline">\(\lim_{n \rightarrow \infty} S_n = 1\)&lt;/span> ） 所以收敛域&lt;span class="math inline">\([1,1]\)&lt;/span> 2）再求和函数&lt;span class="math inline">\(S(x)\)&lt;/span> &lt;span class="math inline">\(\begin{aligned} S(x) &amp;amp;=\sum_{n=1}^{\infty} \frac{x^{n}}{n(n+1)} \\ &amp;amp;=\sum_{n=1}^{\infty} \frac{x^{n}}{n}-\sum_{n=1}^{\infty} \frac{x^{n}}{n+1} \end{aligned}\)&lt;/span> 当&lt;span class="math inline">\(x=0\)&lt;/span>时，&lt;span class="math inline">\(S(0) = 0\)&lt;/span> 当&lt;span class="math inline">\(x \neq 0\)&lt;/span>时， $
&lt;span class="math display">\[\begin{aligned} S(x) &amp;amp;=-\ln(1-x)-\frac{1}{x} \sum_{n=1}^{\infty} \frac{x^{n+1}}{n+1} \\ &amp;amp;=-\ln(1-x)-\frac{1}{x} \sum_{n=2}^{\infty} \frac{x^{n}}{n}\\ &amp;amp;=-\ln (1-x)-\frac{1}{x}\left(\sum_{n=1}^{\infty} \frac{x^{n}}{n}-x\right) \\ &amp;amp;=-\ln (1-x)-\frac{1}{x}[-\ln (1-x)-x] \\ &amp;amp;=\left(\frac{1}{x}-1\right) \ln (1-x)+1 \end{aligned}\]&lt;/span>
&lt;p>, (-1 x&amp;lt;1) and x $ 当&lt;span class="math inline">\(x=1\)&lt;/span>时，&lt;span class="math inline">\(S(1) = \sum_{n=1}^{\infty} \frac{1}{n(n+1)} =1\)&lt;/span> 综上， &lt;span class="math inline">\(f(x)=\left\{\begin{array}{ll}0 &amp;amp; , x=0 \\ 1 &amp;amp; , x=1 \\ \left(\frac{1}{x}-1\right) \ln (1-x)+1, &amp;amp; -1 \leq x&amp;lt;1,\text{且} x \neq 0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>eg2：&lt;span class="math inline">\(\sum_{n=0}^{\infty} \frac{(-1)^{n}}{2 n+1} x^{2 n}\)&lt;/span>, 求&lt;span class="math inline">\(S(x)\)&lt;/span> 1）先求收敛域： &lt;span class="math inline">\(\lim _{n \rightarrow \infty}\left|\frac{a_{n+1}}{a_{n}}\right|=1\)&lt;/span> 得收敛半径&lt;span class="math inline">\(R=1\)&lt;/span> 且&lt;span class="math inline">\(x= \pm 1\)&lt;/span>时，&lt;span class="math inline">\(\sum_{n=0}^{\infty} \frac{(-1)^{n}}{2 n+1}\)&lt;/span>收敛（交错级数单调递减，且&lt;span class="math inline">\(\lim_{n\rightarrow \infty} a_n =0\)&lt;/span>，由莱布尼兹审敛法可得此级数收敛） 所以收敛域&lt;span class="math inline">\([-1,1]\)&lt;/span> 2）再求&lt;span class="math inline">\(S(x)\)&lt;/span> 当&lt;span class="math inline">\(x=0\)&lt;/span>时，&lt;span class="math inline">\(S(0) = 1\)&lt;/span> 当&lt;span class="math inline">\(x \neq 0\)&lt;/span>时，(下面步骤中将级数看作几何级数，几何级数收敛于&lt;span class="math inline">\(\frac{a_1}{1-q}\)&lt;/span>,可以方便的转换成和函数的形式) &lt;span class="math inline">\(\begin{aligned} x S(x) &amp;amp;=\sum_{n=0}^{\infty} \frac{(-1)^{n}}{2 n+1} x^{2 n+1} \\ &amp;amp;=\sum_{i=0}^{\infty}(-1)^{n} \cdot \int_{0}^{x} x^{2 n} d x \\ &amp;amp;=\sum_{n=0}^{\infty} \int_{0}^{x}(-1)^{n} x^{n} d x \\ &amp;amp;=\int_{0}^{x}\left(\sum_{n=0}^{\infty}(-1)^{n} x^{2 n}\right) d x \\ &amp;amp;=\int_{0}^{x}\left(\frac{1}{1+x^{2}}\right) d x \\ &amp;amp;=\arctan x \end{aligned}\)&lt;/span> &lt;span class="math inline">\((-1&amp;lt;x^2 \le 1)\)&lt;/span>，即&lt;span class="math inline">\((-1 \le x \le 1)\)&lt;/span>&lt;/p>
&lt;p>所以&lt;span class="math inline">\(S(x) = \frac{\arctan x} {x}, \quad (-1 \le x \le 1)\)&lt;/span> 综上， &lt;span class="math inline">\(S(x)=\left\{\begin{array}{cc}1, &amp;amp; x=0 \\ \frac{a \arctan x}{x}, &amp;amp; -1 \leq x \leq 1 \text { R } x \neq 0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h3 id="幂级数的应用">幂级数的应用&lt;/h3>
&lt;h4 id="指数对数分数次幂正余弦定积分的近似计算">指数、对数、分数次幂、正余弦、定积分的近似计算&lt;/h4>
&lt;h5 id="分数次幂的近似计算">分数次幂的近似计算&lt;/h5>
&lt;p>eg1：计算 &lt;span class="math inline">\(\sqrt[5]{240}\)&lt;/span> 的近似值,要求误差不超过 0.0001.&lt;/p>
&lt;p>&lt;span class="math inline">\(\sqrt[5]{240}=\sqrt[5]{243-3}=3\left(1-\frac{1}{3^{4}}\right)^{1 / 5}\)&lt;/span> 根据二项展开式&lt;span class="math inline">\((1+x)^{m}=1+m x+\frac{m(m-1)}{2 !} x^{2}+\cdots+\frac{m(m-1) \cdots(m-n+1)}{n !} x^{n}+\cdots\)&lt;/span>，收敛域&lt;span class="math inline">\((-1&amp;lt;x&amp;lt;1)\)&lt;/span> 取&lt;span class="math inline">\(m=\frac{1}{5}, x=-\frac{1}{3^{4}},\)&lt;/span> 即得： &lt;span class="math inline">\(\begin{aligned} \sqrt[5]{240}=3 &amp;amp;\left(1-\frac{1}{5} \cdot \frac{1}{3^{4}}-\frac{1 \cdot 4}{5^{2} \cdot 2 !} \cdot \frac{1}{3^{8}}-\frac{1 \cdot 4 \cdot 9}{5^{3} \cdot 3 !} \cdot \frac{1}{3^{12}}-\cdots-\right.\\ &amp;amp;\left.\frac{1 \cdot 4 \cdot 9 \cdot \cdots \cdot(5 n-6)}{5^{n} \cdot n !} \cdot \frac{1}{3^{4 n}}-\cdots\right) \end{aligned}\)&lt;/span> 误差包括舍入误差和截断误差。 计算时保留到小数点后5位，首先保证舍入误差不超过 0.0001 取上式前两项时，截断误差（余项大小）： &lt;span class="math inline">\(\begin{aligned}\left|r_{2}\right| &amp;amp;=3\left(\frac{1 \cdot 4}{5^{2} \cdot 2 !} \cdot \frac{1}{3^{8}}+\frac{1 \cdot 4 \cdot 9}{5^{3} \cdot 3 !} \cdot \frac{1}{3^{12}}+\frac{1 \cdot 4 \cdot 9 \cdot 14}{5^{4} \cdot 4 !} \cdot \frac{1}{3^{16}}+\cdots\right) \\ &amp;amp;&amp;lt;3 \cdot \frac{1 \cdot 4}{5^{2} \cdot 2 !} \cdot \frac{1}{3^{8}}\left[1+\frac{1}{81}+\left(\frac{1}{81}\right)^{2}+\cdots\right] \\ &amp;amp;=\frac{6}{25} \cdot \frac{1}{3^{8}} \cdot \frac{1}{1-\frac{1}{81}}=\frac{1}{25 \cdot 27 \cdot 40}&amp;lt;\frac{1}{20000} \end{aligned}\)&lt;/span> 则取级数前两项时，得： &lt;span class="math inline">\(\sqrt[5]{240} \approx 3\left(1-\frac{1}{5} \cdot \frac{1}{3^{4}}\right) \approx 2.9926\)&lt;/span>&lt;/p>
&lt;h5 id="对数的近似计算">对数的近似计算&lt;/h5>
&lt;p>eg1：计算 ln 2 的近似值,要求误差不超过 0.000 1.&lt;/p>
&lt;p>方法1： 有级数展开式：&lt;span class="math inline">\(ln(1+x)=x-\frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + ... = \Sigma_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n \quad (-1&amp;lt;x \leqslant 1)\)&lt;/span> 假设取前n项作为近似值，由收敛的交错级数性质知，余项（正好是近似计算时的截断误差）： &lt;span class="math inline">\(\left|r_{n}\right| \leqslant \frac{1}{n+1}\)&lt;/span> 需要取前10000项计算才能保证截断误差不超过 0.000 1. 下面找收敛更快的级数做近似计算&lt;/p>
&lt;p>方法2： 级数展开式：&lt;span class="math inline">\(\ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\frac{x^{4}}{4}+\cdots+(-1)^{n-1} \frac{x^{n}}{n}+\cdots \quad(-1&amp;lt;x \leqslant 1)\)&lt;/span> x换为-x，得：&lt;span class="math inline">\(\ln (1-x)=-x-\frac{x^{2}}{2}-\frac{x^{3}}{3}-\frac{x^{4}}{4}-\cdots+(-1)^{n-1} \frac{(-x)^{n}}{n}+\cdots \quad(-1 \leqslant x&amp;lt;1)\)&lt;/span> 两式相减，只含奇数次幂： &lt;span class="math inline">\(\begin{aligned} \ln \frac{1+x}{1-x} &amp;amp;=\ln (1+x)-\ln (1-x) \\&amp;amp;=2\left(x+\frac{1}{3} x^{3}+\frac{1}{5} x^{5}+\cdots+\frac{1}{2 n+1} x^{2 n+1}+\cdots\right)(-1&amp;lt;x&amp;lt;1) \end{aligned}\)&lt;/span> 令 &lt;span class="math inline">\(\frac{1+x}{1-x}=2,\)&lt;/span> 解 出 &lt;span class="math inline">\(x=\frac{1}{3} .\)&lt;/span> 以 &lt;span class="math inline">\(x=\frac{1}{3}\)&lt;/span> 代 入： &lt;span class="math inline">\(\ln 2=2\left(\frac{1}{3}+\frac{1}{3} \cdot \frac{1}{3^{3}}+\frac{1}{5} \cdot \frac{1}{3^{5}}+\frac{1}{7} \cdot \frac{1}{3^{7}}+\cdots+\frac{1}{2 n+1} \cdot \frac{1}{3^{2 n+1}}+\cdots\right)\)&lt;/span> 取前四项，其截断误差（余项）为： &lt;span class="math inline">\(\begin{aligned}\left|r_{4}\right| &amp;amp;=2\left(\frac{1}{9} \cdot \frac{1}{3^{9}}+\frac{1}{11} \cdot \frac{1}{3^{11}}+\frac{1}{13} \cdot \frac{1}{3^{13}}+\cdots+\frac{1}{2 n+1} \cdot \frac{1}{3^{2 n+1}}+\cdots\right) \\ &amp;amp;&amp;lt;\frac{2}{3^{11}}\left[1+\frac{1}{9}+\left(\frac{1}{9}\right)^{2}+\cdots+\left(\frac{1}{9}\right)^{n}+\cdots\right] \\ &amp;amp;=\frac{2}{3^{11}} \cdot \frac{1}{1-\frac{1}{9}}=\frac{1}{4 \cdot 3^{9}}&amp;lt;\frac{1}{70000} \end{aligned}\)&lt;/span> 计算时，取小数点后5位，首先保证舍入误差不超过 0.000 1. 则取级数前四项，得： &lt;span class="math inline">\(\ln 2 \approx 2\left(\frac{1}{3}+\frac{1}{3} \cdot \frac{1}{3^{3}}+\frac{1}{5} \cdot \frac{1}{3^{5}}+\frac{1}{7} \cdot \frac{1}{3^{7}}\right)\approx 0.6931\)&lt;/span>&lt;/p>
&lt;h4 id="微分方程的幂级数解法">微分方程的幂级数解法&lt;/h4>
&lt;h5 id="一阶微分方程的幂级数解法">一阶微分方程的幂级数解法&lt;/h5>
&lt;p>一阶微分方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=f(x, y)\)&lt;/span>，给定初值条件： &lt;span class="math inline">\(\left.y\right|_{x=x_{0}}=y_{0}\)&lt;/span> &lt;strong>如果其中 函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 是 &lt;span class="math inline">\(\left(x-x_{0}\right),\left(y-y_{0}\right)\)&lt;/span> 的多项式&lt;/strong>，即：&lt;span class="math inline">\(f(x, y)=a_{00}+a_{10}\left(x-x_{0}\right)+a_{01}\left(y-y_{0}\right)+\cdots+a_{l m}\left(x-x_{0}\right)^{l}\left(y-y_{0}\right)^{m}\)&lt;/span>， 那么可设所求特解为：&lt;span class="math inline">\(y=y_{0}+a_{1}\left(x-x_{0}\right)+a_{2}\left(x-x_{0}\right)^{2}+\cdots+a_{n}\left(x-x_{0}\right)^{n}+\cdots\)&lt;/span> 可用待定系数法求解其中系数 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{n}, \cdots\)&lt;/span>&lt;/p>
&lt;p>eg1：求方程 &lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=-y-x\)&lt;/span> 满足 &lt;span class="math inline">\(\left.y\right|_{x=0}=2\)&lt;/span> 的特解.&lt;/p>
&lt;p>&lt;span class="math inline">\(x_{0}=0, y_{0}=2\)&lt;/span>，设方程的特解为&lt;span class="math inline">\(y=2+a_{1} x+a_{2} x^{2}+\cdots+a_{n} x^{n}+\cdots\)&lt;/span> 则&lt;span class="math inline">\(y^{\prime}=a_{1}+2 a_{2} x+\cdots+n a_{n} x^{n-1}+\cdots\)&lt;/span> 代入方程得：&lt;span class="math inline">\(a_{1}+2 a_{2} x+\cdots+n a_{n} x^{n-1}+\cdots=-2-\left(a_{1}+1\right) x-a_{2} x^{2}-\cdots-a_{n} x^{n}-\cdots\)&lt;/span> 得&lt;span class="math inline">\(a_{1}=-2,2 a_{2}=-\left(a_{1}+1\right), 3 a_{3}=-a_{2}, \cdots, n a_{n}=-a_{n-1}, \cdots\)&lt;/span> 得&lt;span class="math inline">\(a_{1}=-2\)&lt;/span>，&lt;span class="math inline">\(a_{n}=(-1)^{n} \frac{1}{n !}(n \geqslant 2)\)&lt;/span> 则微分方程得解为： &lt;span class="math inline">\(\begin{aligned} y &amp;amp;=2-2 x+\frac{1}{2 !} x^{2}-\frac{1}{3 !} x^{3}+\cdots+(-1)^{n} \frac{1}{n !} x^{n}+\cdots \\ &amp;amp;=1-x+\left[1-x+\frac{1}{2 !} x^{2}-\frac{1}{3 !} x^{3}+\cdots+(-1)^{n} \frac{1}{n !} x^{n}+\cdots\right] \\ &amp;amp;=1-x+\mathrm{e}^{-x} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="二级齐次线性微分方程的幂级数解法">二级齐次线性微分方程的幂级数解法&lt;/h5>
&lt;p>&lt;strong>定理&lt;/strong>：如果二阶齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>中的系数 &lt;span class="math inline">\(P(x)\)&lt;/span> 与 &lt;span class="math inline">\(Q(x)\)&lt;/span> 可在 &lt;span class="math inline">\(-R&amp;lt;x&amp;lt;R\)&lt;/span> 内展开为 &lt;span class="math inline">\(x\)&lt;/span>的幂级数, 那么在 - &lt;span class="math inline">\(R&amp;lt;x&amp;lt;R\)&lt;/span> 内此方程必有形如&lt;span class="math inline">\(y=\sum_{n=0}^{\infty} a_{n} x^{n}\)&lt;/span>的解。&lt;/p>
&lt;h4 id="欧拉公式的证明">欧拉公式的证明&lt;/h4>
&lt;p>考察&lt;a href="#复数项级数定义">复数项级数&lt;/a>&lt;span class="math inline">\(1+z+\frac{1}{2 !} z^{2}+\cdots+\frac{1}{n !} z^{n}+\cdots \quad(z=x+y i)\)&lt;/span>， 可以证明这个复数项级数在整个复平面上是收敛的。 我们可以定义整个复平面上的复变量指数函数&lt;span class="math inline">\(\mathrm{e}^{z}=1+z+\frac{1}{2 !} z^{2}+\cdots+\frac{1}{n !} z^{n}+\cdots \quad(|z|&amp;lt;\infty)\)&lt;/span> 当 &lt;span class="math inline">\(x=0\)&lt;/span> 时, &lt;span class="math inline">\(z\)&lt;/span> 为纯虚数 &lt;span class="math inline">\(y \mathbf{i},\)&lt;/span> 有： &lt;span class="math inline">\(\begin{aligned} \mathrm{e}^{y_{i}} &amp;amp;=1+y \mathrm{i}+\frac{1}{2 !}(y \mathrm{i})^{2}+\frac{1}{3 !}(y \mathrm{i})^{3}+\cdots+\frac{1}{n !}(y \mathrm{i})^{n}+\cdots \\ &amp;amp;=1+y \mathrm{i}-\frac{1}{2 !} y^{2}-\frac{1}{3 !} y^{3} \mathrm{i}+\frac{1}{4 !} y^{4}+\frac{1}{5 !} y^{5} \mathrm{i}-\cdots \\ &amp;amp;=\left(1-\frac{1}{2 !} y^{2}+\frac{1}{4 !} y^{4}-\cdots\right)+\left(y-\frac{1}{3 !} y^{3}+\frac{1}{5 !} y^{5}-\cdots\right) \mathrm{i} \\ &amp;amp;=\cos y+\mathrm{i} \sin y \end{aligned}\)&lt;/span> 把 y 换写为 x,上式变为&lt;span class="math inline">\(e^{x i}=\cos x+i \sin x\)&lt;/span>，称为&lt;strong>欧拉公式&lt;/strong>&lt;/p>
&lt;h2 id="函数项级数三角级数">函数项级数：三角级数&lt;/h2>
&lt;p>前面我们讨论了幂级数（以幂函数为项的级数）的概念、性质、函数展开成幂级数的条件与方法、求幂级数的收敛域以及和函数的方法。 类似的，我们想要讨论以三角函数系为各项组成的级数：三角级数&lt;span class="math inline">\(\sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="三角级数的定义">三角级数的定义&lt;/h3>
&lt;p>&lt;span class="math inline">\(A_{1} \sin \left(\omega t+\varphi_{1}\right)+A_{2} \sin \left(2 \omega t+\varphi_{2}\right)+...+A_{n} \sin \left(n \omega t+\varphi_{n}\right)+...\)&lt;/span> 即：&lt;span class="math inline">\(\sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span> 习惯上会加个常数：&lt;span class="math inline">\(A_0 + \sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span> 通过三角函数的积化和差公式，并取&lt;span class="math inline">\(2l = \frac{2\pi}{\omega}\)&lt;/span>可以变形为：&lt;span class="math inline">\(\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos \frac{n \pi t}{l}+b_{n} \sin \frac{n \pi t}{l}\right)\)&lt;/span> 再做变量代换&lt;span class="math inline">\(\frac{\pi t}{l}=x\)&lt;/span>得三角级数&lt;strong>标准形式&lt;/strong>：&lt;span class="math inline">\(\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos n x+b_{n} \sin n x\right)\)&lt;/span>&lt;/p>
&lt;p>设三角级数&lt;span class="math inline">\(A_0 + \sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span>收敛于&lt;span class="math inline">\(f(t)\)&lt;/span>，即&lt;span class="math inline">\(f(t)=A_0 + \sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span>。可以看出此三角级数是由一些周期为&lt;span class="math inline">\(T_n = \frac{2 \pi}{n \omega}\)&lt;/span>的正弦函数和常数&lt;span class="math inline">\(A_0\)&lt;/span>的叠加，则&lt;span class="math inline">\(f(t)\)&lt;/span>是一个&lt;strong>周期为&lt;span class="math inline">\(T = \frac{2 \pi}{\omega}\)&lt;/span>的周期函数&lt;/strong>。 类似的，设三角级数&lt;span class="math inline">\(\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos n x+b_{n} \sin n x\right)\)&lt;/span>收敛于&lt;span class="math inline">\(f(x)\)&lt;/span>，即&lt;span class="math inline">\(f(x)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos n x+b_{n} \sin n x\right)\)&lt;/span>。可以看出此三角级数是一个&lt;strong>周期&lt;span class="math inline">\(T=2 \pi\)&lt;/span>的周期函数&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>电工学&lt;/strong>谐波分析中，对于&lt;span class="math inline">\(f(t)=A_0 + \sum_{n=1}^{\infty} A_{n} \sin \left(n \omega t+\varphi_{n}\right)\)&lt;/span>， 常数项 &lt;span class="math inline">\(A_0\)&lt;/span>称为 &lt;span class="math inline">\(f(t)\)&lt;/span> 的&lt;strong>直流分量&lt;/strong>, &lt;span class="math inline">\(A_{1} \sin \left(\omega t+\varphi_{1}\right)\)&lt;/span> 称为&lt;strong>一次谐波（或称基波）&lt;/strong>， &lt;span class="math inline">\(A_{2} \sin \left(2 \omega t+\varphi_{2}\right), A_{3} \sin \left(3 \omega t+\varphi_{3}\right), \cdots\)&lt;/span> 依次称为&lt;strong>二次谐波&lt;/strong>,&lt;strong>三次谐波&lt;/strong>，等等。&lt;/p>
&lt;h3 id="三角函数系的正交性">三角函数系的正交性&lt;/h3>
&lt;p>三角函数系&lt;span class="math inline">\(1, \cos x, \sin x, \cos 2 x, \sin 2 x, \cdots, \cos n x, \sin n x, \cdots\)&lt;/span>在区间&lt;span class="math inline">\([ -\pi , \pi ]\)&lt;/span> 上&lt;strong>正交&lt;/strong>，是指&lt;strong>三角函数系中任意两个函数的乘积在区间&lt;span class="math inline">\([ -\pi , \pi ]\)&lt;/span> 上的积分等于0.&lt;/strong>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{-\pi}^{\pi} \cos n x \mathrm{d} x=0 \quad(n=1,2,3, \cdots)\)&lt;/span> &lt;span class="math inline">\(\int_{-\pi}^{\pi} \sin n x \mathrm{d} x=0 \quad(n=1,2,3, \cdots)\)&lt;/span> &lt;span class="math inline">\(\int_{-\pi}^{\pi} \sin k x \cos n x \mathrm{d} x=0 \quad(k, n=1,2,3, \cdots)\)&lt;/span> &lt;span class="math inline">\(\int_{-\pi}^{\pi} \cos k x \cos n x \mathrm{d} x=0 \quad(k, n=1,2,3, \cdots, k \neq n)\)&lt;/span> &lt;span class="math inline">\(\int_{-\pi}^{\pi} \sin k x \sin n x \mathrm{d} x=0 \quad(k, n=1,2,3, \cdots, k \neq n)\)&lt;/span>&lt;/p>
&lt;p>(用奇偶性对称性、三角函数的积化和差公式可证如上几个公式)&lt;/p>
&lt;p>而三角函数系中，&lt;strong>两个相同函数的乘积在区间 &lt;span class="math inline">\([ - \pi , \pi ]\)&lt;/span> 上的积分不等于0&lt;/strong>。&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{-\pi}^{\pi} 1^{2} \mathrm{d} x=2 \pi, \int_{-\pi}^{\pi} \sin ^{2} n x \mathrm{d} x=\pi, \int_{-\pi}^{\pi} \cos ^{2} n x \mathrm{d} x=\pi \quad(n=1,2,3, \cdots)\)&lt;/span>&lt;/p>
&lt;h3 id="pi周期的傅里叶级数">&lt;span class="math inline">\(2\pi\)&lt;/span>周期的傅里叶级数&lt;/h3>
&lt;h4 id="确定三角级数系数的方法">确定三角级数系数的方法&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(f(x)\)&lt;/span> 是周期为 2 &lt;span class="math inline">\(\pi\)&lt;/span> 的周期函数,且能展开成三角级数&lt;span class="math inline">\(f(x)=\frac{a_{0}}{2}+\sum_{k=1}^{\infty}\left(a_{k} \cos k x+b_{k} \sin k x\right)\)&lt;/span>&lt;/p>
&lt;p>利用三角函数系的正交性，如果级数逐项可积， 对原式两边取&lt;span class="math inline">\([-\pi,\pi]\)&lt;/span>的定积分，移项可得&lt;span class="math inline">\(a_{0}=\frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \mathrm{d} x\)&lt;/span>； 原式两边用乘以&lt;span class="math inline">\(\cos n x\)&lt;/span>，然后取取&lt;span class="math inline">\([-\pi,\pi]\)&lt;/span>的定积分，移项可得&lt;span class="math inline">\(a_{n}=\frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \cos n x \mathrm{d} x \quad(n=1,2,3, \cdots)\)&lt;/span> 原式两边用乘以&lt;span class="math inline">\(\sin n x\)&lt;/span>，然后取取&lt;span class="math inline">\([-\pi,\pi]\)&lt;/span>的定积分，移项可得&lt;span class="math inline">\(b_{n}=\frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \sin n x \mathrm{d} x \quad(n=1,2,3, \cdots)\)&lt;/span> 即可定出所有系数&lt;span class="math inline">\(a_{0}, a_{1}, b_{1}, \cdots\)&lt;/span>&lt;/p>
&lt;h4 id="pi周期的傅里叶级数定义">&lt;span class="math inline">\(2\pi\)&lt;/span>周期的傅里叶级数定义&lt;/h4>
&lt;p>如果三角级数&lt;span class="math inline">\(f(x)=\frac{a_{0}}{2}+\sum_{k=1}^{\infty}\left(a_{k} \cos k x+b_{k} \sin k x\right)\)&lt;/span>逐项可积，可以用上面的公式定出所有的系数： &lt;span class="math inline">\(\left.\begin{array}{ll}a_{n}=\frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \cos n x \mathrm{d} x &amp;amp; (n=0,1,2,3, \cdots) \\ b_{n}=\frac{1}{\pi} \int_{-\pi}^{\pi} f(x) \sin n x \mathrm{d} x &amp;amp;(n=1,2,3, \cdots)\end{array}\right\}\)&lt;/span> 称三角级数&lt;span class="math inline">\(\frac{a_{0}}{2}+\sum_{k=1}^{\infty}\left(a_{k} \cos k x+b_{k} \sin k x\right)\)&lt;/span>为&lt;span class="math inline">\(f(x)\)&lt;/span>的傅里叶级数。&lt;/p>
&lt;h4 id="函数展成傅里叶级数的充分条件">函数展成傅里叶级数的充分条件&lt;/h4>
&lt;p>&lt;strong>定理&lt;/strong>(收敛定理, 狄利克雷( Dirichlet) 充分条件 )设 &lt;span class="math inline">\(f(x)\)&lt;/span> 是周期为 2 &lt;span class="math inline">\(\pi\)&lt;/span> 的周期函数,如果它满足： 1）在一个周期内连续或只有有限个第一类间断点， 2）在一个周期内至多只有有限个极值点， 那么 &lt;span class="math inline">\(f(x)\)&lt;/span> 的傅里叶级数收敛,并且： 当 &lt;span class="math inline">\(x\)&lt;/span> 是 &lt;span class="math inline">\(f(x)\)&lt;/span> 的连续点时,级数收敛于 &lt;span class="math inline">\(f(x)\)&lt;/span>; 当 &lt;span class="math inline">\(x\)&lt;/span> 是 &lt;span class="math inline">\(f(x)\)&lt;/span> 的间断点时,级数收敛于 &lt;span class="math inline">\(\frac{1}{2}\left[f\left(x^{-}\right)+f\left(x^{+}\right)\right] .\)&lt;/span>&lt;/p>
&lt;p>（即：只要函数在&lt;span class="math inline">\([ - \pi，\pi ]\)&lt;/span>上至多有有限个第一类间断点,并 且不作无限次振动,函数的傅里叶级数在连续点处就收敛于该点的函数值,在间断点处收敛于该点左极限与右极限的算术平均值. ）&lt;/p>
&lt;p>可见,函数展开成傅里叶级数的条件比&lt;a href="#函数展开成幂级数">展开成幂级数的条件&lt;/a>低得多。&lt;/p>
&lt;h3 id="函数的延拓">函数的延拓&lt;/h3>
&lt;h4 id="周期延拓">周期延拓&lt;/h4>
&lt;p>如果函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 只在 [ - $, ]$ 上有定义,并且满足收敛定理的条外补充函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 的定义,使它拓广成周期为 2 &lt;span class="math inline">\(\pi\)&lt;/span> 的周期函数 F( x). 按这种方式 拓广函数的定义域的过程称为&lt;strong>周期延拓&lt;/strong>.再将 F( x)展开成傅里叶级数. 最后限制 &lt;span class="math inline">\(x\)&lt;/span> 在( &lt;span class="math inline">\(-\pi, \pi)\)&lt;/span> 内,此时 &lt;span class="math inline">\(F(x) \equiv f(x),\)&lt;/span> 这样便得到 &lt;span class="math inline">\(f(x)\)&lt;/span> 的傅里叶级数展开式. 根 据收剑定理,这级数在区间端点 &lt;span class="math inline">\(x=\pm \pi\)&lt;/span> 处收竣于 &lt;span class="math inline">\(\frac{f\left(\pi^{-}\right)+f\left(-\pi^{+}\right)}{2}\)&lt;/span>&lt;/p>
&lt;h4 id="奇延拓或偶延拓">奇延拓或偶延拓&lt;/h4>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span>定义在区间&lt;span class="math inline">\([0, \pi ]\)&lt;/span>上并且满足收敛定理的条件, 我们在开区间&lt;span class="math inline">\(( - \pi ,0 )\)&lt;/span> 内补充函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 的定义, 得到定义在&lt;span class="math inline">\(( - \pi, \pi]\)&lt;/span> 上的函数 &lt;span class="math inline">\(F(x),\)&lt;/span> 使它在 &lt;span class="math inline">\((-\pi, \pi)\)&lt;/span> 上成为 奇函数(偶函数). 按这种方式拓广函数定义域的过程称为&lt;strong>奇延拓(偶延拓)&lt;/strong>。 然后将奇延拓(偶延拓)后的函数展开成傅里叶级数,这个级数必定是正弦级数余弦级数）. 再限制 &lt;span class="math inline">\(x\)&lt;/span> 在 &lt;span class="math inline">\((0, \pi]\)&lt;/span> 上,此时 &lt;span class="math inline">\(F(x) \equiv f(x),\)&lt;/span> 这样便得到 &lt;span class="math inline">\(f(x)\)&lt;/span> 的正弦级 数(余弦级数)展开式.&lt;/p>
&lt;h3 id="正弦级数和余弦级数">正弦级数和余弦级数&lt;/h3>
&lt;p>些函数的傅里叶级数只含有正弦项，这样的级数称为正弦级数。或者只含有常数项和余弦项，这样的级数称为余弦级数。&lt;/p>
&lt;p>当 &lt;span class="math inline">\(f(x)\)&lt;/span> 为奇函数时 &lt;span class="math inline">\(f(x) \cos n x\)&lt;/span> 是奇函数 &lt;span class="math inline">\(, f(x) \sin n x\)&lt;/span> 是偶函数,故: &lt;span class="math inline">\(\left.\begin{array}{l}a_{n}=0 \quad(n=0,1,2, \cdots) \\ b_{n}=\frac{2}{\pi} \int_{0}^{\pi} f(x) \sin n x \mathrm{d} x \quad(n=1,2,3, \cdots)\end{array}\right\}\)&lt;/span> 即知奇函数的傅里叶级数是只含有正弦项的&lt;strong>正弦级数&lt;span class="math inline">\(\sum_{n=1}^{\infty} b_{n} \sin n x\)&lt;/span>&lt;/strong>&lt;/p>
&lt;p>当 &lt;span class="math inline">\(f(x)\)&lt;/span> 为偶函数时 &lt;span class="math inline">\(, f(x) \cos n x\)&lt;/span> 是偶函数 &lt;span class="math inline">\(, f(x) \sin n x\)&lt;/span> 是奇函数,故: &lt;span class="math inline">\(\left.\begin{array}{l}a_{n}=\frac{2}{\pi} \int_{0}^{\pi} f(x) \cos n x \mathrm{d} x \quad(n=0,1,2, \cdots), \\ b_{n}=0 \quad(n=1,2,3, \cdots)\end{array}\right\}\)&lt;/span> 即知偶函数的傅里叶级数是只含常数项和余弦项的&lt;strong>余弦级数&lt;/strong>&lt;span class="math inline">\(\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos n x\)&lt;/span>&lt;/p>
&lt;h3 id="一般周期的傅里叶级数">一般周期的傅里叶级数&lt;/h3>
&lt;p>&lt;span class="math inline">\(2\pi\)&lt;/span>周期的傅里叶级数可以很容易推广到一般周期（设周期为&lt;span class="math inline">\(T= 2l\)&lt;/span>）：&lt;/p>
&lt;p>&lt;strong>定理&lt;/strong> 设周期为 2l 的周期函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 满足收敛定理的条件,则它的傅里叶级 数展开式为&lt;span class="math inline">\(f(x)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty}\left(a_{n} \cos \frac{n \pi x}{l}+b_{n} \sin \frac{n \pi x}{l}\right)(x \in C)\)&lt;/span>，其中： &lt;span class="math inline">\(\begin{aligned} a_{n} &amp;amp;=\frac{1}{l} \int_{-1}^{1} f(x) \cos \frac{n \pi x}{l} \mathrm{d} x \quad(n=0,1,2, \cdots) \\ b_{n} &amp;amp;=\frac{1}{l} \int_{-1}^{1} f(x) \sin \frac{n \pi x}{l} \mathrm{d} x \quad(n=1,2,3, \cdots) \\ C &amp;amp;=\left\{x \mid f(x)=\frac{1}{2}\left[f\left(x^{-}\right)+f\left(x^{+}\right)\right]\right\} \end{aligned}\)&lt;/span> 当 &lt;span class="math inline">\(f(x)\)&lt;/span> 为奇函数时，&lt;span class="math inline">\(f(x)=\sum_{n=1}^{\infty} b_{n} \sin \frac{n \pi x}{l} \quad(x \in C)\)&lt;/span>，其中&lt;span class="math inline">\(b_{n}=\frac{2}{l} \int_{0}^{l} f(x) \sin \frac{n \pi x}{l} \mathrm{d} x \quad(n=1,2,3, \cdots)\)&lt;/span> 当 &lt;span class="math inline">\(f(x)\)&lt;/span> 为偶函数时，&lt;span class="math inline">\(f(x)=\frac{a_{0}}{2}+\sum_{n=1}^{\infty} a_{n} \cos \frac{n \pi x}{l}(x \in C)\)&lt;/span>，其中&lt;span class="math inline">\(a_{n}=\frac{2}{l} \int_{0}^{l} f(x) \cos \frac{n \pi x}{l} \mathrm{d} x \quad(n=0,1,2, \cdots)\)&lt;/span>&lt;/p>
&lt;h3 id="傅里叶级数的复数形式">傅里叶级数的复数形式&lt;/h3>
&lt;p>利用欧拉公式的如下形式：&lt;span class="math inline">\(\cos t=\frac{\mathrm{e}^{t \mathrm{i}}+\mathrm{e}^{-t_{i}}}{2}, \sin t=\frac{\mathrm{e}^{t\mathrm{i}}-\mathrm{e}^{-t\mathrm{i}}}{2 \mathrm{i}}\)&lt;/span> 可将一般一般周期（设周期为&lt;span class="math inline">\(T= 2l\)&lt;/span>）的傅里叶级数华化为更简洁的复数形式：&lt;span class="math inline">\(\sum_{n=-\infty}^{\infty} c_{n} e^{\frac{n \pi x}{l} i}\)&lt;/span> 其中&lt;span class="math inline">\(c_{n}=\frac{1}{2 l} \int_{-l}^{l} f(x) \mathrm{e}^{-\frac{n \pi x}{l} \mathrm{i}} \mathrm{d} x \quad(n=0,\pm 1,\pm 2, \cdots)\)&lt;/span>&lt;/p>
&lt;p>（推导过程详见高数同济第七版（下））&lt;/p>
&lt;h2 id="复数项级数">复数项级数&lt;/h2>
&lt;h4 id="复数项级数定义">复数项级数定义&lt;/h4>
&lt;p>&lt;span class="math inline">\(\left(u_{1}+v_{1} \mathrm{i}\right)+\left(u_{2}+v_{2} \mathrm{i}\right)+\cdots+\left(u_{n}+v_{n} \mathrm{i}\right)+\cdots\)&lt;/span>，其中&lt;span class="math inline">\(u_{n}\)&lt;/span> 与 &lt;span class="math inline">\(v_{n}(n=1,2,3, \cdots)\)&lt;/span> 为实常数或实函数，这样的级数称为复数项级数。&lt;/p>
&lt;h4 id="复数项级数收敛定义">复数项级数收敛定义&lt;/h4>
&lt;p>如果实部所成级数&lt;span class="math inline">\(u_{1}+u_{2}+\cdots+u_{n}+\cdots\)&lt;/span>收敛于和u，虚部所成级数&lt;span class="math inline">\(v_{1}+v_{2}+\cdots+v_{n}+\cdots\)&lt;/span>收敛于和v，则称复数项级数&lt;span class="math inline">\(\left(u_{1}+v_{1} \mathrm{i}\right)+\left(u_{2}+v_{2} \mathrm{i}\right)+\cdots+\left(u_{n}+v_{n} \mathrm{i}\right)+\cdots\)&lt;/span>收敛，且其和为&lt;span class="math inline">\(u+v i\)&lt;/span>&lt;/p>
&lt;h4 id="复数项级数绝对收敛定义">复数项级数绝对收敛定义&lt;/h4>
&lt;p>如果复数项级数各项的模成的级数&lt;span class="math inline">\(\sqrt{u_{1}^{2}+v_{1}^{2}}+\sqrt{u_{2}^{2}+v_{2}^{2}}+\cdots+\sqrt{u_{n}^{2}+v_{n}^{2}}+\cdots\)&lt;/span>收敛，称复数项级数绝对收敛。&lt;/p></description></item><item><title>高等数学-级数习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-级数习题">高等数学-级数习题&lt;/h1>
&lt;h2 id="级数审敛">级数审敛&lt;/h2>
&lt;h3 id="级数收敛定义与性质判敛">级数收敛定义与性质判敛&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823001536092.png" alt="" />&lt;figcaption>image-20200823001536092&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823001546204.png" alt="" />&lt;figcaption>image-20200823001546204&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823083227207.png" alt="" />&lt;figcaption>image-20200823083227207&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823083238321.png" alt="" />&lt;figcaption>image-20200823083238321&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823084522441.png" alt="" />&lt;figcaption>image-20200823084522441&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823084539210.png" alt="" />&lt;figcaption>image-20200823084539210&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823094409497.png" alt="" />&lt;figcaption>image-20200823094409497&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823094439081.png" alt="" />&lt;figcaption>image-20200823094439081&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823112128319.png" alt="" />&lt;figcaption>image-20200823112128319&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823112143018.png" alt="" />&lt;figcaption>image-20200823112143018&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823131153930.png" alt="" />&lt;figcaption>image-20200823131153930&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823131210561.png" alt="" />&lt;figcaption>image-20200823131210561&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823131232305.png" alt="" />&lt;figcaption>image-20200823131232305&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823131245506.png" alt="" />&lt;figcaption>image-20200823131245506&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823184049122.png" alt="" />&lt;figcaption>image-20200823184049122&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823184112259.png" alt="" />&lt;figcaption>image-20200823184112259&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824095539210.png" alt="" />&lt;figcaption>image-20200824095539210&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824095600695.png" alt="" />&lt;figcaption>image-20200824095600695&lt;/figcaption>
&lt;/figure>
&lt;h3 id="正项级数审敛">正项级数审敛&lt;/h3>
&lt;h4 id="比较审敛与极限审敛">比较审敛与极限审敛&lt;/h4>
&lt;h5 id="比较审敛法的一般形式以及基本不等式的应用">比较审敛法的一般形式，以及基本不等式的应用&lt;/h5>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823000329492.png" alt="" />&lt;figcaption>image-20200823000329492&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823000343399.png" alt="" />&lt;figcaption>image-20200823000343399&lt;/figcaption>
&lt;/figure>
&lt;p>（主要是根据不等式：&lt;span class="math inline">\(a+b \ge 2\sqrt{ab}\)&lt;/span>）&lt;/p>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823133606542.png" alt="" />&lt;figcaption>image-20200823133606542&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823133631406.png" alt="" />&lt;figcaption>image-20200823133631406&lt;/figcaption>
&lt;/figure>
&lt;p>（A选项主要根据基本不等式：&lt;span class="math inline">\(\left(\frac{a + b}{2}\right)^2 \le \frac{a^2+b^2}{2}\)&lt;/span>以及&lt;span class="math inline">\(\left(\frac{a - b}{2}\right)^2 \le \frac{a^2+b^2}{2}\)&lt;/span>）&lt;/p>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823140519524.png" alt="" />&lt;figcaption>image-20200823140519524&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823140539865.png" alt="" />&lt;figcaption>image-20200823140539865&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823141909638.png" alt="" />&lt;figcaption>image-20200823141909638&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823141952116.png" alt="" />&lt;figcaption>image-20200823141952116&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823171240621.png" alt="" />&lt;figcaption>image-20200823171240621&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823171256026.png" alt="" />&lt;figcaption>image-20200823171256026&lt;/figcaption>
&lt;/figure>
&lt;p>（此题也可以用比值审敛法做）&lt;/p>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824013838791.png" alt="" />&lt;figcaption>image-20200824013838791&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824013906145.png" alt="" />&lt;figcaption>image-20200824013906145&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824014323257.png" alt="" />&lt;figcaption>image-20200824014323257&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824014339935.png" alt="" />&lt;figcaption>image-20200824014339935&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824020725796.png" alt="" />&lt;figcaption>image-20200824020725796&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824020745505.png" alt="" />&lt;figcaption>image-20200824020745505&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824020805616.png" alt="" />&lt;figcaption>image-20200824020805616&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824100519961.png" alt="" />&lt;figcaption>image-20200824100519961&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824100554568.png" alt="" />&lt;figcaption>image-20200824100554568&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151455246.png" alt="" />&lt;figcaption>image-20200824151455246&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151512237.png" alt="" />&lt;figcaption>image-20200824151512237&lt;/figcaption>
&lt;/figure>
&lt;h5 id="极限审敛法比较审敛法的极限形式以及等价同阶高阶无穷小的应用">极限审敛法/比较审敛法的极限形式，以及等价/同阶/高阶无穷小的应用&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821162144108.png" alt="" />&lt;figcaption>image-20200821162144108&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821162135598.png" alt="" />&lt;figcaption>image-20200821162135598&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823084144710.png" alt="" />&lt;figcaption>image-20200823084144710&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823084158677.png" alt="" />&lt;figcaption>image-20200823084158677&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823090229595.png" alt="" />&lt;figcaption>image-20200823090229595&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823090245286.png" alt="" />&lt;figcaption>image-20200823090245286&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/960a304e251f95ca9090cee4c7177f3e6709527e" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823101220390.png" alt="" />&lt;figcaption>image-20200823101220390&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823101257075.png" alt="" />&lt;figcaption>image-20200823101257075&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823105630113.png" alt="" />&lt;figcaption>image-20200823105630113&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823105644207.png" alt="" />&lt;figcaption>image-20200823105644207&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823154857570.png" alt="" />&lt;figcaption>image-20200823154857570&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823154920128.png" alt="" />&lt;figcaption>image-20200823154920128&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823154936051.png" alt="" />&lt;figcaption>image-20200823154936051&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823160432308.png" alt="" />&lt;figcaption>image-20200823160432308&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823160412500.png" alt="" />&lt;figcaption>image-20200823160412500&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823170523768.png" alt="" />&lt;figcaption>image-20200823170523768&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823170536654.png" alt="" />&lt;figcaption>image-20200823170536654&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823192511608.png" alt="" />&lt;figcaption>image-20200823192511608&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823192552941.png" alt="" />&lt;figcaption>image-20200823192552941&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823201017986.png" alt="" />&lt;figcaption>image-20200823201017986&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823201040388.png" alt="" />&lt;figcaption>image-20200823201040388&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823222143991.png" alt="" />&lt;figcaption>image-20200823222143991&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823222126237.png" alt="" />&lt;figcaption>image-20200823222126237&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-此题需要功底">例12 此题需要功底&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824005246931.png" alt="" />&lt;figcaption>image-20200824005246931&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824005318606.png" alt="" />&lt;figcaption>image-20200824005318606&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-此题需要功底">例13 此题需要功底&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824011332421.png" alt="" />&lt;figcaption>image-20200824011332421&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824011348233.png" alt="" />&lt;figcaption>image-20200824011348233&lt;/figcaption>
&lt;/figure>
&lt;h4 id="比值审敛法">比值审敛法&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823200329359.png" alt="" />&lt;figcaption>image-20200823200329359&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823200348610.png" alt="" />&lt;figcaption>image-20200823200348610&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823202134338.png" alt="" />&lt;figcaption>image-20200823202134338&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823202149853.png" alt="" />&lt;figcaption>image-20200823202149853&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根值审敛法">根值审敛法&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823202415654.png" alt="" />&lt;figcaption>image-20200823202415654&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823202439153.png" alt="" />&lt;figcaption>image-20200823202439153&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823205615419.png" alt="" />&lt;figcaption>image-20200823205615419&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823205640172.png" alt="" />&lt;figcaption>image-20200823205640172&lt;/figcaption>
&lt;/figure>
&lt;h3 id="交错级数审敛">交错级数审敛&lt;/h3>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821163757471.png" alt="" />&lt;figcaption>image-20200821163757471&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821163811654.png" alt="" />&lt;figcaption>image-20200821163811654&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824005246931.png" alt="" />&lt;figcaption>image-20200824005246931&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824005318606.png" alt="" />&lt;figcaption>image-20200824005318606&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824014832346.png" alt="" />&lt;figcaption>image-20200824014832346&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824014849030.png" alt="" />&lt;figcaption>image-20200824014849030&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824101438792.png" alt="" />&lt;figcaption>image-20200824101438792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824101424133.png" alt="" />&lt;figcaption>image-20200824101424133&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求级数收敛范围">求级数收敛范围&lt;/h2>
&lt;h3 id="求p级数收敛范围">求p级数收敛范围&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820200206138.png" alt="" />&lt;figcaption>image-20200820200206138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820200242190.png" alt="" />&lt;figcaption>image-20200820200242190&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求幂级数的收敛域">求幂级数的收敛域&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821145837429.png" alt="" />&lt;figcaption>image-20200821145837429&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821145856106.png" alt="" />&lt;figcaption>image-20200821145856106&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821150153480.png" alt="" />&lt;figcaption>image-20200821150153480&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821150135645.png" alt="" />&lt;figcaption>image-20200821150135645&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822101616463.png" alt="" />&lt;figcaption>image-20200822101616463&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822101600998.png" alt="" />&lt;figcaption>image-20200822101600998&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822105302759.png" alt="" />&lt;figcaption>image-20200822105302759&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822105335291.png" alt="" />&lt;figcaption>image-20200822105335291&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823171857701.png" alt="" />&lt;figcaption>image-20200823171857701&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823171909159.png" alt="" />&lt;figcaption>image-20200823171909159&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823172127849.png" alt="" />&lt;figcaption>image-20200823172127849&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823172142161.png" alt="" />&lt;figcaption>image-20200823172142161&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823173028140.png" alt="" />&lt;figcaption>image-20200823173028140&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823173046986.png" alt="" />&lt;figcaption>image-20200823173046986&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151818149.png" alt="" />&lt;figcaption>image-20200824151818149&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151840693.png" alt="" />&lt;figcaption>image-20200824151840693&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151900452.png" alt="" />&lt;figcaption>image-20200824151900452&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824151928803.png" alt="" />&lt;figcaption>image-20200824151928803&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824152154281.png" alt="" />&lt;figcaption>image-20200824152154281&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824152210162.png" alt="" />&lt;figcaption>image-20200824152210162&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824152333761.png" alt="" />&lt;figcaption>image-20200824152333761&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824152414073.png" alt="" />&lt;figcaption>image-20200824152414073&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求级数的和函数或和">求级数的和函数或和&lt;/h2>
&lt;h3 id="根据级数收敛的定义求级数的和">根据级数收敛的定义，求级数的和&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820140722254.png" alt="" />&lt;figcaption>image-20200820140722254&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820140705132.png" alt="" />&lt;figcaption>image-20200820140705132&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821225106935.png" alt="" />&lt;figcaption>image-20200821225106935&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821225124368.png" alt="" />&lt;figcaption>image-20200821225124368&lt;/figcaption>
&lt;/figure>
&lt;h3 id="幂级数求和函数">幂级数求和函数&lt;/h3>
&lt;p>幂级数求和函数之前，要先确定收敛域。&lt;/p>
&lt;p>常见函数的麦克劳林级数：&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 15%" />
&lt;col style="width: 63%" />
&lt;col style="width: 20%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>函数&lt;/th>
&lt;th>展开成麦克劳林级数（在&lt;span class="math inline">\(x_0=0\)&lt;/span>附近展开成级数）&lt;/th>
&lt;th>收敛域&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(e^x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+x+ \frac{x^2}{2!} + ... + \frac{x^n}{n!} + ..\\ = \Sigma_{n=0}^{\infty} \frac{x^n}{n!}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\sin x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(= x - \frac{x^3}{3!} + \frac{x^5}{5!} - \frac{x^7}{7!} +...\\ = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{(2n+1)!} x^{2n+1}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\cos x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1 - \frac{x^2}{2!} + \frac{x^4}{4!} - \frac{x^6}{6!} + ... \\ = \Sigma_{n=0}^{\infty} \frac{(-1)^n}{(2n)!} x^{2n}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\infty&amp;lt;x&amp;lt;+\infty\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\frac{1}{1-x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+x+x^2+x^3+... \\ = \Sigma_{n=0}^{\infty} x^n\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\frac{1}{1+x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(= \Sigma_{n=0}^{\infty} (-1)^n x^n\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(ln(1+x)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=x-\frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + ... \\ = \Sigma_{n=1}^{\infty} \frac{(-1)^{n-1}}{n} x^n\)&lt;/span>&lt;br />注意这个级数从n=1开始&lt;/td>
&lt;td>&lt;span class="math inline">\(-1&amp;lt;x \le 1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(-ln(1-x)\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=x + \frac{x^2}{2} + \frac{x^3}{3} + \frac{x^4}{4} + ... \\ = \Sigma_{n=1}^{\infty} \frac{x^n}{n}\)&lt;/span>&lt;br />注意这个级数从n=1开始&lt;/td>
&lt;td>&lt;span class="math inline">\(-1 \le x&amp;lt;1\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\((1+x)^{m}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(=1+m x+\frac{m(m-1)}{2 !} x^{2}+\cdots+\frac{m(m-1) \cdots(m-n+1)}{n !} x^{n}+\cdots\)&lt;/span>&lt;br />这个展开叫做&lt;strong>二项展开式&lt;/strong>，也是代数学中的二项展开定理&lt;/td>
&lt;td>&lt;span class="math inline">\((-1&amp;lt;x&amp;lt;1)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821121132861.png" alt="" />&lt;figcaption>image-20200821121132861&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821121147153.png" alt="" />&lt;figcaption>image-20200821121147153&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821133740958.png" alt="" />&lt;figcaption>image-20200821133740958&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821133752212.png" alt="" />&lt;figcaption>image-20200821133752212&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821171811348.png" alt="" />&lt;figcaption>image-20200821171811348&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821171823157.png" alt="" />&lt;figcaption>image-20200821171823157&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821174512439.png" alt="" />&lt;figcaption>image-20200821174512439&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821174526081.png" alt="" />&lt;figcaption>image-20200821174526081&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821174542949.png" alt="" />&lt;figcaption>image-20200821174542949&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821184357935.png" alt="" />&lt;figcaption>image-20200821184357935&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821184342463.png" alt="" />&lt;figcaption>image-20200821184342463&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821222554910.png" alt="" />&lt;figcaption>image-20200821222554910&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821222611302.png" alt="" />&lt;figcaption>image-20200821222611302&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821222628291.png" alt="" />&lt;figcaption>image-20200821222628291&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-4">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821231836255.png" alt="" />&lt;figcaption>image-20200821231836255&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821231856996.png" alt="" />&lt;figcaption>image-20200821231856996&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-3">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822095223496.png" alt="" />&lt;figcaption>image-20200822095223496&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822095242006.png" alt="" />&lt;figcaption>image-20200822095242006&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822104124300.png" alt="" />&lt;figcaption>image-20200822104124300&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822104139427.png" alt="" />&lt;figcaption>image-20200822104139427&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-3">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824154157654.png" alt="" />&lt;figcaption>image-20200824154157654&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824154217956.png" alt="" />&lt;figcaption>image-20200824154217956&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-2">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824160737653.png" alt="" />&lt;figcaption>image-20200824160737653&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824160758283.png" alt="" />&lt;figcaption>image-20200824160758283&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824161150230.png" alt="" />&lt;figcaption>image-20200824161150230&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824161204208.png" alt="" />&lt;figcaption>image-20200824161204208&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824161222299.png" alt="" />&lt;figcaption>image-20200824161222299&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824162605314.png" alt="" />&lt;figcaption>image-20200824162605314&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824162641338.png" alt="" />&lt;figcaption>image-20200824162641338&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824163606579.png" alt="" />&lt;figcaption>image-20200824163606579&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824163623596.png" alt="" />&lt;figcaption>image-20200824163623596&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824165341794.png" alt="" />&lt;figcaption>image-20200824165341794&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824165401974.png" alt="" />&lt;figcaption>image-20200824165401974&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824171354562.png" alt="" />&lt;figcaption>image-20200824171354562&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824171416817.png" alt="" />&lt;figcaption>image-20200824171416817&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824171433503.png" alt="" />&lt;figcaption>image-20200824171433503&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824173122201.png" alt="" />&lt;figcaption>image-20200824173122201&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200824173141841.png" alt="" />&lt;figcaption>image-20200824173141841&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18-此题需要功底">例18 此题需要功底&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825000821470.png" alt="" />&lt;figcaption>image-20200825000821470&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825000853574.png" alt="" />&lt;figcaption>image-20200825000853574&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例19">例19&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825002643648.png" alt="" />&lt;figcaption>image-20200825002643648&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825002701794.png" alt="" />&lt;figcaption>image-20200825002701794&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825002719266.png" alt="" />&lt;figcaption>image-20200825002719266&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例20">例20&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100811552.png" alt="" />&lt;figcaption>image-20200825100811552&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100828180.png" alt="" />&lt;figcaption>image-20200825100828180&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100843319.png" alt="" />&lt;figcaption>image-20200825100843319&lt;/figcaption>
&lt;/figure>
&lt;h3 id="幂级数求和函数再求级数的和">幂级数求和函数，再求级数的和&lt;/h3>
&lt;p>幂级数求和函数之前，要先确定收敛域。&lt;/p>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820142423097.png" alt="" />&lt;figcaption>image-20200820142423097&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820142412294.png" alt="" />&lt;figcaption>image-20200820142412294&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820144714300.png" alt="" />&lt;figcaption>image-20200820144714300&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820144648794.png" alt="" />&lt;figcaption>image-20200820144648794&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822141259487.png" alt="" />&lt;figcaption>image-20200822141259487&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822141320003.png" alt="" />&lt;figcaption>image-20200822141320003&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-6">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823175926570.png" alt="" />&lt;figcaption>image-20200823175926570&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823175941175.png" alt="" />&lt;figcaption>image-20200823175941175&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823180003172.png" alt="" />&lt;figcaption>image-20200823180003172&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-此题需要功底">例5 此题需要功底&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825092421661.png" alt="" />&lt;figcaption>image-20200825092421661&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825092518490.png" alt="" />&lt;figcaption>image-20200825092518490&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825092601684.png" alt="" />&lt;figcaption>image-20200825092601684&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求傅里叶级数的和">求傅里叶级数的和&lt;/h3>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821151959651.png" alt="" />&lt;figcaption>image-20200821151959651&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821152017189.png" alt="" />&lt;figcaption>image-20200821152017189&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822232931676.png" alt="" />&lt;figcaption>image-20200822232931676&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822233002965.png" alt="" />&lt;figcaption>image-20200822233002965&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823173305299.png" alt="" />&lt;figcaption>image-20200823173305299&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200823173320706.png" alt="" />&lt;figcaption>image-20200823173320706&lt;/figcaption>
&lt;/figure>
&lt;h2 id="函数展开成级数">函数展开成级数&lt;/h2>
&lt;h3 id="函数展开成幂级数">函数展开成幂级数&lt;/h3>
&lt;p>函数展开成幂级数，有公式法（泰勒展开，展成泰勒级数）和间接法（借助基本函数的幂级数展开、逐项可导、可积性质的方法）。一般用间接法。展开成幂级数的同时一般要确定收敛域。&lt;/p>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820214101317.png" alt="" />&lt;figcaption>image-20200820214101317&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820215119479.png" alt="" />&lt;figcaption>image-20200820215119479&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200820215134739.png" alt="" />&lt;figcaption>image-20200820215134739&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821165519044.png" alt="" />&lt;figcaption>image-20200821165519044&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821165541917.png" alt="" />&lt;figcaption>image-20200821165541917&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-8">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822074359967.png" alt="" />&lt;figcaption>image-20200822074359967&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821235605076.png" alt="" />&lt;figcaption>image-20200821235605076&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-7">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200821235534753.png" alt="" />&lt;figcaption>image-20200821235534753&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822144203634.png" alt="" />&lt;figcaption>image-20200822144203634&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825093432944.png" alt="" />&lt;figcaption>image-20200825093432944&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825093449867.png" alt="" />&lt;figcaption>image-20200825093449867&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-5">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825094434397.png" alt="" />&lt;figcaption>image-20200825094434397&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825094453043.png" alt="" />&lt;figcaption>image-20200825094453043&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-5">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100224771.png" alt="" />&lt;figcaption>image-20200825100224771&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100237328.png" alt="" />&lt;figcaption>image-20200825100237328&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-4">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100442944.png" alt="" />&lt;figcaption>image-20200825100442944&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825100458105.png" alt="" />&lt;figcaption>image-20200825100458105&lt;/figcaption>
&lt;/figure>
&lt;h3 id="函数展开成傅里叶级数">函数展开成傅里叶级数&lt;/h3>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822183324844.png" alt="" />&lt;figcaption>image-20200822183324844&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200822183340673.png" alt="" />&lt;figcaption>image-20200822183340673&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-12">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825102438905.png" alt="" />&lt;figcaption>image-20200825102438905&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825102456519.png" alt="" />&lt;figcaption>image-20200825102456519&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-9">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825102827846.png" alt="" />&lt;figcaption>image-20200825102827846&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200825102841572.png" alt="" />&lt;figcaption>image-20200825102841572&lt;/figcaption>
&lt;/figure></description></item><item><title>About</title><link>https://ole12138.github.io/about/</link><pubDate>Wed, 25 Nov 2020 05:22:09 +0800</pubDate><guid>https://ole12138.github.io/about/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;p>&lt;a href="mailto:784319947@qq.com">784319947@qq.com&lt;/a>&lt;/p>
&lt;p>本站文章的所有markdown源码都放在了&lt;a href="https://github.com/ole12138/ole12138.github.io/tree/source/content">仓库source分支下&lt;/a>。&lt;/p>
&lt;p>本站原创博文，公开转载请注明出处，并邮件告知博主。‘&lt;/p>
&lt;p>本站转载的博文（非原创），大部分已注明出处，若有侵权请联系博主删除。&lt;/p></description></item><item><title>线性代数-向量组的线性相关性</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/</link><pubDate>Mon, 10 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-向量组的线性相关性">线性代数-向量组的线性相关性&lt;/h1>
&lt;h2 id="向量与向量组">向量与向量组&lt;/h2>
&lt;h3 id="向量">向量&lt;/h3>
&lt;h5 id="向量的定义">向量的定义&lt;/h5>
&lt;p>n 个有次序的数 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)&lt;/span> 所组成的数组称为n 维向量, 这 &lt;span class="math inline">\(n\)&lt;/span>个数称为该向量的 n 个分量，第 i 个数 &lt;span class="math inline">\(a_i\)&lt;/span> 称为第 &lt;span class="math inline">\(i\)&lt;/span> 个分量。（代数，或者说线性代数中的定义）&lt;/p>
&lt;p>在解析几何中，我们把“既有大小又有方向的量”叫做向量，并把可随意平行移动的有向线段作为向量的几何形象。在引进坐标系以后，这种向量就有了坐标表示式——三个有次序的实数，也就是本书中的3维向量。因此，当n≤3时，n维向量可以把有向线段作为几何形象，但当n&amp;gt;3时，n维向量就不再有这种几何形象，只是沿用一些几何术语罢了。&lt;/p>
&lt;h5 id="实向量与复向量">实向量与复向量&lt;/h5>
&lt;p>分量全为实数的向量称为实向量，分量为复数的向量称为复向量本书中除特别指明者外，一般只讨论实向量&lt;/p>
&lt;h5 id="行向量与列向量">行向量与列向量&lt;/h5>
&lt;p>n维向量可写成一行，也可写成一列。分别称为行向量和列向量，也就是行矩阵和列矩阵，并规定行向量与列向量都按矩阵的运算规则进行运算。&lt;/p>
&lt;p>n维列向量： &lt;span class="math inline">\(a=\left(\begin{array}{c}a_{1} \\ a_{2} \\ \vdots \\ a_{n}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>n维行向量： &lt;span class="math inline">\(a^{\mathrm{T}}=\left(a_{1}, a_{2}, \cdots, a_{n}\right)\)&lt;/span>&lt;/p>
&lt;p>从矩阵角度看，有着相同分量的行向量与列向量。总看做是两个不同的向量（虽然按照&lt;a href="#向量的定义">向量的定义&lt;/a>，a与&lt;span class="math inline">\(a^T\)&lt;/span>应是同一个向量）&lt;/p>
&lt;h3 id="向量组">向量组&lt;/h3>
&lt;p>下面我们先讨论只含有限个向量的向量组，以后再把讨论的结果推广到含无限多个向量的向量组.&lt;/p>
&lt;h4 id="向量组的定义">向量组的定义&lt;/h4>
&lt;p>若干个同维数的列向量（或同维数的行向量）所组成的集合叫做&lt;strong>向量组&lt;/strong>。&lt;/p>
&lt;p>（注意：向量组的每个元素都是一个向量，应该使用boldsymbol黑体，但是一些地方我偷懒了，没有用黑体，下面要注意分辨）&lt;/p>
&lt;p>eg: 一个m×n矩阵的全体列向量是一个含&lt;strong>n个&lt;/strong>m维&lt;strong>列向量&lt;/strong>的向量组， 它的全体行向量是一个含&lt;strong>m个&lt;/strong>n维&lt;strong>行向量&lt;/strong>的向量组&lt;/p>
&lt;p>eg2: 线性方程&lt;span class="math inline">\(A_{m \times n} x=0\)&lt;/span>的全体解当R（A）&amp;lt;n时是一个含&lt;strong>无限多个&lt;/strong>n维&lt;strong>列向量&lt;/strong>的向量组&lt;/p>
&lt;h4 id="有限个向量的向量组与矩阵一一对应">有限个向量的向量组与矩阵一一对应&lt;/h4>
&lt;p>矩阵的列向量组和行向量组都是只含有限个向量的向量组；反之，一个含有限个向量的向量组总可以构成一个矩阵。&lt;/p>
&lt;p>总之，含有限个向量的有序向量组可以与矩阵一一对应。&lt;/p>
&lt;p>eg1: &lt;span class="math inline">\(m\)&lt;/span> 个 &lt;span class="math inline">\(n\)&lt;/span> 维列向量所组成的向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 构成一个 &lt;span class="math inline">\(n \times m\)&lt;/span> 矩阵： &lt;span class="math inline">\(\boldsymbol{A}=\left(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\right)\)&lt;/span>&lt;/p>
&lt;p>eg2： m 个 n 维行向量所组成的向量组 &lt;span class="math inline">\(B: \beta_{1}^{\mathrm{T}}, \beta_{2}^{\mathrm{T}}, \cdots, \beta_{m}^{\mathrm{T}}\)&lt;/span>,构成一个 &lt;span class="math inline">\(m \times n\)&lt;/span> 矩阵： &lt;span class="math inline">\(\boldsymbol{B}=\left(\begin{array}{c}\boldsymbol{\beta}_{1}^{\mathrm{T}} \\ \boldsymbol{\beta}_{2}^{\mathrm{T}} \\ \vdots \\ \boldsymbol{\beta}_{\mathrm{m}}^{\mathrm{T}}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="向量组的线性组合">向量组的线性组合&lt;/h2>
&lt;h4 id="向量组的线性组合-1">向量组的线性组合&lt;/h4>
&lt;p>给定向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m},\)&lt;/span> 对于任何一组实数 &lt;span class="math inline">\(k_{1}, k_{2}, \cdots, k_{m}\)&lt;/span>， 表达式&lt;span class="math inline">\(k_{1} a_{1}+k_{2} a_{2}+\cdots+k_{m} a_{m}\)&lt;/span>称为&lt;strong>向量组 A 的一个线性组合&lt;/strong>, &lt;span class="math inline">\(k_{1}, k_{2}, \cdots, k_{m}\)&lt;/span> 称为这个&lt;strong>线性组合的系数&lt;/strong>&lt;/p>
&lt;h4 id="向量b可由向量组a线性表示">向量b可由向量组A线性表示&lt;/h4>
&lt;h5 id="向量b可由向量组a线性表示的定义">向量b可由向量组A线性表示的定义&lt;/h5>
&lt;p>给定向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 和向量 &lt;span class="math inline">\(b\)&lt;/span>,如果存在一组数 &lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{m},\)&lt;/span> 使&lt;span class="math inline">\(b=\lambda_{1} a_{1}+\lambda_{2} a_{2}+\cdots+\lambda_{m} a_{m}\)&lt;/span>， 则向量 b 是向量组 A 的线代组合, 这时称&lt;strong>向量 b 能由向量组 A 线性表示&lt;/strong>.&lt;/p>
&lt;h5 id="向量b能由向量组a线性表示leftrightarrow-bax有解leftrightarrowrarab">向量b能由向量组&lt;span class="math inline">\(A\)&lt;/span>线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(b=Ax\)&lt;/span>有解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(R(A)=R(A,b)\)&lt;/span>&lt;/h5>
&lt;p>向量b能由向量组&lt;span class="math inline">\(A: \boldsymbol a_{1}, \boldsymbol a_{2}, \cdots, \boldsymbol a_{m}\)&lt;/span>线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 方程组&lt;span class="math inline">\(b=\lambda_{1} \boldsymbol a_{1}+\lambda_{2} \boldsymbol a_{2}+\cdots+\lambda_{m} \boldsymbol a_{m}\)&lt;/span>有解。 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\right)\)&lt;/span> 的秩等于矩阵 &lt;span class="math inline">\(\boldsymbol{B}=\left(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}, \boldsymbol{b}\right)\)&lt;/span> 的秩 &lt;span class="math inline">\(.\)&lt;/span>&lt;/p>
&lt;h4 id="向量组b可由向量组a线性表示">向量组B可由向量组A线性表示&lt;/h4>
&lt;h5 id="向量组b能由向量组a线性表示概念">向量组B能由向量组A线性表示概念&lt;/h5>
&lt;p>设有两个向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 及 &lt;span class="math inline">\(B: b_{1}, b_{2}, \cdots, b_{l},\)&lt;/span> 若 &lt;span class="math inline">\(B\)&lt;/span> 组中的每个向量都能由向量组A线性表示则称向量组B能由向量组A线性表示。&lt;/p>
&lt;h5 id="列向量组-b-能由列向量组a-线性表示-leftrightarrow-存在系数矩阵k使得b-ak">列向量组$ B$ 能由列向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在系数矩阵K，使得&lt;span class="math inline">\(B = AK\)&lt;/span>&lt;/h5>
&lt;blockquote>
&lt;p>若&lt;span class="math inline">\(\boldsymbol{B}=\left(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{l}\right)\)&lt;/span>（&lt;strong>列向量组&lt;/strong>）能由组&lt;span class="math inline">\(\boldsymbol{A}=\left(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\right)\)&lt;/span>（&lt;strong>列向量组&lt;/strong>）线性表示, 即对每个向量 &lt;span class="math inline">\(\boldsymbol b_{j}(j=1,2, \cdots, l)\)&lt;/span> 存在数&lt;span class="math inline">\(k_{1 j}, k_{2 j}, \cdots, k_{m j},\)&lt;/span> 使： &lt;span class="math inline">\(\boldsymbol b_{j}=k_{1 j} \boldsymbol a_{1}+k_{2 j} \boldsymbol a_{2}+\cdots+k_{m j} \boldsymbol a_{m}=\left(\boldsymbol a_{1}, \boldsymbol a_{2}, \cdots, \boldsymbol a_{m}\right)\left(\begin{array}{c}k_{1 j} \\ k_{2 j} \\ \vdots \\ k_{m j}\end{array}\right)\)&lt;/span> 从而： &lt;span class="math inline">\(\left(\boldsymbol b_{1}, \boldsymbol b_{2}, \cdots, \boldsymbol b_{l}\right)=\left(\boldsymbol a_{1}, \boldsymbol a_{2}, \cdots, \boldsymbol a_{m}\right)\left(\begin{array}{cccc}k_{11} &amp;amp; k_{12} &amp;amp; \cdots &amp;amp; k_{1l} \\ k_{21} &amp;amp; k_{22} &amp;amp; \cdots &amp;amp; k_{2l} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ k_{m 1} &amp;amp; k_{m l} &amp;amp; \cdots &amp;amp; k_{m 1}\end{array}\right)\)&lt;/span> 这里记：矩阵 &lt;span class="math inline">\(\boldsymbol{K}_{m \times 1}=\left(k_{i j}\right)\)&lt;/span> 称为这一线性表示的系数矩阵.&lt;/p>
&lt;p>即，列向量组$ B$ 能由列向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在系数矩阵K，使得&lt;span class="math inline">\(B = AK\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="行向量组b能有行向量组a线性表示-leftrightarrow-存在系数矩阵k使得b-ka">行向量组B能有行向量组A线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在系数矩阵K，使得&lt;span class="math inline">\(B = KA\)&lt;/span>&lt;/h5>
&lt;blockquote>
若$ B=(
&lt;span class="math display">\[\begin{array}{c}\boldsymbol b_{1}\\ \boldsymbol b_{2}\\ \vdots\\ \boldsymbol b_{l}\end{array}\]&lt;/span>
&lt;p>)$ （&lt;strong>行向量组&lt;/strong>）能由 &lt;span class="math inline">\(A=\left(\begin{array}{c}\boldsymbol a_{1}\\ \boldsymbol a_{2}\\ \vdots\\ \boldsymbol a_{m}\end{array}\right)\)&lt;/span> （&lt;strong>行向量组&lt;/strong>）线性表示, 即对每个向量 &lt;span class="math inline">\(\boldsymbol b_{j}(j=1,2, \cdots, l)\)&lt;/span> 存在数&lt;span class="math inline">\(k_{i 1}, k_{i 2}, \cdots, k_{i m},\)&lt;/span> 使： &lt;span class="math inline">\(\boldsymbol b_{j}=k_{i 1} \boldsymbol a_{1}+k_{i 2} \boldsymbol a_{2}+\cdots+k_{i m } \boldsymbol a_{m}=\left(k_{i 1}, k_{i 2}, \cdots, k_{i m}\right)\left(\begin{array}{c}\boldsymbol a_{1}\\ \boldsymbol a_{2}\\ \vdots\\ \boldsymbol a_{m}\end{array}\right)\)&lt;/span> 从而： &lt;span class="math inline">\(\left(\begin{array}{c}\boldsymbol b_{1}\\ \boldsymbol b_{2}\\ \vdots\\ \boldsymbol b_{l}\end{array}\right)=\left(\begin{array}{cccc}k_{11} &amp;amp; k_{12} &amp;amp; \cdots &amp;amp; k_{1m} \\ k_{21} &amp;amp; k_{22} &amp;amp; \cdots &amp;amp; k_{2m} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ k_{l 1} &amp;amp; k_{l2} &amp;amp; \cdots &amp;amp; k_{l m}\end{array}\right)\left(\begin{array}{c}\boldsymbol a_{1}\\ \boldsymbol a_{2}\\ \vdots\\ \boldsymbol a_{m}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>即，行向量组B能有行向量组A线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在系数矩阵K，使得&lt;span class="math inline">\(B = KA\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="向量组-b-能由向量组a-线性表示-leftrightarrow-rboldsymbolarboldsymbola-boldsymbolb">向量组$ B$ 能由向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>&lt;/h5>
&lt;p>向量组 &lt;span class="math inline">\(B: b_{1}, b_{2}, \cdots, b_{l}\)&lt;/span> 能由向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在系数矩阵X，使得&lt;span class="math inline">\(B = AX\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\right)\)&lt;/span> 的 秩等于矩阵 &lt;span class="math inline">\((\boldsymbol{A}, \boldsymbol{B})=\left(a_{1}, \cdots, \boldsymbol{a}_{m},\right.\left.b_{1}, \cdots, b_{1}\right)\)&lt;/span> 的秩,即 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;h5 id="向量组-b-能由向量组a-线性表示-rightarrow-rboldsymbolble-rboldsymbola">向量组$ B$ 能由向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{B})\le R(\boldsymbol{A})\)&lt;/span>&lt;/h5>
&lt;p>设向量组 &lt;span class="math inline">\(B: \boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{l}\)&lt;/span> 能由向量组 &lt;span class="math inline">\(A: \boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\)&lt;/span> 线性表示，则&lt;span class="math inline">\(R\left(b_{1}, b_{2}, \cdots, b_{l}\right) \leqslant R\left(a_{1}, a_{2}, \cdots, a_{m}\right)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： 向量组 &lt;span class="math inline">\(B: \boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{l}\)&lt;/span> 能由向量组 &lt;span class="math inline">\(A: \boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\)&lt;/span> 线性表示时， 由上一条性质（定理）知&lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>， 又&lt;span class="math inline">\(R(\boldsymbol{B}) \leqslant R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>， 得&lt;span class="math inline">\(R(\boldsymbol{B}) \leqslant R(\boldsymbol{A})\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="综上性质">综上性质：&lt;/h5>
&lt;p>向量组&lt;span class="math inline">\(B: b_{1}, b_{2}, \cdots, b_{l}\)&lt;/span>能由向量组&lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span>线性表示 （几何语言） &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 有矩阵 &lt;span class="math inline">\(\boldsymbol{K},\)&lt;/span> 使 &lt;span class="math inline">\(\boldsymbol{B}=\boldsymbol{A K}\)&lt;/span> （矩阵语言） &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 方程 &lt;span class="math inline">\(A X=B\)&lt;/span> 有解 （矩阵语言） &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span> （矩阵语言）&lt;/p>
&lt;p>向量组&lt;span class="math inline">\(B: b_{1}, b_{2}, \cdots, b_{l}\)&lt;/span>能由向量组&lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span>线性表示 （几何语言） &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{B})\le R(\boldsymbol{A})\)&lt;/span> （矩阵语言）&lt;/p>
&lt;p>上一章中把线性方程组写成矩阵形式，通过矩阵的运算求得它的解，还用矩阵的语言给出了线性方程组有解、有唯一解的充分必要条件； 本章中将向量组的问题表述成矩阵形式，通过矩阵的运算得出结果，然后把矩阵形式的结果“翻译”成几何问题的结论这种用矩阵来表述问题，并通过矩阵的运算解决问题的方法，通常叫做&lt;strong>矩阵方法&lt;/strong>，这正是线性代数的基本方法，应有意识地去加强这方法的练习。&lt;/p>
&lt;h4 id="向量组等价">向量组等价&lt;/h4>
&lt;h5 id="向量组等价概念">向量组等价概念&lt;/h5>
&lt;p>若向量组A与向量组B能相互线性表示，则称这两个向量组等价。&lt;/p>
&lt;h5 id="矩阵等价leftrightarrow向量组等价">矩阵等价&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>向量组等价&lt;/h5>
&lt;p>设矩阵A与B行等价（矩阵等价），即矩阵A经初等行变换变成矩阵B，则B的每个行向量都是A的行向量组的线性组合，即B的行向量组能由A的行向量组线性表示。由于初等变换可逆，知矩阵B亦可经初等行变换变为A，从而A的行向量组也能由B的行向量组线性表示。于是A的行向量组与B的行向量组等价（向量组等价）。&lt;/p>
&lt;p>类似可知，若矩阵A与B列等价，则A的列向量组与B的列向量组等价&lt;/p>
&lt;h5 id="向量组等价-rboldsymbolarboldsymbolbrboldsymbola-boldsymbolb">向量组等价$$ &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>&lt;/h5>
&lt;p>向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 与向量组 &lt;span class="math inline">\(B: b_{1}, b_{2}, \cdots, b_{t}\)&lt;/span> 等价$$ &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>，其中 &lt;span class="math inline">\(\boldsymbol A\)&lt;/span> 和 &lt;span class="math inline">\(\boldsymbol B\)&lt;/span> 是向国组 A 和 &lt;span class="math inline">\(B\)&lt;/span> 所构成的矩阵.（其实是&lt;a href="#向量组$%20B$%20能由向量组$A$%20线性表示%20$\Leftrightarrow$%20$R(\boldsymbol%7BA%7D)=R(\boldsymbol%7BA%7D,%20\boldsymbol%7BB%7D)$">相关性质&lt;/a>的推广）&lt;/p>
&lt;h3 id="方程组的线性组合线性表示等价概念">方程组的线性组合、线性表示、等价概念&lt;/h3>
&lt;p>向量组的线性组合线性表示及等价等概念，也可移用于线性方程组： 对方程组A的各个方程作线性运算所得到的一个方程就称为&lt;strong>方程组A的一个线性组合&lt;/strong>； 若方程组B的每个方程都是方程组A的线性组合，就称&lt;strong>方程组B能由方程组A线性表示&lt;/strong>，这时方程组A的解一定是方程组B的解； 若方程组A与方程组B能相互线性表示，就称这&lt;strong>两个方程组可互推&lt;/strong>，可互推的线性方程组一定&lt;strong>同解&lt;/strong>&lt;/p>
&lt;h2 id="向量组的线性相关性">向量组的线性相关性&lt;/h2>
&lt;h5 id="向量组的线性相关概念">向量组的线性相关概念&lt;/h5>
&lt;p>给定向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m},\)&lt;/span> 如果存在不全为零的数 &lt;span class="math inline">\(k_{1}, k_{2}, \cdots,k_{m}\)&lt;/span>，使得&lt;span class="math inline">\(k_{1} a_{1}+k_{2} a_{2}+\cdots+k_{m} a_{m}=0\)&lt;/span>，则称&lt;strong>向量组A是线性相关的&lt;/strong>，否则称它线性无关.&lt;/p>
&lt;p>向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}(m \geqslant 2)\)&lt;/span> 线性相关 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 在向量组 &lt;span class="math inline">\(A\)&lt;/span> 中至少有一个向量能由其余m-1个向量线性表示。&lt;/p>
&lt;blockquote>
&lt;p>证明： 如果向量组 A 线性相关,则有不全为 0 的数 &lt;span class="math inline">\(k_{1}, k_{2}, \cdots, k_{m}\)&lt;/span> 使 &lt;span class="math inline">\(k_{1} a_{1}+\)&lt;/span>&lt;span class="math inline">\(k_{2} a_{2}+\cdots+k_{m} a_{m}=0 .\)&lt;/span> 因 &lt;span class="math inline">\(k_{1}, k_{2}, \cdots, k_{m}\)&lt;/span> 不全为 &lt;span class="math inline">\(0,\)&lt;/span> 不妨设 &lt;span class="math inline">\(k_{1} \neq 0,\)&lt;/span> 于是便有&lt;span class="math inline">\(a_{1}=\frac{-1}{k_{1}}\left(k_{2} a_{2}+\cdots+k_{m} a_{m}\right)\)&lt;/span>. 如果向量组A中有某个向量能由其余m-1个向量线性表示，不妨设&lt;span class="math inline">\(\boldsymbol{a}_{m}\)&lt;/span>能由 &lt;span class="math inline">\(a_{1}, \cdots, a_{m-1}\)&lt;/span> 线性表示, 即有 &lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{m-1}\)&lt;/span> 使 &lt;span class="math inline">\(a_{m}=\lambda_{1} a_{1}+\cdots+\lambda_{m-1} a_{m-1}\)&lt;/span>，于是&lt;span class="math inline">\(\lambda_{1} a_{1}+\cdots+\lambda_{m-1} a_{m-1}+(-1) a_{m}=0\)&lt;/span>，因为 &lt;span class="math inline">\(\lambda_{1}, \cdots, \lambda_{m-1},-1\)&lt;/span> 这 &lt;span class="math inline">\(m\)&lt;/span> 个数不全为 0（至少 &lt;span class="math inline">\(- 1\neq0\)&lt;/span>）,所以向量组 A 线性相关。&lt;/p>
&lt;/blockquote>
&lt;h5 id="向量组线性相关的几何意义">向量组线性相关的几何意义&lt;/h5>
&lt;p>说向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 线性相关,通常是指 &lt;span class="math inline">\(m \geqslant 2\)&lt;/span> 的情形, 但定义也适用于m=1的情形。当m=1时，向量组只含一个向量，对于只含一个向量a的向量组，当a=0时是线性相关的，当a≠0时是线性无关的。 对于含2个向量&lt;span class="math inline">\(a_1， a_2\)&lt;/span>的向量组，它线性相关的充分必要条件是&lt;span class="math inline">\(a_1， a_2\)&lt;/span>的分量对应成比例，其几何意义是两向量共线. 3个向量线性相关的几何意义是三向量共面（注：三向量共面还可以用混合积判断）&lt;/p>
&lt;h5 id="方程组的线性相关概念">方程组的线性相关概念&lt;/h5>
&lt;p>向量组的线性相关与线性无关的概念也可移用于线性方程组。 当方程组中有某个方程是其余方程的线性组合时，这个方程就是多余的，这时称方程组（各个方程）是线性相关的； 当方程组中没有多余方程，就称该方程组（各个方程）线性无关（或线性独立）&lt;/p>
&lt;h5 id="向量组线性相关leftrightarrowa-x0有非零解leftrightarrow矩阵的秩小于向量个数">向量组线性相关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(A x=0\)&lt;/span>有非零解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵的秩小于向量个数&lt;/h5>
&lt;p>向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 构成矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{1}, a_{2}, \cdots, a_{m}\right),\)&lt;/span> 向量组 &lt;span class="math inline">\(A\)&lt;/span> 线性相关，就是齐次线性方程组&lt;span class="math inline">\(x_{1} a_{1}+x_{2} a_{2}+\cdots+x_{m} a_{m}=0,\)&lt;/span> 即 &lt;span class="math inline">\(A x=0\)&lt;/span>有非零解&lt;/p>
&lt;p>定理： 向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 线 性相关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>向量组构成的矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{1}, a_{2}, \cdots, a_{m}\right)\)&lt;/span> 的秩小于向量个数 &lt;span class="math inline">\(m\)&lt;/span> 向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 线 性无关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(R(\boldsymbol{A})=m\)&lt;/span>&lt;/p>
&lt;h5 id="向量组线性相关的推论">向量组线性相关的推论&lt;/h5>
&lt;p>定理： 1）若向量组 &lt;span class="math inline">\(A: a_{1}, \cdots, a_{m}\)&lt;/span> 线 性相关,则向量组 &lt;span class="math inline">\(B: a_{1}, \cdots, a_{m},\)&lt;/span>&lt;span class="math inline">\(a_{m+1}\)&lt;/span> 也线性相关. 反言之,若向量组 &lt;span class="math inline">\(B\)&lt;/span> 线性无关,则向量组 &lt;span class="math inline">\(A\)&lt;/span> 也线性无关。 2）m个n维向量组成的向量组，当维数n小于向量个数m时一定线性相关；特别地，n+1个n维向量一定线性相关。 3）设向量组 &lt;span class="math inline">\(A: a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 线性无关，而向量组 &lt;span class="math inline">\(B: a_{1}, \cdots, a_{m}, b\)&lt;/span> 线性相关，则向量b必能由向量组A线性表示，且表示式是惟一的。&lt;/p>
&lt;h5 id="向量组线性相关性的证明">向量组线性相关性的证明&lt;/h5>
&lt;p>有两种证法都是常用的，证明时首先是把已知条件表述成矩阵形式。&lt;/p>
&lt;p>证一的关键是：按定义4把证明向量组线性无关转化为证明齐次方程没有非零解，因而去考察方程Bx=0. 证二用矩阵的秩的有关知识，以及上文关于秩的定理，从而可以不涉及线性方程而直接证得结论&lt;/p>
&lt;h2 id="向量组的秩">向量组的秩&lt;/h2>
&lt;p>上两节在讨论向量组的线性组合和线性相关性时，矩阵的秩起了十分重要的作用。为使讨论进一步深入，下面把秩的概念引进向量组。&lt;/p>
&lt;h5 id="向量组的极大线性无关组">向量组的极大线性无关组&lt;/h5>
&lt;h6 id="向量组的极大线性无关组的原始定义">向量组的极大线性无关组的原始定义&lt;/h6>
&lt;p>设有向量组 A ,如果在 A 中能选出 &lt;span class="math inline">\(r\)&lt;/span> 个向量 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r},\)&lt;/span> 满足： 1）向量组 &lt;span class="math inline">\(A_{0}: a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性无关； 2）向量组A中任意r+1个向量（如果A中有r+1个向量的话）都线性相关。 那么称向量组&lt;span class="math inline">\(A_{0}\)&lt;/span>是向量组A的一个最大/极大线性无关向量组（简称最大无关组）。&lt;/p>
&lt;h6 id="向量组的极大线性无关组的第二种定义">向量组的极大线性无关组的第二种定义&lt;/h6>
&lt;p>设有向量组 A ,如果在 A 中能选出 &lt;span class="math inline">\(r\)&lt;/span> 个向量 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r},\)&lt;/span> 满足： 1）向量组 &lt;span class="math inline">\(A_{0}: a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性无关； 2）向量组A中任意向量a都可由向量组 &lt;span class="math inline">\(A_{0}: a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性表示。 那么称向量组&lt;span class="math inline">\(A_{0}\)&lt;/span>是向量组A的一个最大/极大线性无关向量组（简称最大无关组）；&lt;/p>
&lt;blockquote>
&lt;p>证明： 需要证向量组 A 中任意 r + 1 个向里线性相关. 设 &lt;span class="math inline">\(b_{1}, b_{2}, \cdots, b_{r+1}\)&lt;/span> 是 &lt;span class="math inline">\(A\)&lt;/span>中任意r+1个向量，由条件2）知这r+1个向量能由向量组A线性表示， 根据：&lt;a href="#向量组$%20B$%20能由向量组$A$%20线性表示%20$\Rightarrow$%20$R(\boldsymbol%7BB%7D)\le%20R(\boldsymbol%7BA%7D)$">向量组$ B$ 能由向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{B})\le R(\boldsymbol{A})\)&lt;/span>&lt;/a>， 得&lt;span class="math inline">\(R\left(b_{1}, b_{2}, \cdots, b_{r+1}\right) \leqslant R\left(a_{1}, a_{2}, \cdots, a_{r}\right)=r\)&lt;/span>， 再根据：&lt;a href="#向量组线性相关$\Leftrightarrow$$A%20x=0$有非零解$\Leftrightarrow$矩阵的秩小于向量个数">向量组线性相关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(A x=0\)&lt;/span>有非零解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵的秩小于向量个数&lt;/a>， 得：这&lt;span class="math inline">\(r+1\)&lt;/span> 个向量 &lt;span class="math inline">\(b_{1}, b_{2}, \cdots, b_{r+1}\)&lt;/span> 线性相关. 即，推得了&lt;a href="#向量组的极大线性无关组">向量组极大线性无关组的原始定义&lt;/a>。&lt;/p>
&lt;/blockquote>
&lt;h5 id="向量组与其极大线性无关组等价">向量组与其极大线性无关组等价&lt;/h5>
&lt;blockquote>
&lt;p>证明：&lt;/p>
&lt;p>向量组A和它自己的最大无关组&lt;span class="math inline">\(A_0\)&lt;/span>是等价的这是因为&lt;span class="math inline">\(A_0\)&lt;/span>组是A组的个部分组，故&lt;span class="math inline">\(A_0\)&lt;/span>组总能由A组线性表示（A中每个向量都能由A组表示）。 由&lt;a href="#向量组的极大线性无关组">向量组的极大线性无关组定义的条件2）&lt;/a>知：向量组A中任意r+1个向量&lt;span class="math inline">\(a_{1}, \cdots, a_{r}, a\)&lt;/span>都线性相关； 而 &lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span> 线性无关，由&lt;a href="#线性相关的推论">线性相关的推论3）&lt;/a>可知，组内任意的向量&lt;span class="math inline">\(a\)&lt;/span> 能由 &lt;span class="math inline">\(a_{1}, \cdots, a_{r}\)&lt;/span> 线性表示。 则A组能由&lt;span class="math inline">\(A_0\)&lt;/span>组线性表示.&lt;/p>
&lt;p>所以 A 组与&lt;span class="math inline">\(A_0\)&lt;/span>组是等价的。&lt;/p>
&lt;/blockquote>
&lt;h5 id="向量组的秩-1">向量组的秩&lt;/h5>
&lt;p>极大/最大无关组所含向量个数r称为向量组A的秩，记作&lt;span class="math inline">\(R_A\)&lt;/span>. 只含零向量的向量组没有最大无关组，规定它的秩为0.&lt;/p>
&lt;h5 id="矩阵的秩它的行向量组的秩它的列向量组的秩">矩阵的秩=它的行向量组的秩=它的列向量组的秩&lt;/h5>
&lt;blockquote>
&lt;p>证明：（用矩阵的秩的定义、向量组线性相关的充分必要条件证明）&lt;/p>
&lt;p>设 &lt;span class="math inline">\(\mathbf{A}=\left(a_{1}, a_{2}, \cdots, a_{m}\right), R(\mathbf{A})=r,\)&lt;/span> 并设 &lt;span class="math inline">\(r\)&lt;/span> 阶子式 &lt;span class="math inline">\(D_{r} \neq 0 .\)&lt;/span> 根据定理 ：&lt;a href="#向量组线性相关$\Leftrightarrow$$A%20x=0$有非零解$\Leftrightarrow$矩阵的秩小于向量个数">向量组线性相关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(A x=0\)&lt;/span>有非零解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵的秩小于向量个数&lt;/a>， 由 &lt;span class="math inline">\(D_r \neq 0\)&lt;/span> 知 &lt;span class="math inline">\(D_r\)&lt;/span>, 所在的 r 列线性无关; 又由 A 中所有 r +1 阶子式均为零,知 A中任意 r + 1 个列向量都线性相关. 因此 &lt;span class="math inline">\(D_r\)&lt;/span> 所在的 r 列是 A 的列向量组的一个极大线性无关组。所以列向量组的秩等于r。&lt;/p>
&lt;p>类似可证矩阵 A 的行向量组的秩也等于 R（A）.&lt;/p>
&lt;/blockquote>
&lt;p>从上述证明中可见： 若&lt;span class="math inline">\(D_r\)&lt;/span>是矩阵A的一个最高阶非零子式，则&lt;span class="math inline">\(D_r\)&lt;/span>所在的r列即是A的列向量组的一个最大/极大无关组，&lt;span class="math inline">\(D_r\)&lt;/span>所在的r行即是A的行向量组的一个最大/极大无关组。&lt;/p>
&lt;p>有了以上结论：矩阵的秩=它的行向量组的秩=它的列向量组的秩， 本章在此之前涉及矩阵秩的性质： &lt;a href="#向量b能由向量组$A$线性表示$\Leftrightarrow$%20$b=Ax$有解$\Leftrightarrow$$R(A)=R(A,b)$">向量b能由向量组&lt;span class="math inline">\(A\)&lt;/span>线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(b=Ax\)&lt;/span>有解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(R(A)=R(A,b)\)&lt;/span>&lt;/a> &lt;a href="#向量组$%20B$%20能由向量组$A$%20线性表示%20$\Leftrightarrow$%20$R(\boldsymbol%7BA%7D)=R(\boldsymbol%7BA%7D,%20\boldsymbol%7BB%7D)$">向量组$ B$ 能由向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>&lt;/a> &lt;a href="#向量组等价$\Leftrightarrow%20$%20$R(\boldsymbol%7BA%7D)=R(\boldsymbol%7BB%7D)=R(\boldsymbol%7BA%7D,%20\boldsymbol%7BB%7D)$">向量组等价$$ &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})=R(\boldsymbol{A}, \boldsymbol{B})\)&lt;/span>&lt;/a> &lt;a href="#向量组$%20B$%20能由向量组$A$%20线性表示%20$\Rightarrow$%20$R(\boldsymbol%7BB%7D)\le%20R(\boldsymbol%7BA%7D)$">向量组$ B$ 能由向量组&lt;span class="math inline">\(A\)&lt;/span> 线性表示 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(R(\boldsymbol{B})\le R(\boldsymbol{A})\)&lt;/span>&lt;/a> &lt;a href="#向量组线性相关的推论">向量组线性相关的推论3）&lt;/a> 其中出现的矩阵的秩，都可改为向量组的秩。 今后向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 的秩也记作 &lt;span class="math inline">\(R\left(a_{1}, a_{2}, \cdots, a_{m}\right)\)&lt;/span>。这几条性质也不再区分矩阵的秩和向量组的秩。&lt;/p>
&lt;p>扩展阅读：为什么矩阵行秩等于列秩？ 扩展阅读：秩 (线性代数) 比较阅读：&lt;a href="http://www2.edu-edu.com.cn/lesson_crs78/self/j_4184/soft/ch0303.html">向量组的秩&lt;/a>&lt;/p>
&lt;h5 id="求矩阵的列向量组的极大线性无关组并表示其他向量">求矩阵的列向量组的极大线性无关组，并表示其他向量&lt;/h5>
&lt;p>如果矩阵&lt;span class="math inline">\(A_{mxn}\)&lt;/span>与&lt;span class="math inline">\(B_{lxn}\)&lt;/span>的&lt;strong>行向量组等价&lt;/strong>（这时齐次线性&lt;strong>方程组Ax=0与Bx=0可互推&lt;/strong>），则方程Ax=0与Bx=0&lt;strong>同解&lt;/strong>，从而&lt;strong>A的列向量组各向量之间与B的列向量组各向量之间有相同的线性关系&lt;/strong>。 如果B是一个行最简形矩阵，则容易看出B的列向量组各向量之间的线性关系，从而也就得到A的列向量组各向量之间的线性关系（一个向量组的这种线性关系一般很多，但只要求出这个向量组的最大无关组及不属于最大无关组的向量用最大无关组线性表示的表示式，有了这些，就能推知其余的线性关系）&lt;/p>
&lt;p>所以对矩阵进行初等行变换，得到行阶梯/最简矩阵，确定矩阵的秩。 矩阵的秩=列向量组的秩，找对应个数的不相关列向量，作为极大线性无关组。 矩阵继续变为行最简矩阵，比较容易看出向量间的线性关系。 原矩阵的列向量之间也满足同样的线性关系。&lt;/p>
&lt;h2 id="线性方程组的解的结构">线性方程组的解的结构&lt;/h2>
&lt;p>&lt;a href="./线性代数-矩阵初等变换与线性方程组.md">矩阵的初等变换和线性方程组&lt;/a>章节中，我们已经介绍了&lt;strong>用矩阵的初等变换解线性方程组的方法&lt;/strong>，并建立了两个重要定理，即 （1）n个未知数的齐次线性方程组Ax=0有非零解的充分必要条件是系数矩阵的秩R(A)&amp;lt;n （2）n个未知数的非齐次线性方程组Ax=b有解的充分必要条件是系数矩阵A的秩等于增广矩阵B的秩，且当R(A)=R(B)=n时方程组有唯一解。&lt;/p>
&lt;p>本章此节，我们将&lt;strong>用向量组线性相关性的理论来讨论线性方程组的解&lt;/strong>&lt;/p>
&lt;h3 id="齐次线性方程组解的结构">齐次线性方程组解的结构&lt;/h3>
&lt;h4 id="齐次线性方程组">齐次线性方程组&lt;/h4>
&lt;p>对于齐次线性方程组（&lt;strong>方程组形式&lt;/strong>）： &lt;span class="math inline">\(\left\{\begin{array}{l}a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n}=0 \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=0 \\ \cdots \cdots \cdots \cdots \\ a_{m 1} x_{1}+a_{m 2} x_{2}+\cdots+a_{m n} x_{n}=0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>记： &lt;span class="math inline">\(\boldsymbol{A}=\left[\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m 1} &amp;amp; a_{m 2} &amp;amp; \cdots &amp;amp; a_{m n}\end{array}\right]\)&lt;/span>，&lt;span class="math inline">\(\boldsymbol{x}=\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right)\)&lt;/span> 写成方程组的&lt;strong>向量/矩阵方程形式&lt;/strong>：&lt;span class="math inline">\(A x=0\)&lt;/span>&lt;/p>
&lt;h4 id="齐次方程组的解向量">齐次方程组的解向量&lt;/h4>
&lt;p>&lt;span class="math inline">\(x_{1}=\xi_{11}, x_{2}=\xi_{21}, \cdots, x_{n}=\xi_{n 1}\)&lt;/span> 为上面方程组的解，则： &lt;span class="math inline">\(x=\xi_{1}=\left(\begin{array}{c}\xi_{11} \\ \xi_{21} \\ \vdots \\ \xi_{n 1}\end{array}\right)\)&lt;/span> 称为方程组的解向量。 同时，它也是对应向量方程的解。&lt;/p>
&lt;h4 id="齐次方程组解的线性性质">齐次方程组解的线性性质&lt;/h4>
&lt;h6 id="若-xxi_1-xxi_2-为a-x0-的解-则-xxi_1xi_2-也是a-x0的解">若 &lt;span class="math inline">\(x=\xi_{1}, x=\xi_{2}\)&lt;/span> 为&lt;span class="math inline">\(A x=0\)&lt;/span> 的解 , 则 &lt;span class="math inline">\(x=\xi_{1}+\xi_{2}\)&lt;/span> 也是&lt;span class="math inline">\(A x=0\)&lt;/span>的解&lt;/h6>
&lt;blockquote>
&lt;p>证明：&lt;span class="math inline">\(\boldsymbol{A}\left(\xi_{1}+\xi_{2}\right)=A \xi_{1}+A \xi_{2}=0+0=0\)&lt;/span>，满足&lt;span class="math inline">\(A x=0\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="若-xxi_1-为a-x0-的解-k-为实数则-xk-xi_1-也是a-x0-的解">若 &lt;span class="math inline">\(x=\xi_{1}\)&lt;/span> 为&lt;span class="math inline">\(A x=0\)&lt;/span> 的解, &lt;span class="math inline">\(k\)&lt;/span> 为实数,则 &lt;span class="math inline">\(x=k \xi_{1}\)&lt;/span> 也是&lt;span class="math inline">\(A x=0\)&lt;/span> 的解&lt;/h6>
&lt;blockquote>
&lt;p>证明：&lt;span class="math inline">\(\boldsymbol{A}\left(k \xi_{1}\right)=k\left(\boldsymbol{A} \xi_{1}\right)=k \boldsymbol{0}=\boldsymbol{0}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="齐次方程组的通解与基础解系">齐次方程组的通解与基础解系&lt;/h4>
&lt;h5 id="齐次方程组的通解与基础解系概念">齐次方程组的通解与基础解系概念&lt;/h5>
&lt;p>把方程&lt;span class="math inline">\(A x=0\)&lt;/span> 的全体解所组成的集合记作S， 如果能求得解集S的一个最大无关组 &lt;span class="math inline">\(S_{0}: \xi_{1}, \xi_{2}, \cdots, \xi_{l}\)&lt;/span>，那么方程&lt;span class="math inline">\(A x=0\)&lt;/span>的任一解都可由极大/最大无关组&lt;span class="math inline">\(S_0\)&lt;/span>线性表示； 另一方面，由&lt;a href="#齐次方程组解的线性性质">齐次方程组解向量的线性性质&lt;/a>可知，最大无关组&lt;span class="math inline">\(S_0\)&lt;/span>的任何线性组合&lt;span class="math inline">\(x=k_{1} \xi_{1}+k_{2} \xi_{2}+\cdots+k_{l} \xi_{l}\)&lt;/span>都是方程&lt;span class="math inline">\(A x=0\)&lt;/span> 的解，因此&lt;strong>&lt;span class="math inline">\(x=k_{1} \xi_{1}+k_{2} \xi_{2}+\cdots+k_{l} \xi_{l}\)&lt;/span>是方程&lt;span class="math inline">\(A x=0\)&lt;/span> 的通解&lt;/strong>。&lt;/p>
&lt;p>方程&lt;span class="math inline">\(A x=0\)&lt;/span> 的解集S的&lt;strong>极大/最大无关组&lt;/strong> &lt;span class="math inline">\(S_{0}: \xi_{1}, \xi_{2}, \cdots, \xi_{l}\)&lt;/span>称为该齐次线性方程组的一个&lt;strong>基础解系&lt;/strong>。&lt;/p>
&lt;p>由上面的讨论可知，要求齐次线性方程组的通解，只需求出它的基础解系。&lt;/p>
&lt;h5 id="求齐次线性方程组的基础解系">求齐次线性方程组的基础解系&lt;/h5>
&lt;p>设齐次线性方程组的系数矩阵A的秩为r， 不妨设A的前r个列向量线性无关，（经同解变形/矩阵初等行变换）于是A的行最简形矩阵B为： &lt;span class="math inline">\(\boldsymbol{B}=\left(\begin{array}{cccccc}1 &amp;amp; \cdots &amp;amp; 0 &amp;amp; b_{11} &amp;amp; \cdots &amp;amp; b_{1, n-r} \\ \vdots &amp;amp; &amp;amp; \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ 0 &amp;amp; \cdots &amp;amp; 1 &amp;amp; b_{r 1} &amp;amp; \cdots &amp;amp; b_{r, n-r} \\ 0 &amp;amp; &amp;amp; &amp;amp; \cdots &amp;amp; &amp;amp; 0 \\ \vdots &amp;amp; &amp;amp; &amp;amp; &amp;amp; &amp;amp; \vdots \\ 0 &amp;amp; &amp;amp; &amp;amp; \cdots &amp;amp; &amp;amp; 0\end{array}\right)\)&lt;/span> 与B矩阵&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>对应，即有方程组： &lt;span class="math inline">\(\left\{\begin{array}{l}x_{1}=-b_{11} x_{r+1}-\cdots-b_{1, n-r} x_{n} \\ \cdots \cdots \cdots \cdots \\ x_{r}=-b_{r 1} x_{r+1}-\cdots-b_{r, n-r} x_{n}\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h6 id="我们可以先求齐次线性方程组的通解再从通解求得基础解系">我们可以先求齐次线性方程组的通解，再从通解求得基础解系：&lt;/h6>
&lt;p>把 &lt;span class="math inline">\(x_{r+1}, \cdots, x_{n}\)&lt;/span> 作为自由未知数,并令它们依次等于 &lt;span class="math inline">\(c_{1}, \cdots, c_{n-r},\)&lt;/span> 可得&lt;strong>方程组的通解&lt;/strong>： &lt;span class="math inline">\(\left(\begin{array}{c}x_{1} \\ \vdots \\ x_{r} \\ x_{r+1} \\ x_{r+2} \\ \vdots \\ x_{n}\end{array}\right)=c_{1}\left[\begin{array}{c}-b_{11} \\ \vdots \\ -b_{r 1} \\ 1 \\ 0 \\ \vdots \\ 0\end{array}\right]+c_{2}\left[\begin{array}{c}-b_{12} \\ \vdots \\ -b_{r 2} \\ 0 \\ 1 \\ \vdots \\ 0\end{array}\right]+\cdots+c_{n-r}\left[\begin{array}{c}-b_{1 . n-r} \\ \vdots \\ -b_{r, n-r} \\ 0 \\ 0 \\ \vdots \\ 1\end{array}\right]\)&lt;/span> 把上面的通解记作向量形式：&lt;span class="math inline">\(x=c_{1} \xi_{1}+c_{2} \xi_{2}+\cdots+c_{n}-r \xi_{n-r}\)&lt;/span>&lt;/p>
&lt;p>可知解集S中的任一向量x能由&lt;span class="math inline">\(\xi_{1}, \xi_{2}, \cdots, \xi_{n-r}\)&lt;/span>线性表示。 又因为矩阵&lt;span class="math inline">\((\xi_{1},\xi_{2}, \cdots, \xi_{n-r})\)&lt;/span>中有 &lt;span class="math inline">\(n-r\)&lt;/span> 阶子式 &lt;span class="math inline">\(\left|\boldsymbol{E}_{n-r}\right| \neq 0\)&lt;/span> 故 &lt;span class="math inline">\(R\left(\xi_{1}, \xi_{2}, \cdots, \xi_{n-r}\right)=n-r\)&lt;/span>，（向量组的秩等于向量个数），所以&lt;span class="math inline">\(\xi_{1}, \xi_{2}, \cdots, \xi_{n-}\)&lt;/span>线性无关。 根据最大无关组的等价定义,即知 &lt;span class="math inline">\(\xi_{1}, \xi_{2}, \cdots, \xi_{n-r}\)&lt;/span> 是解集S的最大无关组，即&lt;strong>&lt;span class="math inline">\(\xi_{1}, \xi_{2}, \cdots, \xi_{n-r}\)&lt;/span> 是方程组的基础解系&lt;/strong>。&lt;/p>
&lt;h6 id="我们也可先求基础解系再写出通解">我们也可先求基础解系，再写出通解：&lt;/h6>
&lt;p>对于自由未知数 &lt;span class="math inline">\(x_{r+1}, x_{r+2}, \cdots, x_{n}\)&lt;/span> ，取下列 &lt;span class="math inline">\(n-r\)&lt;/span> 组数： &lt;span class="math inline">\(\left(\begin{array}{c}x_{r+1} \\ x_{r+2} \\ \vdots \\ x_{n}\end{array}\right)=\left(\begin{array}{c}1 \\ 0 \\ \vdots \\ 0\end{array}\right) \cdot\left(\begin{array}{c}0 \\ 1 \\ \vdots \\ 0\end{array}\right), \cdots,\left(\begin{array}{c}0 \\ 0 \\ \vdots \\ 1\end{array}\right)\)&lt;/span> 根据上文与B对应的方程组，有： &lt;span class="math inline">\(\left(\begin{array}{c}x_{1} \\ \vdots \\ x_{r}\end{array}\right)=\left(\begin{array}{c}-b_{11} \\ \vdots \\ -b_{r 1}\end{array}\right),\left(\begin{array}{c}-b_{12} \\ \vdots \\ -b_{r 2}\end{array}\right), \cdots,\left(\begin{array}{c}-b_{1, n-r} \\ \vdots \\ -b_{r, n-r}\end{array}\right)\)&lt;/span> 合起来就是基础解系： &lt;span class="math inline">\(\xi_{1}=\left(\begin{array}{c}-b_{11} \\ \vdots \\ -b_{r 1} \\ 1 \\ 0 \\ \vdots \\ 0\end{array}\right), \xi_{2}=\left(\begin{array}{c}-b_{12} \\ \vdots \\ -b_{r 2} \\ 0 \\ 1 \\ \vdots \\ 0\end{array}\right), \cdots, \xi_{n-r}=\left(\begin{array}{c}-b_{1, n-r} \\ \vdots \\ -b_{r, n-r} \\ 0 \\ 0 \\ \vdots \\ 1\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="n-元齐次线性方程组-a-x0-rboldsymbolar-rightarrow方程组解集s的秩-r_sn-r">&lt;span class="math inline">\(n\)&lt;/span> 元齐次线性方程组 &lt;span class="math inline">\(A x=0\)&lt;/span> ，&lt;span class="math inline">\(R(\boldsymbol{A})=r\)&lt;/span> &lt;span class="math inline">\(\Rightarrow\)&lt;/span>方程组解集S的秩 &lt;span class="math inline">\(R_{s}=n-r\)&lt;/span>&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(m \times n\)&lt;/span> 矩阵 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的秩 &lt;span class="math inline">\(R(\boldsymbol{A})=r,\)&lt;/span> 则 &lt;span class="math inline">\(n\)&lt;/span> 元 齐次线 性方 程组 &lt;span class="math inline">\(\boldsymbol{A x}=\mathbf{0 的}\)&lt;/span>解集 S 的秩 &lt;span class="math inline">\(R_{S}=n-r\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： 上面求基础解系的过程中有证明： 因为矩阵&lt;span class="math inline">\((\xi_{1},\xi_{2}, \cdots, \xi_{n-r})\)&lt;/span>中有 &lt;span class="math inline">\(n-r\)&lt;/span> 阶子式 &lt;span class="math inline">\(\left|\boldsymbol{E}_{n-r}\right| \neq 0\)&lt;/span> 故 &lt;span class="math inline">\(R\left(\xi_{1}, \xi_{2}, \cdots, \xi_{n-r}\right)=n-r\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>当R（A）=n时，方程&lt;span class="math inline">\(A x=0\)&lt;/span> 只有零解，没有基础解系（此时解集S只含一个零向量）； 当R（A）=r&amp;lt;n时，由这里介绍的性质知方程组&lt;span class="math inline">\(A x=0\)&lt;/span> 的基础解系含n-r个向量。 因此，由最大无关组的性质可知，&lt;strong>方程组的任何n-r个线性无关的解都可构成它的基础解系&lt;/strong>。并由此可知齐次线性方程组的&lt;strong>基础解系并不是唯一的&lt;/strong>，它的&lt;strong>通解的形式也不是唯一的&lt;/strong>。&lt;/p>
&lt;h4 id="齐次线性方程组-a-x0与b-x0同解rightarrow-rarb">齐次线性方程组 &lt;span class="math inline">\(A x=0\)&lt;/span>与&lt;span class="math inline">\(B x=0\)&lt;/span>同解&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(R(A)=R(B)\)&lt;/span>&lt;/h4>
&lt;p>由于&lt;span class="math inline">\(n\)&lt;/span>元齐次线性方程组Ax=0与Bx=0有相同的解集， 又根据上一条性质，有&lt;span class="math inline">\(R(\boldsymbol{A})=n-R_{s}, R(\boldsymbol{B})=n-R_{s}\)&lt;/span>。因此 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;h4 id="齐次线性方程组ax0与bx0同解leftrightarrow矩阵a与b行等价leftrightarrowa与b的行向量组等价">齐次线性方程组&lt;span class="math inline">\(Ax=0\)&lt;/span>与&lt;span class="math inline">\(Bx=0\)&lt;/span>同解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>矩阵A与B行等价&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A与B的行向量组等价&lt;/h4>
&lt;p>使齐次方程组&lt;span class="math inline">\(Ax=0\)&lt;/span>变换到与&lt;span class="math inline">\(Bx=0\)&lt;/span>过程中有3种同解变形：行置换、行倍加、行倍乘。 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>对应到矩阵就是矩阵的初等行变换，则矩阵A与B行等价：&lt;span class="math inline">\(A \overset{r}{\sim} B\)&lt;/span>。即&lt;span class="math inline">\(B=PA\)&lt;/span>,其中P可逆。 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>将矩阵B和A按行分块（分别看作行向量组），即有&lt;span class="math inline">\(\left(\begin{array}{c}b_1\\ b_2 \\ \vdots b_n\end{array}\right) = P \left(\begin{array}{c}a_1\\ a_2 \\ \vdots a_n\end{array}\right)\)&lt;/span> 即，B组能由A组表示。 同时，P可逆，则：&lt;span class="math inline">\(P^{-1}\left(\begin{array}{c}b_1\\ b_2 \\ \vdots b_n\end{array}\right) = \left(\begin{array}{c}a_1\\ a_2 \\ \vdots a_n\end{array}\right)\)&lt;/span> 即，A组能由B组表示。 则A与B的行向量组等价。&lt;/p>
&lt;h4 id="若-boldsymbola_m-times-n-boldsymbolb_n-times-lboldsymbolo-则-rboldsymbolarboldsymbolb-leqslant-n">若 &lt;span class="math inline">\(\boldsymbol{A}_{m \times n} \boldsymbol{B}_{n \times l}=\boldsymbol{O},\)&lt;/span> 则 &lt;span class="math inline">\(R(\boldsymbol{A})+R(\boldsymbol{B}) \leqslant n\)&lt;/span>&lt;/h4>
&lt;p>此条性质前面已有介绍：&lt;a href="./线性代数-矩阵的初等变换与线性方程组#矩阵秩的性质八：若%20$\boldsymbol%7BA%7D_%7Bm%20\times%20n%7D%20\boldsymbol%7BB%7D_%7Bn%20\times%20l%7D=\boldsymbol%7BO%7D,$%20则%20$R(\boldsymbol%7BA%7D)+R(\boldsymbol%7BB%7D)%20\leqslant%20n$">矩阵秩的性质八：若 &lt;span class="math inline">\(\boldsymbol{A}_{m \times n} \boldsymbol{B}_{n \times l}=\boldsymbol{O},\)&lt;/span> 则 &lt;span class="math inline">\(R(\boldsymbol{A})+R(\boldsymbol{B}) \leqslant n\)&lt;/span>&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>证明：&lt;/p>
&lt;p>记 &lt;span class="math inline">\(\boldsymbol{B}=\left(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{l}\right),\)&lt;/span> 则&lt;span class="math inline">\(\boldsymbol{A}\left(b_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{t}\right)=(\boldsymbol{0}, \boldsymbol{0}, \cdots, \boldsymbol{0})\)&lt;/span> &lt;span class="math inline">\(\boldsymbol{A} \boldsymbol{b}_{i}=\mathbf{0}(i=1,2, \cdots, l)\)&lt;/span> 表明矩阵B的个列向量都是齐次方程Ax=0的解。 记方程Ax=0的解集为S，则由 &lt;span class="math inline">\(b_{i} \in S\)&lt;/span> 即&lt;span class="math inline">\(b_i\)&lt;/span>都可以用S表示，知有 &lt;span class="math inline">\(R\left(b_{1}, b_{2}, \cdots, b_{l}\right) \leqslant R_{s},\)&lt;/span> 即 &lt;span class="math inline">\(R(\boldsymbol{B}) \leqslant R_{S}\)&lt;/span> 又根据齐次线性方程组解的性质，有&lt;span class="math inline">\(R(\boldsymbol{A})+R_{s}=n,\)&lt;/span> 故 &lt;span class="math inline">\(R(\boldsymbol{A})+R(\boldsymbol{B}) \leqslant n\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h3 id="非齐次线性方程组解的结构">非齐次线性方程组解的结构&lt;/h3>
&lt;h4 id="非齐次线性方程组">非齐次线性方程组&lt;/h4>
&lt;p>非齐次线性方程组（&lt;strong>方程组形式&lt;/strong>）： &lt;span class="math inline">\(\left\{\begin{array}{l}a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n}=b_{1} \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=b_{2} \\ \cdots \cdots \cdots \cdots \\ a_{m 1} x_{1}+a_{m 2} x_{2}+\cdots+a_{m n} x_{n}=b_{m}\end{array}\right.\)&lt;/span> 也可写作&lt;strong>向量方程&lt;/strong>：&lt;span class="math inline">\(A x=b\)&lt;/span>&lt;/p>
&lt;h4 id="非齐次方程组的解向量">非齐次方程组的解向量&lt;/h4>
&lt;p>向量方程：&lt;span class="math inline">\(A x=b\)&lt;/span>的解，就是对应的非齐次线性方程组的解向量。&lt;/p>
&lt;h4 id="非齐次方程组解向量的性质">非齐次方程组解向量的性质&lt;/h4>
&lt;p>以下两条性质，总结为：叠加性质&lt;/p>
&lt;h5 id="设-xeta_1-及-xeta_2-都是a-xb的解-则-xeta_1-eta_2-为对应的齐次线性方程组a-x0的解">设 &lt;span class="math inline">\(x=\eta_{1}\)&lt;/span> 及 &lt;span class="math inline">\(x=\eta_{2}\)&lt;/span> 都是&lt;span class="math inline">\(A x=b\)&lt;/span>的解, 则 &lt;span class="math inline">\(x=\eta_{1}-\eta_{2}\)&lt;/span> 为对应的齐次线性方程组&lt;span class="math inline">\(A x=0\)&lt;/span>的解&lt;/h5>
&lt;blockquote>
&lt;p>证明： &lt;span class="math inline">\(A\left(\eta_{1}-\eta_{2}\right)=A \eta_{1}-A \eta_{2}=b-b=0\)&lt;/span> 即 &lt;span class="math inline">\(x=\eta_{1}-\eta_{2}\)&lt;/span> 满足方程&lt;span class="math inline">\(A x=0\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="设-xeta-是方程a-xb的解-xxi-是方程a-x0的解-则-xxieta-仍是方程a-xb的解">设 &lt;span class="math inline">\(x=\eta\)&lt;/span> 是方程&lt;span class="math inline">\(A x=b\)&lt;/span>的解 &lt;span class="math inline">\(, x=\xi\)&lt;/span> 是方程&lt;span class="math inline">\(A x=0\)&lt;/span>的解, 则 &lt;span class="math inline">\(x=\xi+\eta\)&lt;/span> 仍是方程&lt;span class="math inline">\(A x=b\)&lt;/span>的解&lt;/h5>
&lt;blockquote>
&lt;p>证明： &lt;span class="math inline">\(A(\xi+\eta)=A \xi+A \eta=0+b=b\)&lt;/span> 即 &lt;span class="math inline">\(x=\xi+\eta\)&lt;/span> 满足方程&lt;span class="math inline">\(A x=b\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="非齐次方程组的通解">非齐次方程组的通解&lt;/h4>
&lt;p>由&lt;a href="#非齐次方程组解向量的性质">非齐次方程组解向量的性质&lt;/a>可知，若求得非齐次方程&lt;span class="math inline">\(A x=b\)&lt;/span>的一个解&lt;span class="math inline">\(\boldsymbol{\eta}^{*}\)&lt;/span>，&lt;span class="math inline">\(A x=b\)&lt;/span>的任一解总可表示为&lt;span class="math inline">\(x=\xi+\eta^*\)&lt;/span>，&lt;span class="math inline">\(x=\xi\)&lt;/span> 为齐次方程&lt;span class="math inline">\(A x=0\)&lt;/span>的解。&lt;/p>
&lt;p>齐次方程&lt;span class="math inline">\(A x=0\)&lt;/span>的通解为 &lt;span class="math inline">\(x=k_{1} \xi_{1}+\cdots+k_{n-r} \xi_{n-r}\)&lt;/span>，于是非齐次方程&lt;span class="math inline">\(A x=b\)&lt;/span>的任一解总可表示为&lt;span class="math inline">\(x=k_{1} \xi_{1}+\cdots+k_{n-r} \xi_{n-r}+\eta^*\)&lt;/span>&lt;/p>
&lt;p>对任何实数 &lt;span class="math inline">\(k_{1}, \cdots, k_{n-r},\)&lt;/span> 上式总是非齐次方程&lt;span class="math inline">\(A x=b\)&lt;/span>的解，所以&lt;strong>非齐次方程&lt;span class="math inline">\(A x=b\)&lt;/span>的通解&lt;/strong>为&lt;span class="math inline">\(x=k_{1} \xi_{1}+\cdots+k_{n-r} \xi_{n-r}+\eta^{*}\)&lt;/span> （&lt;span class="math inline">\(k_{1}, \cdots, k_{n-r}\)&lt;/span> 为任意实数 ），其中 &lt;strong>&lt;span class="math inline">\(\xi_{1}, \cdots, \xi_{n-r}\)&lt;/span> 是对应齐次方程&lt;span class="math inline">\(A x=0\)&lt;/span>的基础解系&lt;/strong>。&lt;/p>
&lt;h3 id="线性方程组的公共解">线性方程组的公共解&lt;/h3>
&lt;p>参考(superap)链接：https://www.zhihu.com/question/340362949/answer/885382762&lt;/p>
&lt;p>假设有A B两个矩阵，有&lt;strong>公共解&lt;/strong>是A的解里面有部分是可以当作B的解。而&lt;strong>同解&lt;/strong>就是A的解就是B的解。&lt;/p>
&lt;p>对于求公共解的问题有三种题型。&lt;/p>
&lt;p>第一种是给出了两个方程组，依次的系数矩阵为A B，则需要对A B作联立求解，类似求非齐次的求解方法，但是非齐次是列的联立，求公共解是行的联立。&lt;/p>
&lt;p>第二种题型是给出了一个方程组B，和另外的一个方程组B的通解。同样的把A的通解解出来，令两个解相等，构成了新的齐次方程组，这里的未知数是就是通解上面的k，解出k1 k2的通解在代入之前的通解即可。&lt;/p>
&lt;p>第三种题型，跟第二种类似了，只是给出了两个通解，方法还是类似的。令解相等，再求解，再代入。&lt;/p>
&lt;h2 id="向量空间">向量空间&lt;/h2>
&lt;h3 id="点空间">点空间&lt;/h3>
&lt;p>几何中，“空间”通常是作为点的集合，即作为“空间”的元素是点，这样的空间叫做&lt;strong>点空间&lt;/strong>。&lt;/p>
&lt;p>[^]:&lt;/p>
&lt;h3 id="向量空间-1">向量空间&lt;/h3>
&lt;h4 id="向量空间的定义">向量空间的定义&lt;/h4>
&lt;p>设V为n维向量的集合，如果&lt;strong>集合V非空&lt;/strong>，且&lt;strong>集合V对于向量的加法及乘数两种运算封闭&lt;/strong>，那么就称集合V为&lt;strong>向量空间&lt;/strong>。 &lt;strong>封闭&lt;/strong>：是指在集合V中可以进行向量的加法及乘数两种运算。具体地说,就是:若 &lt;span class="math inline">\(a \in V, b \in V,\)&lt;/span> 则 &lt;span class="math inline">\(a+b \in V ;\)&lt;/span> 若 &lt;span class="math inline">\(a \in V, \lambda \in \mathbb{R},\)&lt;/span> 则 &lt;span class="math inline">\(\lambda a \in V\)&lt;/span>&lt;/p>
&lt;h4 id="三维向量空间">三维向量空间&lt;/h4>
&lt;p>我们把3维向量的全体所组成的集合&lt;span class="math inline">\(\mathbb{R}^{3}=\left\{r=(x, y, z)^{\top}\mid x, y, z \in \mathbb{R}\right\}\)&lt;/span>叫做&lt;strong>三维向量空间&lt;/strong>.&lt;/p>
&lt;p>在点空间&lt;strong>取定坐标系&lt;/strong>以后,空间中的点 &lt;span class="math inline">\(P(x, y, z)\)&lt;/span> 与 3 维&lt;strong>向量&lt;/strong> &lt;span class="math inline">\(r=(x, y, z)^{\mathrm{T}}\)&lt;/span> 之间有&lt;strong>一一对应&lt;/strong>的关系。因此, &lt;strong>向量空间可以类比为取定了坐标系的点空间&lt;/strong>。&lt;/p>
&lt;p>在讨论&lt;strong>向量的运算&lt;/strong>时，我们把向量看作有向线段；在讨论&lt;strong>向量集&lt;/strong>时，则把向量r看作以r为向径的点P，从而把点P的轨迹作为向量集的图形。&lt;/p>
&lt;p>eg： 点集&lt;span class="math inline">\(\Pi=\{P(x, y, z) \mid a x+b y+c z=d\}\)&lt;/span>是一个平面（a,b,c不全为0）， 于是向量集&lt;span class="math inline">\(\left\{r=(x, y, z)^{\mathrm{T}} \mid a x+b y+c z=d\right\}\)&lt;/span>也叫做向量空间&lt;span class="math inline">\(\mathbb{R}^{3}\)&lt;/span>中的平面，并把Ⅱ作为它的图形&lt;/p>
&lt;h4 id="n维向量空间mathbbrn">n维向量空间&lt;span class="math inline">\(\mathbb{R}^{n}\)&lt;/span>&lt;/h4>
&lt;p>简单的说，&lt;strong>n维向量&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref">&lt;sup>2&lt;/sup>&lt;/a>的全体&lt;/strong>所构成的集合&lt;span class="math inline">\(\mathbb{R}^{n}\)&lt;/span>就是n维向量空间。&lt;/p>
&lt;p>后面介绍过空间向量的基之后，给出&lt;a href="#向量空间的基的定义">n维向量空间的严谨定义&lt;/a>。&lt;/p>
&lt;h4 id="齐次线性方程组的解空间">齐次线性方程组的解空间&lt;/h4>
&lt;p>齐次线性方程组的解集&lt;span class="math inline">\(S=\{x|A x=0\}\)&lt;/span>是一个向量空间（称为齐次线性方程组的解空间）。&lt;/p>
&lt;blockquote>
&lt;p>证明：由&lt;a href="#齐次方程组解的线性性质">齐次线性方程组的解的性质&lt;/a>得，其解集S对向量的线性运算封闭。&lt;/p>
&lt;/blockquote>
&lt;p>注：非齐次线性方程组的解集不是向量空间[^3]。 [^3]: 设当非齐次线性方程组的解集&lt;span class="math inline">\(S=\{x|A x=b\}\)&lt;/span>,当S为空时，空集不是向量空间；当S不为空时，设&lt;span class="math inline">\(\boldsymbol{\eta} \in S,\)&lt;/span> 则&lt;span class="math inline">\(A(2 \eta)=2 b \neq b,\)&lt;/span> 知 &lt;span class="math inline">\(2 \eta \notin S\)&lt;/span>，其解集S对数乘不封闭。同理也可知其解集对加法也不封闭。 由后面&lt;a href="#向量空间的基与对应的r维向量空间">向量空间的基与对应的r维向量空间&lt;/a>可知，向量空间可看作向量组，则齐次线性方程组解空间的基=解集的极大线性无关组=方程组的基础解系。&lt;/p>
&lt;h4 id="向量组-a_1-a_2-cdots-a_m-生成的向量空间">向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 生成的向量空间&lt;/h4>
&lt;h5 id="向量组生成的向量空间">向量组生成的向量空间&lt;/h5>
&lt;p>向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span> 所生成的向量空间为&lt;span class="math inline">\(L=\left\{x=\lambda_{1} a_{1}+\lambda_{2} a_{2}+\cdots+\lambda_{m} a_{m} \mid \lambda_{1}, \lambda_{2}, \cdots, \lambda_{m} \in \mathbb{R}\right\}\)&lt;/span>&lt;/p>
&lt;p>（易证此集对加法和数乘封闭，即此集为向量空间）&lt;/p>
&lt;h5 id="两个向量组等价rightarrow各自生成的向量空间相等">两个向量组等价&lt;span class="math inline">\(\Rightarrow\)&lt;/span>各自生成的向量空间相等&lt;/h5>
&lt;blockquote>
&lt;p>证明：&lt;/p>
&lt;p>设向量组 &lt;span class="math inline">\(a_{1}, \cdots, a_{m}\)&lt;/span> 与向量组 &lt;span class="math inline">\(b_{1}, \cdots, b,\)&lt;/span> 等价， 记： &lt;span class="math inline">\(L_{1}=\left\{x=\lambda_{1} a_{1}+\cdots+\lambda_{m} a_{m}\left|\lambda_{1}, \cdots, \lambda_{m} \in \mathbb{R}\right\}\right.\)&lt;/span> &lt;span class="math inline">\(L_{2}=\left\{x=\mu_{1} b_{1}+\cdots+\mu_{s} b_{s} \mid \mu_{1}, \cdots, \mu_{s} \in \mathbb{R}\right\}\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(x \in L_{1},\)&lt;/span> 则 &lt;span class="math inline">\(x\)&lt;/span> 可由 &lt;span class="math inline">\(a_{1}, \cdots, a_{m}\)&lt;/span> 线性表示.因 &lt;span class="math inline">\(a_{1}, \cdots, a_{m}\)&lt;/span> 可 由 &lt;span class="math inline">\(b_{1}, \cdots, b_{s}\)&lt;/span>线性表示，故 &lt;span class="math inline">\(x\)&lt;/span> 可由 &lt;span class="math inline">\(b_{1}, \cdots, b_{s}\)&lt;/span> 线性表示,所以 &lt;span class="math inline">\(x \in L_{2} .\)&lt;/span> 这就是说,若 &lt;span class="math inline">\(x \in L_{1},\)&lt;/span> 则 &lt;span class="math inline">\(x\in L_{2},\)&lt;/span> 因此 &lt;span class="math inline">\(L_{1} \subset L_{2}\)&lt;/span>&lt;/p>
&lt;p>类似地可证:若 &lt;span class="math inline">\(x \in L_{2},\)&lt;/span> 则 &lt;span class="math inline">\(x \in L_{1},\)&lt;/span> 因此 &lt;span class="math inline">\(L_{2} \subset L_{1}\)&lt;/span>&lt;/p>
&lt;p>因为 &lt;span class="math inline">\(L_{1} \subset L_{2}, L_{2} \subset L_{1},\)&lt;/span> 所以 &lt;span class="math inline">\(L_{1}=L_{2}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="向量空间的基与对应的r维向量空间">向量空间的基与对应的r维向量空间&lt;/h4>
&lt;h5 id="空间向量的基的定义">空间向量的基的定义&lt;/h5>
&lt;p>设 V 为向量空间,如果 &lt;span class="math inline">\(r\)&lt;/span> 个向量 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r} \in V,\)&lt;/span> 且满足： 1）&lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性无关； 2）&lt;span class="math inline">\(V\)&lt;/span> 中任一向量都可由 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 线性表示； 那么, &lt;strong>向量组 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span>&lt;/strong> 就称为向量空间 V 的&lt;strong>一个基&lt;/strong>。 r 称为向量空间 V 的维数。 并称 V 为 r 维向量空间。&lt;/p>
&lt;h5 id="向量空间v可看作向量组">向量空间V可看作向量组&lt;/h5>
&lt;h5 id="向量空间v的基就是向量组的最大无关组">向量空间V的基就是向量组的最大无关组&lt;/h5>
&lt;p>可把向量空间V看作向量组，那么向量空间V的基的定义与向量组&lt;a href="#向量组的极大线性无关组的第二种定义">最大无关组的第二种定义&lt;/a>完全相同。 向量空间V的基就是向量组的最大无关组，向量空间V的维数就是向量组的秩。&lt;/p>
&lt;p>求向量空间的基，可以转化为求向量组的最大无关组。&lt;/p>
&lt;p>由向量组的最大无关组不唯一可知，向量空间的基也不唯一。&lt;/p>
&lt;h4 id="向量空间v选定基之后向量空间中任意向量都可以用坐标表示">向量空间V选定基之后，向量空间中任意向量都可以用坐标表示&lt;/h4>
&lt;p>向量空间V选定基 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>向量组选定极大线性无关组 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>向量组中任意向量都可以用极大线性无关组唯一表示 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>向量空间中任意向量都可以用基唯一表示&lt;/p>
&lt;p>设&lt;strong>向量空间V选定的基为&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{r}\)&lt;/span>&lt;/strong>，任意向量x都可以用基&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{r}\)&lt;/span>唯一表示为&lt;span class="math inline">\(x=\lambda_{1} a_{1}+\lambda_{2} a_{2}+\cdots+\lambda_{r} a_{r}\)&lt;/span>，把数组&lt;span class="math inline">\(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{r}\)&lt;/span>，称为&lt;strong>向量 x 在基 &lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{r}\)&lt;/span> 中的坐标&lt;/strong>。&lt;/p>
&lt;p>特别地，在n维向量空间&lt;span class="math inline">\(\mathbb{R}^{n}\)&lt;/span>中取单位坐标向量组 &lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{n}\)&lt;/span> 为基,则以&lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 为分量的向量 &lt;span class="math inline">\(x,\)&lt;/span> 可表示为&lt;span class="math inline">\(x=x_{1} e_{1}+x_{2} e_{2}+\cdots+x_{n} e_{n}\)&lt;/span>。可见向量在基 &lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{n}\)&lt;/span> 中的坐标就是该向量的分量.因此, &lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{n}\)&lt;/span> 叫&lt;span class="math inline">\(\mathbb{R}^{n}\)&lt;/span>中的&lt;strong>自然基&lt;/strong>。&lt;/p>
&lt;h4 id="基变换与坐标变换">基变换与坐标变换&lt;/h4>
&lt;p>以&lt;span class="math inline">\(\mathbb{R}^{3}\)&lt;/span>空间为例， 假设原来的基&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \boldsymbol{a}_{3}\)&lt;/span>，新的基&lt;span class="math inline">\(b_{1}, b_{2}, b_{3}\)&lt;/span>。&lt;/p>
&lt;h5 id="基变换">基变换&lt;/h5>
&lt;p>即用原来的基&lt;span class="math inline">\(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \boldsymbol{a}_{3}\)&lt;/span>表示新的基&lt;span class="math inline">\(b_{1}, b_{2}, b_{3}\)&lt;/span>。&lt;/p>
&lt;h6 id="方法一以自然基为媒介变换">方法一：以自然基为媒介变换&lt;/h6>
&lt;p>设 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{1}, a_{2}, a_{3}\right), B=\left(b_{1}, b_{2}, b_{3}\right)\)&lt;/span> 用自然基表示A：&lt;span class="math inline">\(\left(a_{1}, a_{2}, a_{3}\right)=\left(e_{1}, e_{2}, e_{3}\right) A\)&lt;/span>， 则自然基为：&lt;span class="math inline">\(\left(e_{1}, e_{2}, e_{3}\right)=\left(a_{1}, a_{2}, a_{3}\right) A^{-1}\)&lt;/span> 用自然基表示B：&lt;span class="math inline">\(\left(b_{1}, b_{2}, b_{3}\right)=\left(e_{1}, e_{2}, e_{3}\right) B=\left(a_{1}, a_{2}, a_{3}\right) A^{-1} B\)&lt;/span>&lt;/p>
&lt;p>记&lt;span class="math inline">\(P=A^{-1} B\)&lt;/span>，则&lt;span class="math inline">\(\left(b_{1}, b_{2}, b_{3}\right)=\left(a_{1}, a_{2}, a_{3}\right) P\)&lt;/span>，这里的P称为过渡矩阵。&lt;/p>
&lt;h6 id="方法二矩阵乘法">方法二：矩阵乘法&lt;/h6>
&lt;p>&lt;span class="math inline">\(b_{1}=\left(a, a_{2}, a_{3}\right)\left(\begin{array}{l}x_{11} \\ x_{21} \\ x_{31}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(b_{2}=\left(a, a_{2}, a_{3}\right)\left(\begin{array}{l}x_{12} \\ x_{22} \\ x_{32}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(b_{3}=\left(a, a_{2}, a_{3}\right)\left(\begin{array}{l}x_{13} \\ x_{23} \\ x_{33}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(b_{1}, b_{2}, b_{3}\right)=\left(a, a_{2}, a_{3}\right)\left[\begin{array}{lll}x_{11} &amp;amp; x_{22} &amp;amp; x_{13} \\ x_{11} &amp;amp; x_{22} &amp;amp; x_{23} \\ x_{31} &amp;amp; x_{32} &amp;amp; x_{33}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>记&lt;span class="math inline">\(P=\left[\begin{array}{lll}x_{11} &amp;amp; x_{22} &amp;amp; x_{13} \\ x_{11} &amp;amp; x_{22} &amp;amp; x_{23} \\ x_{31} &amp;amp; x_{32} &amp;amp; x_{33}\end{array}\right]\)&lt;/span>，同样有&lt;span class="math inline">\(P=A^{-1} B\)&lt;/span>，则&lt;span class="math inline">\(\left(b_{1}, b_{2}, b_{3}\right)=\left(a_{1}, a_{2}, a_{3}\right) P\)&lt;/span>，这里的P称为过渡矩阵。&lt;/p>
&lt;h5 id="坐标变换">坐标变换&lt;/h5>
&lt;p>设向量 x 在旧基和新基中的坐标分别为 &lt;span class="math inline">\(y_{1}, y_{2}, y_{3}\)&lt;/span> 和 &lt;span class="math inline">\(z_{1}, z_{2}, z_{3},\)&lt;/span> 即： &lt;span class="math inline">\(x=\left(a_{1}, a_{2}, a_{3}\right)\left(\begin{array}{l}y_{1} \\ y_{2} \\ y_{3}\end{array}\right)\)&lt;/span>，&lt;span class="math inline">\(x=\left(b_{1}, b_{2}, b_{3}\right)\left(\begin{array}{l}z_{1} \\ z_{2} \\ z_{3}\end{array}\right)\)&lt;/span> 故： &lt;span class="math inline">\(\boldsymbol{A}\left[\begin{array}{l}y_{1} \\ y_{2} \\ y_{3}\end{array}\right]=\boldsymbol{B}\left[\begin{array}{l}z_{1} \\ z_{2} \\ z_{3}\end{array}\right]\)&lt;/span> 得： &lt;span class="math inline">\(\left[\begin{array}{l}z_{1} \\ z_{2} \\ z_{3}\end{array}\right]=\boldsymbol{B}^{-1} \boldsymbol{A}\left[\begin{array}{l}y_{1} \\ y_{2} \\ y_{3}\end{array}\right]\)&lt;/span> 即： &lt;span class="math inline">\(\left(\begin{array}{l}z_{1} \\ z_{2} \\ z_{3}\end{array}\right)=\boldsymbol{P}^{-1}\left(\begin{array}{l}y_{1} \\ y_{2} \\ y_{3}\end{array}\right)\)&lt;/span> 这就是从旧坐标到新坐标的坐标变换公式&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>注：&lt;span class="math inline">\(x_1\)&lt;/span>列可以不作为行最简形矩阵的起始列，那么就不能采用上述化系数矩阵为行最简形矩阵的“标准程序”，而要稍作变化，化为打乱列的顺序的B矩阵。&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2" role="doc-endnote">&lt;p>注：在解析几何中，我们把“既有大小又有方向的量”叫做向量，并把可随意平行移动的有向线段作为向量的几何形象。在引进坐标系以后，这种向量就有了坐标表示式——三个有次序的实数，也就是本书中的3维向量。因此，当n≤3时，n维向量可以把有向线段作为几何形象，但当n&amp;gt;3时，n维向量就不再有这种几何形象，只是沿用一些几何术语罢了。&lt;a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>线性代数-向量组的线性相关性习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/</link><pubDate>Mon, 10 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-向量组的线性相关性习题">线性代数-向量组的线性相关性习题&lt;/h1>
&lt;h2 id="向量组与矩阵">向量组与矩阵&lt;/h2>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927202411878.png" alt="" />&lt;figcaption>image-20200927202411878&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927203348612.png" alt="" />&lt;figcaption>image-20200927203348612&lt;/figcaption>
&lt;/figure>
&lt;p>(1)由于AP=PB， 即： &lt;span class="math inline">\(A(x，Ax，A^2x)\\=(Ax，A^2x，A^3x)\\=(Ax，A^2x，3Ax-2A^2x)\\=(x，Ax，A^2x)\left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\)&lt;/span> ， 从而： &lt;span class="math inline">\(AP=P \left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\)&lt;/span> ， 所以： &lt;span class="math inline">\(B＝ \left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\)&lt;/span>&lt;/p>
&lt;ol start="2" type="1">
&lt;li>&lt;span class="math inline">\(|A|=|PAP^{-1}|\\ =|P|\cdot |B| \cdot |P^{-1}|\\ =|P|\cdot |B| \cdot |P|^{-1}\\ =|B| =0\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;h2 id="向量组的线性表示">向量组的线性表示&lt;/h2>
&lt;h3 id="向量b可由向量组a线性表示的证明">向量b可由向量组A线性表示的证明&lt;/h3>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926165347373.png" alt="" />&lt;figcaption>image-20200926165347373&lt;/figcaption>
&lt;/figure>
&lt;ol type="1">
&lt;li>要证： &lt;span class="math inline">\(a_{1}\)&lt;/span> 能由 &lt;span class="math inline">\(a_{2}, a_{3}\)&lt;/span> 线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 即证&lt;span class="math inline">\(a_1 = (a_2, a_3) \left(\begin{array}{c} k_1 \\ k_2 \end{array}\right)\)&lt;/span>有解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 即证&lt;span class="math inline">\(R(a_2, a_3) = R(a_2, a_3, a_1)\)&lt;/span> 由&lt;span class="math inline">\(R\left(a_{2}, a_{3}, a_{4}\right)=3\)&lt;/span>得，&lt;span class="math inline">\(a_{2}, a_{3}, a_{4}\)&lt;/span>线性无关，则&lt;span class="math inline">\(a_{2}, a_{3}\)&lt;/span>线性无关，则&lt;span class="math inline">\(R(a_{2}, a_{3})=2\)&lt;/span> 又&lt;span class="math inline">\(R\left(a_{1}, a_{2}, a_{3}\right)=2\)&lt;/span> 则&lt;span class="math inline">\(R\left(a_{1}, a_{2}, a_{3}\right)=R(a_2, a_3)\)&lt;/span>，则&lt;span class="math inline">\(a_1 = (a_2, a_3) \left(\begin{array}{c} k_1 \\ k_2 \end{array}\right)\)&lt;/span>有解，则&lt;span class="math inline">\(a_{1}\)&lt;/span> 能由 &lt;span class="math inline">\(a_{2}, a_{3}\)&lt;/span> 线性表示&lt;/li>
&lt;/ol>
&lt;p>(2)要证&lt;span class="math inline">\(a_{4}\)&lt;/span> 不能由 &lt;span class="math inline">\(a_{1}, a_{2}, a_{3}\)&lt;/span> 线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 即证&lt;span class="math inline">\(a_4 = (a_1,a_2, a_3) \left(\begin{array}{c} x_1 \\ x_2 \\x_3 \end{array}\right)\)&lt;/span>无解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 即证&lt;span class="math inline">\(R(a_1,a_2, a_3) &amp;lt; R(a_1,a_2, a_3,a_4 )\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(R(a_1,a_2, a_3,a_4 ) \ge R\left(a_{2}, a_{3}, a_{4}\right)=3 &amp;gt; R\left(a_{1}, a_{2}, a_{3}\right)=2\)&lt;/span> 则&lt;span class="math inline">\(a_4 = (a_1,a_2, a_3) \left(\begin{array}{c} x_1 \\ x_2 \\x_3 \end{array}\right)\)&lt;/span>无解， 则&lt;span class="math inline">\(a_{4}\)&lt;/span> 不能由 &lt;span class="math inline">\(a_{1}, a_{2}, a_{3}\)&lt;/span> 线性表示&lt;/p>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927092132911.png" alt="" />&lt;figcaption>image-20200927092132911&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927092235953.png" alt="" />&lt;figcaption>image-20200927092235953&lt;/figcaption>
&lt;/figure>
&lt;p>解:由题意知，λbai1(a1+b)=λ2(a2+b) 其中，λdu1≠λzhi2，且两数不全为0&lt;/p>
&lt;p>于是dao有:(λ2-λ1)b=λ1a1-λ2a2&lt;/p>
&lt;p>b=a1λ1/(λ2-λ1)-a2λ2/(λ2-λ1)&lt;/p>
&lt;p>令λ1/(λ2-λ1)=c，则:&lt;/p>
&lt;p>λ2/(λ2-λ1)=1+c，(c∈R)&lt;/p>
&lt;p>于是，b=ca1-(1+c)a2&lt;/p>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927165644688.png" alt="" />&lt;figcaption>image-20200927165644688&lt;/figcaption>
&lt;/figure>
&lt;p>证法一： 先证必要性（前推后），因为任意n+1个n维向量必线性相关。所以任意向量b与a1…an相关。存在不完全为0的n+1个数k1…kn,kn+1.使得k1&lt;em>a1+…kn&lt;/em>an+kn+1*b=0；若kn+1=0，a1…an相关，矛盾，所以kn+1不等于0.即b可以被a1…an线性表出。即表示为a1…an的线性组合。 充分性，n维单位向量e1…en可以被a1…an线性表出。a1…an也可以被e1…en线性表出。所以他们等价。所以a1…an的秩为n。所以a1…an线性无关。 证毕。&lt;/p>
&lt;p>证法二： 必要性: a1,a2,…an线性无关 =&amp;gt; |a1,a2,…an| ≠ 0 =&amp;gt; 对任一n维向量b, (a1,a2,…an)X = b 有解 =&amp;gt; 任一n维向量b都可被a1,a2,…an线性表示 充分性: 因为任一n维向量都可被a1,a2,…an线性表示 所以n维基本向量组ε1,ε2,…,εn可由a1,a2,…an线性表示 所以 n = r(ε1,ε2,…,εn) &amp;lt;= r(a1,a2,…an). 所以 a1,a2,…an 线性无关.&lt;/p>
&lt;h6 id="例4-存在类的证明一般用反证法">例4 存在类的证明一般用反证法&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927171454868.png" alt="" />&lt;figcaption>image-20200927171454868&lt;/figcaption>
&lt;/figure>
&lt;p>解： 设对任一&lt;span class="math inline">\(a_k (2\le k \le m)\)&lt;/span>都不能由&lt;span class="math inline">\(a_1, a_2, ... , a_{k-1}\)&lt;/span>线性表示， 则&lt;span class="math inline">\((a_1, a_2, ... , a_{k-1})x = a_k\)&lt;/span>无解， 则&lt;span class="math inline">\(r(a_1, a_2, ... , a_{k-1}) &amp;lt; r(a_1, a_2, ... , a_{k-1}, a_k)\)&lt;/span> 则&lt;span class="math inline">\(1=r(a_1) &amp;lt; r(a_1, a_2)&amp;lt;...&amp;lt;r(a_1, a_2, ... , a_{k})\)&lt;/span> 则&lt;span class="math inline">\(r(a_1, a_2, ... , a_{k}) = k\)&lt;/span> 取&lt;span class="math inline">\(k=m\)&lt;/span>，得&lt;span class="math inline">\(r(a_1, a_2, ... , a_{m}) = m\)&lt;/span>, 即有&lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{m}\)&lt;/span>线性无关，这与已知矛盾。 所有假设不成立，所以存在某个向量 &lt;span class="math inline">\(a_{k}(2 \leqslant k \leqslant m)\)&lt;/span>,使&lt;span class="math inline">\(a_{k}\)&lt;/span> 能由 &lt;span class="math inline">\(a_{1}, \cdots, a_{k-1}\)&lt;/span> 线性表示。&lt;/p>
&lt;h3 id="向量组b可由向量组a线性表示的证明">向量组B可由向量组A线性表示的证明&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926161823988.png" alt="" />&lt;figcaption>image-20200926161823988&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926161848654.png" alt="" />&lt;figcaption>image-20200926161848654&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926161905883.png" alt="" />&lt;figcaption>image-20200926161905883&lt;/figcaption>
&lt;/figure>
&lt;p>注意到：&lt;/p>
&lt;p>B组能由A线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>B=AX有解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r(A)=r(A,B)\)&lt;/span>&lt;/p>
&lt;p>A组不能由B线性表示&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>A=BX无解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r(B)&amp;lt;r(A,B)\)&lt;/span>&lt;/p>
&lt;h3 id="向量组b与向量组a等价的证明">向量组B与向量组A等价的证明&lt;/h3>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926162956189.png" alt="" />&lt;figcaption>image-20200926162956189&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926163010322.png" alt="" />&lt;figcaption>image-20200926163010322&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200926163021868.png" alt="" />&lt;figcaption>image-20200926163021868&lt;/figcaption>
&lt;/figure>
&lt;p>注意到：&lt;/p>
&lt;p>向量组B与向量组A等价&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r(A) = r(B) = r(A,B)\)&lt;/span>&lt;/p>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927175711215.png" alt="" />&lt;figcaption>image-20200927175711215&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927175724101.png" alt="" />&lt;figcaption>image-20200927175724101&lt;/figcaption>
&lt;/figure>
&lt;p>解： 根据已知：向量组&lt;span class="math inline">\(\beta_1, \beta_2, ..., \beta_n\)&lt;/span>可以由向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span>表示，可以写成矩阵方程： &lt;span class="math inline">\((\beta_1, \beta_2, ..., \beta_n) = (\alpha_1, \alpha_2, ... \alpha_n)\left[\begin{array}{c}0 &amp;amp; 1 &amp;amp;\cdots &amp;amp;1 \\1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1 \\ \vdots &amp;amp; \vdots &amp;amp; \ddots&amp;amp; \vdots \\ 1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0\end{array}\right]\)&lt;/span> 记&lt;span class="math inline">\(P=\left[\begin{array}{c}0 &amp;amp; 1 &amp;amp;\cdots &amp;amp;1 \\1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1 \\ \vdots &amp;amp; \vdots &amp;amp; \ddots&amp;amp; \vdots \\ 1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0\end{array}\right]\)&lt;/span> 即&lt;span class="math inline">\((\beta_1, \beta_2, ..., \beta_n) = (\alpha_1, \alpha_2, ... \alpha_n)P\)&lt;/span> 由于&lt;span class="math inline">\(|P| \neq 0\)&lt;/span>,则系数矩阵P可逆。 则&lt;span class="math inline">\((\beta_1, \beta_2, ..., \beta_n) P^{-1}= (\alpha_1, \alpha_2, ... \alpha_n)\)&lt;/span> 即向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span>可由向量组&lt;span class="math inline">\(\beta_1, \beta_2, ..., \beta_n\)&lt;/span>表示。&lt;/p>
&lt;p>则两个向量组可以互相表示，即两个向量组等价。&lt;/p>
&lt;h2 id="向量组的相关性">向量组的相关性&lt;/h2>
&lt;h3 id="向量组的相关性的判断根据秩">向量组的相关性的判断（根据秩）&lt;/h3>
&lt;p>向量组的线性相关性&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span>&lt;span class="math inline">\(Ax=0\)&lt;/span>是否有非零解&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(R(A)&amp;lt;n\)&lt;/span>是否成立&lt;/p>
&lt;p>可以用行列式判断秩，也可以用矩阵初等变换来看秩&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927003122343.png" alt="" />&lt;figcaption>image-20200927003122343&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927003046573.png" alt="" />&lt;figcaption>image-20200927003046573&lt;/figcaption>
&lt;/figure>
&lt;p>行列式判断秩比较简单&lt;/p>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927004552653.png" alt="" />&lt;figcaption>image-20200927004552653&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927004605037.png" alt="" />&lt;figcaption>image-20200927004605037&lt;/figcaption>
&lt;/figure>
&lt;p>行列式=0比较简单&lt;/p>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927152333868.png" alt="" />&lt;figcaption>image-20200927152333868&lt;/figcaption>
&lt;/figure>
&lt;p>解： &lt;span class="math inline">\(e_{1}, e_{2}, \cdots, e_{n}\)&lt;/span>能由&lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)&lt;/span>线性表示，则&lt;span class="math inline">\(n=r(e_{1}, e_{2}, \cdots, e_{n}) \le r(a_{1}, a_{2}, \cdots, a_{n})\)&lt;/span> 又&lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)&lt;/span>都是n维向量，则可以确定&lt;span class="math inline">\(r(a_{1}, a_{2}, \cdots, a_{n})=n\)&lt;/span>, 则&lt;span class="math inline">\(a_{1}, a_{2}, \cdots, a_{n}\)&lt;/span>线性无关。&lt;/p>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927174154287.png" alt="" />&lt;figcaption>image-20200927174154287&lt;/figcaption>
&lt;/figure>
&lt;p>向量组B线性无关 &amp;lt;=&amp;gt; (b1,b2,…,br)X=0 只有零解 &amp;lt;=&amp;gt; (a1,a2,…,as)KX = 0 只有零解 –因为 向量组A线性无关 –所以 &amp;lt;=&amp;gt; KX = 0 只有零解 &amp;lt;=&amp;gt; r(K) = r (K的列数). https://zhidao.baidu.com/question/327222311.html?seed=0&lt;/p>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928172516564.png" alt="" />&lt;figcaption>image-20200928172516564&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928172538128.png" alt="" />&lt;figcaption>image-20200928172538128&lt;/figcaption>
&lt;/figure>
&lt;h3 id="向量组的相关性的判断反证法">向量组的相关性的判断（反证法）&lt;/h3>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927093619183.png" alt="" />&lt;figcaption>image-20200927093619183&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927093628977.png" alt="" />&lt;figcaption>image-20200927093628977&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927093703581.png" alt="" />&lt;figcaption>image-20200927093703581&lt;/figcaption>
&lt;/figure>
&lt;p>注意：0向量和任意向量都线性相关。&lt;/p>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927094901168.png" alt="" />&lt;figcaption>image-20200927094901168&lt;/figcaption>
&lt;/figure>
&lt;p>略&lt;/p>
&lt;h6 id="例3-涉及到后面线性方程组解的结构">例3 涉及到后面线性方程组解的结构&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928192846148.png" alt="" />&lt;figcaption>image-20200928192846148&lt;/figcaption>
&lt;/figure>
&lt;p>（1） 设非齐次线性方程组AX=b的特解为 X(0)；导出组的一个基础解系为 X(1),X(2),……，X(n-r)； 反设上述向量线性相关，则存在不全为零的数C(i)使得 C(0)X(0)+C(1)X(1)+C(2)X(2)+……+C(n-r)X(n-r)=0 等号两边同时乘以A，左边成为b，右边却是0。这与b不等于零向量矛盾。&lt;/p>
&lt;p>（2）由（1）已知&lt;span class="math inline">\(\eta^{*}, \xi_{1}, \cdots, \xi_{n-r}\)&lt;/span>线性无关，则&lt;span class="math inline">\(r(\eta^{*}, \xi_{1}, \cdots, \xi_{n-r})=n-r\)&lt;/span>， 则对应矩阵的秩也为n-r （矩阵的列向量组的秩等于矩阵的秩）， 矩阵&lt;span class="math inline">\((\eta^{*}, \eta^{*}+\xi_{1}, \cdots, \eta^{*}+\xi_{n-r})\)&lt;/span>初等列变换可变为&lt;span class="math inline">\((\eta^{*}, \xi_{1}, \cdots, \xi_{n-r})\)&lt;/span>，初等变换不改变矩阵的秩。 则矩阵的秩有&lt;span class="math inline">\(r(\eta^{*}, \eta^{*}+\xi_{1}, \cdots, \eta^{*}+\xi_{n-r})=r(\eta^{*}, \xi_{1}, \cdots, \xi_{n-r})=n-r\)&lt;/span> 则对应向量组的秩也为&lt;span class="math inline">\(r(\eta^{*}, \eta^{*}+\xi_{1}, \cdots, \eta^{*}+\xi_{n-r})=n-r\)&lt;/span> 则&lt;span class="math inline">\(\eta^{*}, \eta^{*}+\xi_{1}, \cdots, \eta^{*}+\xi_{n-r}\)&lt;/span>线性无关。&lt;/p>
&lt;h3 id="向量组的相关性的判断代换法">向量组的相关性的判断（代换法）&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927101618671.png" alt="" />&lt;figcaption>image-20200927101618671&lt;/figcaption>
&lt;/figure>
&lt;p>解： &lt;span class="math inline">\(b_4 = a_4 + a_1 = b_3 - a_3 + b_1 - a_2 = b_3 + b_1 - (a_3 + a_2) = b_3 + b_1 - b_2\)&lt;/span> 即&lt;span class="math inline">\(b_1 - b_2+b_3 - b_4 = 0\)&lt;/span> 则存在一组不全为零的系数(1,-1,1,-1)使得&lt;span class="math inline">\(b_{1}, b_{2}, b_{3}, b_{4}\)&lt;/span>的线性组合为0. 即&lt;span class="math inline">\(b_{1}, b_{2}, b_{3}, b_{4}\)&lt;/span>线性相关。&lt;/p>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927103041104.png" alt="" />&lt;figcaption>image-20200927103041104&lt;/figcaption>
&lt;/figure>
&lt;p>b1=a1,b2=a1+a2,…..,br=a1+a2a+….+ar 设常数k1，baik2……dukr满足k1b1+k2b2+……+krbr=0 把b1，b2，……br带入中 （k1+k2+……+kr)a1+(k2+k3+……+kr)a2+……+krar=0 向量组zhia1,a2…ar线性无关 则k1+k2+……+kr=0 k2+k3+……+kr=0 …… kr=0 解得k1=0，k2=0，……kn=0 即只有全为0的常数k才能使k1b1+k2b2+……+krbr=0 向量组b1,b2,…br线性无关&lt;/p>
&lt;h2 id="向量组的秩与极大线性无关组">向量组的秩与极大线性无关组&lt;/h2>
&lt;h3 id="计算向量组的秩与极大线性无关组以及用极大线性无关组表示其他向量">计算向量组的秩与极大线性无关组以及用极大线性无关组表示其他向量&lt;/h3>
&lt;p>向量组的秩=对应矩阵的秩；对于列向量组，初等行变换不改变各列向量之间的比例关系。&lt;/p>
&lt;p>可根据矩阵的初等变换来看向量组的秩； 但是确定极大线性无关组之后，用极大无关组表示其他向量，为保持各列向量之间的比例关系，矩阵变换只能用行变换。&lt;/p>
&lt;p>注意：最大无关组不唯一。&lt;/p>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927105645033.png" alt="" />&lt;figcaption>image-20200927105645033&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927105658428.png" alt="" />&lt;figcaption>image-20200927105658428&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927111604994.png" alt="" />&lt;figcaption>image-20200927111604994&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927111631289.png" alt="" />&lt;figcaption>image-20200927111631289&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927113654355.png" alt="" />&lt;figcaption>image-20200927113654355&lt;/figcaption>
&lt;/figure>
&lt;p>注意：最大无关组不唯一。&lt;/p>
&lt;h3 id="已知秩计算向量组中的参数">已知秩计算向量组中的参数&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927142512331.png" alt="" />&lt;figcaption>image-20200927142512331&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927142529127.png" alt="" />&lt;figcaption>image-20200927142529127&lt;/figcaption>
&lt;/figure>
&lt;p>解： 向量组对应的矩阵记为A， 对A进行初等行变换。 变换过程中需要讨论a是否为0， 当a=0时，有3阶子行列式不为0，与向量组的秩=矩阵的秩=2矛盾。 则&lt;span class="math inline">\(a\neq 0\)&lt;/span>。 继续初等行变换，应有两行对应成比例，或者对应位置为0， 从而得到&lt;span class="math inline">\(a=2, b=5\)&lt;/span>&lt;/p>
&lt;h3 id="向量组秩的证明">向量组秩的证明&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928131719594.png" alt="" />&lt;figcaption>image-20200928131719594&lt;/figcaption>
&lt;/figure>
&lt;p>解： &lt;span class="math inline">\(A^2 = A\)&lt;/span> 则&lt;span class="math inline">\((A-E)A = 0\)&lt;/span>， 根据矩阵秩的性质八知，若 &lt;span class="math inline">\((A-E)A = 0\)&lt;/span> 则 &lt;span class="math inline">\(R(\boldsymbol{A -E})+R(\boldsymbol{A}) \leqslant n\)&lt;/span> 根据矩阵秩的性质六知，&lt;span class="math inline">\(n=R(-E)= R[(A-E)+(-A)] \leqslant R(A-E) + R(A)\)&lt;/span> 综上可知&lt;span class="math inline">\(R(A-E) + R(A) = n\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>注： 矩阵秩的性质六：&lt;span class="math inline">\(R(\boldsymbol{A}+\boldsymbol{B}) \leqslant R(\boldsymbol{A})+R(\boldsymbol{B})\)&lt;/span> 矩阵秩的性质八：若 &lt;span class="math inline">\(\boldsymbol{A}_{m \times n} \boldsymbol{B}_{n \times l}=\boldsymbol{O},\)&lt;/span> 则 &lt;span class="math inline">\(R(\boldsymbol{A})+R(\boldsymbol{B}) \leqslant n\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928144834170.png" alt="" />&lt;figcaption>image-20200928144834170&lt;/figcaption>
&lt;/figure>
&lt;p>证明：(用到了矩阵秩的性质八：&lt;span class="math inline">\(r(A)+r(A^*)\le n\)&lt;/span>，学完矩阵的秩和向量组之后再看这里的证明) 设A为n阶&lt;/p>
&lt;p>若r（A）=n，则丨A丨不等于0，&lt;span class="math inline">\(A^*=丨A丨A^{-1}\)&lt;/span>可逆，推出&lt;span class="math inline">\(r(A^*)=n\)&lt;/span>。&lt;/p>
&lt;p>若r（A）=n-2，则&lt;span class="math inline">\(丨A丨=0\)&lt;/span>且n-1阶子式全为0，因此&lt;span class="math inline">\(A^*=0\)&lt;/span>，即&lt;span class="math inline">\(r(A^*)=0\)&lt;/span>&lt;/p>
&lt;p>若r（A）=n-1，则丨A丨等于0且存在n-1阶子式不为0，因此&lt;span class="math inline">\(A^*\)&lt;/span>不等于0，&lt;span class="math inline">\(r(A^*)\ge 1\)&lt;/span> 又因为 &lt;span class="math inline">\(AA^*=丨A丨E=0\)&lt;/span>，&lt;span class="math inline">\(r(A)+r(A^*)\le n\)&lt;/span>，&lt;span class="math inline">\(r(A^*)\le n-r(A) = 1\)&lt;/span> 就可以得到&lt;span class="math inline">\(r(A^*)=1\)&lt;/span>&lt;/p>
&lt;h2 id="线性方程组">线性方程组&lt;/h2>
&lt;h3 id="齐次线性方程组">齐次线性方程组&lt;/h3>
&lt;h4 id="齐次线性方程组的通解与基础解系">齐次线性方程组的通解与基础解系&lt;/h4>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927222014489.png" alt="" />&lt;figcaption>image-20200927222014489&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927222039245.png" alt="" />&lt;figcaption>image-20200927222039245&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927222102460.png" alt="" />&lt;figcaption>image-20200927222102460&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927225338909.png" alt="" />&lt;figcaption>image-20200927225338909&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927225352312.png" alt="" />&lt;figcaption>image-20200927225352312&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927235212548.png" alt="" />&lt;figcaption>image-20200927235212548&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200927235236463.png" alt="" />&lt;figcaption>image-20200927235236463&lt;/figcaption>
&lt;/figure>
&lt;p>设齐次线性方程组AX=0的基础解系为a1=(0,1,2,3)&lt;sup>T,a2=(3,2,1,0)&lt;/sup>T 即a1=(0,1,2,3)&lt;sup>T,a2=(3,2,1,0)&lt;/sup>T是齐次线性方程组AX=0的两个特解 设A=(A1 A2)^T,其中A1,A2为4维列向量,A为2&lt;em>4阶矩阵 则(A1 A2)^T &lt;/em> (a1 a2) = 0 等式两边同时转置得 (a1 a2)^T * (A1 A2) = 0 问题转化为求解新齐次线性方程组的基础解系 增广矩阵为 0 1 2 3 0 3 2 1 0 0 初等行变换 1 0 -1 -2 0 0 1 2 3 0 所以新齐次线性方程组的基础解系为A1=(1,-2,1,0)&lt;sup>T,A2=(2,-3,0,1)&lt;/sup>T 所以所求的齐次线性方程组AX=0为 x1-2x2+x3=0 2x1-3x2+x4=0 原理: ξ是齐次线性方程组的解 的充要条件是 ξ与系数矩阵的行向量正交 所以只要寻找与a1,a2都正交的向量A1,A2,即可构成所求齐次线性方程组的系数矩阵 https://www.zybang.com/question/34bee07d0fbe4c454e4cf0bc4fa0f6e2.html&lt;/p>
&lt;h4 id="齐次线性方程组的公共解">齐次线性方程组的公共解&lt;/h4>
&lt;p>参考来源：https://www.zhihu.com/question/340362949/answer/885382762&lt;/p>
&lt;p>假设有A B两个矩阵，有公共解是A的解里面有部分是可以当作B的解。而同解就是A的解就是B的解。&lt;/p>
&lt;p>对于求公共解的问题有三种题型。&lt;/p>
&lt;p>第一种是给出了两个方程组，依次的系数矩阵为A B，则需要对A B作联立求解，类似求非齐次的求解方法，但是非齐次是列的联立，求公共解是行的联立。&lt;/p>
&lt;p>第二种题型是给出了一个方程组B，和另外的一个方程组B的通解。同样的把A的通解解出来，令两个解相等，构成了新的齐次方程组，这里的未知数是就是通解上面的k，解出k1 k2的通解在代入之前的通解即可。&lt;/p>
&lt;p>第三种题型，跟第二种类似了，只是给出了两个通解，方法还是类似的。令解相等，再求解，再代入。&lt;/p>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928125015902.png" alt="" />&lt;figcaption>image-20200928125015902&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928125034540.png" alt="" />&lt;figcaption>image-20200928125034540&lt;/figcaption>
&lt;/figure>
&lt;h3 id="非齐次线性方程组">非齐次线性方程组&lt;/h3>
&lt;h4 id="计算非齐次方程的通解与基础解系">计算非齐次方程的通解与基础解系&lt;/h4>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928152522409.png" alt="" />&lt;figcaption>image-20200928152522409&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928152619425.png" alt="" />&lt;figcaption>image-20200928152619425&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928154040946.png" alt="" />&lt;figcaption>image-20200928154040946&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928154049369.png" alt="" />&lt;figcaption>image-20200928154049369&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928154102666.png" alt="" />&lt;figcaption>image-20200928154102666&lt;/figcaption>
&lt;/figure>
&lt;p>解： 设该4元非齐次线性方程组为&lt;span class="math inline">\(Ax=b\)&lt;/span> 则&lt;span class="math inline">\(A(\eta_2+\eta_3) = 2b\)&lt;/span>, &lt;span class="math inline">\(A\eta_1 = b\)&lt;/span> 则&lt;span class="math inline">\(A(\eta_2+\eta_3 - 2\eta_1) = 0\)&lt;/span> 则&lt;span class="math inline">\(kA(\eta_2+\eta_3 - 2\eta_1) = 0\)&lt;/span> 则&lt;span class="math inline">\(k(\eta_2+\eta_3 - 2\eta_1)\)&lt;/span>是对应的齐次线性方程&lt;span class="math inline">\(Ax=0\)&lt;/span>的解。 &lt;span class="math inline">\(k(\eta_2+\eta_3 - 2\eta_1)= k\left(\begin{array}{c}-3\\-4\\-5\\-6\end{array}\right)\)&lt;/span> 又对应的齐次线性方程&lt;span class="math inline">\(Ax=0\)&lt;/span>的秩&lt;span class="math inline">\(R_s = n - r(A) = 4-3 = 1\)&lt;/span> 则&lt;span class="math inline">\(Ax=0\)&lt;/span>的通解为：&lt;span class="math inline">\(k\left(\begin{array}{c}-3\\-4\\-5\\-6\end{array}\right)=k_1\left(\begin{array}{c}3\\4\\5\\6\end{array}\right)\)&lt;/span> 则&lt;span class="math inline">\(Ax=b\)&lt;/span>的通解为：&lt;span class="math inline">\(\left(\begin{array}{c}2\\3\\4\\5\end{array}\right)+k_1\left(\begin{array}{c}3\\4\\5\\6\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928183352105.png" alt="" />&lt;figcaption>image-20200928183352105&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928183420454.png" alt="" />&lt;figcaption>image-20200928183420454&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(a_{1}=2 a_{2}-a_{3}\)&lt;/span>, 即&lt;span class="math inline">\((a_1,a_2,a_3,a_4) \left(\begin{array}{c}1\\-2\\1\\0\end{array}\right)=\left(\begin{array}{c}0\\0\\0\\0\end{array}\right)\)&lt;/span> 则&lt;span class="math inline">\(\left(\begin{array}{c}1\\-2\\1\\0\end{array}\right)\)&lt;/span>是Ax=0的一个解， 则&lt;span class="math inline">\(k\left(\begin{array}{c}1\\-2\\1\\0\end{array}\right)\)&lt;/span>是Ax=0的解， 因为&lt;span class="math inline">\(a_{1}=2 a_{2}-a_{3}\)&lt;/span>,即&lt;span class="math inline">\(a_1\)&lt;/span>能用&lt;span class="math inline">\(a_{2}, a_{3}, a_{4}\)&lt;/span>线性表示， 而&lt;span class="math inline">\(a_{2}, a_{3}, a_{4}\)&lt;/span>线性无关， 则&lt;span class="math inline">\(a_{2}, a_{3}, a_{4}\)&lt;/span>是A列向量组的极大线性无关组，&lt;span class="math inline">\(r(A) = 3\)&lt;/span> 根据齐次线性方程解的性质，齐次线性方程组解向量组的秩&lt;span class="math inline">\(R_s = 4-r(A) = 1\)&lt;/span> 则&lt;span class="math inline">\(k\left(\begin{array}{c}1\\-2\\1\\0\end{array}\right)\)&lt;/span>是Ax=0的通解。&lt;/p>
&lt;p>&lt;span class="math inline">\(b=a_1+a_2+a_3+a_4\)&lt;/span>， 即&lt;span class="math inline">\((a_1,a_2,a_3,a_4) \left(\begin{array}{c}1\\1\\1\\1\end{array}\right)=b\)&lt;/span> 即&lt;span class="math inline">\(\left(\begin{array}{c}1\\1\\1\\1\end{array}\right)\)&lt;/span>是&lt;span class="math inline">\(Ax=b\)&lt;/span>的一个特解。 则非齐次线性方程组&lt;span class="math inline">\(Ax=b\)&lt;/span>的通解为：&lt;span class="math inline">\(k\left(\begin{array}{c}1\\-2\\1\\0\end{array}\right)+\left(\begin{array}{c}1\\1\\1\\1\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="根据参数讨论非齐次线性方程的解">根据参数讨论非齐次线性方程的解&lt;/h4>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928170603415.png" alt="" />&lt;figcaption>image-20200928170603415&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928170614779.png" alt="" />&lt;figcaption>image-20200928170614779&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928170727536.png" alt="" />&lt;figcaption>image-20200928170727536&lt;/figcaption>
&lt;/figure>
&lt;h4 id="证明非齐次线性方程组的解">证明非齐次线性方程组的解&lt;/h4>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928201842637.png" alt="" />&lt;figcaption>image-20200928201842637&lt;/figcaption>
&lt;/figure>
&lt;p>证： 已知&lt;span class="math inline">\(x=k_{1} \eta_{1}+k_{2} \eta_{2}+\cdots+k_{s} \eta_{s}\)&lt;/span> 则 &lt;span class="math inline">\(Ax = A(k_{1} \eta_{1}+k_{2} \eta_{2}+\cdots+k_{s} \eta_{s})\\ =A(\eta_{1}, \cdots, \eta_s)\left(\begin{array}{c}k_1\\ \vdots\\k_s\end{array}\right)\\ =(A\eta_{1}, \cdots,A \eta_s)\left(\begin{array}{c}k_1\\ \vdots\\k_s\end{array}\right)\\ =(b, \cdots, b)\left(\begin{array}{c}k_1\\ \vdots\\k_s\end{array}\right)\\ =k_1 b + ... + k_s b\\ =(k_1+...+k_s)b\\ =b\)&lt;/span> 即&lt;span class="math inline">\(x=k_{1} \eta_{1}+k_{2} \eta_{2}+\cdots+k_{s} \eta_{s}\)&lt;/span>是&lt;span class="math inline">\(Ax=b\)&lt;/span>的解。&lt;/p>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928214839820.png" alt="" />&lt;figcaption>image-20200928214839820&lt;/figcaption>
&lt;/figure>
&lt;p>注：这里说的&lt;a href="#例3%20涉及到后面线性方程组解的结构">题31在这里&lt;/a>&lt;/p>
&lt;p>证明： 对于非齐次方程组（这里未知数是&lt;span class="math inline">\(k_1,\cdots,k_{n-r+1}\)&lt;/span>）： &lt;span class="math inline">\(\boldsymbol{x}=k_{1} \boldsymbol{\eta}_{1}+\cdots+k_{n-r+1} \boldsymbol{\eta}_{n-r+1}\)&lt;/span> 即&lt;span class="math inline">\(x=(\eta_1, \cdots, \eta_{n-r+1})\left(\begin{array}{c}k_1\\ \vdots\\k_{n-r+1}\end{array}\right)\)&lt;/span> 因为&lt;span class="math inline">\(\eta_1, \cdots, \eta_{n-r+1}\)&lt;/span>线性无关，则&lt;span class="math inline">\(r(\eta_1, \cdots, \eta_{n-r+1})=n-r+1\)&lt;/span> = 未知数个数 则该非齐次方程组有唯一解。 则对任意的(n-r+1)维向量x都可以用&lt;span class="math inline">\(\eta_1, \cdots, \eta_{n-r+1}\)&lt;/span>线性表示，且表示法唯一。&lt;/p>
&lt;p>取满足&lt;span class="math inline">\(Ax=b\)&lt;/span>的向量x， 则&lt;span class="math inline">\(b=Ax=A(\eta_1, \cdots, \eta_{n-r+1})\left(\begin{array}{c}k_1\\ \vdots\\k_{n-r+1}\end{array}\right)\\ =(b, \cdots, b)\left(\begin{array}{c}k_1\\ \vdots\\k_{n-r+1}\end{array}\right)\\ =k_1 b + \cdots + k_{n-r+1} b\)&lt;/span> 则&lt;span class="math inline">\(k_{1}+\cdots+k_{n-r+1}=1\)&lt;/span>&lt;/p>
&lt;p>综上，有&lt;span class="math inline">\(Ax=b\)&lt;/span>的任一解都可表示为&lt;span class="math inline">\(\boldsymbol{x}=k_{1} \boldsymbol{\eta}_{1}+\cdots+k_{n-r+1} \boldsymbol{\eta}_{n-r+1}\)&lt;/span>，且&lt;span class="math inline">\(k_{1}+\cdots+k_{n-r+1}=1\)&lt;/span>&lt;/p>
&lt;p>证明二： &lt;a href="https://wenku.baidu.com/view/c5e25ca285254b35eefdc8d376eeaeaad0f3160e.html?re=view">网上&lt;/a>找来的答案：（个人感觉答案中某些位置的&lt;span class="math inline">\(Ax=b\)&lt;/span>应该替换为&lt;span class="math inline">\(Ax=0\)&lt;/span>才对） &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928234606052.png" alt="image-20200928234606052" />&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200928234635703.png" alt="" />&lt;figcaption>image-20200928234635703&lt;/figcaption>
&lt;/figure>
&lt;h2 id="向量空间">向量空间&lt;/h2>
&lt;h3 id="判断是否是向量空间">判断是否是向量空间&lt;/h3>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929000722686.png" alt="" />&lt;figcaption>image-20200929000722686&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929000756627.png" alt="" />&lt;figcaption>image-20200929000756627&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929004731370.png" alt="" />&lt;figcaption>image-20200929004731370&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929004810373.png" alt="" />&lt;figcaption>image-20200929004810373&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929005249130.png" alt="" />&lt;figcaption>image-20200929005249130&lt;/figcaption>
&lt;/figure>
&lt;p>证明一： 对增广矩阵&lt;span class="math inline">\((a_1,a_2|b_1,b_2)\)&lt;/span>初等行变换，可得&lt;span class="math inline">\(r(a_1,a_2) = r(b_1,b_2)=r(a_1,a_2,b_1,b_2)=2\)&lt;/span> 则向量组&lt;span class="math inline">\(a_1,a_2\)&lt;/span>与向量组&lt;span class="math inline">\(b_1,b_2\)&lt;/span>等价 根据向量空间的性质，向量组等价，生成对应的向量空间相等，即&lt;span class="math inline">\(L_1 = L_2\)&lt;/span>&lt;/p>
&lt;p>证明二： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010308313.png" alt="image-20200929010308313" />&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010331172.png" alt="" />&lt;figcaption>image-20200929010331172&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010716188.png" alt="" />&lt;figcaption>image-20200929010716188&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010649810.png" alt="" />&lt;figcaption>image-20200929010649810&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929011019772.png" alt="" />&lt;figcaption>image-20200929011019772&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010940739.png" alt="" />&lt;figcaption>image-20200929010940739&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200929010953802.png" alt="" />&lt;figcaption>image-20200929010953802&lt;/figcaption>
&lt;/figure></description></item><item><title>线性代数-矩阵初等变换与线性方程组习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 02 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-矩阵初等变换与线性方程组习题">线性代数-矩阵初等变换与线性方程组习题&lt;/h1>
&lt;h2 id="矩阵初等变换">矩阵初等变换&lt;/h2>
&lt;h3 id="变换成最简型">变换成最简型&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921231812376.png" alt="" />&lt;figcaption>image-20200921231812376&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921231920227.png" alt="" />&lt;figcaption>image-20200921231920227&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求初等变换矩阵">求初等变换矩阵&lt;/h3>
&lt;p>初等行变换&lt;span class="math inline">\(A \rightarrow E\)&lt;/span> 即&lt;span class="math inline">\(PA = E\)&lt;/span> 又&lt;span class="math inline">\(PE = P\)&lt;/span> 则&lt;span class="math inline">\((P|E) \rightarrow (E|P)\)&lt;/span>&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922112607294.png" alt="" />&lt;figcaption>image-20200922112607294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922112648746.png" alt="" />&lt;figcaption>image-20200922112648746&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-a不是方阵时可逆矩阵可能不唯一">例2 A不是方阵时，可逆矩阵可能不唯一&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922124111248.png" alt="" />&lt;figcaption>image-20200922124111248&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922124142564.png" alt="" />&lt;figcaption>image-20200922124142564&lt;/figcaption>
&lt;/figure>
&lt;p>我用初等行变换的方法做第二问，得到的答案是： &lt;span class="math inline">\(Q=\left(\begin{array}{rrr}1 &amp;amp; 2 &amp;amp; 0 \\ -1 &amp;amp; -2 &amp;amp; 1 \\ -4 &amp;amp; -7 &amp;amp; 1\end{array}\right)\)&lt;/span> 与标准答案不同。 参考网上的意思是：当&lt;span class="math inline">\(A^T\)&lt;/span>（或&lt;span class="math inline">\(A\)&lt;/span>）不是方阵时，Q不唯一。 https://zhidao.baidu.com/question/1695810374576283988.html?qbl=relate_question_4 https://m.iask.sina.com.cn/b/20287408.html&lt;/p>
&lt;h3 id="求逆矩阵">求逆矩阵&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922151824498.png" alt="" />&lt;figcaption>image-20200922151824498&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922151837916.png" alt="" />&lt;figcaption>image-20200922151837916&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922172625133.png" alt="" />&lt;figcaption>image-20200922172625133&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922172640005.png" alt="" />&lt;figcaption>image-20200922172640005&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174724888.png" alt="" />&lt;figcaption>image-20200922174724888&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174737292.png" alt="" />&lt;figcaption>image-20200922174737292&lt;/figcaption>
&lt;/figure>
&lt;h2 id="矩阵的秩">矩阵的秩&lt;/h2>
&lt;p>初等变换前后的矩阵是同型矩阵。&lt;/p>
&lt;p>初等变换不改变矩阵的秩，即同型矩阵的秩相等。&lt;/p>
&lt;h3 id="秩的概念与证明">秩的概念与证明&lt;/h3>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174947556.png" alt="" />&lt;figcaption>image-20200922174947556&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175019973.png" alt="" />&lt;figcaption>image-20200922175019973&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175324755.png" alt="" />&lt;figcaption>image-20200922175324755&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175337664.png" alt="" />&lt;figcaption>image-20200922175337664&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-用到后面向量的线性无关概念">例3 用到后面向量的线性无关概念&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183503819.png" alt="" />&lt;figcaption>image-20200922183503819&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183444768.png" alt="" />&lt;figcaption>image-20200922183444768&lt;/figcaption>
&lt;/figure>
&lt;p>找线性无关的向量： https://zhidao.baidu.com/question/265408643.html&lt;/p>
&lt;h6 id="例4-证明等价矩阵的秩相等">例4 证明等价矩阵的秩相等&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922184105092.png" alt="" />&lt;figcaption>image-20200922184105092&lt;/figcaption>
&lt;/figure>
&lt;p>1）先证明:若 A 经一次初等行变换变为 B,则 &lt;span class="math inline">\(R(A) \leqslant R(B)\)&lt;/span> 设 &lt;span class="math inline">\(R(\boldsymbol{A})=r,\)&lt;/span> 且 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的某个 &lt;span class="math inline">\(r\)&lt;/span> 阶子式 &lt;span class="math inline">\(D \neq 0\)&lt;/span>。设进行一次初等行变换后，与 D 相对应的 r 阶子式为 &lt;span class="math inline">\(D_1\)&lt;/span>. 1.1）当对A进行的是行置换或倍乘变换时，&lt;span class="math inline">\(D_{1}=\pm D\)&lt;/span> 或 &lt;span class="math inline">\(D_{1}=k D,\)&lt;/span> 因此 &lt;span class="math inline">\(D_{1} \neq 0,\)&lt;/span> 从而 &lt;span class="math inline">\(R(\boldsymbol{B}) \geqslant r\)&lt;/span> 1.2）当对A进行的是行倍加变换时，可假设是在第一行与第二行进行倍加（其他行的情形可通过行置换变到第一二行）。需要分为两种情况来讨论： 1.2.1）若A 的 r 阶非零子式 D 不包含 A 的第 1 行,这时 D 也是 B 的 r 阶非零子式,故 &lt;span class="math inline">\(R(B) \geqslant r\)&lt;/span>； 1.2.2）若&lt;span class="math inline">\(D\)&lt;/span> 包含 A 的第 1 行,这时把 B 中与 D 对应的 r 阶子式 &lt;span class="math inline">\(D_1\)&lt;/span>, 记作&lt;span class="math inline">\(D_{1}=\left|\begin{array}{c}r_{1}+k r_{2} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|=\left|\begin{array}{c}r_{1} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|+k\left|\begin{array}{c}r_{2} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|=D+k D_{2}\)&lt;/span> 若 &lt;span class="math inline">\(p=2,\)&lt;/span> 则 &lt;span class="math inline">\(D_{1}=D \neq 0 ;\)&lt;/span> 若 &lt;span class="math inline">\(p \neq 2,\)&lt;/span> 则 &lt;span class="math inline">\(D_{2}\)&lt;/span> 也是 &lt;span class="math inline">\(\mathbf{B}\)&lt;/span> 的 &lt;span class="math inline">\(r\)&lt;/span> 阶子式。由 &lt;span class="math inline">\(D_{1}-k D_{2}=D \neq 0,\)&lt;/span> 知 &lt;span class="math inline">\(D_{1}\)&lt;/span> 与&lt;span class="math inline">\(D_{2}\)&lt;/span>不同时为0.总之, B 中存在 &lt;span class="math inline">\(r\)&lt;/span> 阶非零子式 &lt;span class="math inline">\(D_{1}\)&lt;/span> 或 &lt;span class="math inline">\(D_{2},\)&lt;/span> 故 &lt;span class="math inline">\(R(\boldsymbol{B}) \geqslant r\)&lt;/span>&lt;/p>
&lt;p>以上证明了若 A 经一次初等行变换变为 B,则 &lt;span class="math inline">\(R(A) \leqslant R(B)\)&lt;/span>&lt;/p>
&lt;p>2）由于B也可通过一次行变换变为 A ,故也有 &lt;span class="math inline">\(R(\boldsymbol{B}) \leqslant R(\boldsymbol{A}) .\)&lt;/span> 因此经过一次初等行变换从A变换到B，有 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;p>3）经过有限次初等行变换从A变换到B，有 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;p>4）设 A 经 初 等 列 变 换 变 为 B，则 &lt;span class="math inline">\(A^T\)&lt;/span> 经 初 等 行 变 换 变 为 &lt;span class="math inline">\(\mathbf{B}^{\mathrm{T}}\)&lt;/span>, 由 上 段 证 明 知 &lt;span class="math inline">\(R\left(A^{\top}\right)=R\left(B^{\top}\right),\)&lt;/span> 又 &lt;span class="math inline">\(R(A)=R\left(A^{\top}\right), R(B)=R\left(B^{\top}\right),\)&lt;/span> 因此 &lt;span class="math inline">\(R(A)=R(B)\)&lt;/span>&lt;/p>
&lt;h6 id="例5">例5&lt;/h6>
&lt;p>证明r(A)=1的充分必要条件是存在非零列向量a及非零行向量&lt;span class="math inline">\(b^T\)&lt;/span>，使&lt;span class="math inline">\(A=ab^T\)&lt;/span>&lt;/p>
&lt;p>证: 必要性. 因为bai R(A)=1 所以 A有一个非零行du, 且其余行都是此行的倍数 设此行为zhi b^T 则 A = k1b^T … b^T knb^T 令 a = (k1,…,1,…,kn)^T 则 A=ab^T 充分性dao. 因为存在非零列向量a及非零行向量b&lt;sup>T,使A=ab&lt;/sup>T 所以A≠0. 所以 R(A)&amp;gt;=1. 又 R(A)=R(ab^T)&amp;lt;=R(a)=1 所以 R(A)=1. https://zhidao.baidu.com/question/299102973.html&lt;/p>
&lt;h6 id="例6">例6&lt;/h6>
&lt;p>设A为列满秩矩阵，AB=C，证明Bx=0与Cx=0同解&lt;/p>
&lt;p>首先, 若X是baiBX = 0的解du, 则CX = ABX = 0, 即X也是CX = 0的解. 反之, 若X是CX = 0的解, 有ABX = CX = 0, 即Y = BX是AY = 0的解. 而由A列满秩, AY = 0只有零zhi解, 故BX = Y = 0, 即X也是BX = 0的解. 综合两dao方面, BX = 0与CX = 0同解. 还有一种方法: 由A列满秩可得r(B) ≥ r(AB) ≥ r(A)+r(B)-n = r(B) (n表示A的列数), 故r(C) = r(AB) = r(B). 因此BX = 0与CX = 0解空间维数相等. 又易见前者的解空间包含于后者, 因此二者解空间相同. https://zhidao.baidu.com/question/304276864816318884.html&lt;/p>
&lt;h6 id="例7">例7&lt;/h6>
&lt;p>设A为m×n矩阵，证明方程AX=Em有解的充分必要条件为r（A）=m&lt;/p>
&lt;p>充分性：当r(A)=m时，bai则A是行满秩的，A多添任一列向du量组成的zhi增光矩阵还是行满秩的，即有r(A ei)=m，其中daoei是单位阵的第i列，于是方程Ax＝ei有解bi，令X＝【b1 b2 … bm】，则AX＝E。 必要性：若AX=E有解，则m＝r(Em)=r(AX)&amp;lt;=r(A)&amp;lt;=m，于是r(A)=m https://zhidao.baidu.com/question/371476936.html&lt;/p>
&lt;h3 id="求矩阵的秩">求矩阵的秩&lt;/h3>
&lt;h4 id="直接计算矩阵的秩">直接计算矩阵的秩&lt;/h4>
&lt;p>初等变换变为标准型可以求矩阵的秩&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183721928.png" alt="" />&lt;figcaption>image-20200922183721928&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183852740.png" alt="" />&lt;figcaption>image-20200922183852740&lt;/figcaption>
&lt;/figure>
&lt;h4 id="讨论矩阵的秩">讨论矩阵的秩&lt;/h4>
&lt;p>矩阵中有参数存在，矩阵的秩需要讨论。&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203229603.png" alt="" />&lt;figcaption>image-20200922203229603&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203256543.png" alt="" />&lt;figcaption>image-20200922203256543&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203312846.png" alt="" />&lt;figcaption>image-20200922203312846&lt;/figcaption>
&lt;/figure>
&lt;h2 id="解线性方程组">解线性方程组&lt;/h2>
&lt;h3 id="解齐次线性方程组">解齐次线性方程组&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922215516273.png" alt="" />&lt;figcaption>image-20200922215516273&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922215622683.png" alt="" />&lt;figcaption>image-20200922215622683&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922222101961.png" alt="" />&lt;figcaption>image-20200922222101961&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922222114770.png" alt="" />&lt;figcaption>image-20200922222114770&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解非齐次线性方程组">解非齐次线性方程组&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221024421.png" alt="" />&lt;figcaption>image-20200922221024421&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221058906.png" alt="" />&lt;figcaption>image-20200922221058906&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221130563.png" alt="" />&lt;figcaption>image-20200922221130563&lt;/figcaption>
&lt;/figure>
&lt;h3 id="方程组解的讨论">方程组解的讨论&lt;/h3>
&lt;p>其实还是解线性方程组的流程，只是需要讨论参数。&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922231517247.png" alt="" />&lt;figcaption>image-20200922231517247&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922231536837.png" alt="" />&lt;figcaption>image-20200922231536837&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923003313538.png" alt="" />&lt;figcaption>image-20200923003313538&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923003331626.png" alt="" />&lt;figcaption>image-20200923003331626&lt;/figcaption>
&lt;/figure>
&lt;p>（注意：这里很容易漏掉其中一种情况）&lt;/p>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923010711349.png" alt="" />&lt;figcaption>image-20200923010711349&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923010736661.png" alt="" />&lt;figcaption>image-20200923010736661&lt;/figcaption>
&lt;/figure></description></item><item><title>线性代数-矩阵初等变换与线性方程组习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</link><pubDate>Thu, 30 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-矩阵初等变换与线性方程组习题">线性代数-矩阵初等变换与线性方程组习题&lt;/h1>
&lt;h2 id="矩阵初等变换">矩阵初等变换&lt;/h2>
&lt;h3 id="变换成最简型">变换成最简型&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921231812376.png" alt="" />&lt;figcaption>image-20200921231812376&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921231920227.png" alt="" />&lt;figcaption>image-20200921231920227&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求初等变换矩阵">求初等变换矩阵&lt;/h3>
&lt;p>初等行变换&lt;span class="math inline">\(A \rightarrow E\)&lt;/span> 即&lt;span class="math inline">\(PA = E\)&lt;/span> 又&lt;span class="math inline">\(PE = P\)&lt;/span> 则&lt;span class="math inline">\((P|E) \rightarrow (E|P)\)&lt;/span>&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922112607294.png" alt="" />&lt;figcaption>image-20200922112607294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922112648746.png" alt="" />&lt;figcaption>image-20200922112648746&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-a不是方阵时可逆矩阵可能不唯一">例2 A不是方阵时，可逆矩阵可能不唯一&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922124111248.png" alt="" />&lt;figcaption>image-20200922124111248&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922124142564.png" alt="" />&lt;figcaption>image-20200922124142564&lt;/figcaption>
&lt;/figure>
&lt;p>我用初等行变换的方法做第二问，得到的答案是： &lt;span class="math inline">\(Q=\left(\begin{array}{rrr}1 &amp;amp; 2 &amp;amp; 0 \\ -1 &amp;amp; -2 &amp;amp; 1 \\ -4 &amp;amp; -7 &amp;amp; 1\end{array}\right)\)&lt;/span> 与标准答案不同。 参考网上的意思是：当&lt;span class="math inline">\(A^T\)&lt;/span>（或&lt;span class="math inline">\(A\)&lt;/span>）不是方阵时，Q不唯一。 https://zhidao.baidu.com/question/1695810374576283988.html?qbl=relate_question_4 https://m.iask.sina.com.cn/b/20287408.html&lt;/p>
&lt;h3 id="求逆矩阵">求逆矩阵&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922151824498.png" alt="" />&lt;figcaption>image-20200922151824498&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922151837916.png" alt="" />&lt;figcaption>image-20200922151837916&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922172625133.png" alt="" />&lt;figcaption>image-20200922172625133&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922172640005.png" alt="" />&lt;figcaption>image-20200922172640005&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174724888.png" alt="" />&lt;figcaption>image-20200922174724888&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174737292.png" alt="" />&lt;figcaption>image-20200922174737292&lt;/figcaption>
&lt;/figure>
&lt;h2 id="矩阵的秩">矩阵的秩&lt;/h2>
&lt;p>初等变换前后的矩阵是同型矩阵。&lt;/p>
&lt;p>初等变换不改变矩阵的秩，即同型矩阵的秩相等。&lt;/p>
&lt;h3 id="秩的概念与证明">秩的概念与证明&lt;/h3>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922174947556.png" alt="" />&lt;figcaption>image-20200922174947556&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175019973.png" alt="" />&lt;figcaption>image-20200922175019973&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175324755.png" alt="" />&lt;figcaption>image-20200922175324755&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922175337664.png" alt="" />&lt;figcaption>image-20200922175337664&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-用到后面向量的线性无关概念">例3 用到后面向量的线性无关概念&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183503819.png" alt="" />&lt;figcaption>image-20200922183503819&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183444768.png" alt="" />&lt;figcaption>image-20200922183444768&lt;/figcaption>
&lt;/figure>
&lt;p>找线性无关的向量： https://zhidao.baidu.com/question/265408643.html&lt;/p>
&lt;h6 id="例4-证明等价矩阵的秩相等">例4 证明等价矩阵的秩相等&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922184105092.png" alt="" />&lt;figcaption>image-20200922184105092&lt;/figcaption>
&lt;/figure>
&lt;p>1）先证明:若 A 经一次初等行变换变为 B,则 &lt;span class="math inline">\(R(A) \leqslant R(B)\)&lt;/span> 设 &lt;span class="math inline">\(R(\boldsymbol{A})=r,\)&lt;/span> 且 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的某个 &lt;span class="math inline">\(r\)&lt;/span> 阶子式 &lt;span class="math inline">\(D \neq 0\)&lt;/span>。设进行一次初等行变换后，与 D 相对应的 r 阶子式为 &lt;span class="math inline">\(D_1\)&lt;/span>. 1.1）当对A进行的是行置换或倍乘变换时，&lt;span class="math inline">\(D_{1}=\pm D\)&lt;/span> 或 &lt;span class="math inline">\(D_{1}=k D,\)&lt;/span> 因此 &lt;span class="math inline">\(D_{1} \neq 0,\)&lt;/span> 从而 &lt;span class="math inline">\(R(\boldsymbol{B}) \geqslant r\)&lt;/span> 1.2）当对A进行的是行倍加变换时，可假设是在第一行与第二行进行倍加（其他行的情形可通过行置换变到第一二行）。需要分为两种情况来讨论： 1.2.1）若A 的 r 阶非零子式 D 不包含 A 的第 1 行,这时 D 也是 B 的 r 阶非零子式,故 &lt;span class="math inline">\(R(B) \geqslant r\)&lt;/span>； 1.2.2）若&lt;span class="math inline">\(D\)&lt;/span> 包含 A 的第 1 行,这时把 B 中与 D 对应的 r 阶子式 &lt;span class="math inline">\(D_1\)&lt;/span>, 记作&lt;span class="math inline">\(D_{1}=\left|\begin{array}{c}r_{1}+k r_{2} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|=\left|\begin{array}{c}r_{1} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|+k\left|\begin{array}{c}r_{2} \\ r_{p} \\ \vdots \\ r_{q}\end{array}\right|=D+k D_{2}\)&lt;/span> 若 &lt;span class="math inline">\(p=2,\)&lt;/span> 则 &lt;span class="math inline">\(D_{1}=D \neq 0 ;\)&lt;/span> 若 &lt;span class="math inline">\(p \neq 2,\)&lt;/span> 则 &lt;span class="math inline">\(D_{2}\)&lt;/span> 也是 &lt;span class="math inline">\(\mathbf{B}\)&lt;/span> 的 &lt;span class="math inline">\(r\)&lt;/span> 阶子式。由 &lt;span class="math inline">\(D_{1}-k D_{2}=D \neq 0,\)&lt;/span> 知 &lt;span class="math inline">\(D_{1}\)&lt;/span> 与&lt;span class="math inline">\(D_{2}\)&lt;/span>不同时为0.总之, B 中存在 &lt;span class="math inline">\(r\)&lt;/span> 阶非零子式 &lt;span class="math inline">\(D_{1}\)&lt;/span> 或 &lt;span class="math inline">\(D_{2},\)&lt;/span> 故 &lt;span class="math inline">\(R(\boldsymbol{B}) \geqslant r\)&lt;/span>&lt;/p>
&lt;p>以上证明了若 A 经一次初等行变换变为 B,则 &lt;span class="math inline">\(R(A) \leqslant R(B)\)&lt;/span>&lt;/p>
&lt;p>2）由于B也可通过一次行变换变为 A ,故也有 &lt;span class="math inline">\(R(\boldsymbol{B}) \leqslant R(\boldsymbol{A}) .\)&lt;/span> 因此经过一次初等行变换从A变换到B，有 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;p>3）经过有限次初等行变换从A变换到B，有 &lt;span class="math inline">\(R(\boldsymbol{A})=R(\boldsymbol{B})\)&lt;/span>&lt;/p>
&lt;p>4）设 A 经 初 等 列 变 换 变 为 B，则 &lt;span class="math inline">\(A^T\)&lt;/span> 经 初 等 行 变 换 变 为 &lt;span class="math inline">\(\mathbf{B}^{\mathrm{T}}\)&lt;/span>, 由 上 段 证 明 知 &lt;span class="math inline">\(R\left(A^{\top}\right)=R\left(B^{\top}\right),\)&lt;/span> 又 &lt;span class="math inline">\(R(A)=R\left(A^{\top}\right), R(B)=R\left(B^{\top}\right),\)&lt;/span> 因此 &lt;span class="math inline">\(R(A)=R(B)\)&lt;/span>&lt;/p>
&lt;h6 id="例5">例5&lt;/h6>
&lt;p>证明r(A)=1的充分必要条件是存在非零列向量a及非零行向量&lt;span class="math inline">\(b^T\)&lt;/span>，使&lt;span class="math inline">\(A=ab^T\)&lt;/span>&lt;/p>
&lt;p>证: 必要性. 因为bai R(A)=1 所以 A有一个非零行du, 且其余行都是此行的倍数 设此行为zhi b^T 则 A = k1b^T … b^T knb^T 令 a = (k1,…,1,…,kn)^T 则 A=ab^T 充分性dao. 因为存在非零列向量a及非零行向量b&lt;sup>T,使A=ab&lt;/sup>T 所以A≠0. 所以 R(A)&amp;gt;=1. 又 R(A)=R(ab^T)&amp;lt;=R(a)=1 所以 R(A)=1. https://zhidao.baidu.com/question/299102973.html&lt;/p>
&lt;h6 id="例6">例6&lt;/h6>
&lt;p>设A为列满秩矩阵，AB=C，证明Bx=0与Cx=0同解&lt;/p>
&lt;p>首先, 若X是baiBX = 0的解du, 则CX = ABX = 0, 即X也是CX = 0的解. 反之, 若X是CX = 0的解, 有ABX = CX = 0, 即Y = BX是AY = 0的解. 而由A列满秩, AY = 0只有零zhi解, 故BX = Y = 0, 即X也是BX = 0的解. 综合两dao方面, BX = 0与CX = 0同解. 还有一种方法: 由A列满秩可得r(B) ≥ r(AB) ≥ r(A)+r(B)-n = r(B) (n表示A的列数), 故r(C) = r(AB) = r(B). 因此BX = 0与CX = 0解空间维数相等. 又易见前者的解空间包含于后者, 因此二者解空间相同. https://zhidao.baidu.com/question/304276864816318884.html&lt;/p>
&lt;h6 id="例7">例7&lt;/h6>
&lt;p>设A为m×n矩阵，证明方程AX=Em有解的充分必要条件为r（A）=m&lt;/p>
&lt;p>充分性：当r(A)=m时，bai则A是行满秩的，A多添任一列向du量组成的zhi增光矩阵还是行满秩的，即有r(A ei)=m，其中daoei是单位阵的第i列，于是方程Ax＝ei有解bi，令X＝【b1 b2 … bm】，则AX＝E。 必要性：若AX=E有解，则m＝r(Em)=r(AX)&amp;lt;=r(A)&amp;lt;=m，于是r(A)=m https://zhidao.baidu.com/question/371476936.html&lt;/p>
&lt;h3 id="求矩阵的秩">求矩阵的秩&lt;/h3>
&lt;h4 id="直接计算矩阵的秩">直接计算矩阵的秩&lt;/h4>
&lt;p>初等变换变为标准型可以求矩阵的秩&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183721928.png" alt="" />&lt;figcaption>image-20200922183721928&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922183852740.png" alt="" />&lt;figcaption>image-20200922183852740&lt;/figcaption>
&lt;/figure>
&lt;h4 id="讨论矩阵的秩">讨论矩阵的秩&lt;/h4>
&lt;p>矩阵中有参数存在，矩阵的秩需要讨论。&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203229603.png" alt="" />&lt;figcaption>image-20200922203229603&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203256543.png" alt="" />&lt;figcaption>image-20200922203256543&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922203312846.png" alt="" />&lt;figcaption>image-20200922203312846&lt;/figcaption>
&lt;/figure>
&lt;h2 id="解线性方程组">解线性方程组&lt;/h2>
&lt;h3 id="解齐次线性方程组">解齐次线性方程组&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922215516273.png" alt="" />&lt;figcaption>image-20200922215516273&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922215622683.png" alt="" />&lt;figcaption>image-20200922215622683&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922222101961.png" alt="" />&lt;figcaption>image-20200922222101961&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922222114770.png" alt="" />&lt;figcaption>image-20200922222114770&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解非齐次线性方程组">解非齐次线性方程组&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221024421.png" alt="" />&lt;figcaption>image-20200922221024421&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221058906.png" alt="" />&lt;figcaption>image-20200922221058906&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922221130563.png" alt="" />&lt;figcaption>image-20200922221130563&lt;/figcaption>
&lt;/figure>
&lt;h3 id="方程组解的讨论">方程组解的讨论&lt;/h3>
&lt;p>其实还是解线性方程组的流程，只是需要讨论参数。&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922231517247.png" alt="" />&lt;figcaption>image-20200922231517247&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200922231536837.png" alt="" />&lt;figcaption>image-20200922231536837&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923003313538.png" alt="" />&lt;figcaption>image-20200923003313538&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923003331626.png" alt="" />&lt;figcaption>image-20200923003331626&lt;/figcaption>
&lt;/figure>
&lt;p>（注意：这里很容易漏掉其中一种情况）&lt;/p>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923010711349.png" alt="" />&lt;figcaption>image-20200923010711349&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200923010736661.png" alt="" />&lt;figcaption>image-20200923010736661&lt;/figcaption>
&lt;/figure></description></item><item><title>线性代数-矩阵1</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/</link><pubDate>Sat, 25 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-矩阵1">线性代数-矩阵1&lt;/h1>
&lt;h2 id="矩阵">矩阵&lt;/h2>
&lt;h3 id="矩阵的概念">矩阵的概念&lt;/h3>
&lt;h5 id="矩阵的定义">矩阵的定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(m \times n\)&lt;/span>个数，排成m行n列的表格：(为表示它们是一个整体，总加一个括弧) &lt;span class="math inline">\(\boldsymbol{A}=\left(\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp;\ddots &amp;amp; \vdots \\ a_{m 1} &amp;amp; a_{m 2} &amp;amp; \cdots &amp;amp; a_{m n}\end{array}\right)\)&lt;/span>， 称为一个&lt;span class="math inline">\(m \times n\)&lt;/span>&lt;strong>矩阵&lt;/strong>。简记为A。&lt;/p>
&lt;h5 id="实矩阵复矩阵">实矩阵/复矩阵&lt;/h5>
&lt;p>元蒙是实数的矩阵称为实矩阵,元素是复数的矩阵称为复矩阵&lt;/p>
&lt;h5 id="方阵">方阵&lt;/h5>
&lt;p>当&lt;span class="math inline">\(m=n\)&lt;/span>时，称为n阶矩阵（或&lt;strong>n阶方阵&lt;/strong>）。即行数与列数都等于 &lt;span class="math inline">\(n\)&lt;/span> 的矩阵称为n 阶矩阵或 &lt;span class="math inline">\(n\)&lt;/span> 阶方阵.&lt;/p>
&lt;h5 id="方阵的行列式">方阵的行列式&lt;/h5>
&lt;p>设&lt;span class="math inline">\(A=[a_{ij}]\)&lt;/span>为n阶矩阵，其所有元素构成的行列式称为&lt;strong>方阵A的行列式&lt;/strong>。记为&lt;span class="math inline">\(|A|\)&lt;/span>。 注1：仅方阵才有行列式 注2：A=0与&lt;span class="math inline">\(|A|=0\)&lt;/span>不要搞混。&lt;/p>
&lt;h5 id="零矩阵">零矩阵&lt;/h5>
&lt;p>如果一个矩阵的所有元素都是0，称这个矩阵为&lt;strong>0矩阵&lt;/strong>。简记为0.&lt;/p>
&lt;h5 id="行矩阵列矩阵">行矩阵/列矩阵&lt;/h5>
&lt;p>只有一行的矩阵： &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{1} a_{2} \cdots a_{n}\right)\)&lt;/span> 称为行矩阵（又称行向量）&lt;/p>
&lt;p>只有一列的矩阵： &lt;span class="math inline">\(\boldsymbol{B}=\left(\begin{array}{c}b_{1} \\ b_{2} \\ \vdots \\ b_{m}\end{array}\right)\)&lt;/span> 称为列矩阵（又称列向量）&lt;/p>
&lt;h5 id="同型矩阵">同型矩阵&lt;/h5>
&lt;p>如果A和B都是&lt;span class="math inline">\(m \times n\)&lt;/span>矩阵，称A和B是&lt;strong>同型矩阵&lt;/strong>。&lt;/p>
&lt;p>即，两个矩阵的行数相等、列数也相等时, ,就称它们是同型矩阵&lt;/p>
&lt;h5 id="矩阵相等">矩阵相等&lt;/h5>
&lt;p>如果 &lt;span class="math inline">\(A=\left(a_{i j}\right)\)&lt;/span>与 &lt;span class="math inline">\(\mathbf{B}=\left(b_{i j}\right)\)&lt;/span> 都是&lt;span class="math inline">\(m \times n\)&lt;/span>矩阵（同型矩阵）， 且对应元素相等，即&lt;span class="math inline">\(a_{ij} = b_{ij} \quad (\forall i = 1,2,...,m, j= 1,2,...,n)\)&lt;/span>， 称&lt;strong>矩阵A和B相等&lt;/strong>，记A=B。&lt;/p>
&lt;h5 id="线性变换与系数矩阵关系">线性变换与系数矩阵关系&lt;/h5>
&lt;p>&lt;span class="math inline">\(n\)&lt;/span> 个变量 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 与 &lt;span class="math inline">\(m\)&lt;/span> 个变量 &lt;span class="math inline">\(y_{1}, y_{2}, \cdots, y_{m}\)&lt;/span> 之间的关系式： &lt;span class="math inline">\(\left\{\begin{array}{l}y_{1}=a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n} \\ y_{2}=a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n} \\ \cdots \cdots \cdots \cdots \\ y_{m}=a_{m 1} x_{1}+a_{m 2} x_{2}+\cdots+a_{m n} x_{n}\end{array}\right.\)&lt;/span> 表示一个&lt;strong>从变量 &lt;span class="math inline">\(x_{1}, x_{2}, \cdots, x_{n}\)&lt;/span> 到变量 &lt;span class="math inline">\(y_{1}, y_{2}, \cdots, y_{m}\)&lt;/span> 的线性变换&lt;/strong>,其中 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 为常数.线性变换的系数 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 构成矩阵 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{i j}\right)_{m \times n}\)&lt;/span>&lt;/p>
&lt;p>给出线性变换，系数矩阵就唯一确定；给出一个矩阵作为线性变换的系数矩阵，线性变换也唯一确定；即&lt;strong>线性变换和矩阵之间存在着一一对应的关系&lt;/strong> .&lt;/p>
&lt;p>可以利用矩阵来研究 线性变换,也可以利用线性变换来解释矩阵的含义。&lt;/p>
&lt;h5 id="零矩阵-1">零矩阵&lt;/h5>
&lt;p>元素都是0的矩阵称为零矩阵，记作O，注意不同型的零矩阵是不同的。&lt;/p>
&lt;h5 id="单位矩阵">单位矩阵&lt;/h5>
&lt;p>主对角线上元素都是1，其余位置都是0的n阶方阵。记作E &lt;span class="math inline">\(\left[\begin{array}{} 1 &amp;amp; 0 \\ 0 &amp;amp; 1 \end{array}\right]\)&lt;/span> &lt;span class="math inline">\(\left[\begin{array}{} 1 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; 1 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 1\end{array}\right]\)&lt;/span> …&lt;/p>
&lt;p>n阶单位矩阵：&lt;/p>
&lt;p>&lt;span class="math inline">\(\boldsymbol{E}=\left(\begin{array}{cccc}1 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\ 0 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 0 \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; 1\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>对应的线性变换为：&lt;/p>
&lt;p>&lt;span class="math inline">\(\left\{\begin{array}{l}y_{1}=x_{1} \\ y_{2}=x_{2} \\ \cdots \ldots \ldots \ldots \\ y_{n}=x_{n}\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h5 id="对角矩阵">对角矩阵​&lt;/h5>
&lt;p>只有主对角线上有非零元素，其余位置都是0的矩阵。记作&lt;span class="math inline">\(\boldsymbol{\Lambda}=\operatorname{diag}\left(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\right)\)&lt;/span> &lt;span class="math inline">\(\left[\begin{array}{} a_1 &amp;amp; 0 \\ 0 &amp;amp; a_2 \end{array}\right]\)&lt;/span> &lt;span class="math inline">\(\left[\begin{array}{} a_1 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; a_2 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; a_3\end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>n阶对角矩阵： &lt;span class="math inline">\(\boldsymbol{\Lambda}=\left(\begin{array}{cccc}\lambda_{1} &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 \\ 0 &amp;amp; \lambda_{2} &amp;amp; \cdots &amp;amp; 0 \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ 0 &amp;amp; 0 &amp;amp; \cdots &amp;amp; \lambda_{n}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>对应的线性变换为：&lt;/p>
&lt;p>&lt;span class="math inline">\(\left\{\begin{array}{l}y_{1}=\lambda_{1} x_{1} \\ y_{2}=\lambda_{2} x_{2} \\ \cdots \ldots \ldots \ldots \\ y_{n}=\lambda_{n} x_{n}\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h5 id="对称矩阵">对称矩阵&lt;/h5>
&lt;p>需要先了解&lt;a href="#矩阵转置">矩阵转置&lt;/a>的概念。&lt;/p>
&lt;p>设 A 为 n 阶方阵,如果满足 &lt;span class="math inline">\(A^{\mathrm{T}}=A\)&lt;/span>,即&lt;span class="math inline">\(a_{i j}=a_{j i}(i, j=1,2, \cdots, n)\)&lt;/span> 那么 A 称为对称矩阵,简称对称阵.&lt;/p>
&lt;p>对称阵的特点是 : 它的元素以对角线为对称轴对应相等.&lt;/p>
&lt;h5 id="共轭矩阵">共轭矩阵&lt;/h5>
&lt;p>当 &lt;span class="math inline">\(A=\left(a_{i j}\right)\)&lt;/span> 为复矩阵时,用 &lt;span class="math inline">\(\bar{a}_{i j}\)&lt;/span> 表示 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 的共轭复数, 记&lt;span class="math inline">\(\overline{\boldsymbol{A}}=\left(\bar{a}_{i j}\right)\)&lt;/span> &lt;span class="math inline">\(\overline{A}\)&lt;/span>称为 A 的共轭矩阵.&lt;/p>
&lt;p>共轭矩阵的运算律/性质： &lt;span class="math inline">\(\overline{A+B}=\bar{A}+\bar{B}\)&lt;/span> &lt;span class="math inline">\(\overline{\lambda A}=\bar{\lambda} \bar{A}\)&lt;/span> &lt;span class="math inline">\(\overline{\boldsymbol{A B}}=\bar{\boldsymbol{A}} \bar{\boldsymbol{B}}\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵的迹">矩阵的迹&lt;/h5>
&lt;p>矩阵主对角元素之和。即&lt;span class="math inline">\(\Sigma a_{ii}\)&lt;/span>&lt;/p>
&lt;h3 id="矩阵的基本运算">矩阵的基本运算&lt;/h3>
&lt;p>矩阵相加与数乘矩阵合起来,统称为&lt;strong>矩阵的线性运算&lt;/strong>。&lt;/p>
&lt;p>而矩阵乘法、矩阵的转置不是线性运算。&lt;/p>
&lt;h5 id="矩阵加法">矩阵加法&lt;/h5>
&lt;p>&lt;span class="math inline">\(A+B = [a_{ij} + b_{ij}]\)&lt;/span>，这里要求A与B为同型矩阵。&lt;/p>
&lt;p>&lt;span class="math inline">\(\boldsymbol{A}+\boldsymbol{B}=\left(\begin{array}{cccc}a_{11}+b_{11} &amp;amp; a_{12}+b_{12} &amp;amp; \cdots &amp;amp; a_{1 n}+b_{1 n} \\ a_{21}+b_{21} &amp;amp; a_{22}+b_{22} &amp;amp; \cdots &amp;amp; a_{2 n}+b_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{m 1}+b_{m 1} &amp;amp; a_{m 2}+b_{m 2} &amp;amp; \cdots &amp;amp; a_{m n}+b_{m n}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="加法性质运算律">加法性质/运算律&lt;/h5>
&lt;p>A,B,C为同型矩阵时， 交换律：&lt;span class="math inline">\(A+B = B+A\)&lt;/span> 结合律：&lt;span class="math inline">\(A + B + C = A + (B + C)\)&lt;/span> &lt;span class="math inline">\(A+0 = 0+A = A\)&lt;/span> &lt;span class="math inline">\(A+ (-A) = 0\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵数乘">矩阵数乘&lt;/h5>
&lt;p>数$ &lt;span class="math inline">\(与矩阵 A 的乘积：\)&lt;/span>A = [a_{ij}]$&lt;/p>
&lt;p>即： &lt;span class="math inline">\(\lambda \boldsymbol{A}=\boldsymbol{A} \lambda=\left(\begin{array}{cccc}\lambda a_{11} &amp;amp; \lambda a_{12} &amp;amp; \cdots &amp;amp; \lambda a_{1 n} \\ \lambda a_{21} &amp;amp; \lambda a_{22} &amp;amp; \cdots &amp;amp; \lambda a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ \lambda a_{m 1} &amp;amp; \lambda a_{m 2} &amp;amp; \cdots &amp;amp; \lambda a_{m n}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="数乘性质运算律">数乘性质/运算律&lt;/h5>
&lt;p>&lt;span class="math inline">\(k(mA) = m(kA) = (km)A\)&lt;/span> &lt;span class="math inline">\((k+m)A = kA + mA\)&lt;/span> &lt;span class="math inline">\(k(A+B) = kA + kB\)&lt;/span> &lt;span class="math inline">\(1 A = A, 0A = 0\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵乘法">矩阵乘法&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{i j}\right)\)&lt;/span> 是一个 &lt;span class="math inline">\(m \times s\)&lt;/span> 矩阵 &lt;span class="math inline">\(, \boldsymbol{B}=\left(b_{i j}\right)\)&lt;/span> 是一个 &lt;span class="math inline">\(s \times n\)&lt;/span> 矩阵, 那么规定矩阵 A 与矩阵 B 的乘积是一个 &lt;span class="math inline">\(m \times n\)&lt;/span> 矩阵 &lt;span class="math inline">\(C=\left(c_{i j}\right),\)&lt;/span> 其中&lt;span class="math inline">\(c_{i j}=a_{i 1} b_{1 j}+a_{i 2} b_{2 j}+\cdots+a_{i s} b_{i j}=\sum_{k=1}^{s} a_{i k} b_{k j}\)&lt;/span> &lt;span class="math inline">\((i=1,2, \cdots, m ; j=1,2, \cdots, n)\)&lt;/span> 矩阵的乘积记作&lt;span class="math inline">\(C=A B\)&lt;/span>&lt;/p>
&lt;p>而 &lt;span class="math inline">\(\left(a_{i 1}, a_{i 2}, \cdots, a_{i s}\right)\left(\begin{array}{c}b_{1 j} \\ b_{2 j} \\ \vdots \\ b_{i j}\end{array}\right)=a_{i 1} b_{1 j}+a_{i 2} b_{2 j}+\cdots+a_{i j} b_{j i}\)&lt;/span> &lt;span class="math inline">\(=\sum_{k=1}^{s} a_{i k} b_{k j}=c_{i j}\)&lt;/span> 表明乘积矩阵 &lt;span class="math inline">\(\boldsymbol{A B}=\boldsymbol{C}\)&lt;/span> 的( &lt;span class="math inline">\(i, j)\)&lt;/span> 元 &lt;span class="math inline">\(c_{i j}\)&lt;/span> 就是 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的第 &lt;span class="math inline">\(i\)&lt;/span> 行与 &lt;span class="math inline">\(\boldsymbol{B}\)&lt;/span> 的第 &lt;span class="math inline">\(j\)&lt;/span> 列的乘积.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/IMG_20200912_220301.jpg" alt="" />&lt;figcaption>IMG_20200912_220301&lt;/figcaption>
&lt;/figure>
&lt;p>注意：只有当第一个矩阵(左矩阵)的列数等于第二个矩阵(右矩阵)的 行数时,两个矩阵才能相乘。&lt;/p>
&lt;p>从&lt;a href="#线性变换与系数矩阵">线性变换&lt;/a>的角度看，线性变换的系数矩阵作乘积，相当于连续作两次线性变换。&lt;/p>
&lt;p>AB 是 A 左乘 &lt;span class="math inline">\(\boldsymbol{B}(\boldsymbol{B}\)&lt;/span>被 A 左乘)的乘积, BA 是 A 右乘 B 的乘积, AB 有意义时, BA 可以没有意义.矩阵的乘法不满足交换律。 但是若对于两个 n 阶方阵 A，B,若 AB = BA，则称方阵 A 与B是可交换的.&lt;/p>
&lt;h5 id="乘法性质运算律">乘法性质/运算律&lt;/h5>
&lt;h6 id="结合律">结合律&lt;/h6>
&lt;p>&lt;span class="math inline">\((AB)C = A(BC) = ABC\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\lambda(A B)=(\lambda A) B=A(\lambda B)(\)&lt;/span> 其中 &lt;span class="math inline">\(\lambda\)&lt;/span> 为数 &lt;span class="math inline">\()\)&lt;/span>&lt;/p>
&lt;h6 id="分配律">分配律&lt;/h6>
&lt;p>&lt;span class="math inline">\(A(B+C) = AB + AC\)&lt;/span> &lt;span class="math inline">\((A+B) C = AC + BC\)&lt;/span>&lt;/p>
&lt;h6 id="n阶方阵的幂方幂">n阶方阵的幂（方幂）&lt;/h6>
&lt;p>&lt;span class="math inline">\(A \cdot A = A^2\)&lt;/span> &lt;span class="math inline">\(A \cdots A = A^k\)&lt;/span> (k个A的乘积)&lt;/p>
&lt;h6 id="单位矩阵的乘法">单位矩阵的乘法&lt;/h6>
&lt;p>&lt;span class="math inline">\(AE = A, EA = A\)&lt;/span>&lt;/p>
&lt;p>单位矩阵E在矩阵乘法中的作用类似于数1.&lt;/p>
&lt;h6 id="纯量阵的乘法">纯量阵的乘法&lt;/h6>
&lt;p>纯量阵： &lt;span class="math inline">\(\lambda E=\left(\begin{array}{llll}\lambda &amp;amp; &amp;amp; \\ &amp;amp; \lambda &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda\end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>由( &lt;span class="math inline">\(\lambda E) A=\lambda A, A(\lambda E)=\lambda A,\)&lt;/span> 可 知纯量阵 &lt;span class="math inline">\(\lambda E\)&lt;/span> 与矩阵 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的乘积等于数$ &lt;span class="math inline">\(与 A 的乘积. 当 A 为 n 阶方阵时,有\)&lt;/span>(&lt;em>{n}) &lt;/em>{n}=&lt;em>{n}=&lt;/em>{n}(_{n}),$表明纯量阵 $E $与任何同阶方阵都是可交换的.&lt;/p>
&lt;h6 id="对角矩阵lambda的乘法">对角矩阵&lt;span class="math inline">\(\Lambda\)&lt;/span>的乘法&lt;/h6>
&lt;p>&lt;span class="math inline">\(\left[\begin{array}{} a_1 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; a_2 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; a_3\end{array}\right] \left[\begin{array}{} b_1 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; b_2 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; b_3\end{array}\right]\)&lt;/span>&lt;span class="math inline">\(=\left[\begin{array}{} a_1 b_1 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; a_2 b_2 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; a_3 c_3\end{array}\right]\)&lt;/span>&lt;/p>
&lt;h6 id="对角矩阵乘法的交换律">对角矩阵乘法的交换律&lt;/h6>
&lt;p>&lt;span class="math inline">\(\Lambda_1 \Lambda_2 = \Lambda_2 \Lambda_1\)&lt;/span>&lt;/p>
&lt;h6 id="对角矩阵的幂">对角矩阵的幂&lt;/h6>
&lt;p>&lt;span class="math inline">\(\left[ \begin{array} { c c c c } { a_1 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { a _ { 2 } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \ddots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { a _ { n } } \end{array} \right] ^ { n } = \left[ \begin{array} { c c c c } { a _ { 1 } ^ { n } } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { a _ { 2 } ^ { n } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \ddots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { a _ { n } ^ { n } } \end{array} \right]\)&lt;/span>&lt;/p>
&lt;p>$^n = ^n = $&lt;/p>
&lt;h6 id="矩阵乘法没有交换律">矩阵乘法没有交换律&lt;/h6>
&lt;p>一般的矩阵乘法没有交换律 ： &lt;span class="math inline">\(AB \neq BA\)&lt;/span>, &lt;span class="math inline">\((\boldsymbol{A} \boldsymbol{B})^{k} \neq \boldsymbol{A}^{k} \boldsymbol{B}^{k}\)&lt;/span> &lt;span class="math inline">\((\boldsymbol{A}+\boldsymbol{B})^{2}\neq\boldsymbol{A}^{2}+2 \boldsymbol{A} \boldsymbol{B}+\boldsymbol{B}^{2}\)&lt;/span> &lt;span class="math inline">\((A-B)(A+B)\neq A^{2}-B^{2}\)&lt;/span>&lt;/p>
&lt;p>只有在A与B可交换时，才能取等号。&lt;/p>
&lt;p>注：&lt;span class="math inline">\(AB = AC, A \neq 0 \nRightarrow B=C\)&lt;/span>&lt;/p>
&lt;h6 id="行列向量的乘法">行列向量的乘法&lt;/h6>
&lt;p>设&lt;span class="math inline">\(\alpha,\beta\)&lt;/span>都是n维列向量，则： &lt;span class="math inline">\(\alpha \beta^T, \beta \alpha^T, \alpha \alpha^T\)&lt;/span>都是&lt;span class="math inline">\(n\times n\)&lt;/span>的矩阵； &lt;span class="math inline">\(\alpha^T \beta, \beta^T \alpha, \alpha^T \alpha\)&lt;/span>都是数，也可看成&lt;span class="math inline">\(1\times 1\)&lt;/span>的矩阵。 &lt;span class="math inline">\(\alpha^T \beta, \beta^T \alpha, \alpha^T \alpha\)&lt;/span>分别是&lt;span class="math inline">\(\alpha \beta^T, \beta \alpha^T, \alpha \alpha^T\)&lt;/span>结果矩阵的迹。（矩阵的迹：主对角元素之和）&lt;/p>
&lt;h5 id="矩阵转置">矩阵转置&lt;/h5>
&lt;p>矩阵的转置也是一种运算。&lt;/p>
&lt;p>设&lt;span class="math inline">\(A=[a_{ij}]_{m\times n}\)&lt;/span>，将A的行列互换得到的&lt;span class="math inline">\(n\times m\)&lt;/span>的矩阵&lt;span class="math inline">\([a_{ji}]_{n\times m}\)&lt;/span>称为A的转置矩阵。记为&lt;span class="math inline">\(A^T\)&lt;/span>&lt;/p>
&lt;h5 id="转置性质运算律">转置性质/运算律&lt;/h5>
&lt;p>&lt;span class="math inline">\((A+B)^T = A^T + B^T\)&lt;/span> &lt;span class="math inline">\((kA)^T = k A^T\)&lt;/span> &lt;span class="math inline">\((AB)^T = B^T A^T\)&lt;/span> &lt;span class="math inline">\((A^T)^T = A\)&lt;/span>&lt;/p>
&lt;h3 id="逆矩阵与求逆运算">逆矩阵与求逆运算&lt;/h3>
&lt;p>如果我们想要从&lt;span class="math inline">\(AB=C\)&lt;/span>中计算B时，该怎么做呢？&lt;/p>
&lt;p>这里先提一下逆矩阵的概念：假设对于方阵A，若有方阵$A^{-1} &lt;span class="math inline">\(，使得\)&lt;/span>A^{-1} A = A A^{-1} = E&lt;span class="math inline">\(。 则原等式两边可分别用\)&lt;/span>A^{-1} &lt;span class="math inline">\(左乘，即:\)&lt;/span>A^{-1} A B = A^{-1} C&lt;span class="math inline">\(， 得到\)&lt;/span>B = A^{-1} C$&lt;/p>
&lt;p>而其中的逆矩阵$A^{-1} $要怎么求呢？&lt;/p>
&lt;p>实际上，可以通过对线性方程组（线性变换）进行逆变换，可以引出逆矩阵$A^{-1} $的概念以及求解步骤。 其中又用到了伴随矩阵的概念与性质，所以下面从伴随矩阵讲起。&lt;/p>
&lt;h4 id="伴随矩阵">伴随矩阵&lt;/h4>
&lt;h5 id="伴随矩阵的概念">伴随矩阵的概念&lt;/h5>
&lt;p>矩阵A的伴随矩阵： 行列式| A |的各个元素的代数余子式 A &lt;span class="math inline">\(_{i j}\)&lt;/span> 所构成的如下的矩阵 &lt;span class="math inline">\(A^* = \left[\begin{array}{cccc}A_{11} &amp;amp; A_{21} &amp;amp; \cdots &amp;amp; A_{n 1} \\ A_{12} &amp;amp; A_{22} &amp;amp; \cdots &amp;amp; A_{n 2} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ A_{1 n} &amp;amp; A_{2 n} &amp;amp; \cdots &amp;amp; A_{nn}\end{array}\right]\)&lt;/span> （注意这里&lt;span class="math inline">\(A_{ij}\)&lt;/span>的排列顺序）&lt;/p>
&lt;p>即&lt;span class="math inline">\(A^* = (A_{ji})=(A_{ij})^T\)&lt;/span>, 称为A的伴随矩阵&lt;/p>
&lt;p>注：代数余子式概念参见&lt;a href="./线性代数-行列式.md#代数余子式">行列式&lt;/a>章节&lt;/p>
&lt;h5 id="伴随矩阵的性质">伴随矩阵的性质&lt;/h5>
&lt;p>&lt;span class="math inline">\(A A^* = A^* A = |A| E\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： 设 &lt;span class="math inline">\(\boldsymbol{A}=\left(a_{i j}\right),\)&lt;/span> 记 &lt;span class="math inline">\(\boldsymbol{A A}^{*}=\left(b_{i j}\right),\)&lt;/span> 则&lt;span class="math inline">\(b_{i j}=a_{i 1} A_{j 1}+a_{i 2} A_{j 2}+\cdots+a_{i n} A_{j n}=|A| \delta_{i j}\)&lt;/span>， 故&lt;span class="math inline">\(\boldsymbol{A A}^{*}=\left(|\boldsymbol{A}| \delta_{i j}\right)=|\boldsymbol{A}|\left(\delta_{i j}\right)=|\boldsymbol{A}| \boldsymbol{E}\)&lt;/span> 类似有&lt;span class="math inline">\(\boldsymbol{A}^{*} \boldsymbol{A}=\left(\sum_{k=1}^{n} A_{k i} a_{k j}\right)=\left(|\boldsymbol{A}| \delta_{i j}\right)=|\boldsymbol{A}|\left(\delta_{i j}\right)=|\boldsymbol{A}| \boldsymbol{E}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span class="math inline">\(A^{-1} = \frac{1}{|A|} A^*, A^* = |A| A^{-1}\)&lt;/span> （应该放到矩阵的逆矩阵章节）&lt;/p>
&lt;blockquote>
&lt;p>二阶矩阵的伴随矩阵（仅适用于二阶矩阵）：主对角线互换，副对角线变号 &lt;span class="math inline">\(\left[\begin{array}{} a &amp;amp; b \\ c &amp;amp; d \end{array}\right]^* = \left[\begin{array}{} d &amp;amp; -b \\ -c &amp;amp; a \end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>二阶矩阵的逆矩阵（公式是通用的，但是&lt;span class="math inline">\(A^*\)&lt;/span>只有二阶的比较好求）： &lt;span class="math inline">\(A^{-1} = \frac{1}{|A|} A^*\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span class="math inline">\((kA)^* = k^{n-1} A^*\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|A^*| = |A|^{n-1}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((A^*)^* = |A|^{n-2} A\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((A^*)^T = (A^T)^*\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(A^{-1} = \frac{1}{|A|} A^*\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((A^*)^{-1} = (A^{-1})^* = \frac{1}{|A|} A\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(r(A^*) = \left\{\begin{array}{}n, &amp;amp; r(A) = n\\ 1, &amp;amp; r(A)=n-1\\ 0, &amp;amp;r(A)&amp;lt;n-1 \end{array}\right.\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明：(用到了矩阵秩的性质八：&lt;span class="math inline">\(r(A)+r(A^*)\le n\)&lt;/span>，学完矩阵的秩和向量组之后再看这里的证明) 设A为n阶&lt;/p>
&lt;p>若r（A）=n，则丨A丨不等于0，&lt;span class="math inline">\(A^*=丨A丨A^{-1}\)&lt;/span>可逆，推出&lt;span class="math inline">\(r(A^*)=n\)&lt;/span>。&lt;/p>
&lt;p>若r（A）=n-2，则&lt;span class="math inline">\(丨A丨=0\)&lt;/span>且n-1阶子式全为0，因此&lt;span class="math inline">\(A^*=0\)&lt;/span>，即&lt;span class="math inline">\(r(A^*)=0\)&lt;/span>&lt;/p>
&lt;p>若r（A）=n-1，则丨A丨等于0且存在n-1阶子式不为0，因此&lt;span class="math inline">\(A^*\)&lt;/span>不等于0，&lt;span class="math inline">\(r(A^*)\ge 1\)&lt;/span> 又因为 &lt;span class="math inline">\(AA^*=丨A丨E=0\)&lt;/span>，&lt;span class="math inline">\(r(A)+r(A^*)\le n\)&lt;/span>，&lt;span class="math inline">\(r(A^*)\le n-r(A) = 1\)&lt;/span> 就可以得到&lt;span class="math inline">\(r(A^*)=1\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h4 id="可逆矩阵">可逆矩阵&lt;/h4>
&lt;h5 id="逆矩阵的引出逆变换">逆矩阵的引出：逆变换&lt;/h5>
&lt;p>给定一个线性变换： &lt;span class="math inline">\(\left\{\begin{array}{l}y_{1}=a_{11} x_{1}+a_{12} x_{2}+\cdots+a_{1 n} x_{n} \\ y_{2}=a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n} \\ \cdots \cdots \cdots \cdots \\ y_{n}=a_{n 1} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}\end{array}\right.\)&lt;/span> 它的系数矩阵是一个 n 阶矩阵 A， 并取： &lt;span class="math inline">\(\boldsymbol{X}=\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right), \boldsymbol{Y}=\left(\begin{array}{c}y_{1} \\ y_{2} \\ \vdots \\ y_{n}\end{array}\right)\)&lt;/span> 则线性变换可记为： &lt;span class="math inline">\(\mathbf{Y}=\mathbf{A X}\)&lt;/span>&lt;/p>
&lt;p>以 A 的伴随阵 &lt;span class="math inline">\(A^*\)&lt;/span>左乘上式两端： &lt;span class="math inline">\(\boldsymbol{A}^{*} \boldsymbol{Y}=\boldsymbol{A}^{*} \boldsymbol{A X}\)&lt;/span>&lt;span class="math inline">\(=|\boldsymbol{A}| \boldsymbol{X}\)&lt;/span> 当$| A | $ 时, 可解出&lt;span class="math inline">\(\boldsymbol{X}=\frac{1}{|\boldsymbol{A}|} \boldsymbol{A}^{*} \boldsymbol{Y}\)&lt;/span>,称为Y到X的线性变换，这是X到Y线性变换的&lt;strong>逆变换&lt;/strong>。&lt;/p>
&lt;p>记 &lt;span class="math inline">\(\mathbf{B}=\frac{1}{|\boldsymbol{A}|} \boldsymbol{A}^*\)&lt;/span>，上式可记作&lt;span class="math inline">\(X=B Y\)&lt;/span> 将其代入X到Y的线性变换： &lt;span class="math inline">\(\boldsymbol{Y}=\boldsymbol{A}\boldsymbol{X}=\boldsymbol{A}(\boldsymbol{B} \boldsymbol{Y})=(\boldsymbol{A} \boldsymbol{B}) \boldsymbol{Y}\)&lt;/span>，故 &lt;span class="math inline">\(\boldsymbol{A B}=\boldsymbol{E}\)&lt;/span> 同理：&lt;span class="math inline">\(\boldsymbol{X}=\boldsymbol{B}(\boldsymbol{A X})=(\boldsymbol{B A}) \boldsymbol{X}\)&lt;/span>，故&lt;span class="math inline">\(B A=E\)&lt;/span> 得到&lt;span class="math inline">\(A B=B A=E\)&lt;/span>，由此引入逆矩阵的定义。&lt;/p>
&lt;h5 id="可逆矩阵的定义">可逆矩阵的定义&lt;/h5>
&lt;p>A是n阶&lt;strong>方阵&lt;/strong>，如果存在n阶矩阵B，使得&lt;span class="math inline">\(AB=BA = E\)&lt;/span>成立，称A是&lt;strong>可逆矩阵&lt;/strong>，B是A的逆矩阵，记&lt;span class="math inline">\(A^{-1} = B\)&lt;/span>&lt;/p>
&lt;p>由上面线性变换的逆变换可知，&lt;span class="math inline">\(A^{-1}=\frac{1}{|\boldsymbol{A}|} \boldsymbol{A}^*\)&lt;/span>&lt;/p>
&lt;h5 id="可逆矩阵的性质运算律">可逆矩阵的性质/运算律&lt;/h5>
&lt;p>定理：如果方阵A可逆，则A的逆矩阵唯一。&lt;/p>
&lt;p>定理：方阵A可逆 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(|A| \neq 0\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>结合后面所学的知识，还有：&lt;/p>
&lt;p>方阵A可逆 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(|A| \neq 0\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r(A)=n\)&lt;/span> (秩为n) &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> A的列/行向量线性无关 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(A=P_1 P_2 P_3 ... P_s, P_i (i=1, 2, 3... s)\)&lt;/span> 为初等矩阵 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> A与单位矩阵等价 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 0不是矩阵A的特征值&lt;/p>
&lt;p>当|A|=0 时,A 称为奇异矩阵,否则称非奇异矩阵.所以可逆矩阵又称非奇异矩阵。&lt;/p>
&lt;/blockquote>
&lt;p>定理：设方阵A，B都n阶，且&lt;span class="math inline">\(AB=E\)&lt;/span>，则&lt;span class="math inline">\(BA=E\)&lt;/span>&lt;/p>
&lt;p>方阵A可逆，&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(A^{-1}\)&lt;/span>可逆，且&lt;span class="math inline">\((A^{-1})^{-1}= A\)&lt;/span> 方阵A可逆，&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(kA\)&lt;/span>可逆，且&lt;span class="math inline">\((kA)^{-1} = \frac{1}{k} A^{-1}\)&lt;/span> (&lt;span class="math inline">\(k\neq 0\)&lt;/span>时) 方阵A可逆，&lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;span class="math inline">\(A^T\)&lt;/span>可逆，且&lt;span class="math inline">\((A^T)^{-1} = (A^{-1})^T\)&lt;/span> 方阵A，B都可逆，&lt;span class="math inline">\(\Rightarrow\)&lt;/span> AB也可逆，且&lt;span class="math inline">\((AB)^{-1} = B^{-1} A^{-1}\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>特别的， &lt;span class="math inline">\((A^2)^{-1} = (A^{-1})^2\)&lt;/span> &lt;span class="math inline">\((A^n)^{-1} = (A^{-1})^n\)&lt;/span>&lt;/p>
&lt;p>当A可逆时，还可定义&lt;span class="math inline">\(A^{0}=E, A^{-k}=\left(A^{-1}\right)^{k}\)&lt;/span>，其中 k 为正整数 这样，当 A 可逆, &lt;span class="math inline">\(\lambda\)&lt;/span> 、从 为整数时,有&lt;span class="math inline">\({\boldsymbol{A}}^{\lambda}{\boldsymbol{A}}^{\mu}={\boldsymbol{A}}^{\lambda+\mu},\left({\boldsymbol{A}}^{\lambda}\right)^{\mu}={\boldsymbol{A}}^{\lambda \mu}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>方阵A可逆，则&lt;span class="math inline">\(|A^{-1}| = \frac{1}{|A|}\)&lt;/span> 方阵A可逆，则&lt;span class="math inline">\(A ^ { - 1 } = \frac { 1 } { | A | } \cdot A ^ { * }\)&lt;/span> 方阵A可逆，则&lt;span class="math inline">\(\left( A ^ { * } \right) ^ { - 1 } = \left( A ^ { - 1 } \right) ^ { * }\)&lt;/span>&lt;/p>
&lt;p>注意：方阵A，B，A+B都可逆 &lt;span class="math inline">\(\nRightarrow\)&lt;/span> &lt;span class="math inline">\((A+B)^{-1} = A^{-1} + B^{-1}\)&lt;/span>&lt;/p>
&lt;p>对角矩阵&lt;span class="math inline">\(\Lambda\)&lt;/span>的逆矩阵： &lt;span class="math inline">\(\left[ \begin{array} { c c c c } { a _ {1} , } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { a _ { 2 } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \ddots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { a _ { n } } \end{array} \right] ^{-1} = \left[ \begin{array} { c c c c } { \frac { 1 } { a _ { 1 } } } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { \frac { 1 } { a _ { 2 } } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \ddots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { \frac { 1 } { a _ { n } } } \end{array} \right]\)&lt;/span>&lt;/p>
&lt;p>二阶矩阵求逆矩阵: 行列式分之一,乘以二阶伴随矩阵(主对角线互换, 副对角线取反),记作: &lt;span class="math inline">\(\left[ \begin{array} { l l } { a } &amp;amp; { b } \\ { c } &amp;amp; { d } \end{array} \right] ^ { - 1 } = \frac { 1 } { a d - b c } \left[ \begin{array}{l l} { d } &amp;amp; { - b } \\ { - c} &amp;amp; { a } \end{array} \right]\)&lt;/span>&lt;/p>
&lt;h5 id="方阵求逆逆矩阵的计算">方阵求逆（逆矩阵的计算）&lt;/h5>
&lt;h6 id="方法1定义法">方法1：定义法&lt;/h6>
&lt;p>定义法&lt;span class="math inline">\(AB=E\)&lt;/span>&lt;/p>
&lt;h6 id="方法2伴随矩阵法">方法2：伴随矩阵法&lt;/h6>
&lt;p>&lt;span class="math inline">\(A^{-1} = \frac{1}{|A|} A^*\)&lt;/span> （二阶方阵好用，三阶也还行；高阶方阵的伴随矩阵计算量就太大了）&lt;/p>
&lt;h6 id="方法3初等行变换">方法3：初等行变换&lt;/h6>
&lt;p>&lt;span class="math inline">\((A|E) \overset{\text{由上往下}}{\rightarrow}(\text{上三角矩阵}|\text{一般矩阵})\)&lt;/span> &lt;span class="math inline">\(\overset{\text{由下往上}}{\rightarrow}(\text{对角矩阵}|A^{-1})\)&lt;/span>&lt;/p>
&lt;h6 id="方法4分块矩阵求逆">方法4：分块矩阵求逆&lt;/h6>
&lt;p>${ ^ { - 1 } = } $ &lt;span class="math inline">\({ \left[ \begin{array} { l l } { 0 } &amp;amp; { A } \\ { B } &amp;amp; { 0 } \end{array} \right] ^ { - 1 } = \left[ \begin{array} { l l } { 0 } &amp;amp; { B ^ { - 1 } } \\ { A ^ { - 1 } } &amp;amp; { 0 } \end{array} \right] }\)&lt;/span>&lt;/p>
&lt;h5 id="可对角化方阵">可对角化方阵&lt;/h5>
&lt;p>&lt;span class="math inline">\(\boldsymbol{A P}=\boldsymbol{P \Lambda}\)&lt;/span>时，&lt;span class="math inline">\(A=P A P^{-1}\)&lt;/span>&lt;/p>
&lt;p>可对角化方阵的n次幂： &lt;span class="math inline">\(\boldsymbol{A}=\boldsymbol{P \Lambda P}^{-1}, \boldsymbol{A}^{2}=\boldsymbol{P \Lambda P}^{-1} \boldsymbol{P A P}^{-1}=\boldsymbol{P A}^{2} \boldsymbol{P}^{-1}, \cdots, \boldsymbol{A}^{n}=\boldsymbol{P A}^{n} \boldsymbol{P}^{-1}\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵-a-的-m-次多项式">矩阵 &lt;span class="math inline">\(A\)&lt;/span> 的 &lt;span class="math inline">\(m\)&lt;/span> 次多项式：&lt;/h5>
&lt;p>&lt;span class="math inline">\(\varphi(\boldsymbol{A})=a_{0} \boldsymbol{E}+a_{1} \boldsymbol{A}+\cdots+a_{m} \boldsymbol{A}^{m}\)&lt;/span>&lt;span class="math inline">\(\varphi(\boldsymbol{A})\)&lt;/span>， 称为矩阵 &lt;span class="math inline">\(A\)&lt;/span> 的 &lt;span class="math inline">\(m\)&lt;/span> 次多项式.&lt;/p>
&lt;p>方阵 &lt;span class="math inline">\(\boldsymbol{A}^{k}, \boldsymbol{A}^{\prime}\)&lt;/span> 和 &lt;span class="math inline">\(\boldsymbol{E}\)&lt;/span> 都是可交换的,所以矩阵 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的两个多项式 &lt;span class="math inline">\(\varphi(\boldsymbol{A})\)&lt;/span> 和&lt;span class="math inline">\(f(A)\)&lt;/span> 总是可交换的, 即总有&lt;span class="math inline">\(\varphi(\boldsymbol{A}) f(\boldsymbol{A})=f(\boldsymbol{A}) \varphi(\boldsymbol{A})\)&lt;/span>&lt;/p>
&lt;p>则平方、平方差公式成立&lt;/p>
&lt;h5 id="可对角化矩阵多项式的计算">可对角化矩阵多项式的计算&lt;/h5>
&lt;p>1）如果 &lt;span class="math inline">\(\boldsymbol{A}=\boldsymbol{P \Lambda P}^{-1},\)&lt;/span> 则 &lt;span class="math inline">\(\boldsymbol{A}^{k}=\boldsymbol{P} \boldsymbol{\Lambda}^{k} \boldsymbol{P}^{-1},\)&lt;/span> 从而： &lt;span class="math inline">\(\begin{aligned} \varphi(\boldsymbol{A}) &amp;amp;=a_{0} \boldsymbol{E}+a_{1} \boldsymbol{A}+\cdots+a_{m} \boldsymbol{A}^{m} \\ &amp;amp;=\boldsymbol{P} a_{0} \boldsymbol{E} \boldsymbol{P}^{-1}+\boldsymbol{P} a_{1} \boldsymbol{\Lambda} \boldsymbol{P}^{-1}+\cdots+\boldsymbol{P} a_{m} \boldsymbol{\Lambda}^{m} \boldsymbol{P}^{-1} \\ &amp;amp;=\boldsymbol{P} \varphi(\boldsymbol{\Lambda}) \boldsymbol{P}^{-1} \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>2）如果 &lt;span class="math inline">\(\boldsymbol{\Lambda}=\operatorname{diag}\left(\lambda_{1}, \lambda_{2}, \cdots, \lambda_{n}\right)\)&lt;/span> 为对角阵,则 &lt;span class="math inline">\(\boldsymbol{\Lambda}^{k}=\operatorname{diag}\left(\lambda_{1}^{k}, \lambda_{2}^{k}, \cdots, \lambda_{n}^{k}\right),\)&lt;/span> 从而： &lt;span class="math inline">\(\varphi(\mathbf{\Lambda})=a_{0} \boldsymbol{E}+a_{1} \boldsymbol{\Lambda}+\cdots+a_{m} \boldsymbol{\Lambda}^{m}\)&lt;/span> &lt;span class="math inline">\(=a_{0}\left(\begin{array}{ccc}1 &amp;amp; \\ &amp;amp; 1 \\ &amp;amp; &amp;amp; \ddots \\ &amp;amp; &amp;amp; &amp;amp; 1\end{array}\right)+a_{1}\left(\begin{array}{c}\lambda_{1}&amp;amp; &amp;amp; &amp;amp;\\ &amp;amp; \lambda_{2} &amp;amp; &amp;amp;\\&amp;amp; &amp;amp; \ddots &amp;amp; \\&amp;amp; &amp;amp; &amp;amp; \lambda_n \\ \end{array}\right)+\cdots+a_{m}\left(\begin{array}{c}\lambda_{1}^{m} &amp;amp; &amp;amp; &amp;amp; &amp;amp;\\ &amp;amp;\lambda_{2}^{m}&amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; &amp;amp;\lambda_{n}^{m}\end{array}\right)\)&lt;/span> &lt;span class="math inline">\(=\left(\begin{array}{cccc}\varphi\left(\lambda_{1}\right) &amp;amp; &amp;amp; &amp;amp; \\ &amp;amp; \varphi\left(\lambda_{2}\right) &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \varphi\left(\lambda_{n}\right)\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="分块矩阵">分块矩阵&lt;/h3>
&lt;h4 id="分块矩阵的性质运算律">分块矩阵的性质/运算律&lt;/h4>
&lt;h5 id="分块矩阵加法">分块矩阵加法&lt;/h5>
&lt;p>$+= $&lt;/p>
&lt;h5 id="分块矩阵数乘">分块矩阵数乘&lt;/h5>
&lt;p>&lt;span class="math inline">\(\lambda \boldsymbol{A}=\left(\begin{array}{ccc}\lambda \boldsymbol{A}_{11} &amp;amp; \cdots &amp;amp; \lambda \boldsymbol{A}_{1 r} \\ \vdots &amp;amp; &amp;amp; \vdots \\ \lambda \boldsymbol{A}_{s 1} &amp;amp; \cdots &amp;amp; \lambda \boldsymbol{A}_{\mathrm{sr}}\end{array}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="分块矩阵乘法">分块矩阵乘法&lt;/h5>
&lt;p>矩阵A、B作如下分块： &lt;span class="math inline">\(\boldsymbol{A}=\left(\begin{array}{ccc}\boldsymbol{A}_{11} &amp;amp; \cdots &amp;amp; \boldsymbol{A}_{11} \\ \vdots &amp;amp; &amp;amp; \vdots \\ \boldsymbol{A}_{11} &amp;amp; \cdots &amp;amp; \boldsymbol{A}_{st}\end{array}\right), \boldsymbol{B}=\left(\begin{array}{ccc}\boldsymbol{B}_{11} &amp;amp; \cdots &amp;amp; \boldsymbol{B}_{1 r} \\ \vdots &amp;amp; &amp;amp; \vdots \\ \boldsymbol{B}_{11} &amp;amp; \cdots &amp;amp; \boldsymbol{B}_{t r}\end{array}\right)\)&lt;/span> 则：&lt;/p>
&lt;p>&lt;span class="math inline">\(\boldsymbol{A B}=\left(\begin{array}{ccc}\boldsymbol{C}_{11} &amp;amp; \cdots &amp;amp; \boldsymbol{C}_{1 r} \\ \vdots &amp;amp; &amp;amp; \vdots \\ \boldsymbol{C}_{41} &amp;amp; \cdots &amp;amp; \boldsymbol{C}_{s r}\end{array}\right)\)&lt;/span> 其中&lt;span class="math inline">\(C_{i j}=\sum_{k=1}^{t} A_{i k} B_{k j}(i=1, \cdots, s ; j=1, \cdots, r)\)&lt;/span>&lt;/p>
&lt;p>举例： $= $&lt;/p>
&lt;h5 id="分块矩阵的转置">分块矩阵的转置&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left[\begin{array}{} A &amp;amp; B \\ C &amp;amp; D \end{array}\right]^T = \left[\begin{array}{} A^T &amp;amp; B^T \\ C^T &amp;amp; D^T \end{array}\right]\)&lt;/span>&lt;/p>
&lt;h5 id="分块矩阵的方幂">分块矩阵的方幂&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left[\begin{array}{} A &amp;amp; 0 \\ 0 &amp;amp; B \end{array}\right]^n = \left[\begin{array}{} A^n &amp;amp; 0 \\ 0 &amp;amp; B^n \end{array}\right]\)&lt;/span>&lt;/p>
&lt;h5 id="分块矩阵的逆">分块矩阵的逆&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left[\begin{array}{} A &amp;amp; 0 \\ 0 &amp;amp; B \end{array}\right]^{-1} = \left[\begin{array}{} A^{-1} &amp;amp; 0 \\ 0 &amp;amp; B^{-1} \end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(\begin{array}{ll}O &amp;amp; A \\ B &amp;amp; O\end{array}\right)^{-1} = \left(\begin{array}{cc} O &amp;amp; B^{-1} \\ A^{-1} &amp;amp; O \end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(\begin{array}{ll}A &amp;amp; O \\ C &amp;amp; B\end{array}\right)^{-1} = \left(\begin{array}{cc} A^{-1} &amp;amp; 0 \\ -B^{-1} C A^{-1} &amp;amp; B^{-1} \end{array}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="分块对角矩阵">分块对角矩阵&lt;/h5>
&lt;h6 id="分块对角矩阵概念">分块对角矩阵概念&lt;/h6>
&lt;p>设 A 为 n 阶矩阵,若 A 的分块矩阵只有在对角线上有非零子块,其余 子块都为零矩阵，且在对角线上的子块都是方阵, 即： &lt;span class="math inline">\(\boldsymbol{A}=\left(\begin{array}{ccc}\boldsymbol{A}_{1} &amp;amp; &amp;amp; &amp;amp; \boldsymbol{0} \\ &amp;amp; \boldsymbol{A}_{2} &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ \boldsymbol{O} &amp;amp; &amp;amp; &amp;amp;\boldsymbol{A}_{\mathrm{s}}\end{array}\right)\)&lt;/span> 其中 &lt;span class="math inline">\(A_{i}(i=1,2, \cdots, s)\)&lt;/span> 都是方阵,那么称 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 为分块对角矩阵.&lt;/p>
&lt;h6 id="分块对角矩阵性质">分块对角矩阵性质&lt;/h6>
&lt;p>&lt;span class="math inline">\(|\boldsymbol{A}|=\left|\boldsymbol{A}_{1}\right|\left|\boldsymbol{A}_{2}\right| \cdots|\boldsymbol{A},|\)&lt;/span>&lt;/p>
&lt;p>若 &lt;span class="math inline">\(\left|\boldsymbol{A}_{i}\right| \neq 0(i=1,2, \cdots, s),\)&lt;/span> 则 &lt;span class="math inline">\(|\boldsymbol{A}| \neq 0,\)&lt;/span> 并有： &lt;span class="math inline">\(\boldsymbol{A}^{-1}=\left[\begin{array}{ccc}\boldsymbol{A}_{1}^{-1} &amp;amp; &amp;amp; \boldsymbol{O} \\ &amp;amp; \boldsymbol{A}_{2}^{-1} &amp;amp; \\ &amp;amp; \ddots &amp;amp; \\ \boldsymbol{O} &amp;amp; &amp;amp; \boldsymbol{A}_{s}^{-1}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;h5 id="按列分块的乘法">按列分块的乘法&lt;/h5>
&lt;p>$AB = A(_1, _2 , , _n) = (A_1, A_2 , , A_n) $&lt;/p>
&lt;p>有时候，将矩阵按行或按列分块后，会便于理解及计算。&lt;/p>
&lt;p>矩阵乘法的理解： 若把 A 按行分成m 块,把 B 按列分成 n 块,便有： &lt;span class="math inline">\(\boldsymbol{A B}=\left(\begin{array}{c}\boldsymbol{\alpha}_{1}^{\mathrm{T}} \\ \boldsymbol{\alpha}_{2}^{\mathrm{T}} \\ \vdots \\ \boldsymbol{\alpha}_{\mathrm{m}}^{\mathrm{T}}\end{array}\right)\left(\boldsymbol{b}_{1}, \boldsymbol{b}_{2}, \cdots, \boldsymbol{b}_{n}\right)=\left(\begin{array}{cccc}\boldsymbol{\alpha}_{1}^{\mathrm{T}} \boldsymbol{b}_{1} &amp;amp; \boldsymbol{\alpha}_{1}^{\mathrm{T}} \boldsymbol{b}_{2} &amp;amp; \cdots &amp;amp; \boldsymbol{\alpha}_{1}^{\mathrm{T}} \boldsymbol{b}_{n} \\ \boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol{b}_{1} &amp;amp; \boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol{b}_{2} &amp;amp; \cdots &amp;amp; \boldsymbol{\alpha}_{2}^{\mathrm{T}} \boldsymbol{b}_{n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ \boldsymbol{\alpha}_{m}^{\mathrm{T}} \boldsymbol{b}_{1} &amp;amp; \boldsymbol{\alpha}_{m}^{\mathrm{T}} \boldsymbol{b}_{2} &amp;amp; \cdots &amp;amp; \boldsymbol{\alpha}_{m}^{\mathrm{T}} \boldsymbol{b}_{\mathrm{n}}\end{array}\right)=\left(c_{i j}\right)_{m \times n}\)&lt;/span> 其中： &lt;span class="math inline">\(c_{i j}=\boldsymbol{\alpha}_{i}^{\top} \boldsymbol{b}_{j}=\left(a_{i 1}, a_{i 2}, \cdots, a_{i s}\right)\left(\begin{array}{c}b_{1 j} \\ b_{2 j} \\ \vdots \\ b_{s j}\end{array}\right)=\sum_{k=1}^{s} a_{i k} b_{k j}\)&lt;/span>&lt;/p>
&lt;p>矩阵每行分别缩放一定倍数的理解： 以对角阵 A &lt;span class="math inline">\(_{m}\)&lt;/span> 左乘矩阵 &lt;span class="math inline">\(\boldsymbol{A}_{m \times n}\)&lt;/span> 时,把 A 按行分块,有： &lt;span class="math inline">\(\boldsymbol{\Lambda}_{m} \boldsymbol{A}_{m \times n}=\left(\begin{array}{ccc}\lambda_{1}&amp;amp; &amp;amp; &amp;amp; \\&amp;amp; \lambda_{2} &amp;amp; &amp;amp; \\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_{m}\end{array}\right)\left[\begin{array}{c}\boldsymbol{\alpha}_{1}^{\mathrm{T}} \\ \boldsymbol{\alpha}_{2}^{\mathrm{T}} \\ \vdots \\ \boldsymbol{\alpha}_{m}^{\mathrm{T}}\end{array}\right]=\left[\begin{array}{c}\lambda_{1} \boldsymbol{\alpha}_{1}^{\mathrm{T}} \\ \lambda_{2} \boldsymbol{\alpha}_{2}^{\mathrm{T}} \\ \vdots \\ \lambda_{m} \boldsymbol{\alpha}_{m}^{\mathrm{T}}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>矩阵每列分别缩放一定倍数的理解： 以对角阵 A, 右乘矩阵 &lt;span class="math inline">\(A_{m \times n}\)&lt;/span> 时,把 A 按列分块,有： &lt;span class="math inline">\(\boldsymbol{A \Lambda}_{n}=\left(a_{1}, a_{2}, \cdots, a_{n}\right) \left( \begin{array}{ccc}\lambda_{1} &amp;amp; &amp;amp; &amp;amp;\\ &amp;amp;\lambda_{2} &amp;amp; &amp;amp;\\ &amp;amp; &amp;amp; \ddots &amp;amp; \\ &amp;amp; &amp;amp; &amp;amp; \lambda_{n}\end{array}\right)=\left(\lambda_{1} a_{1}, \lambda_{2} a_{2}, \cdots, \lambda_{n} a_{n}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="方阵的行列式-1">方阵的行列式&lt;/h3>
&lt;p>行列式章节大部分已经介绍过，这里只作罗列：&lt;/p>
&lt;p>&lt;span class="math inline">\(| A^T|=| \boldsymbol{A} \mid\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|\boldsymbol{A} \boldsymbol{B}|=|\boldsymbol{A}||\boldsymbol{B}|\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|k \mathbf{A}|=k^{n}|\mathbf{A}|\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|A B|=|A||B|\)&lt;/span>，以及推论&lt;span class="math inline">\(|A^2| = |A|^2, |A^n| = |A|^n\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left|\boldsymbol{A}^{*}\right|=|\boldsymbol{A}|^{n-1}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left|\boldsymbol{A}^{-1}\right|=|\boldsymbol{A}|^{-1}\)&lt;/span>&lt;/p>
&lt;p>若 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 是 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵 &lt;span class="math inline">\(, \lambda_{i}(i=1,2, \cdots, n)\)&lt;/span> 是 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的特征值,则 &lt;span class="math inline">\(|\boldsymbol{A}|=\prod_{i=1}^{n} \lambda_{i}\)&lt;/span>&lt;/p>
&lt;p>若矩阵 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 和 &lt;span class="math inline">\(\boldsymbol{B}\)&lt;/span> 相似 &lt;span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B},\)&lt;/span> 则 &lt;span class="math inline">\(|\boldsymbol{A}|=|\boldsymbol{B}|\)&lt;/span>&lt;/p>
&lt;p>若&lt;span class="math inline">\(A^*\)&lt;/span>是 A 的伴随矩阵,则&lt;span class="math inline">\(\boldsymbol{A A}^{*}=\boldsymbol{A}^{*} \boldsymbol{A}=|\boldsymbol{A}| \boldsymbol{E}\)&lt;/span>&lt;/p>
&lt;p>如果 A 和 B 分别是 &lt;span class="math inline">\(m\)&lt;/span> 阶和 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵,则： &lt;span class="math inline">\(\left|\begin{array}{ll}\boldsymbol{A} &amp;amp; * \\ \boldsymbol{O} &amp;amp; \boldsymbol{B}\end{array}\right|=\left|\begin{array}{ll}\boldsymbol{A} &amp;amp; \boldsymbol{O} \\ * &amp;amp; \boldsymbol{B}\end{array}\right|=|\boldsymbol{A}| \cdot|\boldsymbol{B}|\)&lt;/span>，其中A,B要求为方阵,其余位置不要求为方阵 &lt;span class="math inline">\(\left|\begin{array}{cc}\boldsymbol{O} &amp;amp; \boldsymbol{A} \\ \boldsymbol{B} &amp;amp; *\end{array}\right|=\left|\begin{array}{cc}* &amp;amp; \boldsymbol{A} \\ \boldsymbol{B} &amp;amp; \boldsymbol{O}\end{array}\right|=(-1)^{m n}|\boldsymbol{A}| \cdot|\boldsymbol{B}|\)&lt;/span>，其中A,B要求为方阵,其余位置不要求为方阵,m和n为A与B的阶数&lt;/p>
&lt;p>注意：对于 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵 &lt;span class="math inline">\(\boldsymbol{A}, \boldsymbol{B},\)&lt;/span> 一般来说 &lt;span class="math inline">\(\boldsymbol{A B} \neq \boldsymbol{B A}\)&lt;/span>,但总有&lt;span class="math inline">\(|A B|=|B A|\)&lt;/span>&lt;/p></description></item><item><title>线性代数-矩阵1习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 25 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-矩阵1习题">线性代数-矩阵1习题&lt;/h1>
&lt;h2 id="矩阵的基本运算">矩阵的基本运算&lt;/h2>
&lt;p>主要涉及矩阵加法、数乘、乘法、转置。&lt;/p>
&lt;h3 id="矩阵的乘法">矩阵的乘法&lt;/h3>
&lt;h4 id="矩阵乘法的计算">矩阵乘法的计算&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921171929520.png" alt="" />&lt;figcaption>image-20200921171929520&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172018763.png" alt="" />&lt;figcaption>image-20200921172018763&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172152544.png" alt="" />&lt;figcaption>image-20200921172152544&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172215029.png" alt="" />&lt;figcaption>image-20200921172215029&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172911518.png" alt="" />&lt;figcaption>image-20200921172911518&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172926683.png" alt="" />&lt;figcaption>image-20200921172926683&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-这题没做出来">例4 这题没做出来&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172950596.png" alt="" />&lt;figcaption>image-20200921172950596&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921173003021.png" alt="" />&lt;figcaption>image-20200921173003021&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921194558092.png" alt="" />&lt;figcaption>image-20200921194558092&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921194609085.png" alt="" />&lt;figcaption>image-20200921194609085&lt;/figcaption>
&lt;/figure>
&lt;h4 id="矩阵乘法的性质">矩阵乘法的性质&lt;/h4>
&lt;h6 id="例1-一般矩阵乘法不可交换">例1 一般矩阵乘法不可交换&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172539170.png" alt="" />&lt;figcaption>image-20200921172539170&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-基本消元不成立">例2 基本消元不成立&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172656436.png" alt="" />&lt;figcaption>image-20200921172656436&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172703926.png" alt="" />&lt;figcaption>image-20200921172703926&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172722887.png" alt="" />&lt;figcaption>image-20200921172722887&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172735637.png" alt="" />&lt;figcaption>image-20200921172735637&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172748928.png" alt="" />&lt;figcaption>image-20200921172748928&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求逆矩阵">求逆矩阵&lt;/h2>
&lt;h3 id="直接求逆矩阵">直接求逆矩阵&lt;/h3>
&lt;p>二阶：逆矩阵为：行列式分之伴随&lt;/p>
&lt;p>高阶：&lt;span class="math inline">\((A|E) \rightarrow (E | A^-1)\)&lt;/span>&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921181622666.png" alt="" />&lt;figcaption>image-20200921181622666&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921181704511.png" alt="" />&lt;figcaption>image-20200921181704511&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190010545.png" alt="" />&lt;figcaption>image-20200921190010545&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/6a63f6246b600c3307cc2c67184c510fd8f9a1ec" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190214088.png" alt="" />&lt;figcaption>image-20200921190214088&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190240647.png" alt="" />&lt;figcaption>image-20200921190240647&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190257191.png" alt="" />&lt;figcaption>image-20200921190257191&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190315210.png" alt="" />&lt;figcaption>image-20200921190315210&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190334339.png" alt="" />&lt;figcaption>image-20200921190334339&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190345113.png" alt="" />&lt;figcaption>image-20200921190345113&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190412677.png" alt="" />&lt;figcaption>image-20200921190412677&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190424903.png" alt="" />&lt;figcaption>image-20200921190424903&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解矩阵方程">解矩阵方程&lt;/h3>
&lt;p>线性变换可以表示为矩阵方程。线性变化与矩阵方程一一对应。&lt;/p>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182121252.png" alt="" />&lt;figcaption>image-20200921182121252&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182156262.png" alt="" />&lt;figcaption>image-20200921182156262&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172357774.png" alt="" />&lt;figcaption>image-20200921172357774&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921172441038.png" alt="" />&lt;figcaption>image-20200921172441038&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182440339.png" alt="" />&lt;figcaption>image-20200921182440339&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182452147.png" alt="" />&lt;figcaption>image-20200921182452147&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182523666.png" alt="" />&lt;figcaption>image-20200921182523666&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921182534303.png" alt="" />&lt;figcaption>image-20200921182534303&lt;/figcaption>
&lt;/figure>
&lt;h2 id="可对角化矩阵多项式求解">可对角化矩阵多项式求解&lt;/h2>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190542818.png" alt="" />&lt;figcaption>image-20200921190542818&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190559166.png" alt="" />&lt;figcaption>image-20200921190559166&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190638115.png" alt="" />&lt;figcaption>image-20200921190638115&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190652914.png" alt="" />&lt;figcaption>image-20200921190652914&lt;/figcaption>
&lt;/figure>
&lt;h2 id="分块矩阵">分块矩阵&lt;/h2>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921200754792.png" alt="" />&lt;figcaption>image-20200921200754792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921200804271.png" alt="" />&lt;figcaption>image-20200921200804271&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-不会证">例2 不会证&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921204255430.png" alt="" />&lt;figcaption>image-20200921204255430&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\left(\begin{array}{ll}O &amp;amp; A \\ B &amp;amp; O\end{array}\right)^{-1} = \left(\begin{array}{cc} O &amp;amp; B^{-1} \\ A^{-1} &amp;amp; O \end{array}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(\begin{array}{ll}A &amp;amp; O \\ C &amp;amp; B\end{array}\right)^{-1} = \left(\begin{array}{cc} A^{-1} &amp;amp; 0 \\ -B^{-1} C A^{-1} &amp;amp; B^{-1} \end{array}\right)\)&lt;/span>&lt;/p>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921204358157.png" alt="" />&lt;figcaption>image-20200921204358157&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921204422576.png" alt="" />&lt;figcaption>image-20200921204422576&lt;/figcaption>
&lt;/figure>
&lt;h2 id="矩阵的证明">矩阵的证明&lt;/h2>
&lt;h3 id="证明矩阵是对称矩阵">证明矩阵是对称矩阵&lt;/h3>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921180830666.png" alt="" />&lt;figcaption>image-20200921180830666&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\boldsymbol{B}^{T} \boldsymbol{A} \boldsymbol{B} = ((AB)^T B)^T = (B^T A^T B)^T\)&lt;/span> 又A是对称阵，即&lt;span class="math inline">\(A^T = A\)&lt;/span> 则$(B^T A^T B)^T = (B^T A B)^T $&lt;/p>
&lt;p>所以$^{T} = (B^T A B)^T &lt;span class="math inline">\(，即\)&lt;/span>B^T A B$是对称阵。&lt;/p>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921180914260.png" alt="" />&lt;figcaption>image-20200921180914260&lt;/figcaption>
&lt;/figure>
&lt;p>注：写出元素，用定义证明。&lt;/p>
&lt;h3 id="逆矩阵的证明">逆矩阵的证明&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190730677.png" alt="" />&lt;figcaption>image-20200921190730677&lt;/figcaption>
&lt;/figure>
&lt;p>证明:因为 A^k = 0 所以 (E-A)(E+A+A&lt;sup>2+…+A&lt;/sup>(k-1)) = E+A+A&lt;sup>2+…+A&lt;/sup>(k-1) -A-A&lt;sup>2-…-A&lt;/sup>(k-1)-A^k = E - A^k = E 所以 E-A 可逆,且 (E-A)^-1 = E+A+A&lt;sup>2+…+A&lt;/sup>(k-1)&lt;/p>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190839795.png" alt="" />&lt;figcaption>image-20200921190839795&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921190924362.png" alt="" />&lt;figcaption>image-20200921190924362&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/738b4710b912c8fc3ae60181f2039245d6882161" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921192054099.png" alt="" />&lt;figcaption>image-20200921192054099&lt;/figcaption>
&lt;/figure>
&lt;p>AA&lt;em>＝|A|E，AA^-1＝E .所以A&lt;/em>＝|A|A^-1.既A*可逆。接下来就好做了。。。&lt;/p>
&lt;h3 id="伴随矩阵的证明">伴随矩阵的证明&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200921193142460.png" alt="" />&lt;figcaption>image-20200921193142460&lt;/figcaption>
&lt;/figure>
&lt;p>（1）证明: 假设&lt;span class="math inline">\(|a^*|≠0\)&lt;/span> 由&lt;span class="math inline">\(a^*\)&lt;/span>可逆 因为&lt;span class="math inline">\(aa^*=|a|a=0\)&lt;/span> 等式两边右乘&lt;span class="math inline">\((a^*)^-1\)&lt;/span>则得 &lt;span class="math inline">\(a=0\)&lt;/span> 故&lt;span class="math inline">\(a^*=0\)&lt;/span> 所以&lt;span class="math inline">\(|a^*|=0\)&lt;/span> 与假设矛盾.&lt;/p>
&lt;p>（2）略&lt;/p></description></item><item><title>线性代数-行列式</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</link><pubDate>Mon, 20 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-行列式">线性代数-行列式&lt;/h1>
&lt;h2 id="行列式">行列式&lt;/h2>
&lt;h3 id="行列式的概念">行列式的概念&lt;/h3>
&lt;h5 id="排列">排列&lt;/h5>
&lt;p>1个n阶排列是指由&lt;span class="math inline">\(1,2,...,n\)&lt;/span>共n个数构成的一个有序数组。通常用&lt;span class="math inline">\(j_1,j_2,...j_n\)&lt;/span>表示一个n阶排列。&lt;/p>
&lt;h5 id="逆序">逆序&lt;/h5>
&lt;p>一个排列中，如果一个大的数排在小的数之前，就称这两个数构成一个逆序。（两个数的逆序）&lt;/p>
&lt;h5 id="逆序数">逆序数&lt;/h5>
&lt;p>一个排列的逆序总数称为这个排列的逆序数. 用 &lt;span class="math inline">\(\tau\left(j_{1} j_{2} \cdots j_{n}\right)\)&lt;/span> 表示排列 &lt;span class="math inline">\(j_{1} j_{2} \cdots j_{n}\)&lt;/span> 的逆序数。&lt;/p>
&lt;h5 id="奇排列与偶排列">奇排列与偶排列&lt;/h5>
&lt;p>如果一个排列的逆序数是偶数，则称这个排列为偶排列，否则称为奇排列.&lt;/p>
&lt;h5 id="行列式-1">行列式&lt;/h5>
&lt;p>行列式是一个数。&lt;/p>
&lt;p>对于n阶行列式，有： &lt;span class="math inline">\(\left|\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{nn}\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=\sum_{j_{1} j_{2} \cdots j_{n}}(-1)^{\tau\left(j_{1} j_{2} \cdots j_{n}\right)} a_{1 j_{1}} a_{2 j_{2}} \cdots a_{n j_{n}}\)&lt;/span> &lt;span class="math inline">\(\sum_{j_{1} j_{2} \cdots j_{n}}\)&lt;/span> 表示对所有 &lt;span class="math inline">\(n\)&lt;/span> 阶排列求和,它结果是所有（取自不同行不同列的 n 个元素的乘积再乘以一个&lt;span class="math inline">\(\pm 1\)&lt;/span>）结果的代数和。各项的正负号由排列的逆序数决定。&lt;/p>
&lt;p>等式右端又称&lt;strong>n 阶行列式的完全展开式&lt;/strong>.&lt;/p>
&lt;p>eg：二阶行列式的完全展开式： &lt;span class="math inline">\(\left|\begin{array}{ll}a &amp;amp; b \\ c &amp;amp; d\end{array}\right|=a d-b c\)&lt;/span>&lt;/p>
&lt;p>eg2：三阶行列式的完全展开式： &lt;span class="math inline">\(\left|\begin{array}{lll}a_{11} &amp;amp; a_{12} &amp;amp; a_{13} \\ a_{21} &amp;amp; a_{22} &amp;amp; a_{23} \\ a_{31} &amp;amp; a_{32} &amp;amp; a_{33}\end{array}\right|=a_{11} a_{22} a_{33}+a_{12} a_{23} a_{31}+a_{13} a_{21} a_{32}-a_{13} a_{22} a_{31}-a_{12} a_{21} a_{33}-a_{11} a_{23} a_{32}\)&lt;/span>&lt;/p>
&lt;p>（二阶行列式、三阶行列式写完全展开式有一种简便记法：主对角线方向的元素-副对角线方向的元素。 在二阶、三阶行列式中0比较多时比较好用。 注意：只有二阶、三阶行列式有此特点/计算法，高阶行列式必须要按后面行列式展开公式来计算。）&lt;/p>
&lt;h3 id="行列式的性质">行列式的性质&lt;/h3>
&lt;h5 id="转置值不变">转置值不变&lt;/h5>
&lt;p>1）经过转置行列式的值不变,即 &lt;span class="math inline">\(| A^T|=| \boldsymbol{A} \mid\)&lt;/span>&lt;/p>
&lt;p>1.2）上一条的推论：行列式行的性质与列的性质是对等的.（所以下面只讨论行的性质，要明白列也有相同性质）&lt;/p>
&lt;p>eg： &lt;span class="math inline">\(\left|\begin{array}{ll}1 &amp;amp; 2 \\ 3 &amp;amp; 4\end{array}\right|=\left|\begin{array}{ll}1 &amp;amp; 3 \\ 2 &amp;amp; 4\end{array}\right|\)&lt;/span>&lt;/p>
&lt;h5 id="两行互换值变号">两行互换值变号&lt;/h5>
&lt;p>2）两行(或列) 互换位置,行列式的值变号.&lt;/p>
&lt;p>2.2）上一条的推论：如果行列式中两行(或列) 相同,行列式的值为 0.&lt;/p>
&lt;h5 id="数乘性质">数乘性质&lt;/h5>
&lt;p>3）如某行（或列）有公因子 k,则可把 k 提出行列式记号外. (亦即用数 k 乘行列式&lt;span class="math inline">\(|A|\)&lt;/span>等于用 k 乘它的某行(或列))。如整个行列式都有公因子k，则可以提出n次k （即&lt;span class="math inline">\(|k \mathbf{A}|=k^{n}|\mathbf{A}|\)&lt;/span>）&lt;/p>
&lt;p>3.2）上一条的推论：某行(或列) 的元素全为 0,行列式的值为 0.&lt;/p>
&lt;p>3.3）根据3）和2）有推论：若两行(或列) 的元素对应成比例，行列式的值为 0.&lt;/p>
&lt;h5 id="拆分性质">拆分性质&lt;/h5>
&lt;p>4）如果行列式某行(或列) 是两个元素之和，则可把行列式拆成两个行列式之和.&lt;/p>
&lt;p>eg：&lt;/p>
&lt;p>&lt;span class="math inline">\(\left|\begin{array}{ccc}a_{1}+b_{1} &amp;amp; a_{2}+b_{2} &amp;amp; a_{3}+b_{3} \\ c_{1} &amp;amp; c_{2} &amp;amp; c_{3} \\ d_{1} &amp;amp; d_{2} &amp;amp; d_{3}\end{array}\right|=\left|\begin{array}{ccc}a_{1} &amp;amp; a_{2} &amp;amp; a_{3} \\ c_{1} &amp;amp; c_{2} &amp;amp; c_{3} \\ d_{1} &amp;amp; d_{2} &amp;amp; d_{3}\end{array}\right|+\left|\begin{array}{ccc}b_{1} &amp;amp; b_{2} &amp;amp; b_{3} \\ c_{1} &amp;amp; c_{2} &amp;amp; c_{3} \\ d_{1} &amp;amp; d_{2} &amp;amp; d_{3}\end{array}\right|\)&lt;/span>&lt;/p>
&lt;h5 id="倍加性质">倍加性质&lt;/h5>
&lt;p>5）把某行(或列) 的 k 倍加到另一行(或列),行列式的值不变.&lt;/p>
&lt;p>eg：&lt;/p>
&lt;p>&lt;span class="math inline">\(\left|\begin{array}{lll}a_{1} &amp;amp; a_{2} &amp;amp; a_{3} \\ b_{1} &amp;amp; b_{2} &amp;amp; b_{3} \\ c_{1} &amp;amp; c_{2} &amp;amp; c_{3}\end{array}\right|=\left|\begin{array}{ccc}a_{1} &amp;amp; a_{2} &amp;amp; a_{3} \\ b_{1}+k a_{1} &amp;amp; b_{2}+k a_{2} &amp;amp; b_{3}+k a_{3} \\ c_{1} &amp;amp; c_{2} &amp;amp; c_{3}\end{array}\right|\)&lt;/span>&lt;/p>
&lt;h5 id="学过矩阵后补充的性质">学过矩阵后补充的性质&lt;/h5>
&lt;p>1）（行列式乘法公式）若 A , B 都是 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵,则 &lt;span class="math inline">\(|A B|=|A||B|\)&lt;/span>&lt;/p>
&lt;p>2）若 A 是 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵.&lt;span class="math inline">\(A^*\)&lt;/span> 是 &lt;span class="math inline">\(A\)&lt;/span> 的伴随矩阵,则 &lt;span class="math inline">\(\left|\boldsymbol{A}^{*}\right|=|\boldsymbol{A}|^{n-1}\)&lt;/span>&lt;/p>
&lt;p>3）若 A 是 &lt;span class="math inline">\(n\)&lt;/span> 阶可逆矩阵, &lt;span class="math inline">\(A^{-1}\)&lt;/span> 是 &lt;span class="math inline">\(A\)&lt;/span> 的逆矩阵,则 &lt;span class="math inline">\(\left|\boldsymbol{A}^{-1}\right|=|\boldsymbol{A}|^{-1}\)&lt;/span>&lt;/p>
&lt;p>4）若 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 是 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵 &lt;span class="math inline">\(, \lambda_{i}(i=1,2, \cdots, n)\)&lt;/span> 是 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 的特征值,则 &lt;span class="math inline">\(|\boldsymbol{A}|=\prod_{i=1}^{n} \lambda_{i}\)&lt;/span>&lt;/p>
&lt;p>5）若矩阵 &lt;span class="math inline">\(\boldsymbol{A}\)&lt;/span> 和 &lt;span class="math inline">\(\boldsymbol{B}\)&lt;/span> 相似 &lt;span class="math inline">\(\boldsymbol{A} \sim \boldsymbol{B},\)&lt;/span> 则 &lt;span class="math inline">\(|\boldsymbol{A}|=|\boldsymbol{B}|\)&lt;/span>&lt;/p>
&lt;p>6）是 A 的伴随矩阵,则若 A 是 n 阶矩阵, &lt;span class="math inline">\(A^*\)&lt;/span>是 A 的伴随矩阵,则&lt;span class="math inline">\(\boldsymbol{A A}^{*}=\boldsymbol{A}^{*} \boldsymbol{A}=|\boldsymbol{A}| \boldsymbol{E}\)&lt;/span>&lt;/p>
&lt;h3 id="行列式按行或列展开公式">行列式按行（或列）展开公式&lt;/h3>
&lt;h5 id="余子式">余子式&lt;/h5>
&lt;p>n阶行列式： &lt;span class="math inline">\(D=\left|\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{m}\end{array}\right|\)&lt;/span> 从中划去 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 所在的第 &lt;span class="math inline">\(i\)&lt;/span> 行、第 &lt;span class="math inline">\(j\)&lt;/span> 列的元素，由剩下的元素按原来的位置排法构成的一个 &lt;span class="math inline">\(n-1\)&lt;/span> 阶行列式： &lt;span class="math inline">\(\begin{array}{|cccccc|}a_{11} &amp;amp; \cdots &amp;amp; a_{1, j-1} &amp;amp; a_{1, j+1} &amp;amp; \cdots &amp;amp; a_{1 n} \\ \vdots &amp;amp; &amp;amp; \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{i-1,1} &amp;amp; \cdots &amp;amp; a_{i-1, j-1} &amp;amp; a_{i-1, j+1} &amp;amp; \cdots &amp;amp; a_{i-1, n} \\ a_{i+1,1} &amp;amp; \cdots &amp;amp; a_{i+1, j-1} &amp;amp; a_{i+1, j+1} &amp;amp; \cdots &amp;amp; a_{i+1, n} \\ \vdots &amp;amp; &amp;amp; \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; \cdots &amp;amp; a_{n, j-1} &amp;amp; a_{n, j+1} &amp;amp; \cdots &amp;amp; a_{n n}\end{array} \mid\)&lt;/span> 称其为 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 的余子式,记为 &lt;span class="math inline">\(M_{i j}\)&lt;/span>&lt;/p>
&lt;h5 id="代数余子式">代数余子式&lt;/h5>
&lt;p>称 &lt;span class="math inline">\((-1)^{i+j} M_{i j}\)&lt;/span> 为 &lt;span class="math inline">\(a_{i j}\)&lt;/span> 的代数余子式,记为 &lt;span class="math inline">\(A_{i j}\)&lt;/span>。即&lt;span class="math inline">\(A_{i j}=(-1)^{i-j} M_{i j}\)&lt;/span>&lt;/p>
&lt;h6 id="代数余子式性质">代数余子式性质&lt;/h6>
&lt;p>行列式的任一行(列) 元素与另一行(列) 元素的代数余子式乘积之和为 0,即： &lt;span class="math inline">\(\sum_{k=1}^{n} a_{i k} A_{j k}=a_{i 1} A_{j 1}+a_{i 2} A_{j 2}+\cdots+a_{i m} A_{j n}=0, \quad i \neq j\)&lt;/span> &lt;span class="math inline">\(\sum_{k=1}^{n} a_{k i} A_{k j}=a_{1 i} A_{1 j}+a_{2 i} A_{2 j}+\cdots+a_{n i} A_{n j}=0, \quad i \neq j\)&lt;/span>&lt;/p>
&lt;h4 id="行列式按行或列展开公式-1">行列式按行（或列）展开公式&lt;/h4>
&lt;p>n 阶行列式的值等于它的任何一行(列) 元素,与其对应的代数余子式乘积之和，即： &lt;span class="math inline">\(|\boldsymbol{A}|=a_{i 1} A_{i 1}+a_{i 2} A_{i 2}+\cdots+a_{i n} A_{m i}=\sum_{k=1}^{n} a_{i k} A_{i k}, \quad i=1,2, \cdots, n\)&lt;/span> （按第i行展开） &lt;span class="math inline">\(|\boldsymbol{A}|=a_{1 j} A_{1 j}+a_{2 j} A_{2 j}+\cdots+a_{n j} A_{w} = \sum_{k=1}^{n} a_{k j} A_{k j}, \quad j=1,2, \cdots n\)&lt;/span> （按第j列展开）&lt;/p>
&lt;h4 id="几个重要的展开公式">几个重要的展开公式&lt;/h4>
&lt;p>根据行列式按行（或列）展开公式，可以写出所有的行列式的完全展开式。 其中几种特殊的行列式，其完全展开式很有特点，可以直接记忆。&lt;/p>
&lt;h5 id="上下三角行列式的值等于主对角线元素的乘积">上（下）三角行列式的值等于主对角线元素的乘积&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left|\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ &amp;amp; &amp;amp; \ddots &amp;amp; \vdots \\ &amp;amp; &amp;amp; &amp;amp; a_{nn}\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=\left|\begin{array}{cccc}a_{11} &amp;amp; &amp;amp; &amp;amp; \\ a_{21} &amp;amp; a_{22} &amp;amp; &amp;amp; \\ \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{nn}\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=a_{11} a_{22} \cdots a_{n n}\)&lt;/span>&lt;/p>
&lt;h5 id="副对角线上下三角行列式">副对角线上（下）三角行列式&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left|\begin{array}{ccccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1, n-1} &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2, n-1} &amp;amp; 0 \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots &amp;amp; \vdots \\ a_{n 1} &amp;amp; 0 &amp;amp; \cdots &amp;amp; 0 &amp;amp; 0\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=\left|\begin{array}{cccc}0 &amp;amp; \cdots &amp;amp; 0 &amp;amp; a_{1 n} \\ 0 &amp;amp; \cdots &amp;amp; a_{2, n-1} &amp;amp; a_{2 n} \\ \vdots &amp;amp; &amp;amp; \vdots &amp;amp; \vdots \\ a_{n 1} &amp;amp; \cdots &amp;amp; a_{n \cdot n-1} &amp;amp; a_{n n}\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=(-1)^{\frac{n(n-1)}{2}} a_{1 n} a_{2, n-1} \cdots a_{n 1}\)&lt;/span>&lt;/p>
&lt;h5 id="拉普拉斯公式">拉普拉斯公式&lt;/h5>
&lt;p>如果 A 和 B 分别是 &lt;span class="math inline">\(m\)&lt;/span> 阶和 &lt;span class="math inline">\(n\)&lt;/span> 阶矩阵,则： &lt;span class="math inline">\(\left|\begin{array}{ll}\boldsymbol{A} &amp;amp; * \\ \boldsymbol{O} &amp;amp; \boldsymbol{B}\end{array}\right|=\left|\begin{array}{ll}\boldsymbol{A} &amp;amp; \boldsymbol{O} \\ * &amp;amp; \boldsymbol{B}\end{array}\right|=|\boldsymbol{A}| \cdot|\boldsymbol{B}|\)&lt;/span>，其中A,B要求为方阵,其余位置不要求为方阵 &lt;span class="math inline">\(\left|\begin{array}{cc}\boldsymbol{O} &amp;amp; \boldsymbol{A} \\ \boldsymbol{B} &amp;amp; *\end{array}\right|=\left|\begin{array}{cc}* &amp;amp; \boldsymbol{A} \\ \boldsymbol{B} &amp;amp; \boldsymbol{O}\end{array}\right|=(-1)^{m n}|\boldsymbol{A}| \cdot|\boldsymbol{B}|\)&lt;/span>，其中A,B要求为方阵,其余位置不要求为方阵,m和n为A与B的阶数&lt;/p>
&lt;h5 id="范德蒙行列式">范德蒙行列式&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left|\begin{array}{cccc}1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 1 \\ x_{1} &amp;amp; x_{2} &amp;amp; \cdots &amp;amp; x_{n} \\ x_{1}^{2} &amp;amp; x_{2}^{2} &amp;amp; \cdots &amp;amp; x_{n}^{2} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ x_{1}^{n-1} &amp;amp; x_{2}^{n-1} &amp;amp; \cdots &amp;amp; x_{n}^{n-1}\end{array}\right|\)&lt;/span> &lt;span class="math inline">\(=\prod_{1\leqslant j&amp;lt;i \leqslant n}\left(x_i-x_{j}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="行列式的计算">行列式的计算&lt;/h3>
&lt;p>&lt;a href="#行列式的性质">行列式的性质&lt;/a>部分，介绍了行列式关于行和关于列的三种运算,即 &lt;span class="math inline">\(r_{i} \leftrightarrow r_{j}, r_{i} \times k\)&lt;/span>，&lt;span class="math inline">\(r_{i}+k r_{j}\)&lt;/span> 和 &lt;span class="math inline">\(c_{i} \leftrightarrow c_{j}, c_{i} \times k, c_{i}+k c_{j},\)&lt;/span> 利用这些运算可简化行列式的计算。&lt;/p>
&lt;p>行列式的计算，一般遵循先化简再求值的计算步骤： 先利用&lt;a href="#行列式的性质">行列式的性质&lt;/a>，尽可能得0或得1（比较标准的形式是化为上/下三角行列式； 然后利用&lt;a href="#行列式按行（或列）展开公式">行列式展开公式&lt;/a>求解。&lt;/p>
&lt;h5 id="行列式解法">行列式解法&lt;/h5>
&lt;p>最好都实践一下：&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/34685081">八大类型行列式及其解法&lt;/a>&lt;/p>
&lt;h3 id="行列式在解方程组应用克拉默法则">行列式在解方程组应用：克拉默法则&lt;/h3>
&lt;h5 id="克拉默法则">克拉默法则&lt;/h5>
&lt;p>对于有n个方程n个未知数的线性方程组： &lt;span class="math inline">\(\left\{\begin{array}{l}a_{11} x_{1}+a_{12} x_{2} \pi \cdots+a_{1 n} x_{n}=b_{1} \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=b_{2} \\...\\ a_{n_{1}} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}=b_{n}\end{array}\right.\)&lt;/span> 如果系数行列式&lt;span class="math inline">\(D=|A| \neq 0\)&lt;/span>, 则方程组有唯一解，且$x_1 = ,x_2 = , …, x_n = $ 其中&lt;span class="math inline">\(D_i\)&lt;/span>是系数行列式的第i列替换为&lt;span class="math inline">\([b_1, b_2, ... , b_n]^T\)&lt;/span>形成的行列式。&lt;/p>
&lt;h5 id="克拉默法则推论">克拉默法则推论&lt;/h5>
&lt;p>若齐次方程组： &lt;span class="math inline">\(\left\{\begin{array}{l}a_{11} x_{1}+a_{12} x_{2} \pi \cdots+a_{1 n} x_{n}=0 \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=0 \\...\\ a_{n_{1}} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}=0\end{array}\right.\)&lt;/span> 的系数行列式不为0，则方程组有唯一一组零解。&lt;/p>
&lt;h5 id="克拉默法则推论的逆否命题">克拉默法则推论的逆否命题&lt;/h5>
&lt;p>若齐次方程组： &lt;span class="math inline">\(\left\{\begin{array}{l}a_{11} x_{1}+a_{12} x_{2} \pi \cdots+a_{1 n} x_{n}=0 \\ a_{21} x_{1}+a_{22} x_{2}+\cdots+a_{2 n} x_{n}=0 \\...\\ a_{n_{1}} x_{1}+a_{n 2} x_{2}+\cdots+a_{n n} x_{n}=0\end{array}\right.\)&lt;/span> 有非零解，则它的系数行列式必为0.&lt;/p></description></item><item><title>线性代数-行列式习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/</link><pubDate>Mon, 20 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数-行列式习题">线性代数-行列式习题&lt;/h1>
&lt;h2 id="行列式的计算">行列式的计算&lt;/h2>
&lt;h5 id="代数余子式的计算">代数余子式的计算&lt;/h5>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911221652230.png" alt="" />&lt;figcaption>image-20200911221652230&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911221836795.png" alt="" />&lt;figcaption>image-20200911221836795&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911232642881.png" alt="" />&lt;figcaption>image-20200911232642881&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911232659350.png" alt="" />&lt;figcaption>image-20200911232659350&lt;/figcaption>
&lt;/figure>
&lt;h5 id="抽象行列式的计算">抽象行列式的计算&lt;/h5>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911225811869.png" alt="" />&lt;figcaption>image-20200911225811869&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911225837139.png" alt="" />&lt;figcaption>image-20200911225837139&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911230416735.png" alt="" />&lt;figcaption>image-20200911230416735&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911230429298.png" alt="" />&lt;figcaption>image-20200911230429298&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911231016396.png" alt="" />&lt;figcaption>image-20200911231016396&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911231054693.png" alt="" />&lt;figcaption>image-20200911231054693&lt;/figcaption>
&lt;/figure>
&lt;h5 id="数值行列式的计算">数值行列式的计算&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911234112887.png" alt="" />&lt;figcaption>image-20200911234112887&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200911234206440.png" alt="" />&lt;figcaption>image-20200911234206440&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200912000823836.png" alt="" />&lt;figcaption>image-20200912000823836&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200912000854139.png" alt="" />&lt;figcaption>image-20200912000854139&lt;/figcaption>
&lt;/figure></description></item><item><title>线性代数总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 19 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性代数总结">线性代数总结&lt;/h1>
&lt;p>根据同济线性代数第一版的序言，线性代数本是高等数学第13章，后来提出来单独成书。&lt;/p>
&lt;p>线性代数分为6块内容：行列式、矩阵、向量与向量空间、方程组、特征值、二次型。 概念互相渗透，联系紧密。&lt;/p>
&lt;p>行列式、矩阵、向量、方程组联系尤为紧密。 向量是研究方程组的解的过程中，提炼抽象出来的。（并提出了向量的相关无关、向量的秩、矩阵的秩的概念） 行列式和矩阵式求解方程组的过程中，提炼的工具。（消元的过程中，无法避免&lt;span class="math inline">\(ad-bc\)&lt;/span>的形式，将其定义为二阶行列式；系数与未知数的相乘并相加，系数提出来更简洁，就成了系数矩阵） 矩阵按列分块，就变成了向量。（解方程组的问题就变成了各列向量能否线性表示b的问题）&lt;/p>
&lt;p>二次型的几何意义：空间解析几何的二次曲面。&lt;/p>
&lt;p>线性代数的难点和重点：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>两难一重&lt;/th>
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>重点一&lt;/td>
&lt;td>方程组&lt;/td>
&lt;td>有无解？有几个解？如何求解以及参数处理&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>重点二&lt;/td>
&lt;td>特征值、特征向量&lt;/td>
&lt;td>&lt;span class="math inline">\(A\alpha = \lambda \alpha\)&lt;/span>，矩阵相似，对角阵相似。综合性强&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>难点&lt;/td>
&lt;td>向量&lt;/td>
&lt;td>线性表示、相关无关、秩&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>线性代数的特点： 1）概念多，定理多，运算法则多，符号多（易混淆） 2）内容上纵横交错，知识前后联系紧密（需要编织知识网络，重视一题多解）（解法灵活多变） 3）逻辑推理要求高（尤其是证明）&lt;/p>
&lt;h2 id="向量">向量&lt;/h2>
&lt;h3 id="概念运算">概念,运算&lt;/h3>
&lt;h3 id="线性表示">线性表示&lt;/h3>
&lt;h5 id="问alpha_1-alpha_2-...-alpha_n-能否线性表示beta等于问一个非齐次方程组alpha_1-alpha_2-...-alpha_nxbeta-有解没解的问题.">问&lt;span class="math inline">\(\alpha_1, \alpha_2 ... \alpha_n\)&lt;/span> 能否线性表示&lt;span class="math inline">\(\beta\)&lt;/span>,等于问一个非齐次方程组&lt;span class="math inline">\((\alpha_1, \alpha_2 ... \alpha_n)X=\beta\)&lt;/span> 有解没解的问题.&lt;/h5>
&lt;h3 id="线性相关与无关">线性相关与无关&lt;/h3>
&lt;h5 id="线性相关与无关定义">线性相关与无关定义&lt;/h5>
&lt;p>设&lt;span class="math inline">\(\alpha_1, \alpha_2, ... ,\alpha_n\)&lt;/span> 为一组n维向量，如果存在一组不全为0的数&lt;span class="math inline">\(k_1, k_2, ... , k_s\)&lt;/span>，使得&lt;span class="math inline">\(k_1 \alpha_1 + k_2 \alpha_2 + ... + k_s \alpha_s = 0\)&lt;/span> 成立，称向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, ... , \alpha_s\)&lt;/span> 线性相关； 如果上述等式仅当&lt;span class="math inline">\(k_1 = k_2 = ... = k_s = 0\)&lt;/span> 时成立，则称向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, ... , \alpha_s\)&lt;/span> 线性无关&lt;/p>
&lt;p>注意这里（n和s的区别）&lt;/p>
&lt;h5 id="问alpha_1-alpha_2-...-alpha_n-是否线性相关等于问一个齐次方程组alpha_1-alpha_2-...-alpha_nx0-有解没解是否只有0解的问题.">问&lt;span class="math inline">\(\alpha_1, \alpha_2 ... \alpha_n\)&lt;/span> 是否线性相关,等于问一个齐次方程组&lt;span class="math inline">\((\alpha_1, \alpha_2 ... \alpha_n)X=0\)&lt;/span> 有解没解(是否只有0解)的问题.&lt;/h5>
&lt;p>n维向量的向量组 &lt;span class="math inline">\(\alpha_{1}, \alpha_{2} \cdots \alpha_{m}\)&lt;/span> 线性相关 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\exists\)&lt;/span> 不全为0的 &lt;span class="math inline">\(k_{1} k_{2} \cdots k_{m}\)&lt;/span> , s.t. &lt;span class="math inline">\(k_1 \alpha_1 + k_2 \alpha_2 + \cdots + k_m \alpha_m = 0\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\exists\)&lt;/span> 不全为0的 &lt;span class="math inline">\(k_{1} k_{2} \cdots k_{m}\)&lt;/span> , s.t. &lt;span class="math inline">\(\left[\alpha_{1} \alpha_{2} \cdots \alpha_{m}\right]\left[\begin{array}{l}{k_{1}} \\ {k_{2}} \\ {k_{m}}\end{array}\right]=0\)&lt;/span> &lt;span class="math inline">\(\leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\left[\alpha_{1} \alpha_{2} \cdots \alpha_{m}\right]\left[\begin{array}{l}{x_{1}} \\ {x_{2}} \\ {x_{m}}\end{array}\right]=0\)&lt;/span> 存在非0解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r\left(\alpha_{1} \alpha_{2} \cdots \alpha_{m}\right)&amp;lt;m\)&lt;/span>&lt;/p>
&lt;p>推论&lt;/p>
&lt;ol type="1">
&lt;li>&lt;p>n个n维向量&lt;span class="math inline">\(\alpha_1, \alpha_2 ... \alpha_n\)&lt;/span> 相关 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(|\alpha_1, \alpha_2 ... \alpha_n|=0\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>n+1个n维向量必线性相关&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(\alpha_1, \alpha_2 ... \alpha_s\)&lt;/span> 相关,则&lt;span class="math inline">\(\alpha_1, \alpha_2 ... \alpha_s ... \alpha_{s+r}\)&lt;/span> 必相关&lt;/p>
&lt;p>i.e. 方程组有非0解,添加几个未知数之后仍有非0解&lt;/p>&lt;/li>
&lt;li>&lt;p>低维向量线性无关,那么添加维度(坐标)后的高维向量也无关&lt;/p>
&lt;p>e.g. &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20191210133418.png" alt="也是求齐次方程组基础解系的原理" />&lt;/p>&lt;/li>
&lt;/ol>
&lt;h5 id="低维向量线性相关的几何意义">低维向量线性相关的几何意义&lt;/h5>
&lt;h6 id="两个三维向量线性相关表示向量共线坐标成比例">两个三维向量线性相关,表示向量共线(坐标成比例);&lt;/h6>
&lt;h6 id="三个三维向量线性相关表示共面坐标成比例">三个三维向量线性相关,表示共面(坐标成比例)&lt;/h6>
&lt;h3 id="秩">秩&lt;/h3>
&lt;h5 id="极大线性无关组">极大线性无关组&lt;/h5>
&lt;p>设&lt;span class="math inline">\(\alpha_1, \alpha_2, .. \alpha_s\)&lt;/span> 是一个n维向量组，如果向量组中有r个向量线性无关，且向量的任意&lt;span class="math inline">\(r+1\)&lt;/span>个向量线性相关，则这r个线性无关的向量称为向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, .. \alpha_s\)&lt;/span> 的极大线性无关组&lt;/p>
&lt;h5 id="向量组的秩">向量组的秩&lt;/h5>
&lt;p>向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, .. \alpha_s\)&lt;/span>的&lt;strong>极大线性无关组中所含有向量的个数&lt;/strong>称为此向量组的秩，记作&lt;span class="math inline">\(r(\alpha_1, \alpha_2, .. \alpha_s)\)&lt;/span> 如果一个向量组仅含有零向量，则规定它的秩为0&lt;/p>
&lt;p>&lt;a href="#%20等价矩阵">等价的向量组&lt;/a>具有相同的秩&lt;/p>
&lt;h5 id="矩阵的秩">矩阵的秩&lt;/h5>
&lt;p>矩阵列向量组的秩，或者矩阵行向量组的秩，称为矩阵的秩&lt;/p>
&lt;p>矩阵的秩也可以认为是不为0的余子式的最大阶数&lt;/p>
&lt;h5 id="矩阵与向量的秩的关联">矩阵与向量的秩的关联&lt;/h5>
&lt;h6 id="raa的列秩a的行秩">&lt;span class="math inline">\(r(A)=A的列秩=A的行秩\)&lt;/span>&lt;/h6>
&lt;p>矩阵等价,秩相等.&lt;/p>
&lt;p>向量组等价,秩相等;秩相等,向量组不一定等价.&lt;/p>
&lt;h5 id="矩阵秩公式">矩阵秩公式&lt;/h5>
&lt;p>&lt;span class="math inline">\(r(A^T)=r(A)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(r(A+B)\le r(A)+r(B)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(r(kA)=r(A)\)&lt;/span>&lt;/p>
&lt;p>&lt;a href="http://ask.koolearn.com/new/q/1743493">&lt;span class="math inline">\(r(AB)\le min(r(A),r(B))\)&lt;/span>&lt;/a>&lt;/p>
&lt;p>若A可逆,则 &lt;span class="math inline">\(r(AB)=r(B), r(BA)=r(B)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(r(AA^T)=r(A)\)&lt;/span>&lt;/p>
&lt;p>设&lt;a href="https://zhidao.baidu.com/question/1771834549742172660">A-mxn, B-nxs, 且&lt;span class="math inline">\(AB=0\)&lt;/span>, 则&lt;span class="math inline">\(r(A)+r(B) \le n\)&lt;/span>&lt;/a>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left[\begin{matrix} A &amp;amp; O \\ O &amp;amp; B\end{matrix}\right]=r(A)+r(B)\)&lt;/span>&lt;/p>
&lt;h6 id="定理经过初等变换矩阵的秩不变.">定理:经过初等变换,矩阵的秩不变.&lt;/h6>
&lt;h3 id="向量空间">向量空间&lt;/h3>
&lt;h5 id="运算封闭">运算封闭&lt;/h5>
&lt;p>若从某个非空数集中任选两个元素（同一元素可重复选出），选出的这两个元素通过某种（或几种）&lt;em>运算&lt;/em>后的得数仍是该数集中的元素，那么，就说该集合&lt;em>对于&lt;/em>这种（或几种）&lt;em>运算是封闭的&lt;/em>&lt;/p>
&lt;h5 id="向量空间-1">向量空间&lt;/h5>
&lt;p>设S是&lt;strong>n维向量的非空集合&lt;/strong>,且S中向量&lt;strong>对于加法和数乘运算是封闭&lt;/strong>的,则称S构成一向量空间&lt;/p>
&lt;h5 id="子空间">子空间&lt;/h5>
&lt;h5 id="基底">基底&lt;/h5>
&lt;p>若&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span> 为向量空间&lt;strong>S中的一个线性无关的向量组&lt;/strong>, 且&lt;strong>S中任一向量可由&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span> 线性表示&lt;/strong>, 称&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span> 为向量空间中的一个基底&lt;/p>
&lt;h5 id="向量空间的维数">向量空间的维数&lt;/h5>
&lt;p>向量空间中,&lt;strong>基底所含向量的个数&lt;/strong>,称为此向量空间的维数. 若&lt;span class="math inline">\(\alpha_1, \alpha_2, ... \alpha_n\)&lt;/span> 为向量空间S的一个基底,则其维数为n, 称为n维向量空间, 记为&lt;span class="math inline">\(R^n\)&lt;/span>&lt;/p>
&lt;h5 id="坐标">坐标&lt;/h5>
&lt;h5 id="基变换与坐标变换">基变换与坐标变换&lt;/h5>
&lt;h5 id="内积">内积&lt;/h5>
&lt;p>设向量:&lt;/p>
&lt;p>&lt;span class="math inline">\(\alpha = \left( \begin{array} { c } { a _ { 1 } } \\ { a _ { 2 } } \\ { \vdots } \\ { a _ { n } } \end{array} \right) , \boldsymbol { \beta } = \left( \begin{array} { c } { b _ { 1 } } \\ { b _ { 2 } } \\ { \vdots } \\ { b _ { n } } \end{array} \right)\)&lt;/span>&lt;/p>
&lt;p>则&lt;span class="math inline">\(\alpha\)&lt;/span> 与&lt;span class="math inline">\(\beta\)&lt;/span> 内积为:&lt;/p>
&lt;p>&lt;span class="math inline">\(( \boldsymbol { \alpha } , \boldsymbol { \beta } ) = \boldsymbol { \alpha } ^ { \mathrm { T } } \boldsymbol { \beta } = \left( a _ { 1 } , a _ { 2 } , \cdots , a _ { n } \right) \left[\begin{array}{}{ b _ { 1 } }\\ { \vdots } \\ { b _ { n } } \end{array}\right] = a _ { 1 } b _ { 1 } + a _ { 2 } b _ { 2 } + \cdots + a _ { n } b _ { n }\)&lt;/span>&lt;/p>
&lt;p>向量的长度: &lt;span class="math inline">\(| \boldsymbol { \alpha } | = \sqrt { a _ { 1 } ^ { 2 } + a _ { 2 } ^ { 2 } + \cdots + a _ { n } ^ { 2 } }\)&lt;/span>&lt;/p>
&lt;p>内积性质:&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{array} { l } { ( \boldsymbol { \alpha } , \boldsymbol { \beta } ) = ( \boldsymbol { \beta } , \boldsymbol { \alpha } ) } \\ { \boldsymbol { \alpha } = \boldsymbol { 0 } \Leftrightarrow ( \boldsymbol { \alpha } , \boldsymbol { \alpha } ) = 0 } \\ { ( \boldsymbol { \alpha } , \boldsymbol { \beta } + \boldsymbol { \gamma } ) = ( \boldsymbol { \alpha } , \boldsymbol { \beta } ) + ( \boldsymbol { \alpha } , \boldsymbol { \gamma } ) } \end{array}\)&lt;/span>&lt;/p>
&lt;h5 id="正交">正交&lt;/h5>
&lt;p>若两向量内积为0,则这两个向量正交 i.e. &lt;span class="math inline">\(( \boldsymbol { \alpha } , \boldsymbol { \beta } ) = a _ { 1 } b _ { 1 } + a _ { 2 } b _ { 2 } + \cdots + a _ { n } b _ { n } = 0\)&lt;/span>, 则 &lt;span class="math inline">\(\alpha\)&lt;/span> 与 &lt;span class="math inline">\(\beta\)&lt;/span>正交&lt;/p>
&lt;h5 id="施密特正交化方法">施密特正交化方法&lt;/h5>
&lt;p>设&lt;span class="math inline">\(\alpha_1, \alpha_2, ..., \alpha_s\)&lt;/span> 为&lt;span class="math inline">\(R^s\)&lt;/span> 中一组线性无关的向量&lt;/p>
&lt;p>令:&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{array} { l } { \beta _ { 1 } = \alpha _ { 1 } } \\ { \beta _ { 2 } = \alpha _ { 2 } - \frac { \left( \alpha _ { 2 } , \beta _ { 1 } \right) } { \left( \beta _ { 1 } , \beta _ { 1 } \right) } \beta _ { 1 } } \\ { \cdots } \\ { \beta _ { s } = \alpha _ { s } - \frac { \left( \alpha _ { s } , \beta _ { 1 } \right) } { \left( \beta _ { 1 } , \beta _ { 1 } \right) } \beta _ { 1 }\cdots - \frac { \left( \alpha _ { s } , \beta _ { s - 1 } \right) } { \left( \beta _ { s - 1 } , \beta _ { s - 1 } \right) } \beta _ { s - 1 } } \end{array}\)&lt;/span>&lt;/p>
&lt;p>则 &lt;span class="math inline">\(\beta_1, \beta_2, ... \beta_s\)&lt;/span> 相互正交&lt;/p>
&lt;h5 id="规范正交基">规范正交基&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(\alpha_1, \alpha_2, ..., \alpha_n\)&lt;/span> 为&lt;span class="math inline">\(R^n\)&lt;/span> 中&lt;strong>一组基(底)&lt;/strong>&lt;/p>
&lt;p>将其(施密特)&lt;strong>正交化&lt;/strong>得 &lt;span class="math inline">\(\beta_1, \beta_2, ..., \beta_n\)&lt;/span>&lt;/p>
&lt;p>再将其&lt;strong>单位化&lt;/strong>得&lt;span class="math inline">\(\boldsymbol { \eta } _ { 1 } = \frac { \boldsymbol { \beta } _ { 1 } } { \left| \boldsymbol { \beta } _ { 1 } \right| }, \eta _ { 2 } = \frac { \beta _ { 2 } } { \left| \beta _ { 2 } \right| } , \cdots , \eta _ { n } = \frac { \beta _ { n } } { \left| \beta _ { n } \right| }\)&lt;/span>&lt;/p>
&lt;p>则&lt;span class="math inline">\(\eta_1, \eta_2, ... , \eta_n\)&lt;/span> 满足 &lt;span class="math inline">\((\eta_i, \eta_j)=0, i \neq j ; |\eta_i|=1, i=1,2, ... , n\)&lt;/span>&lt;/p>
&lt;p>称&lt;span class="math inline">\(\eta_1, \eta_2, ... , \eta_n\)&lt;/span> 为 &lt;span class="math inline">\(R^n\)&lt;/span> 中的一组规范正交基&lt;/p>
&lt;h5 id="正交矩阵">正交矩阵&lt;/h5>
&lt;h6 id="定义-设-eta_1-eta_2-...-eta_n-为-rn-中的一组规范正交基令qeta_1-eta_2-...-eta_n-则q满足qt-q-q-qt-e-称为正交矩阵">定义 设 &lt;span class="math inline">\(\eta_1, \eta_2, ... , \eta_n\)&lt;/span> 为 &lt;span class="math inline">\(R^n\)&lt;/span> 中的一组规范正交基,令&lt;span class="math inline">\(Q=[\eta_1, \eta_2, ... , \eta_n]\)&lt;/span> , 则Q满足&lt;span class="math inline">\(Q^T Q = Q Q^T = E\)&lt;/span> , 称为正交矩阵&lt;/h6>
&lt;p>如果n阶矩阵A满足&lt;span class="math inline">\(A^T A = E\)&lt;/span>， 即(&lt;span class="math inline">\(A^{-1} = A^T\)&lt;/span>),那么称A为正交矩阵，简称正交阵&lt;/p>
&lt;p>方阵A为正交矩阵&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> A的列向量/行向量都是单位向量，且两两正交&lt;/p>
&lt;h6 id="正交矩阵性质">正交矩阵性质:&lt;/h6>
&lt;p>&lt;span class="math inline">\(\begin{array} { l } { Q ^ { \mathrm { T } } = Q ^ { - 1 } \quad (Q^T Q=E)} \\ { | Q | = \pm 1 } \end{array}\)&lt;/span>&lt;/p>
&lt;p>若&lt;span class="math inline">\(Q_1, Q_2\)&lt;/span> 为正交矩阵, 则 &lt;span class="math inline">\(Q_1, Q_2\)&lt;/span>仍为正交矩阵&lt;/p>
&lt;p>&lt;a href="https://blog.csdn.net/u012532559/article/details/44872181">相关链接:相似矩阵与二次型的转换&lt;/a>&lt;/p>
&lt;h2 id="线性方程组">线性方程组&lt;/h2>
&lt;h3 id="线性方程组概念">线性方程组概念&lt;/h3>
&lt;h5 id="线性方程组同解变形矩阵行变换">线性方程组同解变形(矩阵行变换)&lt;/h5>
&lt;ol type="1">
&lt;li>两个方程互换位置&lt;/li>
&lt;li>非零常数乘到方程的两端&lt;/li>
&lt;li>某方程的k被加到另一个方程上&lt;/li>
&lt;/ol>
&lt;h3 id="齐次方程组ax0">齐次方程组&lt;span class="math inline">\(Ax=0\)&lt;/span>&lt;/h3>
&lt;h4 id="无解0解唯一解非零解">无解,0解(唯一解),非零解&lt;/h4>
&lt;h6 id="定理-齐次方程组a_mtimes-nx0-有非零解-leftrightarrow-ran">定理 齐次方程组&lt;span class="math inline">\(A_{m\times n}x=0\)&lt;/span> 有非零解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(r(A)&amp;lt;n\)&lt;/span>&lt;/h6>
&lt;p>推论 当&lt;span class="math inline">\(m&amp;lt;n\)&lt;/span> 时, &lt;span class="math inline">\(Ax=0\)&lt;/span> 必有非零解 (i.e. 方程组数小于未知数个数)&lt;/p>
&lt;p>推论 当m=n时, &lt;span class="math inline">\(Ax=0\)&lt;/span> 有非零解 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(|A|=0\)&lt;/span>&lt;/p>
&lt;h5 id="解的性质">解的性质&lt;/h5>
&lt;p>if &lt;span class="math inline">\(\eta\)&lt;/span> is solution of &lt;span class="math inline">\(Ax=0\)&lt;/span> , then &lt;span class="math inline">\(k\eta\)&lt;/span> is solution, too.&lt;/p>
&lt;p>if &lt;span class="math inline">\(\eta_1, \eta_2\)&lt;/span> is solution of &lt;span class="math inline">\(Ax=0\)&lt;/span>, then &lt;span class="math inline">\(k_1\eta_1 + k_2\eta_2\)&lt;/span> is solution, too.&lt;/p>
&lt;h4 id="基础解系">基础解系&lt;/h4>
&lt;h6 id="齐次方程组的基础解系方程组解向量的极大线性无关组">齐次方程组的基础解系:方程组解向量的极大线性无关组&lt;/h6>
&lt;p>i.e. &lt;/p>
&lt;ol type="1">
&lt;li>&lt;span class="math inline">\(\eta_1, \eta_2, ... \eta_t\)&lt;/span> 是 &lt;span class="math inline">\(Ax=0\)&lt;/span> 的解&lt;/li>
&lt;li>&lt;span class="math inline">\(\eta_1, \eta_2, ... \eta_t\)&lt;/span> 线性无关&lt;/li>
&lt;li>&lt;span class="math inline">\(Ax=0\)&lt;/span> 的任意一个解都可以由 &lt;span class="math inline">\(\eta_1, \eta_2, ... \eta_t\)&lt;/span> 线性表出&lt;/li>
&lt;/ol>
&lt;h5 id="齐次方程组解向量的极大线性无关组基础解系个数n-ra">齐次方程组解向量的极大线性无关组(基础解系)个数&lt;span class="math inline">\(n-r(A)\)&lt;/span>&lt;/h5>
&lt;p>定理 如果齐次方程组 &lt;span class="math inline">\(Ax=b \quad(II)\)&lt;/span> 系数矩阵的秩 &lt;span class="math inline">\(r(A)=r&amp;lt;n\)&lt;/span> , 则&lt;span class="math inline">\(II\)&lt;/span> 有 &lt;span class="math inline">\(n-r\)&lt;/span> 个线性无关的解,且 &lt;span class="math inline">\(II\)&lt;/span> 的任意一个解都可以由这&lt;span class="math inline">\(n-r\)&lt;/span> 个线性无关的解(基础解系)线性表出&lt;/p>
&lt;p>定理 若 &lt;span class="math inline">\(\eta_1, \eta_2, \cdot\cdot\cdot \eta_t\)&lt;/span> 是齐次方程组 &lt;span class="math inline">\(II\)&lt;/span> 的基础解系,则 &lt;span class="math inline">\(II\)&lt;/span> 的通解是是: &lt;span class="math inline">\(k_1 \eta_1 + k_2 \eta_2 + \cdot \cdot \cdot + k_t \eta_t\)&lt;/span>, &lt;span class="math inline">\(k_1, k_2, ... , k_t\)&lt;/span> 是任意常数&lt;/p>
&lt;h4 id="相关无关">相关无关&lt;/h4>
&lt;p>在向量组部分介绍过了: &lt;a href="#线性相关与无关">向量的相关无关&lt;/a>&lt;/p>
&lt;h3 id="非齐次方程组axb">非齐次方程组&lt;span class="math inline">\(Ax=b\)&lt;/span>&lt;/h3>
&lt;h5 id="有解判定-无解唯一解-无穷多解">有解判定: 无解,唯一解, 无穷多解&lt;/h5>
&lt;p>定理 &lt;span class="math inline">\(A x=b\)&lt;/span> 有解 &lt;span class="math inline">\(\Leftrightarrow r(A)=r(\overline A)\)&lt;/span>&lt;/p>
&lt;p>唯一解: &lt;span class="math inline">\(r(A)=r(\bar{A})=n\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\infty\)&lt;/span> 解: &lt;span class="math inline">\(r(A)=r(\bar{A})&amp;lt;n\)&lt;/span>&lt;/p>
&lt;p>无解: &lt;span class="math inline">\(r(A)+1=r(\bar{A})\)&lt;/span>&lt;/p>
&lt;h5 id="解的形式">解的形式&lt;/h5>
&lt;h6 id="解的性质-1">解的性质&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20191210143620.png" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20191210143727.png" />&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20191210143956.png" alt="" />&lt;figcaption>这条是齐次方程组的性质&lt;/figcaption>
&lt;/figure>
&lt;h6 id="解的结构">解的结构&lt;/h6>
&lt;p>定理 设&lt;span class="math inline">\(\alpha\)&lt;/span> 是方程组&lt;span class="math inline">\(Ax=b\)&lt;/span> 的解, &lt;span class="math inline">\(\eta_{1}, \eta_{2}, \cdots, \eta_{t}\)&lt;/span> 是导出组&lt;span class="math inline">\(Ax=0\)&lt;/span> 的基础解系,则方程组&lt;span class="math inline">\(Ax=b\)&lt;/span> 的通解为 &lt;span class="math inline">\(\alpha+k_{1} \eta_{1}+k_{2} \eta_{2} \cdots+k_{t} \eta_{t}\)&lt;/span> , 其中 &lt;span class="math inline">\(k_{1} k_{2} \cdots k_{t}\)&lt;/span> 是任意常数&lt;/p>
&lt;p>求解非齐次方程组做两件事:非齐次方程组求一个特解,求齐次方程组的基础解系,并用k衔接&lt;/p>
&lt;h3 id="公共解同解">公共解,同解&lt;/h3>
&lt;h3 id="应用">应用&lt;/h3>
&lt;ol type="1">
&lt;li>相关无关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 齐次方程组 &lt;span class="math inline">\((\alpha_1, \alpha_2, \cdot\cdot\cdot \alpha_s)x=0\)&lt;/span>有非零解&lt;/li>
&lt;li>线性无关&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 非齐次方程组 &lt;span class="math inline">\((\alpha_1, \alpha_2, \cdot\cdot\cdot \alpha_s)x=\beta\)&lt;/span> 有没有解&lt;/li>
&lt;li>&lt;span class="math inline">\(AP=B\neq P\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math inline">\(A \alpha = \lambda x\)&lt;/span> 求x&lt;/li>
&lt;/ol>
&lt;h2 id="特征值与特征向量">特征值与特征向量&lt;/h2>
&lt;h5 id="定义">定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(A \alpha=\lambda \alpha, \alpha \neq 0\)&lt;/span>, 注意特征向量不为0&lt;/p>
&lt;p>说明（标准定义）： 设A是n阶矩阵, &lt;span class="math inline">\(\alpha\)&lt;/span>是n维非0列向量,满足: &lt;span class="math inline">\(A \alpha=\lambda \alpha\)&lt;/span>, 则称&lt;span class="math inline">\(\lambda\)&lt;/span>是矩阵A的特征值, &lt;span class="math inline">\(\alpha\)&lt;/span>是矩阵A属于特征值&lt;span class="math inline">\(\lambda\)&lt;/span>的特征向量&lt;/p>
&lt;h5 id="性质">性质&lt;/h5>
&lt;p>&lt;span class="math inline">\(A \alpha=\lambda \alpha, \alpha \neq 0 \Rightarrow (A+k E) \alpha=(\lambda+k) \alpha\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(A \alpha=\lambda \alpha, \alpha \neq 0 \Rightarrow A^{n} \alpha=\lambda^{n} \alpha\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|A|=\prod \lambda\)&lt;/span>&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>&lt;/p>
&lt;p>&lt;span class="math inline">\(A \alpha=\lambda \alpha, \alpha \neq 0 \Rightarrow A^{-1} \alpha=\frac{1}{\lambda} \alpha\)&lt;/span>&lt;/p>
&lt;p>若A可逆, &lt;span class="math inline">\(\lambda\)&lt;/span> 是A的特征值, 则 &lt;span class="math inline">\(\frac{|A|}{\lambda}\)&lt;/span> 是&lt;span class="math inline">\(A^*\)&lt;/span> 的特征值&lt;/p>
&lt;p>性质总结：&lt;/p>
&lt;p>设&lt;span class="math inline">\(\lambda\)&lt;/span>是矩阵A的特征值，则矩阵&lt;span class="math inline">\(kA, A^2, aA+bE, A^m, A^{-1}, A*\)&lt;/span> ， 分别有特征值 &lt;span class="math inline">\(k\lambda, \lambda^2, a\lambda+b, \lambda^m, \frac{1}{\lambda}, \frac{|A|}{\lambda}\)&lt;/span>&lt;/p>
&lt;p>设&lt;span class="math inline">\(\alpha\)&lt;/span>是A对应&lt;span class="math inline">\(\lambda\)&lt;/span>的特征向量，则&lt;span class="math inline">\(\alpha\)&lt;/span>也是矩阵&lt;span class="math inline">\(kA, A^2, aA+bE, A^m, A^{-1}, A*\)&lt;/span>对应特征值&lt;span class="math inline">\(k\lambda, \lambda^2, a\lambda+b, \lambda^m, \frac{1}{\lambda}, \frac{|A|}{\lambda}\)&lt;/span>的特征向量&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/30454490">不同特征值的特征向量必正交&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/267405336">特征值之和等于矩阵的迹&lt;/a>&lt;/p>
&lt;h5 id="求特征值与特征向量">求特征值与特征向量&lt;/h5>
&lt;p>利用定义与性质&lt;/p>
&lt;p>利用定义式的变形得行列式求特征值（解行列式=0）&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{array}{l}{ {\left(\lambda_{i} E-A\right) x=0} \quad (x \neq 0)\\ \Rightarrow | \lambda E-A |=0} \\ \end{array}\)&lt;/span>&lt;/p>
&lt;p>再分别代入特征值&lt;span class="math inline">\(\lambda_i\)&lt;/span>， 利用定义式的变形求特征向量（解齐次方程组）&lt;/p>
&lt;p>&lt;span class="math inline">\({\left(\lambda_{i} E-A\right) x=0} \quad (x \neq 0)\)&lt;/span>&lt;/p>
&lt;h3 id="相似矩阵">相似矩阵&lt;/h3>
&lt;h5 id="定义-1">定义:&lt;/h5>
&lt;p>&lt;span class="math inline">\(A \sim B:\)&lt;/span> A, B都是n阶方阵, &lt;span class="math inline">\(\exists\)&lt;/span> 可逆&lt;span class="math inline">\(P, P^{-1} A P=B\)&lt;/span> , 称A相似于B&lt;/p>
&lt;p>&lt;span class="math inline">\(A \sim \Lambda\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵相似的性质">矩阵相似的性质:&lt;/h5>
&lt;ul>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim A\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow B \sim A\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B, B \sim C \Rightarrow A \sim C\)&lt;/span> (e.g. &lt;span class="math inline">\(A \sim \Lambda, B \sim \Lambda \Rightarrow A \sim B\)&lt;/span> 多用来证明)&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow A + kE \sim B + kE\)&lt;/span>&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>&lt;small>&lt;span style="color:gray">proof: &lt;span class="math inline">\(P ^ { - 1 } ( A + k E ) P = P ^ { - 1 } A P + P ^ { - 1 } k E P = B + k E\)&lt;/span>&lt;/span>&lt;/small>&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow A^n \sim B^n\)&lt;/span> &lt;small>proof: &lt;span class="math inline">\(A \sim B \Rightarrow P^{-1}AP=B \quad (两边平方) \Rightarrow (P^{-1}AP)^2=B^2 \\\)&lt;/span>, 数学归纳得原式&lt;/small>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow \begin{equation} |\lambda E-A|=|\lambda E-B| \Rightarrow \lambda_{A}=\lambda_{B} \end{equation}\)&lt;/span> &lt;small>proof: &lt;span class="math inline">\(\begin{aligned}|\lambda E-B| &amp;amp;=\left|\lambda E-P^{-1} A P\right| \\ &amp;amp;=\left|P^{-1}(\lambda E-A) P\right| \\ &amp;amp;=\left|P^{-1}\right|\cdot|\lambda E-A|\cdot|P| \\ &amp;amp;=|\lambda E-A| \end{aligned}\)&lt;/span>&lt;/small>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow r(A)=r(B)\)&lt;/span> &lt;small>proof: &lt;span class="math inline">\(r(B)=r\left(P^{-1} A P\right) \\ =r(A P) \\ =r(A)\)&lt;/span>&lt;/small>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow |A|=|B|\)&lt;/span> &lt;small>proof: &lt;span class="math inline">\(|B|=|P^{-1} A P| = |P^{-1} | \cdot |A| \cdot |P| = |A|\)&lt;/span>&lt;/small>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow \sum a_{i i}=\sum b_{i i}\)&lt;/span> (迹的和相等)&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>即：A相似B，{反身，传递，倍加E，n次}仍相似，相似则{特征值，秩，行列式，迹}相等。&lt;/p>
&lt;h5 id="性质推广">性质推广&lt;/h5>
&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow A^{-1} \sim B^{-1}\)&lt;/span>&lt;/p>
&lt;p>证明：&lt;br> &lt;span class="math inline">\(\begin{array}{l}{\left(P^{-1} A P\right)^{-1}=B^{-1}} \\ {P^{-1} A^{-1}\left(P^{-1}\right)^{-1}=B^{-1}} \\ {P^{-1} A^{-1} P=B^{-1}} \\ {\therefore A^{-1} \sim B^{-1}}\end{array}\)&lt;/span>&lt;/p>
&lt;ul>
&lt;li>&lt;p>$A B A^T B^T $&lt;/p>
&lt;p>证明:&lt;br>令&lt;span class="math inline">\(\left(P^{T} \right)^{-1}=P_1\)&lt;/span>&lt;br>则&lt;span class="math inline">\(P_1^{-1} A^T P_1 = B^T\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;span class="math inline">\(A \sim B \Rightarrow A^* \sim B^*\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>若&lt;span class="math inline">\(\mathbf{A} \sim \boldsymbol{B}, \boldsymbol{C} \sim \boldsymbol{D}\)&lt;/span>， 则&lt;span class="math inline">\(\left[\begin{array}{ll}{A} &amp;amp; {0} \\ {0} &amp;amp; {C}\end{array}\right] \sim\left[\begin{array}{ll}{B} &amp;amp; {0} \\ {0} &amp;amp; {D}\end{array}\right]\)&lt;/span>&lt;/p>&lt;/li>
&lt;li>&lt;p>若&lt;span class="math inline">\(\mathbf{A} \sim B\)&lt;/span>，则&lt;span class="math inline">\(f(\boldsymbol{A}) \sim f(\boldsymbol{B}),|f(\boldsymbol{A})|=|f(\boldsymbol{B})|\)&lt;/span>，其中&lt;span class="math inline">\(f(\boldsymbol{A})\)&lt;/span>为矩阵&lt;/p>&lt;/li>
&lt;/ul>
&lt;h5 id="相似对角化">相似对角化&lt;/h5>
&lt;p>相似对角化&lt;span class="math inline">\(P^{-1} A P = \Lambda\)&lt;/span>的方法&lt;/p>
&lt;p>设&lt;span class="math inline">\(\alpha _ { 1 } , \alpha _ { 2 } , \cdots , \alpha _ { n }\)&lt;/span>为对应于特征值&lt;span class="math inline">\(\lambda_i(i=1,2,...,n)\)&lt;/span>的特征向量 &lt;span class="math inline">\(\begin{aligned} A \left( \alpha _ { 1 } , \alpha _ { 2 } , \cdots , \alpha _ { n } \right) &amp;amp; = \left( A \alpha _ { 1 } , A \alpha _ { 2 } , \cdots , A \alpha _ { n } \right) \\ &amp;amp; = \left( \lambda _ { 1 } \alpha _ { 1 } , \lambda _ { 2 } \alpha _ { 2 } , \cdots , \lambda _ { n } \alpha _ { n } \right) \\ &amp;amp; =\left[ \boldsymbol { a } _ { 1 } , \boldsymbol { \alpha } _ { 2 } , \cdots , \boldsymbol { \alpha } _ { n } \right] \left[ \begin{array} { c c c c } { \lambda _ { 1 } } \\ { } &amp;amp; { \lambda _ { 2 } } \\ { } &amp;amp; { } &amp;amp; { \ddots } \\ { } &amp;amp; { } &amp;amp; { } &amp;amp; { \lambda _ { n } } \end{array} \right] \end{aligned}\)&lt;/span> 记&lt;span class="math inline">\(P = \left[ \alpha _ { 1 } , \alpha _ { 2 } , \cdots , \alpha _ { n } \right]\)&lt;/span>, 记&lt;span class="math inline">\(\boldsymbol { \Lambda } = \left[ \begin{array} { c c c c } { \lambda _ { 1 } } \\ { } &amp;amp; { \lambda _ { 2 } } \\ { } &amp;amp; { } &amp;amp; { \ddots } \\ { } &amp;amp; { } &amp;amp; { } &amp;amp; { \lambda _ { n } } \end{array} \right]\)&lt;/span>，&lt;/p>
&lt;p>则&lt;span class="math inline">\(P^{-1} A P = \Lambda\)&lt;/span>&lt;/p>
&lt;h5 id="性质-1">性质&lt;/h5>
&lt;p>$A $ A有n个线性无关的特征向量&lt;/p>
&lt;p>&lt;span class="math inline">\(\lambda\)&lt;/span>是k重特征值，则 &lt;span class="math inline">\(\lambda\)&lt;/span>有k个无关的特征向量 &lt;span class="math inline">\(\Leftrightarrow A \sim \Lambda\)&lt;/span>&lt;/p>
&lt;p>A有n个不同的特征值$ A $&lt;/p>
&lt;p>A为对称矩阵 &lt;span class="math inline">\(\Rightarrow A \sim \Lambda\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>若&lt;span class="math inline">\(P^{-1} A P = \Lambda\)&lt;/span>， 则&lt;span class="math inline">\(\Lambda\)&lt;/span>的主对角线上元素就是A的特征值，P的列向量就是A的特征向量&lt;/strong>&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref">&lt;sup>2&lt;/sup>&lt;/a>&lt;/p>
&lt;p>相似对角化可以用来求方阵的n次&lt;/p>
&lt;h3 id="实对称矩阵">实对称矩阵&lt;/h3>
&lt;p>如果有n阶&lt;a href="https://baike.baidu.com/item/矩阵">矩阵&lt;/a>A，其矩阵的元素都为实数，且矩阵A的转置等于其本身（&lt;span class="math inline">\(a_{ij}=a_{ji}\)&lt;/span>）(i,j为元素的脚标），则称A为实对称矩阵（即&lt;span class="math inline">\(A^T=A\)&lt;/span>且元素为实数的矩阵）&lt;/p>
&lt;h5 id="特点">特点&lt;/h5>
&lt;p>特征值必是实数&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/30454490">不同特征值的特征向量必正交&lt;/a>&lt;/p>
&lt;p>必与对角矩阵相似&lt;/p>
&lt;p>可用正交矩阵相似对角化&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref">&lt;sup>3&lt;/sup>&lt;/a>&lt;/p>
&lt;h5 id="实对称矩阵用正交矩阵对角化的方法">实对称矩阵用正交矩阵对角化的方法&lt;/h5>
&lt;ol type="1">
&lt;li>求A的特征值&lt;span class="math inline">\(\lambda_1, \lambda_2, ... \lambda_n\)&lt;/span>&lt;/li>
&lt;li>求特征向量&lt;span class="math inline">\(\alpha_1, \alpha_2 , ... \alpha_n\)&lt;/span>&lt;/li>
&lt;li>改造特征向量为&lt;span class="math inline">\(\gamma_1, \gamma_2, ... , \gamma_n\)&lt;/span>
&lt;ol type="1">
&lt;li>如&lt;span class="math inline">\(\lambda_i \neq \lambda_j\)&lt;/span>， 只需单位化&lt;/li>
&lt;li>如&lt;span class="math inline">\(\lambda_i = \lambda_j\)&lt;/span>
&lt;ol type="1">
&lt;li>若&lt;span class="math inline">\((\alpha_i, \alpha_j) = 0\)&lt;/span>， 只需单位化&lt;/li>
&lt;li>若&lt;span class="math inline">\(\alpha_i, \alpha_j) \neq 0\)&lt;/span>， 施密特正交化，单位化&lt;/li>
&lt;/ol>&lt;/li>
&lt;/ol>&lt;/li>
&lt;li>构造正交矩阵&lt;span class="math inline">\(Q=(\gamma_1, \gamma_2, ... , \gamma_n)\)&lt;/span>&lt;/li>
&lt;li>得&lt;span class="math inline">\(Q^{-1} A Q = \Lambda = \left[ \begin{array} { c c c c } { \lambda _ { 1 } } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { \lambda _ { 2 } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \vdots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { \lambda _ { n } } \end{array} \right]\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;h2 id="二次型">二次型&lt;/h2>
&lt;h3 id="概念定理">概念、定理&lt;/h3>
&lt;h5 id="二次型及其矩阵表示">二次型及其矩阵表示&lt;/h5>
&lt;p>设一个多元函数，其每一项都是二次的，这样的多元函数，称作二次型；任何一个二次型都可以用矩阵的乘法描写出来。&lt;/p>
&lt;h5 id="二次型矩阵化">二次型矩阵化&lt;/h5>
&lt;p>n元二次型&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x_1, x_2,...,x_n) = \Sigma{C_{ii} x_i x_i} + \Sigma{C_{ij} x_i x_j} \\ = [x_1, x_2, ... , x_n] A [x_1, x_2, ... , x_n]^T \\ = x^T A x\)&lt;/span> 其中A为一个对称矩阵，有 &lt;span class="math inline">\(A(i,i) = C_{ii},\\ A(i,j) = A(j,i) = C_{ij}/2\)&lt;/span>&lt;/p>
&lt;p>函数f的平方项&lt;span class="math inline">\(C_{ii} x_i x_i\)&lt;/span>系数依次填入对称矩阵P的对角线，函数f的混合项&lt;span class="math inline">\(C_{ij} x_i x_j\)&lt;/span>系数除以2，分别填入矩阵A对应位置&lt;/p>
&lt;p>这里的矩阵A称为二次型的矩阵&lt;/p>
&lt;p>i.e. 一个三元二次型： &lt;span class="math inline">\(\begin{aligned} f\left(x_{1}, x_{2}, x_{3}\right)=&amp;amp; x_{1}^{2}+5 x_{2}^{2}+5 x_{3}^{2}+2 x_{1} x_{2}-6 x_{2} x_{3} \\ &amp;amp;=\left[x_{1} x_{2} x_{3}\right]\left[\begin{array}{ccc}{1} &amp;amp; {1} &amp;amp; {0} \\ {1} &amp;amp; {5} &amp;amp; {-3} \\ {0} &amp;amp; {-3} &amp;amp; {5}\end{array}\right]\left[\begin{array}{c}{x_{1}} \\ {x_{2}} \\ {x_{3}}\end{array}\right] \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="标准型">标准型&lt;/h5>
&lt;p>&lt;strong>只有平方项&lt;/strong>，没有混合项的二次型&lt;/p>
&lt;p>则标准型对应的矩阵是个&lt;strong>对角矩阵&lt;/strong>&lt;/p>
&lt;h5 id="规范型">规范型&lt;/h5>
&lt;p>平方项系数只能为0，+1，-1的标准型&lt;/p>
&lt;h5 id="惯性指数">惯性指数&lt;/h5>
&lt;p>正惯性指数： 标准型中正的二次项个数&lt;/p>
&lt;p>负惯性指数： 标准型中负的二次项个数&lt;/p>
&lt;h5 id="二次型的秩">二次型的秩&lt;/h5>
&lt;p>&lt;span class="math inline">\(r(f)=r(A)\)&lt;/span>&lt;/p>
&lt;h5 id="坐标变换">坐标变换&lt;/h5>
&lt;p>以3元坐标为例：&lt;/p>
&lt;p>&lt;span class="math inline">\(\left\{\begin{array}{l}{x_{1}=c_{11} y_{1}+c_{12} y_{1}+c_{13} y_{3}} \\ {x_{2}=c_{21} y_{1}+c_{22} y_{2}+c_{23} y_{3}} \\ {x_{3}=c_{31} y_{1}+c_{32} y_{2}+c_{33} y_{3}}\end{array} \quad|C| \neq 0\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left[\begin{array}{l}{x_{1}} \\ {x_{2}} \\ {x_{3}}\end{array}\right]=\left[\begin{array}{lll}{C_{11}} &amp;amp; {C_{12}} &amp;amp; {C_{13}} \\ {C_{21}} &amp;amp; {C_{22}} &amp;amp; {C_{23}} \\ {C_{31}} &amp;amp; {C_{32}} &amp;amp; {C_{33}}\end{array}\right]\left[\begin{array}{l}{y_{1}} \\ {y_{2}} \\ {y_{3}}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>那么通过坐标变换 &lt;span class="math inline">\(x=Cy\)&lt;/span>，把坐标x用矩阵C变换为了y的坐标，这里要求C可逆&lt;/p>
&lt;p>对二次型做坐标变换： &lt;span class="math inline">\(\left\{ \begin{array} { l } { f ( x ) = x ^ { T } A x } \\ { x = C y , | C | \neq 0 } \end{array} \right.\)&lt;/span> &lt;span class="math inline">\(\Rightarrow \\ \begin{aligned} g ( y ) = f \left( C _ { y } \right) &amp;amp; = \left( C y \right) ^ { T } A \left( C y \right) \\ &amp;amp; = y ^ { T } C ^ { T } A C y \\ &amp;amp; = y ^ { T } B y \end{aligned}\)&lt;/span> 其中&lt;span class="math inline">\(B=C^T A C\)&lt;/span>&lt;/p>
&lt;h5 id="矩阵合同">矩阵合同&lt;/h5>
&lt;p>由对二次型的&lt;a href="#%20坐标变换">坐标变换&lt;/a>可知，坐标变换${ x = C y , | C | } &lt;span class="math inline">\(时， 二次型的矩阵A也变为B，并满足\)&lt;/span>B=C^T A C$&lt;/p>
&lt;h6 id="定义-2">定义&lt;/h6>
&lt;p>如果&lt;span class="math inline">\(C^{T} A C=B\)&lt;/span>， 其中C是可逆矩阵，称矩阵A和B合同，记&lt;span class="math inline">\(A \simeq B\)&lt;/span>&lt;/p>
&lt;p>$A B $ $x^T A x $ 与 &lt;span class="math inline">\(x^T B x\)&lt;/span> 正负惯性指数相同&lt;/p>
&lt;h6 id="性质-2">性质&lt;/h6>
&lt;p>&lt;span class="math inline">\(A \simeq A\)&lt;/span>&lt;/p>
&lt;p>如果&lt;span class="math inline">\(A \simeq B\)&lt;/span>， 则&lt;span class="math inline">\(B \simeq A\)&lt;/span>&lt;/p>
&lt;p>如果&lt;span class="math inline">\(A \simeq B, B \simeq C\)&lt;/span>，则&lt;span class="math inline">\(A \simeq C\)&lt;/span>&lt;/p>
&lt;p>任一实对称矩阵必合同于一个对角矩阵&lt;/p>
&lt;h6 id="定理-xt-a-x-经坐标变换xcy-有xt-a-x-yt-b-y-其中ct-a-c-b">定理 $x^T A x $ 经坐标变换&lt;span class="math inline">\(x=Cy\)&lt;/span>， 有&lt;span class="math inline">\(x^T A x = y^T B y\)&lt;/span>， 其中&lt;span class="math inline">\(C^T A C = B\)&lt;/span>&lt;/h6>
&lt;p>即二次型经坐标变换，二次型的矩阵变换为它的合同矩阵&lt;/p>
&lt;h6 id="定理-对任意xt-a-x-都存在坐标变换xcy使得fyt-lambda-y">定理 对任意&lt;span class="math inline">\(x^T A x\)&lt;/span>， 都存在坐标变换&lt;span class="math inline">\(x=Cy\)&lt;/span>，使得&lt;span class="math inline">\(f=y^T \Lambda y\)&lt;/span>&lt;/h6>
&lt;p>即任意二次型都可以找到坐标变换，化为标准型&lt;/p>
&lt;h6 id="定理-惯性定理-对于一个二次型xt-a-x经坐标变换化为标准型其正惯性指数和负惯性指数都是唯一确定的">定理 （惯性定理） 对于一个二次型&lt;span class="math inline">\(x^T A x\)&lt;/span>，经坐标变换化为标准型，其正惯性指数和负惯性指数都是唯一确定的&lt;/h6>
&lt;p>二次型变换为标准型的方法是不唯一的，即可能化为不同的标准型。但是这些标准型的正惯性指数和负惯性指数都是唯一确定的。&lt;/p>
&lt;h3 id="二次型变换为标准型">二次型变换为标准型&lt;/h3>
&lt;h5 id="配方法">配方法&lt;/h5>
&lt;h5 id="正交变换法">正交变换法&lt;/h5>
&lt;ol type="1">
&lt;li>求特征值&lt;span class="math inline">\(\lambda_1, \lambda_2, ... , \lambda_n\)&lt;/span>&lt;/li>
&lt;li>求特征向量&lt;span class="math inline">\(\alpha_1, \alpha_2, ... , \alpha_n\)&lt;/span>&lt;/li>
&lt;li>改造特征向量（正交化，单位化）为&lt;span class="math inline">\(\gamma_1, \gamma_2, ... , \gamma_n\)&lt;/span>
&lt;ol type="1">
&lt;li>特征值不同，特征向量已正交，只需单位化&lt;/li>
&lt;li>特征值有重根
&lt;ol type="1">
&lt;li>该特征值的多个特征向量正交，只需单位化&lt;/li>
&lt;li>该特征值的多个特征向量不正交，施密特正交化，并单位化&lt;/li>
&lt;/ol>&lt;/li>
&lt;/ol>&lt;/li>
&lt;li>拼称正交矩阵&lt;span class="math inline">\(Q=(\gamma_1, \gamma_2, ..., \gamma_n)\)&lt;/span>&lt;/li>
&lt;li>令&lt;span class="math inline">\(x=Qy\)&lt;/span>， 得&lt;span class="math inline">\(x^T A x = y^T \Lambda y, \Lambda = \left[ \begin{array} { c c c c } { \lambda _ { 1 } } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { 0 } &amp;amp; { \lambda _ { 2 } } &amp;amp; { \cdots } &amp;amp; { 0 } \\ { \vdots } &amp;amp; { \vdots } &amp;amp; { \vdots } &amp;amp; { \vdots } \\ { 0 } &amp;amp; { 0 } &amp;amp; { \cdots } &amp;amp; { \lambda _ { n } } \end{array} \right]\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;p>简证：正交矩阵Q有&lt;span class="math inline">\(Q^T = Q^{-1}\)&lt;/span>的性质，结合&lt;a href="#%20相似对角化">相似对角化&lt;/a>的证明过程，可知以上正交变换法是正确的&lt;/p>
&lt;h3 id="正定二次型">正定二次型&lt;/h3>
&lt;hr />
&lt;h5 id="正定二次型定义">正定二次型定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(\forall x = (x_1, x_2, ... , x_n)^T \neq 0\)&lt;/span>，恒有&lt;span class="math inline">\(f(x_1, x_2, ... , x_n) = x^T A x &amp;gt; 0\)&lt;/span>， 则称f为&lt;strong>正定二次型&lt;/strong>，A为&lt;strong>正定矩阵&lt;/strong>&lt;/p>
&lt;h5 id="性质-3">性质&lt;/h5>
&lt;p>合同变换不改变二次型的正定性&lt;/p>
&lt;p>&lt;span class="math inline">\(x^T A x\)&lt;/span>正定二次型 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 正惯性指数p=n &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(A \simeq E \quad (i.e. \exists |C| \neq 0, C^T A C = E)\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> A的特征值全大于0 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> A的顺序主子式全大于0 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在可逆矩阵P，使&lt;span class="math inline">\(A = P^T P\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 存在正交矩阵Q，使&lt;span class="math inline">\(\boldsymbol{Q}^{\mathrm{T}} \boldsymbol{A Q}=\boldsymbol{Q}^{-1} \mathrm{AQ}=\left[\begin{array}{ccc}{\lambda_{1}} &amp;amp; {} &amp;amp; {} \\ {} &amp;amp; {\lambda_{2}} &amp;amp; {} \\ {} &amp;amp; {} &amp;amp; {\ddots} &amp;amp; {} \\ {} &amp;amp; {} &amp;amp; {} &amp;amp; {\lambda_{n}}\end{array}\right], \lambda_{i}&amp;gt;0(i=1,2, \cdots, n)\)&lt;/span>&lt;/p>
&lt;p>若A为正定矩阵，则&lt;span class="math inline">\(k \mathbf{A}(k&amp;gt;0), \mathbf{A}^{\mathrm{T}}, \mathbf{A}^{-1}, \mathbf{A}^{*}\)&lt;/span>也是正定矩阵&lt;a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref">&lt;sup>4&lt;/sup>&lt;/a> 若A为正定矩阵，则&lt;span class="math inline">\(|A|&amp;gt;0\)&lt;/span>，从而A可逆 若A为正定矩阵，则A的主对角线上元素&lt;span class="math inline">\(a_{i i}&amp;gt;0, i=1,2, \cdots, n\)&lt;/span>&lt;/p>
&lt;ol type="1">
&lt;li>&lt;span class="math inline">\((A^{-1})^T = (A^T)^{-1} \overset{A \text{正定}}{=} A^{-1}\)&lt;/span> 所以&lt;span class="math inline">\(A^{-1}\)&lt;/span>是对称矩阵&lt;/li>
&lt;li>设&lt;span class="math inline">\(\lambda\)&lt;/span>是&lt;span class="math inline">\(A^{-1}\)&lt;/span>的特征值， &lt;span class="math inline">\(\alpha\)&lt;/span>是对应的特征向量 &lt;span class="math inline">\(\therefore A^{-1} \alpha = \lambda \alpha\)&lt;/span> &lt;span class="math inline">\(\because\)&lt;/span> A正定，其特征孩子全大于0 &lt;span class="math inline">\(\therefore\)&lt;/span> A的特征值&lt;span class="math inline">\(\frac{1}{\lambda} &amp;gt; 0\)&lt;/span> &lt;span class="math inline">\(\therefore \lambda &amp;gt; 0\)&lt;/span> &lt;span class="math inline">\(\therefore A^{-1}\)&lt;/span>正定&lt;/li>
&lt;/ol>
&lt;h2 id="易混概念辨析">易混概念辨析&lt;/h2>
&lt;h4 id="矩阵等价合同相似">矩阵等价,合同,相似&lt;/h4>
&lt;p>&lt;a href="#等价矩阵">矩阵等价&lt;/a> : 对同型矩阵A、B，存在可逆阵P和Q，使得B=PAQ 充要条件：A和B的秩相等 理解: 初等变换(行/列变换), 不改变矩阵的秩,变换前后的矩阵等价&lt;/p>
&lt;p>&lt;a href="#%20矩阵合同">矩阵合同&lt;/a>: 对同型方阵A、B，存在可逆阵P, 使得&lt;span class="math inline">\(B=P^T A P\)&lt;/span>&lt;/p>
&lt;p>&lt;a href="#%20相似矩阵">矩阵相似&lt;/a>: 对同型方阵A、B，存在可逆阵P, 使得&lt;span class="math inline">\(B=P^{-1}AP, \quad B=P^{-1}AP\)&lt;/span>&lt;/p>
&lt;h6 id="三者关系">三者关系：&lt;/h6>
&lt;p>等价（只有秩相同）–&amp;gt;合同（秩和正负惯性指数相同）–&amp;gt;相似（秩，正负惯性指数，特征值均相同），矩阵亲密关系的一步步深化。&lt;/p>
&lt;p>相似矩阵必为等价矩阵，但等价矩阵未必为相似矩阵 PQ=EPQ=E 的等价矩阵是相似矩阵 合同矩阵必为等价矩阵，等价矩阵未必为合同矩阵 正惯性指数相同的等价矩阵是合同矩阵 合同矩阵未必是相似矩阵 相似矩阵未必合同 正交相似矩阵必为合同矩阵，正交合同矩阵必为相似矩阵 如果A与B都是n阶实对称矩阵，且有相同的特征根．则A与B既相似又合同&lt;/p>
&lt;h4 id="方程组系数矩阵的秩方程组解的秩">方程组系数矩阵的秩,方程组解的秩&lt;/h4>
&lt;p>对于齐次方程组: &lt;span class="math display">\[
\left\{ \begin{array} { l } { x _ { 1 } - x _ { 2 } + 2 x _ { 3 } - 3 x _ { 4 } = 0 } \\
{ 2 x _ { 1 } - 2 x _ { 2 } + 4 x _ { 3 } + 6 x _ { 4 } = 0 } \end{array} \right.
\]&lt;/span> 其系数矩阵: &lt;span class="math display">\[
A=\left[\begin{array}{rrrr}{1} &amp;amp; {-1} &amp;amp; {2} &amp;amp; {-3} \\
{2} &amp;amp; {-2} &amp;amp; {4} &amp;amp; {6}\end{array}\right]\rightarrow\left[\begin{array}{rrrr}{1} &amp;amp; {-1} &amp;amp; {2} &amp;amp; {-3} \\
{0} &amp;amp; {0} &amp;amp; {0} &amp;amp; {12}\end{array}\right]\rightarrow\left[\begin{array}{rrrr}{1} &amp;amp; {-1} &amp;amp; {2} &amp;amp; {0} \\
{0} &amp;amp; {0} &amp;amp; {0} &amp;amp; {1}\end{array}\right]
\]&lt;/span>&lt;/p>
&lt;p>系数矩阵A的秩:&lt;span class="math inline">\(r(A)=2\)&lt;/span>&lt;/p>
&lt;p>方程组系数矩阵A(或者A的列向量)的极大线性无关组: &lt;span class="math inline">\(\left[\begin{array}{l}{1} \\ {2}\end{array}\right],\left[\begin{array}{r}{-3} \\ {6}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;p>方程组极大线性无关组(基础解系)个数，即解的秩: &lt;span class="math inline">\(n-r(A)=4-2=2\)&lt;/span> &lt;span class="math inline">\(\begin{array}{l}{x_{2}=1, x_{3}=0} \\ \quad \rightarrow {\eta_{1}=(1,1,0,0)^{T}} \\ {x_{2}=0, x_{3}=1} \\ \quad \rightarrow {\eta_{2}=(-2,0,1,0)^{T}}\end{array}\)&lt;/span>&lt;/p>
&lt;p>方程组解向量的极大线性无关组(基础解系): &lt;span class="math inline">\(\left[\begin{array}{c}{1} \\ {1} \\ {0} \\ {0}\end{array}\right],\left[\begin{array}{c}{-2} \\ {0} \\ {1} \\ {0}\end{array}\right]\)&lt;/span>&lt;/p>
&lt;h4 id="秩极大线性无关组个数系数矩阵的秩方程组的基础解系">秩,极大线性无关组个数,系数矩阵的秩，方程组的基础解系&lt;/h4>
&lt;p>&lt;a href="#线性相关与无关定义">线性无关(组)&lt;/a>：仅当&lt;span class="math inline">\(k_1 = k_2 = ... = k_s = 0\)&lt;/span> 时, 得&lt;span class="math inline">\(k_1 \alpha_1 + k_2 \alpha_2 + ... + k_s \alpha_s = 0\)&lt;/span> 成立，称向量组&lt;span class="math inline">\(\alpha_1, \alpha_2, ... , \alpha_s\)&lt;/span> 线性无关&lt;/p>
&lt;p>&lt;a href="#%20极大线性无关组">极大线性无关组&lt;/a>：向量组中有r个向量线性无关，且向量的任意&lt;span class="math inline">\(r+1\)&lt;/span>个向量线性相关，这r个线性无关的向量称为向量组的极大线性无关组&lt;/p>
&lt;p>&lt;a href="#%20秩">秩&lt;/a>： 极大线性无关组中向量的个数&lt;/p>
&lt;p>(方程组&lt;span class="math inline">\(Ax=\beta\)&lt;/span>的)系数矩阵：A&lt;/p>
&lt;p>(方程组&lt;span class="math inline">\(Ax=\beta\)&lt;/span>的)增广矩阵：&lt;span class="math inline">\((A|\beta)\)&lt;/span>&lt;/p>
&lt;p>(方程组&lt;span class="math inline">\(Ax=\beta\)&lt;/span>的)基础解系：方程组解空间的极大线性无关组&lt;/p>
&lt;p>(方程组&lt;span class="math inline">\(Ax=\beta\)&lt;/span>的)系数矩阵的秩：&lt;span class="math inline">\(r(A)\)&lt;/span>&lt;/p>
&lt;p>(方程组&lt;span class="math inline">\(Ax=\beta\)&lt;/span>的)基础解系的秩：&lt;span class="math inline">\(n-r(A)\)&lt;/span>&lt;/p>
&lt;h4 id="行列式同等变形-矩阵行列变换-方程组同解变形">行列式同等变形, 矩阵行/列变换, 方程组同解变形&lt;/h4>
&lt;h5 id="说明">说明&lt;/h5>
&lt;p>(行/列)倍乘: 非零元素乘以某一行(列)&lt;/p>
&lt;p>(行/列)倍加: 非零元素乘以某一行(列),加到另一行(列)上&lt;/p>
&lt;p>(行/列)互换: 某一行(列)与另一行(列)位置互换&lt;/p>
&lt;h5 id="区别">区别&lt;/h5>
&lt;h6 id="矩阵行列变换">矩阵行/列变换&lt;/h6>
&lt;p>不是同等变形(变形前后不是“=”关系)&lt;/p>
&lt;p>变换规则:倍乘, 倍加, 互换&lt;/p>
&lt;p>有些情况只能行变换 e.g. 增广矩阵变换&lt;span class="math inline">\((A|\beta) \rightarrow (E|\beta&amp;#39;)\)&lt;/span>, 矩阵求逆&lt;span class="math inline">\((A|E)\rightarrow (E|A^{-1})\)&lt;/span>&lt;/p>
&lt;h6 id="行列式同等变形">行列式同等变形&lt;/h6>
&lt;p>是同等变形&lt;/p>
&lt;p>变形规则: (行/列)倍乘, (行/列)倍加, (行/列)互换(互换位置行列式取反)&lt;/p>
&lt;h6 id="方程组同解变形">方程组同解变形&lt;/h6>
&lt;p>是同等变形&lt;/p>
&lt;p>变形规则: 行倍乘, 行倍加, 行互换&lt;/p>
&lt;p>[线性相关]: &lt;a href="#线性表示">线性表示&lt;/a>:&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>&lt;a href="https://www.zhihu.com/question/304671751">矩阵特征值乘积等于矩阵行列式乘积的证明&lt;/a>&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn2" role="doc-endnote">&lt;p>这也是&lt;strong>构造可逆矩阵P和对角矩阵&lt;span class="math inline">\(\Lambda\)&lt;/span>的方法&lt;/strong>&lt;a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn3" role="doc-endnote">&lt;p>（一般的相似对角化是用特征向量可逆矩阵来实现相似对角化）&lt;a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;li id="fn4" role="doc-endnote">&lt;p>A正定，证明&lt;span class="math inline">\(A^{-1}\)&lt;/span>正定&lt;a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>PAT甲级习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="pat甲级习题">PAT甲级习题&lt;/h1>
&lt;h2 id="栈的模拟">栈的模拟&lt;/h2>
&lt;h5 id="例1">例1&lt;/h5>
&lt;p>已知入栈顺序1-N，并给定栈最大容积M。判断出栈顺序是否正确, 以及是否爆栈&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4090">题目链接&lt;/a>&lt;/p>
&lt;p>方法：栈的模拟&lt;/p>
&lt;p>由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈。利用这个过程来确定出入栈顺序。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.BufferedReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.IOException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.InputStreamReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Stack&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/26 09:55
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4090
&lt;/span>&lt;span style="color:#75715e"> * 已知入栈顺序，判断出栈顺序是否正确, 以及是否爆栈: 栈的模拟
&lt;/span>&lt;span style="color:#75715e"> * 由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1040&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> IOException &lt;span style="color:#f92672">{&lt;/span>
BufferedReader br &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedReader&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> InputStreamReader&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
String&lt;span style="color:#f92672">[]&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">readLine&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">split&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">[&lt;/span>2&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> index&lt;span style="color:#f92672">;&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>k&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">clear&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
test &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
s &lt;span style="color:#f92672">=&lt;/span> br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">readLine&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">split&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
test&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
index &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">||&lt;/span> test&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">peek&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>index&lt;span style="color:#f92672">++);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>test&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">peek&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">||&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> m&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">--&lt;/span>index &lt;span style="color:#f92672">==&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;YES&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;NO&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还有牛客网牛友在讨论区贴出的代码，更简洁&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">//链接：https://www.nowcoder.com/questionTerminal/597a931ab1794139835ad2991faeab2d
&lt;/span>&lt;span style="color:#75715e">//来源：牛客网 北航闫子浩
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> M,N,K,a[&lt;span style="color:#ae81ff">1001&lt;/span>],i,j,l;
&lt;span style="color:#66d9ef">char&lt;/span> c[&lt;span style="color:#ae81ff">2&lt;/span>];
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d %d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>M,&lt;span style="color:#f92672">&amp;amp;&lt;/span>N,&lt;span style="color:#f92672">&amp;amp;&lt;/span>K);&lt;span style="color:#75715e">//M为栈长，N为数组长，K为组数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>(K&lt;span style="color:#f92672">--&lt;/span>){
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>j&lt;span style="color:#f92672">=&lt;/span>l&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>N;i&lt;span style="color:#f92672">++&lt;/span>){&lt;span style="color:#75715e">//l为当前栈长，j为最近入栈的数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,a);
&lt;span style="color:#66d9ef">while&lt;/span>(l&lt;span style="color:#f92672">&amp;lt;&lt;/span>M&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span>j)a[&lt;span style="color:#f92672">++&lt;/span>l]&lt;span style="color:#f92672">=++&lt;/span>j;
&lt;span style="color:#66d9ef">if&lt;/span>((l&lt;span style="color:#f92672">==&lt;/span>M&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>a[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">&amp;gt;&lt;/span>j)&lt;span style="color:#f92672">||&lt;/span>a[l&lt;span style="color:#f92672">--&lt;/span>]&lt;span style="color:#f92672">&amp;lt;&lt;/span>a[&lt;span style="color:#ae81ff">0&lt;/span>])i&lt;span style="color:#f92672">=&lt;/span>N;
}
gets(c);
printf(i&lt;span style="color:#f92672">&amp;gt;&lt;/span>N&lt;span style="color:#f92672">?&lt;/span>&lt;span style="color:#e6db74">&amp;#34;NO&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">:&lt;/span>&lt;span style="color:#e6db74">&amp;#34;YES&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="例2">例2&lt;/h5>
&lt;p>已知二叉树中序遍历非递归的栈操作顺序，求该树的后序遍历。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/1/problem/4314">题目链接&lt;/a>&lt;/p>
&lt;p>方法：模拟栈操作可以获得中序遍历序列，另外注意所有 Push 的节点组成的序列就是这棵树的先序遍历序列。于是问题转为从一棵树的先序遍历序列和中序遍历序列生成这棵树。&lt;/p>
&lt;p>所以可以参考：算法总结.md#树的遍历#由前序和中序遍历重建二叉树&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.*&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/2/4 14:27
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/1/problem/4314
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 中序遍历序列可以模拟出栈操作获得，另外注意所有 Push 的节点组成的序列就是这棵树的先序遍历序列。
&lt;/span>&lt;span style="color:#75715e"> * 于是问题转为从一棵树的先序遍历序列和中序遍历序列生成这棵树。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1004_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinaryTree&lt;span style="color:#f92672">&amp;gt;&lt;/span> preOrderList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>8&lt;span style="color:#f92672">);&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinaryTree&lt;span style="color:#f92672">&amp;gt;&lt;/span> inOrderList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>8&lt;span style="color:#f92672">);&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinaryTree&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String action &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Push&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>action&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
BinaryTree node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BinaryTree&lt;span style="color:#f92672">(&lt;/span>scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Pop&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>action&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
BinaryTree root &lt;span style="color:#f92672">=&lt;/span> rebuildBinaryTree&lt;span style="color:#f92672">(&lt;/span>preOrderList&lt;span style="color:#f92672">,&lt;/span> inOrderList&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">postOrderTraversal&lt;/span>&lt;span style="color:#f92672">().&lt;/span>&lt;span style="color:#a6e22e">trim&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 由前序遍历和中序遍历重建二叉树
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 参考： https://zhuanlan.zhihu.com/p/37265145
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> BinaryTree &lt;span style="color:#a6e22e">rebuildBinaryTree&lt;/span>&lt;span style="color:#f92672">(&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinaryTree&lt;span style="color:#f92672">&amp;gt;&lt;/span> preOrderList&lt;span style="color:#f92672">,&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinaryTree&lt;span style="color:#f92672">&amp;gt;&lt;/span> inOrderList&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">)))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">left&lt;/span> &lt;span style="color:#f92672">=&lt;/span> rebuildBinaryTree&lt;span style="color:#f92672">(&lt;/span>preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">,&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">),&lt;/span> inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">,&lt;/span> i&lt;span style="color:#f92672">));&lt;/span>
preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">right&lt;/span> &lt;span style="color:#f92672">=&lt;/span> rebuildBinaryTree&lt;span style="color:#f92672">(&lt;/span>preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()),&lt;/span>
inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">:&lt;/span> preOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BinaryTree&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
BinaryTree left&lt;span style="color:#f92672">;&lt;/span>
BinaryTree right&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> index&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> UUID uuid &lt;span style="color:#f92672">=&lt;/span> UUID&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">randomUUID&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">BinaryTree&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> index&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">index&lt;/span> &lt;span style="color:#f92672">=&lt;/span> index&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">postOrderTraversal&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">(&lt;/span>left &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> left&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">postOrderTraversal&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">(&lt;/span>right &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> right&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">postOrderTraversal&lt;/span>&lt;span style="color:#f92672">())&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> index &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Object object&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">uuid&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">equals&lt;/span>&lt;span style="color:#f92672">(((&lt;/span>BinaryTree&lt;span style="color:#f92672">)&lt;/span>object&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">uuid&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">index&lt;/span>&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="树的深度">树的深度&lt;/h2>
&lt;h5 id="例1-1">例1&lt;/h5>
&lt;h6 id="供应商问题">供应商问题&lt;/h6>
&lt;p>供应商，经销商，零售商组成多级供应链。每经过一级，价格提高一定比率。&lt;/p>
&lt;p>给出每个节点的父亲序号，求最高价格，以及最高价格零售商有几个。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4316">供应商问题题目链接&lt;/a>&lt;/p>
&lt;h6 id="方法1bfs树的广度优先层次遍历">方法1：BFS树的广度优先/层次遍历&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 树形结构：层次遍历找最深的点(本代码实现的方式）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1003&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextDouble&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextDouble&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Node1003&lt;span style="color:#f92672">[]&lt;/span> nodes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1003&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
nodes&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1003&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//构造树
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Node1003 root &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> father &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>father &lt;span style="color:#f92672">!=&lt;/span> Const1003&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">UNDEFINED&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
nodes&lt;span style="color:#f92672">[&lt;/span>father&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>nodes&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
root &lt;span style="color:#f92672">=&lt;/span> nodes&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>LFS&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">,&lt;/span> p&lt;span style="color:#f92672">,&lt;/span> r&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//层次遍历，返回最深层次的价格，以及最深层节点数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">LFS&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Node1003 root&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> price&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> rate&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> retPrice &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> retNum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1003&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1003&lt;span style="color:#f92672">&amp;gt;();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> levelSize &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> level &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> levelSize&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Node1003 node &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">poll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> price&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
level&lt;span style="color:#f92672">++;&lt;/span>
retPrice &lt;span style="color:#f92672">=&lt;/span> price&lt;span style="color:#f92672">;&lt;/span>
retNum &lt;span style="color:#f92672">=&lt;/span> levelSize&lt;span style="color:#f92672">;&lt;/span>
price &lt;span style="color:#f92672">*=&lt;/span> 1 &lt;span style="color:#f92672">+&lt;/span> rate &lt;span style="color:#f92672">*&lt;/span> 0&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">01&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
levelSize &lt;span style="color:#f92672">=&lt;/span> count&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%.2f %d&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> retPrice&lt;span style="color:#f92672">,&lt;/span> retNum&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//节点类
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node1003&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> price&lt;span style="color:#f92672">;&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1003&lt;span style="color:#f92672">&amp;gt;&lt;/span> children&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Node1003&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">price&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Const1003&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">UNDEFINED&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//常量定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Const1003&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> UNDEFINED &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法2dfs深度优先遍历">方法2：DFS深度优先遍历&lt;/h6>
&lt;p>类似上一种方法，牛客网牛友提交的讨论代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//链接：https://www.nowcoder.com/questionTerminal/24429a3319e4466790e65a647130b118
&lt;/span>&lt;span style="color:#75715e">//来源：牛客网
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//爆搜dfs
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;bits/stdc++.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> LL;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxn&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1e5&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> n,root,anscnt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#66d9ef">double&lt;/span> p,r;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> G[maxn];
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> mp;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> cur,&lt;span style="color:#66d9ef">int&lt;/span> step){
&lt;span style="color:#66d9ef">int&lt;/span> ok&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>G[cur].size();&lt;span style="color:#f92672">++&lt;/span>i){
&lt;span style="color:#66d9ef">int&lt;/span> v&lt;span style="color:#f92672">=&lt;/span>G[cur][i];ok&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
dfs(v,step&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;span style="color:#66d9ef">if&lt;/span>(ok){
&lt;span style="color:#66d9ef">if&lt;/span>(step&lt;span style="color:#f92672">&amp;gt;&lt;/span>anscnt){
anscnt&lt;span style="color:#f92672">=&lt;/span>step;&lt;span style="color:#f92672">++&lt;/span>mp[anscnt];&lt;span style="color:#66d9ef">return&lt;/span> ;
}
&lt;span style="color:#66d9ef">if&lt;/span>(step&lt;span style="color:#f92672">==&lt;/span>anscnt){
&lt;span style="color:#f92672">++&lt;/span>mp[anscnt];&lt;span style="color:#66d9ef">return&lt;/span> ;
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %lf %lf&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>p,&lt;span style="color:#f92672">&amp;amp;&lt;/span>r);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,tmp;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>n;&lt;span style="color:#f92672">++&lt;/span>i){
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>tmp);
&lt;span style="color:#66d9ef">if&lt;/span>(tmp&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>){ root&lt;span style="color:#f92672">=&lt;/span>i;&lt;span style="color:#66d9ef">continue&lt;/span>;}
G[tmp].push_back(i);
}
dfs(root,&lt;span style="color:#ae81ff">0&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;%.2f %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,p&lt;span style="color:#f92672">*&lt;/span>pow(&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">+&lt;/span>r&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">0.01&lt;/span>,anscnt),mp[anscnt]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法3枚举">方法3：枚举&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">//牛客网牛友提交的代码
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/1701726/codeBookDetail?submissionId=10247559
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#define MAXN 100000
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> N;
&lt;span style="color:#66d9ef">double&lt;/span> P, R;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>N);
scanf(&lt;span style="color:#e6db74">&amp;#34;%lf&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>P);
scanf(&lt;span style="color:#e6db74">&amp;#34;%lf&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>R);
&lt;span style="color:#66d9ef">int&lt;/span> shit[MAXN];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>shit[i]);
}
&lt;span style="color:#66d9ef">int&lt;/span> maxlevel &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, templevel &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, maxnum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> end;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
{
end &lt;span style="color:#f92672">=&lt;/span> i;
&lt;span style="color:#66d9ef">while&lt;/span> (shit[end] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
templevel&lt;span style="color:#f92672">++&lt;/span>;
end &lt;span style="color:#f92672">=&lt;/span> shit[end];
}
&lt;span style="color:#66d9ef">if&lt;/span> (templevel &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxlevel)
{
maxlevel &lt;span style="color:#f92672">=&lt;/span> templevel;
maxnum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (templevel &lt;span style="color:#f92672">==&lt;/span> maxlevel)
maxnum&lt;span style="color:#f92672">++&lt;/span>;
templevel &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">double&lt;/span> max;
max &lt;span style="color:#f92672">=&lt;/span> P &lt;span style="color:#f92672">*&lt;/span> pow(&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> (R &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">100.0&lt;/span>), maxlevel);
printf(&lt;span style="color:#e6db74">&amp;#34;%.2f %d&amp;#34;&lt;/span>, max, maxnum);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法4枚举优化保存搜索过的答案">方法4：枚举优化：保存搜索过的答案&lt;/h6>
&lt;p>其实是对枚举时的操作做了优化：保存搜索过的内容，下次搜索就不用向下搜索了&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 或者使用数组，记录father[]和price[]，level[]信息,循环查找各点的价钱和层次，注意保存一下搜索过的答案(本代码使用的方法）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1003_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextDouble&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">double&lt;/span> r &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextDouble&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> father &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
father&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> level &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxLevel &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxLevelCount &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> thisLevel &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//枚举找最深层，并记录个数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
thisLevel &lt;span style="color:#f92672">=&lt;/span> getLevel&lt;span style="color:#f92672">(&lt;/span>father&lt;span style="color:#f92672">,&lt;/span> level&lt;span style="color:#f92672">,&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>thisLevel &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxLevel&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
maxLevel &lt;span style="color:#f92672">=&lt;/span> thisLevel&lt;span style="color:#f92672">;&lt;/span>
maxLevelCount &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>thisLevel &lt;span style="color:#f92672">==&lt;/span> maxLevel&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
maxLevelCount&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">format&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;%.2f %d&amp;#34;&lt;/span>&lt;span style="color:#f92672">,&lt;/span> p &lt;span style="color:#f92672">*&lt;/span> Math&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pow&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1 &lt;span style="color:#f92672">+&lt;/span> r &lt;span style="color:#f92672">*&lt;/span> 0&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">01&lt;/span>&lt;span style="color:#f92672">,&lt;/span> maxLevel &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">),&lt;/span> maxLevelCount&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 递归获取level方法(同时保存计算结果，方便重复使用)
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getLevel&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> father&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> level&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>father&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
level&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>level&lt;span style="color:#f92672">[&lt;/span>father&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
level&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> level&lt;span style="color:#f92672">[&lt;/span>father&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
level&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> getLevel&lt;span style="color:#f92672">(&lt;/span>father&lt;span style="color:#f92672">,&lt;/span> level&lt;span style="color:#f92672">,&lt;/span> father&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> level&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>还可以将上面获取level的递归函数改为非递归函数&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">//牛客网牛友提交的代码，不过确实是这个思路
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/6639688/codeBookDetail?submissionId=6510475
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;math.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> n, s[&lt;span style="color:#ae81ff">100001&lt;/span>], g[&lt;span style="color:#ae81ff">100001&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0&lt;/span>}, i, t, c, mc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, x, m &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">double&lt;/span> p, r;
scanf( &lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n );
scanf( &lt;span style="color:#e6db74">&amp;#34;%lf%lf&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>p, &lt;span style="color:#f92672">&amp;amp;&lt;/span>r );
&lt;span style="color:#66d9ef">for&lt;/span>( i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i &lt;span style="color:#f92672">++&lt;/span> )
scanf( &lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, s &lt;span style="color:#f92672">+&lt;/span> i );
&lt;span style="color:#66d9ef">for&lt;/span>( i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i &lt;span style="color:#f92672">++&lt;/span> ){
&lt;span style="color:#66d9ef">if&lt;/span>( &lt;span style="color:#f92672">!&lt;/span>g[i] ){
t &lt;span style="color:#f92672">=&lt;/span> i, c &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>( t &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>g[t] ){
c &lt;span style="color:#f92672">++&lt;/span>;
t &lt;span style="color:#f92672">=&lt;/span> s[t];
}
&lt;span style="color:#66d9ef">if&lt;/span>( t &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ) &lt;span style="color:#75715e">//g[t]前面已经求过
&lt;/span>&lt;span style="color:#75715e">&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> g[t] &lt;span style="color:#f92672">+&lt;/span> c;
&lt;span style="color:#66d9ef">else&lt;/span>
x &lt;span style="color:#f92672">=&lt;/span> c;
&lt;span style="color:#75715e">//判断当前深度
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>( x &lt;span style="color:#f92672">&amp;gt;&lt;/span> m )
mc &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, m &lt;span style="color:#f92672">=&lt;/span> x;
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>( x &lt;span style="color:#f92672">==&lt;/span> m )
mc &lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#75715e">//储存结果
&lt;/span>&lt;span style="color:#75715e">&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> i;
&lt;span style="color:#66d9ef">while&lt;/span>( t &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>g[t] ) g[t] &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">--&lt;/span>, t &lt;span style="color:#f92672">=&lt;/span> s[t];
}
}
printf( &lt;span style="color:#e6db74">&amp;#34;%.2lf %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, p &lt;span style="color:#f92672">*&lt;/span> pow( &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> r &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>, m &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1.0&lt;/span> ), mc );
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="例2-1">例2&lt;/h5>
&lt;h6 id="族谱中人最多的一代">族谱中人最多的一代&lt;/h6>
&lt;p>给定某一族谱，找族谱中人最多的一代，以及这一代的人数。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4318">找族谱中人数最多一代的题目链接&lt;/a>&lt;/p>
&lt;h6 id="方法一穷举">方法一：穷举&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#960050;background-color:#1e0010">链接：&lt;/span>https:&lt;span style="color:#75715e">//www.nowcoder.com/questionTerminal/324faf954885435ba3b1c9bbd2a7a81e
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">来源：牛客网&lt;/span>YuanYuan的讨论
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;malloc.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> get_gen(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>family, &lt;span style="color:#66d9ef">int&lt;/span> child) {
&lt;span style="color:#66d9ef">int&lt;/span> gen &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (family[child] &lt;span style="color:#f92672">!=&lt;/span> child) {
gen&lt;span style="color:#f92672">++&lt;/span>;
child &lt;span style="color:#f92672">=&lt;/span> family[child];
}
&lt;span style="color:#66d9ef">return&lt;/span> gen;
}
&lt;span style="color:#66d9ef">int&lt;/span> main() {
&lt;span style="color:#66d9ef">int&lt;/span> N, M;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>N, &lt;span style="color:#f92672">&amp;amp;&lt;/span>M);
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>family &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) malloc((N &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>i) {
family[i] &lt;span style="color:#f92672">=&lt;/span> i;
}
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> M; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;span style="color:#66d9ef">int&lt;/span> parent;
&lt;span style="color:#66d9ef">int&lt;/span> child_num;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>parent, &lt;span style="color:#f92672">&amp;amp;&lt;/span>child_num);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> child_num; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;span style="color:#66d9ef">int&lt;/span> child;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>child);
family[child] &lt;span style="color:#f92672">=&lt;/span> parent;
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>gen &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) malloc((N &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>i) {
gen[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>i) {
gen[get_gen(family, i)]&lt;span style="color:#f92672">++&lt;/span>;
}
&lt;span style="color:#66d9ef">int&lt;/span> max_gen &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, max_member &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;span style="color:#66d9ef">if&lt;/span> (gen[i] &lt;span style="color:#f92672">&amp;gt;&lt;/span> max_member) {
max_member &lt;span style="color:#f92672">=&lt;/span> gen[i];
max_gen &lt;span style="color:#f92672">=&lt;/span> i;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>, max_member, max_gen);
free(family);
free(gen);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法二dfs">方法二：DFS&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.*&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/5/27 16:34
&lt;/span>&lt;span style="color:#75715e"> * @discription: https://www.nowcoder.com/pat/5/problem/4318
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 从树中找节点数最多的那一层，以及那一层的节点数
&lt;/span>&lt;span style="color:#75715e"> * dfs （本代码实现的方法）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1005&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">,&lt;/span> Node1005&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>16&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//建map，建树
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String id &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Node1005 father &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>father &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
father &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1005&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">,&lt;/span> father&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> childrenNum &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> childrenNum&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
id &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Node1005 child &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>child &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
child &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1005&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">,&lt;/span> child&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
father&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>child&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
dfs&lt;span style="color:#f92672">(&lt;/span>map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;01&amp;#34;&lt;/span>&lt;span style="color:#f92672">),&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> level &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>count &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxCount&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
maxCount &lt;span style="color:#f92672">=&lt;/span> count&lt;span style="color:#f92672">;&lt;/span>
level &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>maxCount &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> level&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 递归dfs
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Node1005 root&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> level&lt;span style="color:#f92672">,&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> level&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>level &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>level &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Node1005 node &lt;span style="color:#f92672">:&lt;/span> root&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dfs&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">,&lt;/span> level &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node1005&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String id&lt;span style="color:#f92672">;&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1005&lt;span style="color:#f92672">&amp;gt;&lt;/span> children&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Node1005&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String id&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法三bfs">方法三：BFS&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.*&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/5/27 16:34
&lt;/span>&lt;span style="color:#75715e"> * @discription: https://www.nowcoder.com/pat/5/problem/4318
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 从树中找节点数最多的那一层，以及那一层的节点数
&lt;/span>&lt;span style="color:#75715e"> * bfs （本代码的方法）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1005_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">,&lt;/span> Node1005_2&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>16&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//建map，建树
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String id &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Node1005_2 father &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>father &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
father &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1005_2&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">,&lt;/span> father&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> childrenNum &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> childrenNum&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
id &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Node1005_2 child &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>child &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
child &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1005_2&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">);&lt;/span>
map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>id&lt;span style="color:#f92672">,&lt;/span> child&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
father&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>child&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>bfs&lt;span style="color:#f92672">(&lt;/span>map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;01&amp;#34;&lt;/span>&lt;span style="color:#f92672">)));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * bfs
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">bfs&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Node1005_2 root&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxLevel &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxCount &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1005_2&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> level &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> levelSize &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>levelSize &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//判断当前层节点是否最多
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>levelSize &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxCount&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
maxCount &lt;span style="color:#f92672">=&lt;/span> levelSize&lt;span style="color:#f92672">;&lt;/span>
maxLevel &lt;span style="color:#f92672">=&lt;/span> level&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//下一层节点入队
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> levelSize&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Node1005_2 node &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">poll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
level&lt;span style="color:#f92672">++;&lt;/span>
levelSize &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
String res &lt;span style="color:#f92672">=&lt;/span> maxCount &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> maxLevel&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> res&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node1005_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String id&lt;span style="color:#f92672">;&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1005_2&lt;span style="color:#f92672">&amp;gt;&lt;/span> children&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Node1005_2&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String id&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">children&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="优化使用二维数组或list数组保存树">优化：使用二维数组或list数组保存树&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//牛客网牛友提交的代码，使用二维数组保存树
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/4739176/codeBookDetail?submissionId=11875064
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;#34;iostream&amp;#34;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">int&lt;/span> member[&lt;span style="color:#ae81ff">103&lt;/span>][&lt;span style="color:#ae81ff">103&lt;/span>]; &lt;span style="color:#75715e">//存放输入成员的下一代成员编号
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> n,m;
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>n&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>m;
&lt;span style="color:#75715e">//输入
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> id,ct;
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>id&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>ct;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;&lt;/span>ct;j&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> temp;
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>temp;
member[id][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">++&lt;/span>;
member[id][member[id][&lt;span style="color:#ae81ff">0&lt;/span>]]&lt;span style="color:#f92672">=&lt;/span>temp;
}
}
&lt;span style="color:#75715e">//最大的数量和该层数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> maxcount&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,maxlayer&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#75715e">//按辈分存放成员，从1开始 ，fmlfree[i][0]用于存放该辈的成员数量
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> fmltree[&lt;span style="color:#ae81ff">103&lt;/span>][&lt;span style="color:#ae81ff">103&lt;/span>];
fmltree[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
fmltree[&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#75715e">//逐层向fmltree添加成员
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> layer&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;;layer&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>fmltree[layer][&lt;span style="color:#ae81ff">0&lt;/span>];i&lt;span style="color:#f92672">++&lt;/span>){
fmltree[layer&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">+=&lt;/span>member[fmltree[layer][i]][&lt;span style="color:#ae81ff">0&lt;/span>];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>member[fmltree[layer][i]][&lt;span style="color:#ae81ff">0&lt;/span>];j&lt;span style="color:#f92672">++&lt;/span>){
count&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#75715e">//向下一层添加本层成员的每个下一代
&lt;/span>&lt;span style="color:#75715e">&lt;/span> fmltree[layer&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>][count]&lt;span style="color:#f92672">=&lt;/span>member[fmltree[layer][i]][j];
}
}
&lt;span style="color:#75715e">//更新maxcount和maxlayer
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(count&lt;span style="color:#f92672">&amp;gt;&lt;/span>maxcount){
maxcount&lt;span style="color:#f92672">=&lt;/span>count;
maxlayer&lt;span style="color:#f92672">=&lt;/span>layer&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span>(count&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#75715e">//输出
&lt;/span>&lt;span style="color:#75715e">&lt;/span> cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>maxcount&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>maxlayer;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="树的构造">树的构造&lt;/h2>
&lt;h5 id="例1-2">例1&lt;/h5>
&lt;p>已知二叉搜索树的所有输入，要求生成一个二叉搜索树，且为完全二叉树。（生成的二叉搜索树不一定要与输入顺序对应）&lt;/p>
&lt;p>题目最后要求层次遍历输出此树。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4115">题目链接&lt;/a>&lt;/p>
&lt;h6 id="方法1引用非数组按层次建树中序遍历写值">方法1：（引用/非数组）按层次建树，中序遍历写值&lt;/h6>
&lt;p>（引用/非数组）按层次建树，中序遍历写值&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.*&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/9 21:21
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4115
&lt;/span>&lt;span style="color:#75715e"> * 建立二叉搜索树，且要求为完全二叉树（唯一），然后层次遍历输出
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 按层次建树，中序遍历写值，再层次遍历取值
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1022&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//建树
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Node1022 root &lt;span style="color:#f92672">=&lt;/span> setupCompleteBinaryTree&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//中序遍历，向树中对应位置写值
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> inOrdrList &lt;span style="color:#f92672">=&lt;/span> inOrderTraversal&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
inOrdrList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//层次遍历输出
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> levelOrderList &lt;span style="color:#f92672">=&lt;/span> bfs&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Node1022 node &lt;span style="color:#f92672">:&lt;/span> levelOrderList&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">value&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 层次建树，初始化一个n个节点的完全二叉树(n&amp;gt;=1)
&lt;/span>&lt;span style="color:#75715e"> * 注意，这个二叉树只建立起结构，没有存入值
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Node1022 &lt;span style="color:#a6e22e">setupCompleteBinaryTree&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
Node1022 root &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1022&lt;span style="color:#f92672">();&lt;/span>
Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
count&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> count &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Node1022 node &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">poll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>count &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">lChild&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1022&lt;span style="color:#f92672">();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">lChild&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
count&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>count &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">rChild&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node1022&lt;span style="color:#f92672">();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">rChild&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
count&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> root&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 中序遍历
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">inOrderTraversal&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Node1022 node&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">||&lt;/span> node &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>node &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">lChild&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
node &lt;span style="color:#f92672">=&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
node &lt;span style="color:#f92672">=&lt;/span> node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">rChild&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 层次遍历
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">bfs&lt;/span>&lt;span style="color:#f92672">(&lt;/span>Node1022 root&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
Queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Node1022&lt;span style="color:#f92672">&amp;gt;&lt;/span> queue &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> LinkedList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>root&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Node1022 node &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">poll&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">lChild&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">lChild&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">rChild&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">rChild&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node1022&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> value&lt;span style="color:#f92672">;&lt;/span>
Node1022 lChild&lt;span style="color:#f92672">,&lt;/span> rChild&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法2二叉树的数组存储中序递归建树写值">方法2：二叉树的数组存储，中序递归建树写值&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.ArrayList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Arrays&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.List&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/9 23:22
&lt;/span>&lt;span style="color:#75715e"> * @discription: https://www.nowcoder.com/pat/5/problem/4115
&lt;/span>&lt;span style="color:#75715e"> * 建立二叉搜索树且为完全二叉树
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 考虑二叉树的数组存储结构，数组的优点是随机访问，方便建树。
&lt;/span>&lt;span style="color:#75715e"> * 所有的值都填到数组的前面，则对应的二叉树是完全二叉树。
&lt;/span>&lt;span style="color:#75715e"> * 数组的顺次访问，对应的就是二叉树的层次遍历
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1022_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> tree &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//中序遍历建树
&lt;/span>&lt;span style="color:#75715e">&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> inOrderList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
inOrderTraversal&lt;span style="color:#f92672">(&lt;/span>tree&lt;span style="color:#f92672">,&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> inOrderList&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
tree&lt;span style="color:#f92672">[&lt;/span>inOrderList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">)]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//层次遍历输出
&lt;/span>&lt;span style="color:#75715e">&lt;/span> StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>tree&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inOrderTraversal&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> tree&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> node&lt;span style="color:#f92672">,&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> lChild &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>node &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> rChild &lt;span style="color:#f92672">=&lt;/span> lChild &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>lChild &lt;span style="color:#f92672">&amp;lt;&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
inOrderTraversal&lt;span style="color:#f92672">(&lt;/span>tree&lt;span style="color:#f92672">,&lt;/span> lChild&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>node&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>rChild &lt;span style="color:#f92672">&amp;lt;&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
inOrderTraversal&lt;span style="color:#f92672">(&lt;/span>tree&lt;span style="color:#f92672">,&lt;/span> rChild&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="最短路径问题">最短路径问题&lt;/h2>
&lt;h3 id="路径最短累计值最小最大平均值最小最大">路径最短，累计值最小/最大，平均值最小最大&lt;/h3>
&lt;h5 id="例1-3">例1&lt;/h5>
&lt;h6 id="公共自行车问题">公共自行车问题&lt;/h6>
&lt;p>从源点出发到某点去摆放自行车，经过路径节点上的自行车都要调整为半满。
要找最短路径；
若存在多条最短路径，则选出发前带的自行车最少的路径；
若还是存在多条路径，则选带回去最少自行车的路径。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4324">公共自行车问题题目链接&lt;/a>&lt;/p>
&lt;h6 id="方法1穷举">方法1：穷举&lt;/h6>
&lt;h6 id="方法2dfs回溯">方法2：DFS回溯&lt;/h6>
&lt;p>不是我写的，看人家思路就好&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;limits.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> start, &lt;span style="color:#66d9ef">int&lt;/span> index, &lt;span style="color:#66d9ef">int&lt;/span> end);
&lt;span style="color:#66d9ef">int&lt;/span> cmax, N, sp, M;
&lt;span style="color:#66d9ef">int&lt;/span> costTimes, outBikes, inBikes;
&lt;span style="color:#66d9ef">int&lt;/span> resultTimes &lt;span style="color:#f92672">=&lt;/span> INT_MAX;
&lt;span style="color:#66d9ef">int&lt;/span> resultOutBikes, resultInBikes;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> bikes, path, resultPath;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> times;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> visited;
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
ios&lt;span style="color:#f92672">::&lt;/span>sync_with_stdio(false);
&lt;span style="color:#75715e">// 输入数据
&lt;/span>&lt;span style="color:#75715e">&lt;/span> cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> cmax &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> N &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> sp &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> M;
bikes.resize(N&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
visited.resize(N&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, false);
times.resize(N&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(N&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>N; i&lt;span style="color:#f92672">++&lt;/span>) {
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> bikes[i];
}
&lt;span style="color:#66d9ef">int&lt;/span> m, n, dist;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>M; i&lt;span style="color:#f92672">++&lt;/span>) {
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> m &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> n &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> dist;
times[m][n] &lt;span style="color:#f92672">=&lt;/span> dist;
times[n][m] &lt;span style="color:#f92672">=&lt;/span> dist;
}
&lt;span style="color:#75715e">// 深搜并输出结果
&lt;/span>&lt;span style="color:#75715e">&lt;/span> dfs(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, sp);
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> resultOutBikes &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; 0&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>resultPath.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> resultPath[i];
}
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> resultInBikes;
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> start, &lt;span style="color:#66d9ef">int&lt;/span> index, &lt;span style="color:#66d9ef">int&lt;/span> end)
{
&lt;span style="color:#75715e">// 访问
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited[index] &lt;span style="color:#f92672">=&lt;/span> true;
path.push_back(index);
costTimes &lt;span style="color:#f92672">+=&lt;/span> times[start][index];
&lt;span style="color:#75715e">// 处理
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(index &lt;span style="color:#f92672">==&lt;/span> end) {
&lt;span style="color:#75715e">// 计算这条路上带去的车和带回的车
&lt;/span>&lt;span style="color:#75715e">&lt;/span> inBikes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, outBikes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>path.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(bikes[path[i]] &lt;span style="color:#f92672">&amp;gt;&lt;/span> cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) {
inBikes &lt;span style="color:#f92672">+=&lt;/span> bikes[path[i]] &lt;span style="color:#f92672">-&lt;/span>cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span>((cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> bikes[path[i]]) &lt;span style="color:#f92672">&amp;lt;&lt;/span> inBikes) {
inBikes &lt;span style="color:#f92672">-=&lt;/span> (cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> bikes[path[i]]);
} &lt;span style="color:#66d9ef">else&lt;/span> {
outBikes &lt;span style="color:#f92672">+=&lt;/span> (cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">-&lt;/span> bikes[path[i]]) &lt;span style="color:#f92672">-&lt;/span> inBikes;
inBikes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
}
&lt;span style="color:#75715e">// 判断这条路是否更好
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(costTimes &lt;span style="color:#f92672">!=&lt;/span> resultTimes) {
&lt;span style="color:#66d9ef">if&lt;/span>(costTimes &lt;span style="color:#f92672">&amp;lt;&lt;/span> resultTimes) {
resultTimes &lt;span style="color:#f92672">=&lt;/span> costTimes;
resultPath &lt;span style="color:#f92672">=&lt;/span> path;
resultOutBikes &lt;span style="color:#f92672">=&lt;/span> outBikes;
resultInBikes &lt;span style="color:#f92672">=&lt;/span> inBikes;
}
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(outBikes &lt;span style="color:#f92672">!=&lt;/span> resultOutBikes) {
&lt;span style="color:#66d9ef">if&lt;/span>(outBikes &lt;span style="color:#f92672">&amp;lt;&lt;/span> resultOutBikes) {
resultPath &lt;span style="color:#f92672">=&lt;/span> path;
resultOutBikes &lt;span style="color:#f92672">=&lt;/span> outBikes;
resultInBikes &lt;span style="color:#f92672">=&lt;/span> inBikes;
}
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(inBikes &lt;span style="color:#f92672">&amp;lt;&lt;/span> resultInBikes) {
resultPath &lt;span style="color:#f92672">=&lt;/span> path;
resultOutBikes &lt;span style="color:#f92672">=&lt;/span> outBikes;
resultInBikes &lt;span style="color:#f92672">=&lt;/span> inBikes;
}
} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">// 递归
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>N; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span>(times[index][i] &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>visited[i]) {
dfs(index, i, end);
}
}
}
&lt;span style="color:#75715e">// 回溯
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited[index] &lt;span style="color:#f92672">=&lt;/span> false;
path.pop_back();
costTimes &lt;span style="color:#f92672">-=&lt;/span> times[start][index];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另有人写的，有点像dfs的非递归形式，也可能算动态规划：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/156003592/codeBookDetail?submissionId=54952529
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;utility&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define INF 0x3f3f3f3f
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Edge&lt;/span>{
&lt;span style="color:#66d9ef">int&lt;/span> from;
&lt;span style="color:#66d9ef">int&lt;/span> to;
&lt;span style="color:#66d9ef">int&lt;/span> cost;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> trace;
Edge(&lt;span style="color:#66d9ef">int&lt;/span> from_, &lt;span style="color:#66d9ef">int&lt;/span> to_, &lt;span style="color:#66d9ef">int&lt;/span> cost_)&lt;span style="color:#f92672">:&lt;/span>
from(from_), to(to_), cost(cost_), trace(){}
};
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Edge&lt;span style="color:#f92672">&amp;amp;&lt;/span> lhs, &lt;span style="color:#66d9ef">const&lt;/span> Edge&lt;span style="color:#f92672">&amp;amp;&lt;/span> rhs){
&lt;span style="color:#66d9ef">return&lt;/span> lhs.cost &lt;span style="color:#f92672">&amp;gt;&lt;/span> rhs.cost;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
&lt;span style="color:#66d9ef">int&lt;/span> C_max, N, sp, M;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> C_max &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> N &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> sp &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> M;
&lt;span style="color:#66d9ef">int&lt;/span> perfect &lt;span style="color:#f92672">=&lt;/span> C_max &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ss(N &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>){
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> ss[i];
}
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>Edge&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> graph(N &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> M; i&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> s1, s2, t;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> s1 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> s2 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> t;
graph[s1].emplace_back(s1, s2, t);
graph[s2].emplace_back(s2, s1, t);
}
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dist(N &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, INF);
priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Edge, deque&lt;span style="color:#f92672">&amp;lt;&lt;/span>Edge&lt;span style="color:#f92672">&amp;gt;&lt;/span>, greater&lt;span style="color:#f92672">&amp;lt;&lt;/span>Edge&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pq;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> paths;
Edge e(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
e.trace.push_back(&lt;span style="color:#ae81ff">0&lt;/span>);
pq.push(e);
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>pq.empty()){
Edge e &lt;span style="color:#f92672">=&lt;/span> pq.top(); pq.pop();
&lt;span style="color:#66d9ef">if&lt;/span>(e.cost &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[sp]) &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(e.cost &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[e.to]) &lt;span style="color:#66d9ef">continue&lt;/span>;
dist[e.to] &lt;span style="color:#f92672">=&lt;/span> e.cost;
&lt;span style="color:#66d9ef">if&lt;/span>(e.to &lt;span style="color:#f92672">==&lt;/span> sp){
paths.push_back(e.trace);
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> ne : graph[e.to]){
&lt;span style="color:#66d9ef">int&lt;/span> ncost &lt;span style="color:#f92672">=&lt;/span> e.cost &lt;span style="color:#f92672">+&lt;/span> ne.cost;
&lt;span style="color:#66d9ef">if&lt;/span>(ncost &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[ne.to]) &lt;span style="color:#66d9ef">continue&lt;/span>;
Edge ee(e.from, ne.to, ncost);
ee.trace &lt;span style="color:#f92672">=&lt;/span> e.trace;
ee.trace.push_back(ne.to);
pq.push(ee);
}
}
pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> opt(INF, INF);
&lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> ans_sent, ans_back;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)paths.size(); i&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> current &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> tot &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> paths[i];
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)path.size(); j&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> d &lt;span style="color:#f92672">=&lt;/span> ss[path[j]] &lt;span style="color:#f92672">-&lt;/span> perfect;
current &lt;span style="color:#f92672">+=&lt;/span> d;
&lt;span style="color:#66d9ef">if&lt;/span>(current &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>){
tot &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>current;
current &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(make_pair(tot, current) &lt;span style="color:#f92672">&amp;lt;&lt;/span> opt){
opt &lt;span style="color:#f92672">=&lt;/span> make_pair(tot, current);
idx &lt;span style="color:#f92672">=&lt;/span> i;
ans_sent &lt;span style="color:#f92672">=&lt;/span> tot;
ans_back &lt;span style="color:#f92672">=&lt;/span> current;
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>, ans_sent);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> v : paths[idx]){
&lt;span style="color:#66d9ef">if&lt;/span>(v &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span>);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, v);
}
printf(&lt;span style="color:#e6db74">&amp;#34; %d&amp;#34;&lt;/span>, ans_back);
puts(&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法3保存各种状态dijkstra算法">方法3：保存各种状态Dijkstra算法&lt;/h6>
&lt;p>&lt;strong>主要的状态&lt;/strong>：&lt;/p>
&lt;p>bikes[]保存各点需要调整的自行车数&lt;/p>
&lt;p>D[]保存从源点到各点的最短距离&lt;/p>
&lt;p>need[]保存各点需要的自行车数&lt;/p>
&lt;p>back[]保存各点需要带回的自行车数&lt;/p>
&lt;p>visited[]保存各点是否已找到最短距离&lt;/p>
&lt;p>trace[]记录到各点最短路径上，该点的前一个节点号&lt;/p>
&lt;p>&lt;strong>过程&lt;/strong>：&lt;/p>
&lt;p>从源点开始，&lt;/p>
&lt;p>根据D、need、back选最合适的点加入到已visited集，并更新未visited点的D、need、back、trace&lt;/p>
&lt;p>重复上一步的步骤，直到点都加入visited集。&lt;/p>
&lt;p>（注意：更新need、back值时要根据路径上前一点累计计算）&lt;/p>
&lt;p>&lt;strong>过程例子&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200518215729206.png" alt="image-20200518215729206">&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200518215701043.png" alt="image-20200518215701043">&lt;/p>
&lt;p>代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.*&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/3/17 17:30
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4324
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 图上起点到终点路径的距离最短，要求子路径距离最短
&lt;/span>&lt;span style="color:#75715e"> * 在各段最短子路径上，要求运去/need的车最少（每段累加）
&lt;/span>&lt;span style="color:#75715e"> * 在各段最短子路径上，运去的车need最少的前提下，要求运回的车最少
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 参考：https://www.nowcoder.com/profile/1011153/codeBookDetail?submissionId=8013527
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1001&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> sp &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//每个顶点上多出的自行车数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bikes &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//代表了边及上面的权值
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Roads roads &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Roads&lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
bikes&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
bikes&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>c &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
roads&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setRoad&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">,&lt;/span> b&lt;span style="color:#f92672">,&lt;/span> v&lt;span style="color:#f92672">);&lt;/span>
roads&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setRoad&lt;/span>&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">,&lt;/span> a&lt;span style="color:#f92672">,&lt;/span> v&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>dijkstra&lt;span style="color:#f92672">(&lt;/span>bikes&lt;span style="color:#f92672">,&lt;/span> c&lt;span style="color:#f92672">,&lt;/span> roads&lt;span style="color:#f92672">,&lt;/span> sp&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * dijkstra单源点最短路径算法，固定源点是顶点0
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">dijkstra&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bikes&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> capacity&lt;span style="color:#f92672">,&lt;/span> Roads roads&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> dest&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> D &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//记录路径上到达每个顶点的前一个顶点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> trace &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> need &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> back &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> visited &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
D&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Const&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">fill&lt;/span>&lt;span style="color:#f92672">(&lt;/span>trace&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">);&lt;/span>
D&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> min &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>min &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//标记已加入最短集
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//更新与之相关的非最短集
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">Entry&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> entry &lt;span style="color:#f92672">:&lt;/span> roads&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getRoadsOfNode&lt;/span>&lt;span style="color:#f92672">(&lt;/span>min&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">entrySet&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//对于边(i,j,v)：顶点i与j存在一条边，距离是v，对应这里roads[i].entry(j,v)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> entry&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getKey&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> entry&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">getValue&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>D&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v &lt;span style="color:#f92672">&amp;lt;&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//找最短路径
&lt;/span>&lt;span style="color:#75715e">&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v&lt;span style="color:#f92672">;&lt;/span>
trace&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> min&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//在此基础上，带来和送回的自行车数目要累加(优化过的结果为：）
&lt;/span>&lt;span style="color:#75715e">&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> bikes&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
need&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
need&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">-=&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>D&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> v &lt;span style="color:#f92672">==&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//先把算出来的值临时用n存起来，和之前的need比较
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> bikes&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>min&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>b &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
n &lt;span style="color:#f92672">-=&lt;/span> b&lt;span style="color:#f92672">;&lt;/span>
b &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">&amp;lt;&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">||&lt;/span> &lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">==&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b &lt;span style="color:#f92672">&amp;lt;&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
trace&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> min&lt;span style="color:#f92672">;&lt;/span>
back&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">;&lt;/span>
need&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//从非最短集中找最短
&lt;/span>&lt;span style="color:#75715e">&lt;/span> min &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> minD &lt;span style="color:#f92672">=&lt;/span> Const&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> minNeed &lt;span style="color:#f92672">=&lt;/span> Const&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> minBack &lt;span style="color:#f92672">=&lt;/span> Const&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> bikes&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> isDisLess &lt;span style="color:#f92672">=&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> minD&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> isNeedLess &lt;span style="color:#f92672">=&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> minD &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> minNeed&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> isBackLess &lt;span style="color:#f92672">=&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> minD &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> minNeed &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> minBack&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>isDisLess &lt;span style="color:#f92672">||&lt;/span> isNeedLess &lt;span style="color:#f92672">||&lt;/span> isBackLess&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
min &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">;&lt;/span>
minD &lt;span style="color:#f92672">=&lt;/span> D&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
minNeed &lt;span style="color:#f92672">=&lt;/span> need&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
minBack &lt;span style="color:#f92672">=&lt;/span> back&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#75715e">//dijkstra完成
&lt;/span>&lt;span style="color:#75715e">&lt;/span> StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>need&lt;span style="color:#f92672">[&lt;/span>dest&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">();&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>dest&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> dest&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(&lt;/span>trace&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>trace&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]);&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> trace&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">()).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 2&lt;span style="color:#f92672">);&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>back&lt;span style="color:#f92672">[&lt;/span>dest&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Roads&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> nodeNum&lt;span style="color:#f92672">;&lt;/span>
HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;[]&lt;/span> roads&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">Roads&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> nodeNum&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nodeNum&lt;/span> &lt;span style="color:#f92672">=&lt;/span> nodeNum&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">roads&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">[&lt;/span>nodeNum&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> nodeNum&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
roads&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>8&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getRoad&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Integer res &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">roads&lt;/span>&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> res &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> Const&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span> &lt;span style="color:#f92672">:&lt;/span> res&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setRoad&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> j&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">roads&lt;/span>&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">roads&lt;/span>&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">,&lt;/span> value&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">getRoadsOfNode&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">roads&lt;/span>&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Const&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> INFTY &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>优化后的过程&lt;/strong>：&lt;/p>
&lt;p>题目要求：
找距离最短（首要），从源点带来的自行车最少（次要），带回去的自行车最少（次次要）的路径。
合并带来最少和带回去最少的要求，则要求cost最小。
（cost为正时表时要带来的数量，为负时绝对值代表要带回去的数量。）
（比如某两条路径距离都最短，第一条路径cost为正，需要带来自行车；第二条路径cost为负，需要带回去自行车，带来的自行车为0，那么选第二条路径）&lt;/p>
&lt;p>则题目变成：
找距离最短（首要），cost最小（次要）的路径。
即多重最短/最小值问题。&lt;/p>
&lt;p>这样的问题，只要在原生的Dijkstra算法中，判断首要最短的语句后，加上次要最小的判断即可。&lt;/p>
&lt;p>&lt;strong>优化后的代码&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;climits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dijkstra&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>cmax, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>map, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>bikeNum, &lt;span style="color:#66d9ef">int&lt;/span> endV) {
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> visited(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, false);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dist(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, INT_MAX);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> cost(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> preV(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
dist[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
visited[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> true;
cost[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> u &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">int&lt;/span> minDist &lt;span style="color:#f92672">=&lt;/span> INT_MAX;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>visited[j] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dist[j] &lt;span style="color:#f92672">&amp;lt;&lt;/span> minDist) {
minDist &lt;span style="color:#f92672">=&lt;/span> dist[j];
u &lt;span style="color:#f92672">=&lt;/span> j;
}
}
visited[u] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>visited[j] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> map[u][j] &lt;span style="color:#f92672">&amp;lt;&lt;/span> INT_MAX) {
&lt;span style="color:#66d9ef">if&lt;/span> (dist[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[u] &lt;span style="color:#f92672">+&lt;/span> map[u][j]) {
dist[j] &lt;span style="color:#f92672">=&lt;/span> dist[u] &lt;span style="color:#f92672">+&lt;/span> map[u][j];
cost[j] &lt;span style="color:#f92672">=&lt;/span> cost[u] &lt;span style="color:#f92672">+&lt;/span> cmax &lt;span style="color:#f92672">-&lt;/span> bikeNum[j];
preV[j] &lt;span style="color:#f92672">=&lt;/span> u;
} &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (dist[j] &lt;span style="color:#f92672">==&lt;/span> dist[u] &lt;span style="color:#f92672">+&lt;/span> map[u][j]) {
&lt;span style="color:#66d9ef">if&lt;/span> (cost[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> cost[u] &lt;span style="color:#f92672">+&lt;/span> cmax &lt;span style="color:#f92672">-&lt;/span> bikeNum[j]) {
cost[j] &lt;span style="color:#f92672">=&lt;/span> cost[u] &lt;span style="color:#f92672">+&lt;/span> cmax &lt;span style="color:#f92672">-&lt;/span> bikeNum[j];
preV[j] &lt;span style="color:#f92672">=&lt;/span> u;
}
}
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> endV;
&lt;span style="color:#66d9ef">int&lt;/span> nums[&lt;span style="color:#ae81ff">501&lt;/span>], size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, minBike &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">if&lt;/span> (preV[p] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (cost[p] &lt;span style="color:#f92672">+&lt;/span> minBike &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
minBike &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>cost[p];
}
nums[size&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> p;
p &lt;span style="color:#f92672">=&lt;/span> preV[p];
}
printf(&lt;span style="color:#e6db74">&amp;#34;%d 0&amp;#34;&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>minBike);
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> size &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>) {
printf(&lt;span style="color:#e6db74">&amp;#34;-&amp;gt;%d&amp;#34;&lt;/span>, nums[i]);
}
&lt;span style="color:#66d9ef">if&lt;/span> (cost[endV] &lt;span style="color:#f92672">+&lt;/span> minBike&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
printf(&lt;span style="color:#e6db74">&amp;#34; 0&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
} &lt;span style="color:#66d9ef">else&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;% d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>minBike&lt;span style="color:#f92672">-&lt;/span>cost[endV]);
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span> argv[]) {
&lt;span style="color:#66d9ef">int&lt;/span> cmax, n, endv, m;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d %d %d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cmax, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>endv, &lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> bikeNum(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
bikeNum[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>bikeNum[i]);
}
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> map(n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> (n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, INT_MAX));
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;span style="color:#66d9ef">int&lt;/span> u, v;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>u, &lt;span style="color:#f92672">&amp;amp;&lt;/span>v);
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>map[u][v]);
map[v][u] &lt;span style="color:#f92672">=&lt;/span> map[u][v];
}
&lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> cmax&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
dijkstra(n, c, map, bikeNum, endv);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="例2-2">例2&lt;/h5>
&lt;h6 id="条条大路通罗马问题">条条大路通罗马问题&lt;/h6>
&lt;p>指定出发城市，去到罗马。
要求路径最短；
次要要求总愉悦值最大（每经过一个城市都会带来一定程度的愉悦感）；
次次要要求平均愉悦值最大（总愉悦值相同时，考虑平均愉悦值，那么要求经过城市越少越好）&lt;/p>
&lt;h6 id="方法1保存各种状态的dijkstra算法">方法1：保存各种状态的Dijkstra算法&lt;/h6>
&lt;p>过程：&lt;/p>
&lt;p>初始化各种状态（各点的累计距离值、累计快乐值、步数值）
从源点开始，挑选累计距离值最小（首要）、累计快乐值最大（次要）、步数值最小（次次要）的点，进行visited
更新没有visited各点的距离值、累计快乐值最、步数值最小
重复上面个两步，直到所有点都visited&lt;/p>
&lt;p>过程例子：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200520233158842.png" alt="image-20200520233158842">&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200520233303611.png" alt="image-20200520233303611">&lt;/p>
&lt;p>编写代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Arrays&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.HashMap&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Stack&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/5/19 17:25
&lt;/span>&lt;span style="color:#75715e"> * @discription: https://www.nowcoder.com/pat/5/problem/4315
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 要求路径最短，累加值最大，平均值最大（或步数最少）
&lt;/span>&lt;span style="color:#75715e"> * 这里用Dijkstra算法，（代码已实现）
&lt;/span>&lt;span style="color:#75715e"> * 还可以使用优先队列优化dijkstra算法中循环找最小的过程（这里的代码没有实现优化）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1002&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
String startName &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
City1002&lt;span style="color:#f92672">[]&lt;/span> citys &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> City1002&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
citys&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> City1002&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">,&lt;/span> startName&lt;span style="color:#f92672">,&lt;/span> 0&lt;span style="color:#f92672">);&lt;/span>
HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> nameIdMap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>8&lt;span style="color:#f92672">);&lt;/span>
nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>startName&lt;span style="color:#f92672">,&lt;/span> 0&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
City1002 city &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> City1002&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">,&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
citys&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> city&lt;span style="color:#f92672">;&lt;/span>
nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>city&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">,&lt;/span> city&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> roads &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">][&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">fill&lt;/span>&lt;span style="color:#f92672">(&lt;/span>roads&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">],&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> k&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
String c1 &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
String c2 &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">next&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> cost &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
roads&lt;span style="color:#f92672">[&lt;/span>nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>c1&lt;span style="color:#f92672">)][&lt;/span>nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>c2&lt;span style="color:#f92672">)]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cost&lt;span style="color:#f92672">;&lt;/span>
roads&lt;span style="color:#f92672">[&lt;/span>nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>c2&lt;span style="color:#f92672">)][&lt;/span>nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>c1&lt;span style="color:#f92672">)]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cost&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>dijkstra2Rom&lt;span style="color:#f92672">(&lt;/span>citys&lt;span style="color:#f92672">,&lt;/span> roads&lt;span style="color:#f92672">,&lt;/span> nameIdMap&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> String &lt;span style="color:#a6e22e">dijkstra2Rom&lt;/span>&lt;span style="color:#f92672">(&lt;/span>City1002&lt;span style="color:#f92672">[]&lt;/span> citys&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> road&lt;span style="color:#f92672">,&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&lt;/span>String&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> nameIdMap&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> cost &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> happiCumu &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> visited &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> trace &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> pass &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> minCostCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">];&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">fill&lt;/span>&lt;span style="color:#f92672">(&lt;/span>cost&lt;span style="color:#f92672">,&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">fill&lt;/span>&lt;span style="color:#f92672">(&lt;/span>trace&lt;span style="color:#f92672">,&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NONE&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">fill&lt;/span>&lt;span style="color:#f92672">(&lt;/span>minCostCount&lt;span style="color:#f92672">,&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
cost&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//没visited的点中按优先级找距离最小、快乐和最大、平均快乐最大的点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> minCost &lt;span style="color:#f92672">=&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> maxHappiCumu &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> minStep &lt;span style="color:#f92672">=&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">INFTY&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NONE&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//首要cost最小，次要happiCumu最大，次次要averHapp最大/步数最少
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> minCost&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
k &lt;span style="color:#f92672">=&lt;/span> j&lt;span style="color:#f92672">;&lt;/span>
minCost &lt;span style="color:#f92672">=&lt;/span> cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
maxHappiCumu &lt;span style="color:#f92672">=&lt;/span> happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
minStep &lt;span style="color:#f92672">=&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> minCost&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxHappiCumu&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
k &lt;span style="color:#f92672">=&lt;/span> j&lt;span style="color:#f92672">;&lt;/span>
maxHappiCumu &lt;span style="color:#f92672">=&lt;/span> happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
minStep &lt;span style="color:#f92672">=&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> maxHappiCumu&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> minStep&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
k &lt;span style="color:#f92672">=&lt;/span> j&lt;span style="color:#f92672">;&lt;/span>
minStep &lt;span style="color:#f92672">=&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>k &lt;span style="color:#f92672">==&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NONE&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">break&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//访问该点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//更新未访问点的各种状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> citys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> costThroughK &lt;span style="color:#f92672">=&lt;/span> cost&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> road&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> happiThroughK &lt;span style="color:#f92672">=&lt;/span> happiCumu&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> citys&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">happiness&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> stepThoughK &lt;span style="color:#f92672">=&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> changeRoute &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>costThroughK &lt;span style="color:#f92672">&amp;lt;&lt;/span> cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
changeRoute &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
minCostCount&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> minCostCount&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>costThroughK &lt;span style="color:#f92672">==&lt;/span> cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
minCostCount&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> minCostCount&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> happiMore &lt;span style="color:#f92672">=&lt;/span> happiThroughK &lt;span style="color:#f92672">&amp;gt;&lt;/span> happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span> stepLess &lt;span style="color:#f92672">=&lt;/span> happiThroughK &lt;span style="color:#f92672">==&lt;/span> happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> stepThoughK &lt;span style="color:#f92672">&amp;lt;&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>happiMore &lt;span style="color:#f92672">||&lt;/span> stepLess&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
changeRoute &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>changeRoute&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
trace&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> k&lt;span style="color:#f92672">;&lt;/span>
cost&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> costThroughK&lt;span style="color:#f92672">;&lt;/span>
happiCumu&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> happiThroughK&lt;span style="color:#f92672">;&lt;/span>
pass&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> stepThoughK&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> romId &lt;span style="color:#f92672">=&lt;/span> nameIdMap&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;ROM&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>minCostCount&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>cost&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>happiCumu&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>happiCumu&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">/&lt;/span> pass&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>romId &lt;span style="color:#f92672">!=&lt;/span> Const1002&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">NONE&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>romId&lt;span style="color:#f92672">);&lt;/span>
romId &lt;span style="color:#f92672">=&lt;/span> trace&lt;span style="color:#f92672">[&lt;/span>romId&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>citys&lt;span style="color:#f92672">[&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">()].&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 2&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">City1002&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
String name&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> happiness&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#a6e22e">City1002&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> id&lt;span style="color:#f92672">,&lt;/span> String name&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> happiness&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#f92672">=&lt;/span> id&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#f92672">=&lt;/span> name&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">happiness&lt;/span> &lt;span style="color:#f92672">=&lt;/span> happiness&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Const1002&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> INFTY &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">MAX_VALUE&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> NONE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法2dijkstra找最短多条最短dfs找最优">方法2：Dijkstra找最短，多条最短dfs找最优&lt;/h6>
&lt;p>Dijkstra找最短路径，如果最短路径有多条，存入队列/数组中待用；
然后用dfs遍历各条最短路径，计算每条路径的愉悦值和步数，从中选最优路径&lt;/p>
&lt;p>此方法的两个实现：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//转自牛客网牛友提交的代码：
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/5832296/codeBookDetail?submissionId=10915168
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;set&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;map&amp;gt; &lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define INF 9999999
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">city&lt;/span>{
city(string _n, &lt;span style="color:#66d9ef">int&lt;/span> _h){name&lt;span style="color:#f92672">=&lt;/span>_n; happy&lt;span style="color:#f92672">=&lt;/span>_h;}
string name;
&lt;span style="color:#66d9ef">int&lt;/span> happy;
};
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>city&lt;span style="color:#f92672">&amp;gt;&lt;/span> cities;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> cost;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> allPath;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> bestPath;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> possiblePath;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> visited;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dist; &lt;span style="color:#75715e">//记录起点到各个点的距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span>map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> name2id;
&lt;span style="color:#66d9ef">int&lt;/span> cityNum, roadNum;
&lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dijkstra&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> s){
&lt;span style="color:#66d9ef">int&lt;/span> i;
dist[s] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span>(true){
&lt;span style="color:#66d9ef">int&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; u&lt;span style="color:#f92672">&amp;lt;&lt;/span>cityNum; u&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>visited[u]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>(v&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">||&lt;/span>dist[u]&lt;span style="color:#f92672">&amp;lt;&lt;/span>dist[v])) v&lt;span style="color:#f92672">=&lt;/span>u;
}
&lt;span style="color:#66d9ef">if&lt;/span>(v&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">break&lt;/span>;
visited[v]&lt;span style="color:#f92672">=&lt;/span>true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> u&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; u&lt;span style="color:#f92672">&amp;lt;&lt;/span>cityNum; u&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(dist[u] &lt;span style="color:#f92672">&amp;gt;&lt;/span> dist[v] &lt;span style="color:#f92672">+&lt;/span> cost[v][u]){
dist[u] &lt;span style="color:#f92672">=&lt;/span> dist[v] &lt;span style="color:#f92672">+&lt;/span> cost[v][u];
allPath[u].clear();
allPath[u].push_back(v);
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(dist[u]&lt;span style="color:#f92672">==&lt;/span>dist[v]&lt;span style="color:#f92672">+&lt;/span>cost[v][u]){
allPath[u].push_back(v);
}
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> maxHappy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">double&lt;/span> maxAve &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> pathNum &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">//最短路的条数
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">findBestPath&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> t){
possiblePath.push_back(t);
&lt;span style="color:#66d9ef">if&lt;/span>(t&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>){
pathNum&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> happy &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>possiblePath.size(); i&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> index &lt;span style="color:#f92672">=&lt;/span> possiblePath[i];
happy &lt;span style="color:#f92672">+=&lt;/span> cities[index].happy;
}
&lt;span style="color:#66d9ef">if&lt;/span>(happy &lt;span style="color:#f92672">&amp;gt;&lt;/span> maxHappy){
bestPath &lt;span style="color:#f92672">=&lt;/span> possiblePath;
maxHappy &lt;span style="color:#f92672">=&lt;/span> happy;
maxAve &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">double&lt;/span>)happy&lt;span style="color:#f92672">/&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)(possiblePath.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
}&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(happy&lt;span style="color:#f92672">==&lt;/span>maxHappy){
&lt;span style="color:#66d9ef">double&lt;/span> aveNow &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">double&lt;/span>)happy&lt;span style="color:#f92672">/&lt;/span>(&lt;span style="color:#66d9ef">double&lt;/span>)(possiblePath.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span>(aveNow&lt;span style="color:#f92672">&amp;gt;&lt;/span>maxAve){
bestPath &lt;span style="color:#f92672">=&lt;/span> possiblePath;
maxAve &lt;span style="color:#f92672">=&lt;/span> aveNow;
}
}
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>allPath[t].size(); i&lt;span style="color:#f92672">++&lt;/span>){
findBestPath(allPath[t][i]);
possiblePath.pop_back();
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> argc, &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">**&lt;/span> argv) {
&lt;span style="color:#66d9ef">int&lt;/span> c, i, j, happy;
string start, from, to, str;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>cityNum, &lt;span style="color:#f92672">&amp;amp;&lt;/span>roadNum);
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>start;
cities.push_back(city(start,&lt;span style="color:#ae81ff">0&lt;/span>));
name2id[start] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//起点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>cityNum; i&lt;span style="color:#f92672">++&lt;/span>){
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>str&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>happy;
name2id[str] &lt;span style="color:#f92672">=&lt;/span> i;
cities.push_back(city(str,happy));
}
cost.resize(cityNum, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(cityNum,INF));
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>roadNum; i&lt;span style="color:#f92672">++&lt;/span>){
cin&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>from&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>to&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>c;
&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> name2id[from];
&lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> name2id[to];
cost[a][b] &lt;span style="color:#f92672">=&lt;/span> cost[b][a] &lt;span style="color:#f92672">=&lt;/span> c;
}
dist.resize(cityNum,INF);
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;&lt;/span>cityNum; i&lt;span style="color:#f92672">++&lt;/span>)
dist[i] &lt;span style="color:#f92672">=&lt;/span> cost[&lt;span style="color:#ae81ff">0&lt;/span>][i];
&lt;span style="color:#66d9ef">int&lt;/span> s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//起点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> name2id[&lt;span style="color:#e6db74">&amp;#34;ROM&amp;#34;&lt;/span>];&lt;span style="color:#75715e">//终点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited.resize(cityNum,false);
allPath.resize(cityNum);
dijkstra(s);&lt;span style="color:#75715e">//查找从起点出发的所有最短路
&lt;/span>&lt;span style="color:#75715e">&lt;/span> findBestPath(t);&lt;span style="color:#75715e">//找到最短路中的最优解
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> minCost&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>bestPath.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>){
&lt;span style="color:#66d9ef">int&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> bestPath[i];
&lt;span style="color:#66d9ef">int&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> bestPath[i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>];
minCost &lt;span style="color:#f92672">+=&lt;/span> cost[a][b];
}
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>pathNum&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>minCost&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>maxHappy&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>)maxAve&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>endl;
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>bestPath.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>){
string name &lt;span style="color:#f92672">=&lt;/span> cities[bestPath[i]].name;
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>name&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span>;
&lt;span style="color:#66d9ef">else&lt;/span>
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>name&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>endl;
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一个相似实现&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//转自牛客网牛友提交的代码
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/7316467/codeBookDetail?submissionId=9006304
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#define INF 0x3f3f3f3f
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">City&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> Position, Happy;
};
City &lt;span style="color:#a6e22e">cst_cty&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> happy, &lt;span style="color:#66d9ef">int&lt;/span> position) {
City new_city;
new_city.Happy &lt;span style="color:#f92672">=&lt;/span> happy;
new_city.Position &lt;span style="color:#f92672">=&lt;/span> position;
&lt;span style="color:#66d9ef">return&lt;/span> new_city;
}
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> cur, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> vis, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;amp;&lt;/span> pre, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> path, &lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> max_avg, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> max_happiness,&lt;span style="color:#66d9ef">int&lt;/span> end,&lt;span style="color:#66d9ef">int&lt;/span> temp_hap, map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, string&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> pos_name, map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, City&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> name_info, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> temp_path) {
vis[cur] &lt;span style="color:#f92672">=&lt;/span> true;
temp_path.push_back(cur);
&lt;span style="color:#75715e">//temp_hap += name_info[pos_name[cur]].Happy;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cur&lt;span style="color:#f92672">==&lt;/span>end)
{
&lt;span style="color:#66d9ef">int&lt;/span> temp_hap &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(temp_path.size()); i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> temp_path[i];
temp_hap &lt;span style="color:#f92672">+=&lt;/span> name_info[pos_name[cur]].Happy;
}
&lt;span style="color:#66d9ef">double&lt;/span> temp_avg &lt;span style="color:#f92672">=&lt;/span> temp_hap&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#ae81ff">1.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> (temp_path.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">if&lt;/span> (temp_hap&lt;span style="color:#f92672">&amp;gt;&lt;/span>max_happiness)
{
max_happiness &lt;span style="color:#f92672">=&lt;/span> temp_hap;
path &lt;span style="color:#f92672">=&lt;/span> temp_path;
max_avg &lt;span style="color:#f92672">=&lt;/span> temp_avg;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (temp_hap&lt;span style="color:#f92672">==&lt;/span>max_happiness&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>temp_avg&lt;span style="color:#f92672">&amp;gt;&lt;/span>max_avg)
{
max_avg &lt;span style="color:#f92672">=&lt;/span> temp_avg;
path &lt;span style="color:#f92672">=&lt;/span> temp_path;
}
}
&lt;span style="color:#66d9ef">for&lt;/span> (vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>iterator it &lt;span style="color:#f92672">=&lt;/span> pre[cur].begin(); it &lt;span style="color:#f92672">!=&lt;/span> pre[cur].end(); it&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#75715e">//if (vis[*it]==false)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//{
&lt;/span>&lt;span style="color:#75715e">&lt;/span> dfs(&lt;span style="color:#f92672">*&lt;/span>it, vis, pre, path, max_avg, max_happiness, end, temp_hap, pos_name, name_info, temp_path);
&lt;span style="color:#75715e">//}
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#75715e">//temp_hap -= name_info[pos_name[cur]].Happy;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> temp_path.pop_back();
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#66d9ef">int&lt;/span> N, K;
string start;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> N &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> K &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> start;
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, City&lt;span style="color:#f92672">&amp;gt;&lt;/span> name_info;
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, string&lt;span style="color:#f92672">&amp;gt;&lt;/span> pos_name;
name_info[start] &lt;span style="color:#f92672">=&lt;/span> cst_cty(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
pos_name[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> start;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> temp_happy;
string temp_name;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> temp_name &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> temp_happy;
name_info[temp_name] &lt;span style="color:#f92672">=&lt;/span> cst_cty(temp_happy, i);
pos_name[i] &lt;span style="color:#f92672">=&lt;/span> temp_name;
}
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> mat(N, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(N, &lt;span style="color:#ae81ff">0&lt;/span>));
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> K; i&lt;span style="color:#f92672">++&lt;/span>)
{
string name_a, name_b;
&lt;span style="color:#66d9ef">int&lt;/span> cost;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> name_a &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> name_b &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> cost;
mat[name_info[name_a].Position][name_info[name_b].Position] &lt;span style="color:#f92672">=&lt;/span> mat[name_info[name_b].Position][name_info[name_a].Position] &lt;span style="color:#f92672">=&lt;/span> cost;
}
&lt;span style="color:#75715e">//初始化
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//djk
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> pre(N, vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>());&lt;span style="color:#75715e">//记录最短路径的自终点开始的前驱节点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> dis(N, INF);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> vis(N, false);
&lt;span style="color:#66d9ef">int&lt;/span> start_cty &lt;span style="color:#f92672">=&lt;/span> name_info[start].Position, end_cty &lt;span style="color:#f92672">=&lt;/span> name_info[&lt;span style="color:#e6db74">&amp;#34;ROM&amp;#34;&lt;/span>].Position;
dis[start_cty] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//dis[i]记录起始点到i点的最短距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> path_cnt(N, &lt;span style="color:#ae81ff">0&lt;/span>);
path_cnt[start_cty] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (true)
{
&lt;span style="color:#66d9ef">int&lt;/span> cur_node &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, min_dis &lt;span style="color:#f92672">=&lt;/span> INF;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (vis[i]&lt;span style="color:#f92672">==&lt;/span>false&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>dis[i]&lt;span style="color:#f92672">&amp;lt;&lt;/span>min_dis)
{
min_dis &lt;span style="color:#f92672">=&lt;/span> dis[i];
cur_node &lt;span style="color:#f92672">=&lt;/span> i;
}
}&lt;span style="color:#75715e">//找到当前情况下既没有访问过同时又离起始节点距离最小的节点
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//if (min_dis == INF || cur_node == end_cty)
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (cur_node&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
{
&lt;span style="color:#66d9ef">break&lt;/span>;
}
&lt;span style="color:#75715e">//min_dis为无穷表示找不到最小的边
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
vis[cur_node] &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> N; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (vis[i]&lt;span style="color:#f92672">==&lt;/span>false&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>mat[cur_node][i]&lt;span style="color:#f92672">&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)&lt;span style="color:#75715e">//考察离起始点最近的节点相连的节点是否需要更新
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
&lt;span style="color:#66d9ef">if&lt;/span> (dis[i]&lt;span style="color:#f92672">&amp;gt;&lt;/span>dis[cur_node]&lt;span style="color:#f92672">+&lt;/span>mat[cur_node][i])
{
dis[i] &lt;span style="color:#f92672">=&lt;/span> dis[cur_node] &lt;span style="color:#f92672">+&lt;/span> mat[cur_node][i];
pre[i].clear();
pre[i].push_back(cur_node);
path_cnt[i] &lt;span style="color:#f92672">=&lt;/span> path_cnt[cur_node];
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (dis[i]&lt;span style="color:#f92672">==&lt;/span>dis[cur_node]&lt;span style="color:#f92672">+&lt;/span>mat[cur_node][i])&lt;span style="color:#75715e">//不能写成if，否则前面修改了dis[i]之后，后面必然是相等的，这样，两个if语句都会执行
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
pre[i].push_back(cur_node);
path_cnt[i] &lt;span style="color:#f92672">+=&lt;/span> path_cnt[cur_node];
}
}
}
}
&lt;span style="color:#75715e">//pre记录前驱节点，然后使用dfs从终点逆序遍历
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//dfs部分
&lt;/span>&lt;span style="color:#75715e">&lt;/span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> temp_path, path;
&lt;span style="color:#66d9ef">int&lt;/span> max_happiness &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">double&lt;/span> max_avg &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span>;
dfs(end_cty, vis, pre, path, max_avg, max_happiness, start_cty, &lt;span style="color:#ae81ff">0&lt;/span>, pos_name, name_info, temp_path);
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> path_cnt[end_cty] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> dis[end_cty] &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> max_happiness &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(max_avg) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pos_name[start_cty];
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>(path.size()&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>); i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>)
{
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pos_name[path[i]];
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法3dfs加剪枝">方法3：DFS加剪枝&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//链接：https://www.nowcoder.com/questionTerminal/bf8045decb1348a3bd6967305cbdad4c
&lt;/span>&lt;span style="color:#75715e">//来源：牛客网——牛客156003592号的讨论代码
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;queue&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;utility&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;map&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;span style="color:#75715e">#define INF 0x3f3f3f3f
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>string, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> to_id;
map&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, string&lt;span style="color:#f92672">&amp;gt;&lt;/span> to_name;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> hps(&lt;span style="color:#ae81ff">200&lt;/span>);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>pair&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> graph(&lt;span style="color:#ae81ff">200&lt;/span>);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">bool&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> visited(&lt;span style="color:#ae81ff">200&lt;/span>);
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> path;
vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ans;
&lt;span style="color:#66d9ef">int&lt;/span> min_cost &lt;span style="color:#f92672">=&lt;/span> INF;
&lt;span style="color:#66d9ef">int&lt;/span> max_hp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>INF;
&lt;span style="color:#66d9ef">int&lt;/span> avg_hp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>INF;
&lt;span style="color:#66d9ef">int&lt;/span> diff_cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> curr, &lt;span style="color:#66d9ef">int&lt;/span> cost, &lt;span style="color:#66d9ef">int&lt;/span> hp){
visited[curr] &lt;span style="color:#f92672">=&lt;/span> true;
path.push_back(curr);
&lt;span style="color:#66d9ef">if&lt;/span>(curr &lt;span style="color:#f92672">==&lt;/span> to_id[string(&lt;span style="color:#e6db74">&amp;#34;ROM&amp;#34;&lt;/span>)]){
&lt;span style="color:#66d9ef">if&lt;/span>(cost &lt;span style="color:#f92672">&amp;lt;&lt;/span> min_cost){
min_cost &lt;span style="color:#f92672">=&lt;/span> cost;
max_hp &lt;span style="color:#f92672">=&lt;/span> hp;
avg_hp &lt;span style="color:#f92672">=&lt;/span> hp &lt;span style="color:#f92672">/&lt;/span> (path.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
diff_cnt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
ans &lt;span style="color:#f92672">=&lt;/span> path;
}
&lt;span style="color:#66d9ef">else&lt;/span>{
diff_cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(hp &lt;span style="color:#f92672">&amp;gt;&lt;/span> max_hp){
max_hp &lt;span style="color:#f92672">=&lt;/span> hp;
avg_hp &lt;span style="color:#f92672">=&lt;/span> hp &lt;span style="color:#f92672">/&lt;/span> (path.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
ans &lt;span style="color:#f92672">=&lt;/span> path;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(hp &lt;span style="color:#f92672">==&lt;/span> max_hp){
&lt;span style="color:#66d9ef">if&lt;/span>((&lt;span style="color:#66d9ef">int&lt;/span>) (hp &lt;span style="color:#f92672">/&lt;/span> (path.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)) &lt;span style="color:#f92672">&amp;gt;&lt;/span> avg_hp){
avg_hp &lt;span style="color:#f92672">=&lt;/span> hp &lt;span style="color:#f92672">/&lt;/span> (path.size() &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
ans &lt;span style="color:#f92672">=&lt;/span> path;
}
}
}
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> p : graph[curr]){
&lt;span style="color:#66d9ef">int&lt;/span> to &lt;span style="color:#f92672">=&lt;/span> p.first;
&lt;span style="color:#66d9ef">int&lt;/span> c &lt;span style="color:#f92672">=&lt;/span> p.second;
&lt;span style="color:#66d9ef">if&lt;/span>(visited[to]) &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span>(cost &lt;span style="color:#f92672">+&lt;/span> c &lt;span style="color:#f92672">&amp;gt;&lt;/span> min_cost) &lt;span style="color:#66d9ef">continue&lt;/span>;
dfs(to, cost &lt;span style="color:#f92672">+&lt;/span> c, hp &lt;span style="color:#f92672">+&lt;/span> hps[to]);
}
visited[curr] &lt;span style="color:#f92672">=&lt;/span> false;
path.pop_back();
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(){
ios&lt;span style="color:#f92672">::&lt;/span>sync_with_stdio(false);
&lt;span style="color:#66d9ef">int&lt;/span> N, K;
string start;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> N &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> K &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> start;
to_id[start] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
to_name[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> start;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> N &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>){
string city;
&lt;span style="color:#66d9ef">int&lt;/span> hp;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> city &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> hp;
to_id[city] &lt;span style="color:#f92672">=&lt;/span> i;
to_name[i] &lt;span style="color:#f92672">=&lt;/span> city;
hps[i] &lt;span style="color:#f92672">=&lt;/span> hp;
}
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> K; i&lt;span style="color:#f92672">++&lt;/span>){
string city1, city2;
&lt;span style="color:#66d9ef">int&lt;/span> from, to, cost;
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> city1 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> city2 &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> cost;
from &lt;span style="color:#f92672">=&lt;/span> to_id[city1];
to &lt;span style="color:#f92672">=&lt;/span> to_id[city2];
graph[from].emplace_back(to, cost);
graph[to].emplace_back(from, cost);
}
dfs(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">0&lt;/span>);
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> diff_cnt &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> min_cost &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>;
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> max_hp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> avg_hp &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>)ans.size(); i&lt;span style="color:#f92672">++&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(i) cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;-&amp;gt;&amp;#34;&lt;/span>;
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> to_name[ans[i]];
}
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> endl;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>总感觉这位牛友diff_cnt++;这句代码应该加个判断是不是cost相等。但是人家的代码通过了，amazing。&lt;/p>
&lt;h2 id="排序问题">排序问题&lt;/h2>
&lt;h5 id="例1-4">例1&lt;/h5>
&lt;h6 id="插入还是堆排序">插入还是堆排序&lt;/h6>
&lt;p>给原始序列、排序排到一半的序列。问排序方法是插入排序还是堆排序。然后要求给出下一步的排序结果&lt;/p>
&lt;p>两种排序的区别：
插入排序前面部分是排好的，后面的部分没有改变（稳定的排序）
堆排序后面部分是排好的，前面部分也发生了改变（不稳定）
可根据以上两种排序的特点确定是堆排序还是插入排序。&lt;/p>
&lt;p>注意插入排序和堆排序的排序过程，继续排一步&lt;/p>
&lt;h6 id="题解">题解&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/1 10:25
&lt;/span>&lt;span style="color:#75715e"> * @discription: https://www.nowcoder.com/pat/5/problem/4322
&lt;/span>&lt;span style="color:#75715e"> * 插入排序、堆排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1009&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//如果是插入排序，返回的是一个大于0的数（已排序个数）
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> insertionSortLength &lt;span style="color:#f92672">=&lt;/span> insertionSortLength&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">,&lt;/span> b&lt;span style="color:#f92672">);&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>insertionSortLength &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Insertion Sort&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Heap Sort&amp;#34;&lt;/span>&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;\n&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>insertionSortLength &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//如果是插入排序，继续排一步
&lt;/span>&lt;span style="color:#75715e">&lt;/span> nextInsertionSort&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">,&lt;/span> insertionSortLength&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//如果是堆排序，确定排到哪个位置了（pos是堆尾）
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pos &lt;span style="color:#f92672">=&lt;/span> heapSortNextPos&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">,&lt;/span> b&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>pos &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//继续排一步
&lt;/span>&lt;span style="color:#75715e">&lt;/span> nextHeapSort&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">,&lt;/span> pos&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">);&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">insertionSortLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;lt;&lt;/span> b&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
i&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">&amp;lt;&lt;/span> b&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
j&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">!=&lt;/span> b&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> i&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">heapSortNextPos&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
i&lt;span style="color:#f92672">--;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> max &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> i&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> max&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
max &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>max &lt;span style="color:#f92672">&amp;gt;&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
i&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> i&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">nextInsertionSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> pos &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> tmp&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
b&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
i&lt;span style="color:#f92672">--;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
b&lt;span style="color:#f92672">[++&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">nextHeapSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//交换堆顶和堆尾，堆size--，从堆顶向下调整
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">];&lt;/span>
b&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">];&lt;/span>
b&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
adjust&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">,&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> pos&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 堆排序的整体过程（这里只是方便参考，本题中没有用到）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#75715e">/* private static void heapSort(int[] a) {
&lt;/span>&lt;span style="color:#75715e"> //初始化堆:从第一个非叶子节点开始向前，每一个节点和其子节点进行递归调整
&lt;/span>&lt;span style="color:#75715e"> int size = a.length;
&lt;/span>&lt;span style="color:#75715e"> for (int i = (a.length - 1) / 2; i &amp;gt;= 0; i--) {
&lt;/span>&lt;span style="color:#75715e"> adjust(a, i, size);
&lt;/span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;span style="color:#75715e"> //交换堆顶和堆尾，堆大小-1，从堆顶向下调整；重复直到堆变为空
&lt;/span>&lt;span style="color:#75715e"> while (size &amp;gt; 0) {
&lt;/span>&lt;span style="color:#75715e"> //交换
&lt;/span>&lt;span style="color:#75715e"> int tmp = a[size - 1];
&lt;/span>&lt;span style="color:#75715e"> a[size - 1] = a[0];
&lt;/span>&lt;span style="color:#75715e"> a[0] = tmp;
&lt;/span>&lt;span style="color:#75715e"> //堆size--,从堆顶向下调整
&lt;/span>&lt;span style="color:#75715e"> adjust(a, 0, --size);
&lt;/span>&lt;span style="color:#75715e"> }
&lt;/span>&lt;span style="color:#75715e"> }*/&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 递归调整当前节点与其子节点
&lt;/span>&lt;span style="color:#75715e"> * 可以优化为非递归形式（未实现）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">adjust&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> heap&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> heapSize&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> left &lt;span style="color:#f92672">=&lt;/span> pos &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> right &lt;span style="color:#f92672">=&lt;/span> pos &lt;span style="color:#f92672">*&lt;/span> 2 &lt;span style="color:#f92672">+&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//找节点与其子节点中最大值的节点下标
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> max &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>left &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>left&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">?&lt;/span> left &lt;span style="color:#f92672">:&lt;/span> pos&lt;span style="color:#f92672">;&lt;/span>
max &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>right &lt;span style="color:#f92672">&amp;lt;&lt;/span> heapSize &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>right&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>max&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">?&lt;/span> right &lt;span style="color:#f92672">:&lt;/span> max&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>max &lt;span style="color:#f92672">!=&lt;/span> pos&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//调整/交换
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">];&lt;/span>
heap&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> heap&lt;span style="color:#f92672">[&lt;/span>max&lt;span style="color:#f92672">];&lt;/span>
heap&lt;span style="color:#f92672">[&lt;/span>max&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//递归调整子节点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> adjust&lt;span style="color:#f92672">(&lt;/span>heap&lt;span style="color:#f92672">,&lt;/span> max&lt;span style="color:#f92672">,&lt;/span> heapSize&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="动态规划">动态规划&lt;/h2>
&lt;p>动态规划思想可以用来解决最优化问题。&lt;/p>
&lt;p>最优化问题的形式
max/min 目标函数F()
st. 限制条件（等式、不等式、变量范围限制）&lt;/p>
&lt;h3 id="最长不下降子序列">最长不下降子序列&lt;/h3>
&lt;p>最长子序列长度问题的介绍，在算法总结.md#动态规划&lt;/p>
&lt;h4 id="例1-最长的可接受花色条纹子序列">例1 最长的可接受花色条纹子序列&lt;/h4>
&lt;p>给一个序列，表示可接受的花色序列。再给一个序列，表示已有的花色序列。要从已有的花色序列中裁取可接受的花色序列（每种可接受的花色可保留多份）。&lt;/p>
&lt;pre>&lt;code>比如已有的花色序列是 {2 2 4 1 5 5 6 3 1 1 5 6}. 可接受的花色序列是{2 3 1 5 6},
那么有如下的裁取方式{2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, 和 {2 2 3 1 1 5 6}.
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4084">题目链接&lt;/a>&lt;/p>
&lt;h5 id="方法1-映射法-转换为最长不下降子序列长度问题">方法1 映射法 转换为最长不下降子序列长度问题&lt;/h5>
&lt;p>参考：https://www.nowcoder.com/questionTerminal/0171de2cf94a43d690c336a363a41693&lt;/p>
&lt;p>建立映射表 (2,1) (3,2) (1,3) (5,4) (6,5)&lt;/p>
&lt;p>初始条带&lt;/p>
&lt;p>2 2 4 1 5 5 6 3 1 1 5 6
将条带中不存在的颜色去掉
2 2 1 5 5 6 3 1 1 5 6
根据映射表，对条带进行映射:
1 1 3 4 4 5 2 3 3 4 5
&lt;strong>问题转换为求最长不下降子序列&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.HashMap&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Map&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/20 23:19
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4084
&lt;/span>&lt;span style="color:#75715e"> * 将eva喜欢的颜色按顺序编号（赋权），建立映射关系（颜色-编号）。
&lt;/span>&lt;span style="color:#75715e"> * 将条带中不符合eva喜好的颜色去掉。根据映射关系生成剩余条带的编号序列。
&lt;/span>&lt;span style="color:#75715e"> * 则原题目变成：求剩余条带编号的最长不下降子序列长度。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1034&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">,&lt;/span> Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> map &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> HashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>20&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">put&lt;/span>&lt;span style="color:#f92672">(&lt;/span>scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>l&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> l&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Integer tmp &lt;span style="color:#f92672">=&lt;/span> map&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>tmp &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a&lt;span style="color:#f92672">[&lt;/span>count&lt;span style="color:#f92672">++]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//dp[i]表示以a[i]结尾的最长不下降子序列长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>count&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//边界条件：dp[i] = 1;
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//状态转移方程： dp[i] = max(dp[j]+1,dp[i]) , j = 0,1,,i-1, 当[j] &amp;lt;= a[i],
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// dp[i] = dp[i], 当所有a[j]都 &amp;gt; a[i]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> count&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> max &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> count&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> i&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
max &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> max &lt;span style="color:#f92672">?&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">:&lt;/span> max&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>max&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="方法2-其他动态规划法">方法2 其他动态规划法&lt;/h5>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/20 23:19
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4084
&lt;/span>&lt;span style="color:#75715e"> * 动态规划思想
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1034_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> l &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>l &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> l&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
b&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//dp[i][j]表示，加入第i种颜色后，前j个颜色序列组成的最大非逆子序列长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>l &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> l&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> Math&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">max&lt;/span>&lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">],&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> b&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>m&lt;span style="color:#f92672">][&lt;/span>l&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="背包问题">背包问题&lt;/h3>
&lt;p>如果背包问题还不太了解，可以参考：算法笔记——胡凡曾磊 （P444 提高篇（5）动态规划专题）
背包问题进阶：&lt;a href="https://www.cnblogs.com/jbelial/articles/2116074.html">背包九讲&lt;/a>&lt;/p>
&lt;h4 id="01背包问题">01背包问题&lt;/h4>
&lt;p>01背包问题是这样的：有n件物品，每件物品的重量w[i],价值c[i]。现有一个背包，容量为V，问如何选择物品装入背包，使装入背包物品的总价值最大？&lt;/p>
&lt;h5 id="例1-用零钱凑一定的金额">例1 用零钱凑一定的金额&lt;/h5>
&lt;p>给n张零钱，面值分别为v[i]，问如何选择零钱，凑成给定的金额V。如果有多种方法，使用面值尽量小的，张数多的方法。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4119">原题链接&lt;/a>&lt;/p>
&lt;p>这道题目属于：背包问题-01背包问题-01满背包问题&lt;/p>
&lt;p>从最优化问题的角度考虑，&lt;/p>
&lt;p>可以看作是如下的最优化问题（方法1）：&lt;/p>
&lt;p>&lt;strong>限制条件&lt;/strong>：
变量i 属于[1,n],
面值v[i] 属于{v[1]:v[n]}
选择的面值之和必须&lt;strong>恰好为&lt;/strong>给定的金额V
&lt;strong>目标函数&lt;/strong>：
使用的零钱张数（最多）&lt;/p>
&lt;p>也可以看作是如下的最优化问题（方法2）：&lt;/p>
&lt;p>&lt;strong>限制条件&lt;/strong>：
变量i 属于[1,n],
面值v[i] 属于{v[1]:v[n]}
选择的零钱总额&lt;strong>小于等于&lt;/strong>给定的金额V
&lt;strong>目标函数&lt;/strong>：
使用的零钱总额（最大）&lt;/p>
&lt;h5 id="方法1-凑给定金额v使用的零钱张数最大">方法1 凑给定金额V，使用的零钱张数最大&lt;/h5>
&lt;p>假设第i张零钱的面值是$v[i]$ 。用$dp[i][v]$表示从前i张零钱中，凑成金额v时的零钱张数。&lt;/p>
&lt;h6 id="考虑是否选择第i张零钱凑成金额v使用的零钱张数最大">考虑是否选择第i张零钱（凑成金额v，使用的零钱张数最大）&lt;/h6>
&lt;p>如果&lt;strong>选择使用&lt;/strong>第i张零钱凑成金额v，使用的零钱张数$dp[i][v]$由前$i-1$张零钱使用的张数决定，即$dp[i][v] = dp[i-1][v-v[i]]+1$
如果&lt;strong>选择不使用&lt;/strong>第i张零钱凑成金额v，使用的零钱张数$dp[i][v]$也由前$i-1$张零钱使用的张数决定，即$dp[i][v] = dp[i-1][v]$
最终&lt;strong>是否使用&lt;/strong>第i张零钱凑成金额v，选以上两种方式中，使用零钱张数较多的一种，即$dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])$&lt;/p>
&lt;h6 id="关于初始化">关于初始化&lt;/h6>
&lt;p>$dp[1:n][1:n]$全都初始化为了-inf （也可以是其他特定的数值）,表示不能从这些位置开始转移。$dp[1:n][0]$全部初始化为0，是状态转移方程的边界（起始位置）&lt;/p>
&lt;p>最终$dp[n][V]$表示恰好凑成金额V所使用的零钱张数&lt;/p>
&lt;h6 id="java代码">java代码&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.ArrayList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Arrays&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/13 18:21
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4119
&lt;/span>&lt;span style="color:#75715e"> * 最优化问题：动态规划问题：选硬币问题，满背包问题
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 最优化问题描述
&lt;/span>&lt;span style="color:#75715e"> * 目标函数：使用零钱张数最多
&lt;/span>&lt;span style="color:#75715e"> * 限制条件：使用的面值之和为V
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 动态规划将最优化问题分解为多个子问题，通过综合子问题的最优解来得到原问题的最优解。且动态规划会将子问题的解保存下来，避免重复计算
&lt;/span>&lt;span style="color:#75715e"> * 动态规划问题的状态转移方程：
&lt;/span>&lt;span style="color:#75715e"> * dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])
&lt;/span>&lt;span style="color:#75715e"> * 使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp[i][v]都和前i-1张零钱的使用状况有关。是否使用第i张，取决于哪种情况使用的零钱张数多。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1026&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> coins &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//排序，逆序
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>coins&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++,&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//背包数组，记录存入背包的硬币个数；路径记录数组
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//默认初始化dp[1:n][0]为0，dp[1:n][1:m]设为-1表示不能从这些位置开始转移。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">].&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//恰好装满的判断:保证不是从-1转移过来的
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">((&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
flag&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>n&lt;span style="color:#f92672">][&lt;/span>m&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>flag&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]);&lt;/span>
j &lt;span style="color:#f92672">-=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
i&lt;span style="color:#f92672">--;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Integer e &lt;span style="color:#f92672">:&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>e&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;No Solution&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="java代码优化降为1维数组滚动数组">java代码优化（降为1维数组/滚动数组）&lt;/h6>
&lt;p>原来的动态规划问题的状态转移方程：&lt;/p>
&lt;p>$dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])$&lt;/p>
&lt;p>使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp[i][v]都和前i-1张零钱的使用状况有关。是否使用第i张，取决于哪种情况使用的零钱张数多。&lt;/p>
&lt;p>优化：&lt;/p>
&lt;p>由于使用的零钱张数dp[i][v]都仅和前i-1张零钱的使用状况$dp[i-1][1:v]$有关，我们可以将2维数组降为1维数组(滚动数组）&lt;/p>
&lt;p>新的状态转移方程：&lt;/p>
&lt;p>$dp[v] = max(dp[v-v[i]]+1, dp[v])$&lt;/p>
&lt;p>由于dp[v-v[i]]+1, dp[v]使用的是上一轮（i-1轮）的值，在dp[v]使用前不应当被更改，所以对v的枚举应该逆序进行。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.ArrayList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Arrays&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.util.Scanner&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/13 18:21
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4119
&lt;/span>&lt;span style="color:#75715e"> * 最优化问题：动态规划问题：选硬币问题，满背包问题
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 最优化问题描述
&lt;/span>&lt;span style="color:#75715e"> * 目标函数：使用零钱张数最多
&lt;/span>&lt;span style="color:#75715e"> * 限制条件：使用的面值之和恰好为V
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 动态规划将最优化问题分解为多个子问题，通过综合子问题的最优解来得到原问题的最优解。且动态规划会将子问题的解保存下来，避免重复计算
&lt;/span>&lt;span style="color:#75715e"> * 动态规划问题的状态转移方程：
&lt;/span>&lt;span style="color:#75715e"> * dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])
&lt;/span>&lt;span style="color:#75715e"> * 使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp[i][v]都和前i-1张零钱的使用状况有关。是否使用第i张，取决于哪种情况使用的零钱张数多。
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 优化：
&lt;/span>&lt;span style="color:#75715e"> * 由于使用的零钱张数dp[i][v]都仅和前i-1张零钱的使用状况dp[i-1][1:v]有关，我们可以将2维数组降为1维数组(滚动数组）
&lt;/span>&lt;span style="color:#75715e"> * 新的状态转移方程：
&lt;/span>&lt;span style="color:#75715e"> * dp[v] = max(dp[v-v[i]]+1, dp[v])
&lt;/span>&lt;span style="color:#75715e"> * 由于dp[v-v[i]]+1, dp[v]使用的是上一轮（i-1轮）的值，在dp[v]使用前不应当被更改，所以对v的枚举应该逆序进行。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1026_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> m &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> coins &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//排序，逆序
&lt;/span>&lt;span style="color:#75715e">&lt;/span> Arrays&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">sort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>coins&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++,&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">];&lt;/span>
coins&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> tmp&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//背包数组，记录存入背包的硬币个数；路径记录数组
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">][&lt;/span>m &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//默认初始化dp[0]为0，dp[1:m]设为-1表示不能从这些位置开始转移。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//恰好装满的判断:保证不是从-1转移过来的
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">&amp;gt;=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j &lt;span style="color:#f92672">-&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
flag&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>dp&lt;span style="color:#f92672">[&lt;/span>m&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> m&lt;span style="color:#f92672">;&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>flag&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]);&lt;/span>
j &lt;span style="color:#f92672">-=&lt;/span> coins&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
i&lt;span style="color:#f92672">--;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
StringBuilder sb &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> StringBuilder&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>Integer e &lt;span style="color:#f92672">:&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>e&lt;span style="color:#f92672">).&lt;/span>&lt;span style="color:#a6e22e">append&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">setLength&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">);&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>sb&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;No Solution&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="方法2-使用的零钱面值总额不超过v使得使用的零钱面值总额最大">方法2 使用的零钱面值总额不超过V，使得使用的零钱面值总额最大&lt;/h5>
&lt;p>如果目标函数（使用的零钱总额)最大值就是V，那么原问题（用零钱凑给定金额V）有解。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#75715e">//牛客网牛友bystc提交的代码
&lt;/span>&lt;span style="color:#75715e">//https://www.nowcoder.com/profile/5065450/codeBookDetail?submissionId=12502427
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> ncoins &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10005&lt;/span>;
&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> nmonay &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">105&lt;/span>;
&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">cmp&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>a, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>b) {
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">&amp;gt;&lt;/span> b;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#66d9ef">int&lt;/span> dp[ncoins][nmonay];
&lt;span style="color:#66d9ef">int&lt;/span> coins[ncoins];
&lt;span style="color:#66d9ef">bool&lt;/span> isIncluded[nmonay][ncoins];
&lt;span style="color:#66d9ef">int&lt;/span> n, m;
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>n, &lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
scanf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>coins[i]);
}
std&lt;span style="color:#f92672">::&lt;/span>sort(coins &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, coins &lt;span style="color:#f92672">+&lt;/span> n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, cmp);
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>j)
isIncluded[i][j] &lt;span style="color:#f92672">=&lt;/span> false;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>i) dp[&lt;span style="color:#ae81ff">0&lt;/span>][i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) dp[i][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i)
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> m; &lt;span style="color:#f92672">++&lt;/span>j) {
&lt;span style="color:#66d9ef">if&lt;/span>( j &lt;span style="color:#f92672">&amp;lt;&lt;/span> coins[i] &lt;span style="color:#f92672">||&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> coins[i] &lt;span style="color:#f92672">+&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j &lt;span style="color:#f92672">-&lt;/span> coins[i]] ) {
dp[i][j] &lt;span style="color:#f92672">=&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j];
}
&lt;span style="color:#66d9ef">else&lt;/span> {
dp[i][j] &lt;span style="color:#f92672">=&lt;/span> dp[i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>][j &lt;span style="color:#f92672">-&lt;/span> coins[i]] &lt;span style="color:#f92672">+&lt;/span> coins[i];
isIncluded[j][i] &lt;span style="color:#f92672">=&lt;/span> true;
}
}
&lt;span style="color:#66d9ef">if&lt;/span>(dp[n][m] &lt;span style="color:#f92672">!=&lt;/span> m) {
printf(&lt;span style="color:#e6db74">&amp;#34;No Solution&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">bool&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> true;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> n; i &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> m &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#f92672">--&lt;/span>i) {
&lt;span style="color:#66d9ef">if&lt;/span>(isIncluded[m][i]) {
&lt;span style="color:#66d9ef">if&lt;/span>(flag) {
printf(&lt;span style="color:#e6db74">&amp;#34;%d&amp;#34;&lt;/span>, coins[i]);
flag &lt;span style="color:#f92672">=&lt;/span> false;
}
&lt;span style="color:#66d9ef">else&lt;/span>
printf(&lt;span style="color:#e6db74">&amp;#34; %d&amp;#34;&lt;/span>, coins[i]);
m &lt;span style="color:#f92672">-=&lt;/span> coins[i];
}
}
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="初始化的问题">初始化的问题&lt;/h5>
&lt;p>不同的初始化条件决定了dp数组的意义：
是装入的总价值的最大值（不一定恰好装满）
还是装入的总价值（但一定装满）&lt;/p>
&lt;p>具体的讲，初始化的问题（可用数学归纳法证明状态的转移过程：见bilibili大雪菜背包九讲专题）：&lt;/p>
&lt;p>对于滚动数组/一维数组，$dp[0:m]$都初始化为0，则$dp[m]$中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满）
对于滚动数组/一维数组，$dp[1:m]$都初始化为$-INF$，$dp[0] = 0$, 则$dp[m$]中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值
对于二维数组，$dp[0:n][0:m]$都初始化为0，则$dp[n][m]$中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满）
对于二维数组，$dp[0:n][1:m]$都初始化为$-INF$，$dp[1:n][0] = 0$, 则$dp[n][m]$中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值&lt;/p></description></item><item><title>数据结构-栈和队列</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="栈和队列">栈和队列&lt;/h1>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328200545921.png" alt="" />&lt;figcaption>image-20200328200545921&lt;/figcaption>
&lt;/figure>
&lt;h2 id="栈">栈&lt;/h2>
&lt;h3 id="基本概念">基本概念&lt;/h3>
&lt;h5 id="栈的定义">栈的定义&lt;/h5>
&lt;p>栈（ Stack）只允许在一端进行插入或删除操作的线性表&lt;/p>
&lt;p>后进先出（LIFO）&lt;/p>
&lt;h5 id="共享栈的定义">共享栈的定义&lt;/h5>
&lt;p>将两个栈底设置在共享空间的两端，栈顶向空间中间延伸&lt;/p>
&lt;p>优点：存取时间复杂度仍为O（1），但空间利用更加有效&lt;/p>
&lt;h5 id="栈的基本操作">栈的基本操作&lt;/h5>
&lt;p>Initstack（&amp;amp;S）：初始化一个空栈S StackEmpty（S）：判断一个栈是否为空，若栈为空则返回true，否则返回 False。 Push（&amp;amp;S,x）：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop（&amp;amp;S，&amp;amp;x）：出栈，若栈非空，则弹出栈顶元素，并用×返回。 GetTop（s，&amp;amp;x）：读栈顶元素，若栈非空则用×返回栈顶元素。 ClearStack（&amp;amp;S）：销毁栈，并释放S占用的内存空间。&lt;/p>
&lt;h3 id="存储结构">存储结构&lt;/h3>
&lt;h4 id="顺序存储">顺序存储&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328201504762.png" alt="" />&lt;figcaption>image-20200328201504762&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328201659785.png" alt="image-20200328201659785" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328201752448.png" alt="image-20200328201752448" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328202002514.png" alt="image-20200328202002514" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328202418937.png" alt="image-20200328202418937" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328202652541.png" alt="image-20200328202652541" />&lt;/p>
&lt;p>而对于共享栈：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328203132531.png" alt="" />&lt;figcaption>image-20200328203132531&lt;/figcaption>
&lt;/figure>
&lt;h4 id="链式存储">链式存储&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328203310146.png" alt="" />&lt;figcaption>image-20200328203310146&lt;/figcaption>
&lt;/figure>
&lt;p>所有的操作都在表头进行。入栈出栈对应于单链表在表头的插入和删除，判空也与单链表相同。&lt;/p>
&lt;h3 id="栈的应用">栈的应用&lt;/h3>
&lt;h4 id="括号匹配">括号匹配&lt;/h4>
&lt;h4 id="表达式求值">表达式求值&lt;/h4>
&lt;h5 id="中缀表达式转后缀式1">中缀表达式转后缀式&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>&lt;/h5>
&lt;p>&lt;a href="https://www.cnblogs.com/luxiaoxun/archive/2012/08/04/2622800.html">表达式求值、表达式转二叉树&lt;/a>&lt;/p>
&lt;p>中缀表达式转后缀表达式主要有两种方法&lt;/p>
&lt;ul>
&lt;li>根据中缀表达式，写出表达式树，然后后序遍历，即得到后缀表达式（去掉括号的输出）。&lt;/li>
&lt;li>读取中缀表达式，直接输出操作数，利用栈保存操作符。向栈中保存操作符前，栈中优先级高的操作符要先输出/参与运算。这样得到的输出也是后缀表达式。&lt;/li>
&lt;/ul>
&lt;p>例如，中缀表达式a + b&lt;em>c + (d &lt;/em> e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。&lt;/p>
&lt;p>&lt;strong>中缀表达式转换后缀表达式过程&lt;/strong>：使用栈（保存操作符）的方法，具体过程如下：&lt;/p>
&lt;ol type="1">
&lt;li>如果遇到操作数，我们就直接将其输出（加入到后缀表达式）。&lt;/li>
&lt;li>如果遇到操作符，（栈中优先级高的操作符要先输出/参与运算，再把当前操作符入栈）
&lt;ol type="1">
&lt;li>若为’(’，直接入栈&lt;/li>
&lt;li>若为’)‘，则依次把栈中的运算符输出（加入到后缀表达式），直到出现’(‘，并从栈中删除’(’； 注意，左括号只弹出并不输出。&lt;/li>
&lt;li>若为’+‘，’-‘，’*‘，’，‘/’
&lt;ol type="1">
&lt;li>若高于栈顶元素优先级，或栈空，或栈顶为’(’，直接入栈；&lt;/li>
&lt;li>否则，先依次弹出栈顶运算符，直到一个优先级比它低的运算符或’(‘为止; 弹出完这些元素后，才将遇到的操作符压入到栈中。 有一点需要注意，只有在遇到" ) "的情况下我们才弹出’(‘，其他情况我们都不会弹出’(’。&lt;/li>
&lt;/ol>&lt;/li>
&lt;/ol>&lt;/li>
&lt;li>如果我们读到了输入的末尾，则将栈中所有元素依次弹出。&lt;/li>
&lt;/ol>
&lt;div class="sourceCode" id="cb1">&lt;pre class="sourceCode java">&lt;code class="sourceCode java">&lt;span id="cb1-1">&lt;a href="#cb1-1">&lt;/a>&lt;span class="kw">public&lt;/span> &lt;span class="kw">class&lt;/span> CalcExpr {&lt;/span>
&lt;span id="cb1-2">&lt;a href="#cb1-2">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-3">&lt;a href="#cb1-3">&lt;/a> &lt;span class="co">*&lt;/span> 操作符，优先级由高到低&lt;/span>
&lt;span id="cb1-4">&lt;a href="#cb1-4">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-5">&lt;a href="#cb1-5">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">final&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="bu">String&lt;/span>[][] OPERATORS = &lt;span class="kw">new&lt;/span> &lt;span class="bu">String&lt;/span>[][]{&lt;span class="kw">new&lt;/span> &lt;span class="bu">String&lt;/span>[]{&lt;span class="st">&amp;quot;(&amp;quot;&lt;/span>}, &lt;span class="kw">new&lt;/span> &lt;span class="bu">String&lt;/span>[]{&lt;span class="st">&amp;quot;*&amp;quot;&lt;/span>, &lt;span class="st">&amp;quot;/&amp;quot;&lt;/span>},&lt;/span>
&lt;span id="cb1-6">&lt;a href="#cb1-6">&lt;/a> &lt;span class="kw">new&lt;/span> &lt;span class="bu">String&lt;/span>[]{&lt;span class="st">&amp;quot;+&amp;quot;&lt;/span>, &lt;span class="st">&amp;quot;-&amp;quot;&lt;/span>}, &lt;span class="kw">new&lt;/span> &lt;span class="bu">String&lt;/span>[]{&lt;span class="st">&amp;quot;)&amp;quot;&lt;/span>}};&lt;/span>
&lt;span id="cb1-7">&lt;a href="#cb1-7">&lt;/a>&lt;/span>
&lt;span id="cb1-8">&lt;a href="#cb1-8">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-9">&lt;a href="#cb1-9">&lt;/a> &lt;span class="co">*&lt;/span> 中缀表达式转后缀表达式&lt;/span>
&lt;span id="cb1-10">&lt;a href="#cb1-10">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-11">&lt;a href="#cb1-11">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="bu">String&lt;/span> &lt;span class="fu">exprInOrder2PostOrder&lt;/span>(&lt;span class="bu">String&lt;/span> expr) {&lt;/span>
&lt;span id="cb1-12">&lt;a href="#cb1-12">&lt;/a> &lt;span class="kw">if&lt;/span> (expr == &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-13">&lt;a href="#cb1-13">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">null&lt;/span>;&lt;/span>
&lt;span id="cb1-14">&lt;a href="#cb1-14">&lt;/a> }&lt;/span>
&lt;span id="cb1-15">&lt;a href="#cb1-15">&lt;/a> &lt;span class="co">//保存后缀表达式输出结果&lt;/span>&lt;/span>
&lt;span id="cb1-16">&lt;a href="#cb1-16">&lt;/a> &lt;span class="bu">StringBuilder&lt;/span> sb = &lt;span class="kw">new&lt;/span> &lt;span class="bu">StringBuilder&lt;/span>();&lt;/span>
&lt;span id="cb1-17">&lt;a href="#cb1-17">&lt;/a> &lt;span class="co">//符号栈(保存表达式中的操作符）&lt;/span>&lt;/span>
&lt;span id="cb1-18">&lt;a href="#cb1-18">&lt;/a> &lt;span class="bu">Stack&lt;/span>&amp;lt;&lt;span class="bu">String&lt;/span>&amp;gt; stack = &lt;span class="kw">new&lt;/span> &lt;span class="bu">Stack&lt;/span>();&lt;/span>
&lt;span id="cb1-19">&lt;a href="#cb1-19">&lt;/a> &lt;span class="co">//输入字符串分隔为多个token&lt;/span>&lt;/span>
&lt;span id="cb1-20">&lt;a href="#cb1-20">&lt;/a> Tokens tokens = &lt;span class="kw">new&lt;/span> &lt;span class="fu">Tokens&lt;/span>(expr);&lt;/span>
&lt;span id="cb1-21">&lt;a href="#cb1-21">&lt;/a> &lt;span class="co">//顺序操作每个token&lt;/span>&lt;/span>
&lt;span id="cb1-22">&lt;a href="#cb1-22">&lt;/a> &lt;span class="kw">while&lt;/span> (tokens.&lt;span class="fu">hasNext&lt;/span>()) {&lt;/span>
&lt;span id="cb1-23">&lt;a href="#cb1-23">&lt;/a> &lt;span class="bu">String&lt;/span> token = tokens.&lt;span class="fu">next&lt;/span>();&lt;/span>
&lt;span id="cb1-24">&lt;a href="#cb1-24">&lt;/a> &lt;span class="co">//如果是操作符&lt;/span>&lt;/span>
&lt;span id="cb1-25">&lt;a href="#cb1-25">&lt;/a> &lt;span class="kw">if&lt;/span> (&lt;span class="fu">isOperator&lt;/span>(token)) {&lt;/span>
&lt;span id="cb1-26">&lt;a href="#cb1-26">&lt;/a> &lt;span class="co">//栈非空，且栈顶不是&amp;#39;(&amp;#39;，且当前符号优先级不高于栈顶操作符时&lt;/span>&lt;/span>
&lt;span id="cb1-27">&lt;a href="#cb1-27">&lt;/a> &lt;span class="kw">while&lt;/span> (!stack.&lt;span class="fu">empty&lt;/span>() &amp;amp;&amp;amp; !&lt;span class="st">&amp;quot;(&amp;quot;&lt;/span>.&lt;span class="fu">equals&lt;/span>(stack.&lt;span class="fu">peek&lt;/span>()) &amp;amp;&amp;amp; !&lt;span class="fu">isOperatorGreater&lt;/span>(token, stack.&lt;span class="fu">peek&lt;/span>())) {&lt;/span>
&lt;span id="cb1-28">&lt;a href="#cb1-28">&lt;/a> sb.&lt;span class="fu">append&lt;/span>(stack.&lt;span class="fu">pop&lt;/span>()).&lt;span class="fu">append&lt;/span>(&lt;span class="st">&amp;quot; &amp;quot;&lt;/span>);&lt;/span>
&lt;span id="cb1-29">&lt;a href="#cb1-29">&lt;/a> }&lt;/span>
&lt;span id="cb1-30">&lt;a href="#cb1-30">&lt;/a> &lt;span class="co">//符号入栈。如果遇到的是&amp;quot;)&amp;quot;,则不需要入栈，且需弹出&amp;quot;(&amp;quot;&lt;/span>&lt;/span>
&lt;span id="cb1-31">&lt;a href="#cb1-31">&lt;/a> &lt;span class="kw">if&lt;/span> (&lt;span class="st">&amp;quot;)&amp;quot;&lt;/span>.&lt;span class="fu">equals&lt;/span>(token)) {&lt;/span>
&lt;span id="cb1-32">&lt;a href="#cb1-32">&lt;/a> stack.&lt;span class="fu">pop&lt;/span>();&lt;/span>
&lt;span id="cb1-33">&lt;a href="#cb1-33">&lt;/a> } &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-34">&lt;a href="#cb1-34">&lt;/a> stack.&lt;span class="fu">push&lt;/span>(token);&lt;/span>
&lt;span id="cb1-35">&lt;a href="#cb1-35">&lt;/a> }&lt;/span>
&lt;span id="cb1-36">&lt;a href="#cb1-36">&lt;/a> }&lt;/span>
&lt;span id="cb1-37">&lt;a href="#cb1-37">&lt;/a> &lt;span class="co">//如果是操作数（也可能是字母表示的操作数）&lt;/span>&lt;/span>
&lt;span id="cb1-38">&lt;a href="#cb1-38">&lt;/a> &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-39">&lt;a href="#cb1-39">&lt;/a> sb.&lt;span class="fu">append&lt;/span>(token).&lt;span class="fu">append&lt;/span>(&lt;span class="st">&amp;quot; &amp;quot;&lt;/span>);&lt;/span>
&lt;span id="cb1-40">&lt;a href="#cb1-40">&lt;/a> }&lt;/span>
&lt;span id="cb1-41">&lt;a href="#cb1-41">&lt;/a> }&lt;/span>
&lt;span id="cb1-42">&lt;a href="#cb1-42">&lt;/a> &lt;span class="kw">while&lt;/span> (!stack.&lt;span class="fu">isEmpty&lt;/span>()) {&lt;/span>
&lt;span id="cb1-43">&lt;a href="#cb1-43">&lt;/a> sb.&lt;span class="fu">append&lt;/span>(stack.&lt;span class="fu">pop&lt;/span>()).&lt;span class="fu">append&lt;/span>(&lt;span class="st">&amp;quot; &amp;quot;&lt;/span>);&lt;/span>
&lt;span id="cb1-44">&lt;a href="#cb1-44">&lt;/a> }&lt;/span>
&lt;span id="cb1-45">&lt;a href="#cb1-45">&lt;/a> &lt;span class="kw">return&lt;/span> sb.&lt;span class="fu">toString&lt;/span>();&lt;/span>
&lt;span id="cb1-46">&lt;a href="#cb1-46">&lt;/a> }&lt;/span>
&lt;span id="cb1-47">&lt;a href="#cb1-47">&lt;/a>&lt;/span>
&lt;span id="cb1-48">&lt;a href="#cb1-48">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-49">&lt;a href="#cb1-49">&lt;/a> &lt;span class="co">*&lt;/span> 判断是否为操作符&lt;/span>
&lt;span id="cb1-50">&lt;a href="#cb1-50">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-51">&lt;a href="#cb1-51">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="dt">boolean&lt;/span> &lt;span class="fu">isOperator&lt;/span>(&lt;span class="bu">String&lt;/span> ch) {&lt;/span>
&lt;span id="cb1-52">&lt;a href="#cb1-52">&lt;/a> &lt;span class="kw">for&lt;/span> (&lt;span class="bu">String&lt;/span>[] chars : OPERATORS) {&lt;/span>
&lt;span id="cb1-53">&lt;a href="#cb1-53">&lt;/a> &lt;span class="kw">for&lt;/span> (&lt;span class="bu">String&lt;/span> c : chars) {&lt;/span>
&lt;span id="cb1-54">&lt;a href="#cb1-54">&lt;/a> &lt;span class="kw">if&lt;/span> (ch.&lt;span class="fu">equals&lt;/span>(c)) {&lt;/span>
&lt;span id="cb1-55">&lt;a href="#cb1-55">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">true&lt;/span>;&lt;/span>
&lt;span id="cb1-56">&lt;a href="#cb1-56">&lt;/a> }&lt;/span>
&lt;span id="cb1-57">&lt;a href="#cb1-57">&lt;/a> }&lt;/span>
&lt;span id="cb1-58">&lt;a href="#cb1-58">&lt;/a> }&lt;/span>
&lt;span id="cb1-59">&lt;a href="#cb1-59">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">false&lt;/span>;&lt;/span>
&lt;span id="cb1-60">&lt;a href="#cb1-60">&lt;/a> }&lt;/span>
&lt;span id="cb1-61">&lt;a href="#cb1-61">&lt;/a>&lt;/span>
&lt;span id="cb1-62">&lt;a href="#cb1-62">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-63">&lt;a href="#cb1-63">&lt;/a> &lt;span class="co">*&lt;/span> 判断参数ch1的优先级是否高于ch2&lt;/span>
&lt;span id="cb1-64">&lt;a href="#cb1-64">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-65">&lt;a href="#cb1-65">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="dt">boolean&lt;/span> &lt;span class="fu">isOperatorGreater&lt;/span>(&lt;span class="bu">String&lt;/span> ch1, &lt;span class="bu">String&lt;/span> ch2) {&lt;/span>
&lt;span id="cb1-66">&lt;a href="#cb1-66">&lt;/a> &lt;span class="dt">int&lt;/span> level1 = -&lt;span class="dv">1&lt;/span>, level2 = -&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb1-67">&lt;a href="#cb1-67">&lt;/a> &lt;span class="kw">for&lt;/span> (&lt;span class="dt">int&lt;/span> i = &lt;span class="dv">0&lt;/span>; i &amp;lt; OPERATORS.&lt;span class="fu">length&lt;/span>; i++) {&lt;/span>
&lt;span id="cb1-68">&lt;a href="#cb1-68">&lt;/a> &lt;span class="kw">for&lt;/span> (&lt;span class="dt">int&lt;/span> j = &lt;span class="dv">0&lt;/span>; j &amp;lt; OPERATORS[i].&lt;span class="fu">length&lt;/span>; j++) {&lt;/span>
&lt;span id="cb1-69">&lt;a href="#cb1-69">&lt;/a> &lt;span class="kw">if&lt;/span> (ch1 != &lt;span class="kw">null&lt;/span> &amp;amp;&amp;amp; ch1.&lt;span class="fu">equals&lt;/span>(OPERATORS[i][j])) {&lt;/span>
&lt;span id="cb1-70">&lt;a href="#cb1-70">&lt;/a> level1 = i;&lt;/span>
&lt;span id="cb1-71">&lt;a href="#cb1-71">&lt;/a> }&lt;/span>
&lt;span id="cb1-72">&lt;a href="#cb1-72">&lt;/a> &lt;span class="kw">if&lt;/span> (ch2 != &lt;span class="kw">null&lt;/span> &amp;amp;&amp;amp; ch2.&lt;span class="fu">equals&lt;/span>(OPERATORS[i][j])) {&lt;/span>
&lt;span id="cb1-73">&lt;a href="#cb1-73">&lt;/a> level2 = i;&lt;/span>
&lt;span id="cb1-74">&lt;a href="#cb1-74">&lt;/a> }&lt;/span>
&lt;span id="cb1-75">&lt;a href="#cb1-75">&lt;/a> }&lt;/span>
&lt;span id="cb1-76">&lt;a href="#cb1-76">&lt;/a> }&lt;/span>
&lt;span id="cb1-77">&lt;a href="#cb1-77">&lt;/a> &lt;span class="kw">if&lt;/span> (level1 != -&lt;span class="dv">1&lt;/span> &amp;amp;&amp;amp; level2 != -&lt;span class="dv">1&lt;/span> &amp;amp;&amp;amp; level1 &amp;lt; level2) {&lt;/span>
&lt;span id="cb1-78">&lt;a href="#cb1-78">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">true&lt;/span>;&lt;/span>
&lt;span id="cb1-79">&lt;a href="#cb1-79">&lt;/a> }&lt;/span>
&lt;span id="cb1-80">&lt;a href="#cb1-80">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">false&lt;/span>;&lt;/span>
&lt;span id="cb1-81">&lt;a href="#cb1-81">&lt;/a> }&lt;/span>
&lt;span id="cb1-82">&lt;a href="#cb1-82">&lt;/a> &lt;/span>
&lt;span id="cb1-83">&lt;a href="#cb1-83">&lt;/a> &lt;/span>
&lt;span id="cb1-84">&lt;a href="#cb1-84">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">main&lt;/span>(&lt;span class="bu">String&lt;/span>[] args) {&lt;/span>
&lt;span id="cb1-85">&lt;a href="#cb1-85">&lt;/a> &lt;span class="bu">Scanner&lt;/span> scanner = &lt;span class="kw">new&lt;/span> &lt;span class="bu">Scanner&lt;/span>(&lt;span class="bu">System&lt;/span>.&lt;span class="fu">in&lt;/span>);&lt;/span>
&lt;span id="cb1-86">&lt;a href="#cb1-86">&lt;/a> &lt;span class="bu">String&lt;/span> expr = scanner.&lt;span class="fu">nextLine&lt;/span>();&lt;/span>
&lt;span id="cb1-87">&lt;a href="#cb1-87">&lt;/a> &lt;span class="bu">System&lt;/span>.&lt;span class="fu">out&lt;/span>.&lt;span class="fu">println&lt;/span>(&lt;span class="fu">exprInOrder2PostOrder&lt;/span>(expr));&lt;/span>
&lt;span id="cb1-88">&lt;a href="#cb1-88">&lt;/a> scanner.&lt;span class="fu">close&lt;/span>();&lt;/span>
&lt;span id="cb1-89">&lt;a href="#cb1-89">&lt;/a> }&lt;/span>
&lt;span id="cb1-90">&lt;a href="#cb1-90">&lt;/a>}&lt;/span>
&lt;span id="cb1-91">&lt;a href="#cb1-91">&lt;/a>&lt;/span>
&lt;span id="cb1-92">&lt;a href="#cb1-92">&lt;/a>&lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-93">&lt;a href="#cb1-93">&lt;/a> &lt;span class="co">*&lt;/span> 根据分隔符划分为多个token，包含分隔符&lt;/span>
&lt;span id="cb1-94">&lt;a href="#cb1-94">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-95">&lt;a href="#cb1-95">&lt;/a>&lt;span class="kw">class&lt;/span> Tokens {&lt;/span>
&lt;span id="cb1-96">&lt;a href="#cb1-96">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="bu">String&lt;/span> originStr;&lt;/span>
&lt;span id="cb1-97">&lt;a href="#cb1-97">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="bu">String&lt;/span>[] tokens;&lt;/span>
&lt;span id="cb1-98">&lt;a href="#cb1-98">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-99">&lt;a href="#cb1-99">&lt;/a> &lt;span class="co">*&lt;/span> 分隔符默认是加减乘除小括号&lt;/span>
&lt;span id="cb1-100">&lt;a href="#cb1-100">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-101">&lt;a href="#cb1-101">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="bu">String&lt;/span> spliters = &lt;span class="st">&amp;quot;&lt;/span>&lt;span class="sc">\\&lt;/span>&lt;span class="st">+|-|&lt;/span>&lt;span class="sc">\\&lt;/span>&lt;span class="st">*|/|&lt;/span>&lt;span class="sc">\\&lt;/span>&lt;span class="st">(|&lt;/span>&lt;span class="sc">\\&lt;/span>&lt;span class="st">)&amp;quot;&lt;/span>;&lt;/span>
&lt;span id="cb1-102">&lt;a href="#cb1-102">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">int&lt;/span> index;&lt;/span>
&lt;span id="cb1-103">&lt;a href="#cb1-103">&lt;/a>&lt;/span>
&lt;span id="cb1-104">&lt;a href="#cb1-104">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="fu">Tokens&lt;/span>(&lt;span class="bu">String&lt;/span> originStr) {&lt;/span>
&lt;span id="cb1-105">&lt;a href="#cb1-105">&lt;/a> &lt;span class="kw">this&lt;/span>.&lt;span class="fu">originStr&lt;/span> = originStr;&lt;/span>
&lt;span id="cb1-106">&lt;a href="#cb1-106">&lt;/a> &lt;span class="kw">this&lt;/span>.&lt;span class="fu">tokens&lt;/span> = &lt;span class="kw">null&lt;/span>;&lt;/span>
&lt;span id="cb1-107">&lt;a href="#cb1-107">&lt;/a> index = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb1-108">&lt;a href="#cb1-108">&lt;/a> &lt;span class="fu">split&lt;/span>();&lt;/span>
&lt;span id="cb1-109">&lt;a href="#cb1-109">&lt;/a> }&lt;/span>
&lt;span id="cb1-110">&lt;a href="#cb1-110">&lt;/a>&lt;/span>
&lt;span id="cb1-111">&lt;a href="#cb1-111">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">split&lt;/span>() {&lt;/span>
&lt;span id="cb1-112">&lt;a href="#cb1-112">&lt;/a> &lt;span class="kw">if&lt;/span> (originStr != &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-113">&lt;a href="#cb1-113">&lt;/a> tokens = originStr.&lt;span class="fu">split&lt;/span>(&lt;span class="st">&amp;quot;(?&amp;lt;=(&amp;quot;&lt;/span> + spliters + &lt;span class="st">&amp;quot;))|(?=(&amp;quot;&lt;/span> + spliters + &lt;span class="st">&amp;quot;))&amp;quot;&lt;/span>);&lt;/span>
&lt;span id="cb1-114">&lt;a href="#cb1-114">&lt;/a> }&lt;/span>
&lt;span id="cb1-115">&lt;a href="#cb1-115">&lt;/a> }&lt;/span>
&lt;span id="cb1-116">&lt;a href="#cb1-116">&lt;/a>&lt;/span>
&lt;span id="cb1-117">&lt;a href="#cb1-117">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">boolean&lt;/span> &lt;span class="fu">hasNext&lt;/span>() {&lt;/span>
&lt;span id="cb1-118">&lt;a href="#cb1-118">&lt;/a> &lt;span class="kw">if&lt;/span> (originStr != &lt;span class="kw">null&lt;/span> &amp;amp;&amp;amp; index &amp;lt; tokens.&lt;span class="fu">length&lt;/span>) {&lt;/span>
&lt;span id="cb1-119">&lt;a href="#cb1-119">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">true&lt;/span>;&lt;/span>
&lt;span id="cb1-120">&lt;a href="#cb1-120">&lt;/a> }&lt;/span>
&lt;span id="cb1-121">&lt;a href="#cb1-121">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">false&lt;/span>;&lt;/span>
&lt;span id="cb1-122">&lt;a href="#cb1-122">&lt;/a> }&lt;/span>
&lt;span id="cb1-123">&lt;a href="#cb1-123">&lt;/a>&lt;/span>
&lt;span id="cb1-124">&lt;a href="#cb1-124">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="bu">String&lt;/span> &lt;span class="fu">next&lt;/span>() {&lt;/span>
&lt;span id="cb1-125">&lt;a href="#cb1-125">&lt;/a> &lt;span class="kw">return&lt;/span> tokens[index++].&lt;span class="fu">trim&lt;/span>();&lt;/span>
&lt;span id="cb1-126">&lt;a href="#cb1-126">&lt;/a> }&lt;/span>
&lt;span id="cb1-127">&lt;a href="#cb1-127">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h4 id="递归">递归&lt;/h4>
&lt;p>若在一个函数、过程或数据结构的定义中又应用了它自身，则称它为&lt;strong>递归定义&lt;/strong>的，简称&lt;strong>递归&lt;/strong>&lt;/p>
&lt;p>单链表节点的定义，计算斐波那契数的递归实现，都算作递归。&lt;/p>
&lt;p>递归的精髓在于能否将原始问题转换为属性相同但规模较小的问题。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410193733706.png" alt="" />&lt;figcaption>image-20200410193733706&lt;/figcaption>
&lt;/figure>
&lt;h5 id="递归函数">递归函数&lt;/h5>
&lt;p>递归函数的两个必要条件是递归表达式和递归出口。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410194000349.png" alt="" />&lt;figcaption>image-20200410194000349&lt;/figcaption>
&lt;/figure>
&lt;h5 id="递归调用的问题">递归调用的问题&lt;/h5>
&lt;ul>
&lt;li>&lt;p>在递归调用过程中，系统为每一层的返回点、局部变量、传入实参等开辟了递归工作栈来迸行数据存储，递归次数过多容易造成栈溢出。&lt;/p>&lt;/li>
&lt;li>&lt;p>通常情况下递归的效率并不高&lt;/p>&lt;/li>
&lt;/ul>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410194353238.png" alt="" />&lt;figcaption>image-20200410194353238&lt;/figcaption>
&lt;/figure>
&lt;h5 id="递归转换为非递归">递归转换为非递归&lt;/h5>
&lt;p>递归算法转换为非递归算法，有的可以直接用循环实现，有的需要用到栈。&lt;/p>
&lt;h2 id="队列">队列&lt;/h2>
&lt;h3 id="基本概念-1">基本概念&lt;/h3>
&lt;h5 id="队列的定义">队列的定义&lt;/h5>
&lt;p>队列（ Queue）只允许在表的一端进行插入，表的另一端进行删除操作的线性表&lt;/p>
&lt;p>先进先出（FIFO）&lt;/p>
&lt;h5 id="队列的基本操作">队列的基本操作&lt;/h5>
&lt;p>InitQueue（&amp;amp;Q）：初始化队列，构造一个空队列Q QueueEmpty（Q）：判队列空，若队列Q为空返回true，否则返回 false。 En Queue（&amp;amp;Qx）：入队，若队列Q末满，则将x加入使之成为新的队尾。 De queue（&amp;amp;Q&amp;amp;x）：出队，若队列Q非空，则删除队头元素，并用x返回Gethead（Q&amp;amp;x）：读队头元素，若队列Q非空则用x返回队头元素。 Clear Queue（&amp;amp;Q）：销毁队列，并释放队列Q占用的内存空间。&lt;/p>
&lt;h3 id="存储结构-1">存储结构&lt;/h3>
&lt;h4 id="顺序存储-1">顺序存储&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328203917938.png" alt="" />&lt;figcaption>image-20200328203917938&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328204205461.png" alt="" />&lt;figcaption>image-20200328204205461&lt;/figcaption>
&lt;/figure>
&lt;p>判断队空队满：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328204347444.png" alt="" />&lt;figcaption>image-20200328204347444&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328204556161.png" alt="" />&lt;figcaption>image-20200328204556161&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328204838430.png" alt="" />&lt;figcaption>image-20200328204838430&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205219214.png" alt="image-20200328205219214" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205244605.png" alt="image-20200328205244605" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205305871.png" alt="image-20200328205305871" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205443748.png" alt="image-20200328205443748" />&lt;/p>
&lt;h4 id="链式存储-1">链式存储&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205557266.png" alt="" />&lt;figcaption>image-20200328205557266&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205733840.png" alt="" />&lt;figcaption>image-20200328205733840&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205813169.png" alt="" />&lt;figcaption>image-20200328205813169&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328205851286.png" alt="" />&lt;figcaption>image-20200328205851286&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328211059904.png" alt="" />&lt;figcaption>image-20200328211059904&lt;/figcaption>
&lt;/figure>
&lt;p>注：如果初始化时rear为null，可以省略最后的判断&lt;/p>
&lt;h3 id="队列的应用">队列的应用&lt;/h3>
&lt;h4 id="层次遍历">层次遍历&lt;/h4>
&lt;h4 id="计算机系统">计算机系统&lt;/h4>
&lt;h2 id="双端队列">双端队列&lt;/h2>
&lt;h3 id="出栈序列和出队序列">出栈序列和出队序列&lt;/h3>
&lt;h4 id="连续输入和连续输出">连续输入和连续输出&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328214413009.png" alt="" />&lt;figcaption>image-20200328214413009&lt;/figcaption>
&lt;/figure>
&lt;h4 id="栈的非连续输入和输出">栈的非连续输入和输出&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328215034685.png" alt="" />&lt;figcaption>image-20200328215034685&lt;/figcaption>
&lt;/figure>
&lt;h5 id="合法规则">合法规则&lt;/h5>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328215206123.png" alt="" />&lt;figcaption>image-20200328215206123&lt;/figcaption>
&lt;/figure>
&lt;h5 id="合法出栈序列个数">合法出栈序列个数&lt;/h5>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328215408624.png" alt="" />&lt;figcaption>image-20200328215408624&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328215442724.png" alt="" />&lt;figcaption>image-20200328215442724&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328215729389.png" alt="" />&lt;figcaption>image-20200328215729389&lt;/figcaption>
&lt;/figure>
&lt;h3 id="双端队列-1">双端队列&lt;/h3>
&lt;p>双端队列：允许两端都可以进行入队以及出队操作的队列&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328220011867.png" alt="" />&lt;figcaption>image-20200328220011867&lt;/figcaption>
&lt;/figure>
&lt;h3 id="输入受限的双端队列">输入受限的双端队列&lt;/h3>
&lt;p>输入受限的双端队列，屏蔽一端的输出操作，可变成栈。所以栈的所有合法输出序列，在该输入受限的双端队列中都是合法的。&lt;/p>
&lt;h3 id="输出受限的双端队列">输出受限的双端队列&lt;/h3>
&lt;p>输出受限的双端队列，屏蔽一端的输入操作，可变成栈。所以栈的所有合法输出序列，在该输出受限的双端队列中都是合法的。&lt;/p>
&lt;h1 id="数组">数组&lt;/h1>
&lt;h3 id="数组的定义">数组的定义&lt;/h3>
&lt;p>这里的数组是指”数组”这种&lt;strong>逻辑结构&lt;/strong>，不单指C语言中的数组实现。&lt;/p>
&lt;p>&lt;strong>数组&lt;/strong>（逻辑结构）是由n（n&amp;gt;=1）个相同类型的数据元素构成的有限序列，每个数据元素称为一个数组壳素，每个元素受n个线性关系的约束，每个元素在n个线性关系中的序号称为该元素的下标，并称该数组为n维数组。&lt;/p>
&lt;p>数组是线性表的推广。数组相当于n维的、大小固定的线性表。 线性的顺序存储，使用的就是1维的数组的实现（1维数组的存储结构）。&lt;/p>
&lt;p>&lt;strong>数组的特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;p>数组有维度&lt;/p>
&lt;p>常见一维数组和二维数组&lt;/p>&lt;/li>
&lt;li>&lt;p>数组的维度和维界不可变&lt;/p>
&lt;p>数组一旦被定义，其维度和维界不可变，数组除初始化和销毁外，只有存取元素和修改元素的操作&lt;/p>&lt;/li>
&lt;/ul>
&lt;h3 id="数组的存储结构">数组的存储结构&lt;/h3>
&lt;h4 id="行优先存储">行优先存储&lt;/h4>
&lt;p>例如，二维数组&lt;span class="math inline">\(a[m][n]\)&lt;/span>,寻址其中的元素&lt;span class="math inline">\(a_{ij}\)&lt;/span>, &lt;span class="math inline">\(Address(a_{ij}) = Address(a_{00})+(m*i+j)*NODE_SIZE\)&lt;/span>&lt;/p>
&lt;h4 id="列优先存储">列优先存储&lt;/h4>
&lt;h3 id="矩阵的压缩存储">矩阵的压缩存储&lt;/h3>
&lt;p>&lt;strong>矩阵&lt;/strong>是数学中的叫法，其实就是二维数组，只不过数据结构的二维数组序标从0开始，&lt;strong>矩阵的序标从1开始&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>压缩存储&lt;/strong>是指迻多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。&lt;/p>
&lt;p>一些特殊矩阵可以进行压缩存储，这里的特殊矩阵指：具有许多相同矩阵元素或零元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。&lt;/p>
&lt;h4 id="对称矩阵的压缩存储">对称矩阵的压缩存储&lt;/h4>
&lt;p>按行优先存储时，矩阵（二维数组）压缩存储到一个一维数组中，下标对应关系如下（&lt;strong>矩阵下标从1开始&lt;/strong>）&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410205910531.png" alt="" />&lt;figcaption>image-20200410205910531&lt;/figcaption>
&lt;/figure>
&lt;h4 id="三角矩阵的压缩存储">三角矩阵的压缩存储&lt;/h4>
&lt;p>注意矩阵下标从1开始&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410210041421.png" alt="" />&lt;figcaption>image-20200410210041421&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410210226923.png" alt="" />&lt;figcaption>image-20200410210226923&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410210257085.png" alt="" />&lt;figcaption>image-20200410210257085&lt;/figcaption>
&lt;/figure>
&lt;h4 id="三对角矩阵的压缩存储">三对角矩阵的压缩存储&lt;/h4>
&lt;p>注意矩阵下标从1开始&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410210634404.png" alt="" />&lt;figcaption>image-20200410210634404&lt;/figcaption>
&lt;/figure>
&lt;h4 id="稀疏矩阵的压缩存储">稀疏矩阵的压缩存储&lt;/h4>
&lt;p>稀疏矩阵使用三元组（行标，列标，值）来压缩存储&lt;/p>
&lt;p>稀疏矩阵压缩存储后失去了随机存储的特性&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410210916705.png" alt="" />&lt;figcaption>image-20200410210916705&lt;/figcaption>
&lt;/figure>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>CSDN「石锅拌饭」原文链接：https://blog.csdn.net/sgbfblog/java/article/details/8001651&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>数据结构-线性表</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="线性表">线性表&lt;/h1>
&lt;p>线性表是一种数据结构，其逻辑结构为线性结构；存储结构（实现）有两种：顺序、链式；对应的运算（操作）也略有不同：顺序表示可以随机访问，链式表示可以随机插入删除&lt;/p>
&lt;h2 id="线性表的定义和基本操作">线性表的定义和基本操作&lt;/h2>
&lt;p>线性表是具有&lt;strong>相同类型&lt;/strong>的n（n&amp;gt;=0）个元素的&lt;strong>有限序列&lt;/strong>，其中n为表长，当n=0时，该表为空表&lt;/p>
&lt;p>若L命名为线性表，则一般表示为&lt;span class="math inline">\(L=\left(a_{1}, a_{2}, \dots, a_{i}, a_{i+1}, \dots, a_{n}\right)\)&lt;/span>&lt;/p>
&lt;h3 id="线性表的特点">线性表的特点&lt;/h3>
&lt;p>表中元素&lt;strong>个数有限&lt;/strong>&lt;/p>
&lt;p>表中元素具有逻辑上的顺序性，在序列中各个元素排序有其&lt;strong>先后次序&lt;/strong>&lt;/p>
&lt;p>表中元素都是&lt;strong>数据元素&lt;/strong>，每个元素都是单个元素&lt;/p>
&lt;p>表中元素的&lt;strong>数据类型都相同&lt;/strong>，这意味着每个元素占有相同大小的存储空间&lt;/p>
&lt;p>表中元素具有&lt;strong>抽象性&lt;/strong>，即讨论元素间一对一的逻辑关系，而不考虑元素究竟表示的内容&lt;/p>
&lt;p>线性表是一种&lt;strong>逻辑结构&lt;/strong>，表示元素之间一对一相邻的关系&lt;/p>
&lt;h3 id="线性表的基本操作">线性表的基本操作&lt;/h3>
&lt;p>9种基本操作：初始化、销毁、增删改查、遍历、是否为空、获取长度&lt;/p>
&lt;p>InitList(8L)：初始化表。构造一个空的线性表 DestroyList（&amp;amp;L）：销毁操作。销毁线性表，并释放线性表所占用的内存空间。 LocateElem（L,e)按值查找操作。在表中查找具有给定关键值得元素。 GetELem(L,i) 按位查找操作。获取表中第个位置的元素的值。 Listlnsert(&amp;amp;L,i,e）插入操作。在表中的第个位置上插入指定元素e插 LIstDelete（&amp;amp;L, &amp;amp;e）：删除操作。删除表L中第个位置的元素，并用e返回删除元素的值。 Printlist（L)：输出操作。按前后顺序输出线性表的所有元素值。 Empty（L）：判空操作。若为空表，则返回TRUE否则返回ALSE。 Length（L）：求表长。返回线性表的长度，即L中数据元素的个数。&lt;/p>
&lt;h2 id="线性表的顺序表示">线性表的顺序表示&lt;/h2>
&lt;h3 id="顺序表的定义">顺序表的定义&lt;/h3>
&lt;p>线性表的顺序存储又称顺序表&lt;/p>
&lt;p>一组地址连续存放的存储单元依次存放线性表的元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。&lt;/p>
&lt;p>数组静态分配，数组动态分配（使用指针）&lt;/p>
&lt;h3 id="顺序表的基本操作">顺序表的基本操作&lt;/h3>
&lt;p>插入、删除、按值查找&lt;/p>
&lt;h2 id="线性表的链式表示">线性表的链式表示&lt;/h2>
&lt;p>线性表的链式存储，简称链表&lt;/p>
&lt;p>通过一组任意的存储单元来存储线性表中的数据元素，通过指针实现线性逻辑关系。&lt;/p>
&lt;h3 id="单链表">单链表&lt;/h3>
&lt;h4 id="单链表的定义">单链表的定义&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/截图_202003161801000SS.png" />&lt;/p>
&lt;p>带头节点的单链表和不带头节点的单链表&lt;/p>
&lt;figure>
&lt;img src="C:\Users\wangjm\AppData\Roaming\Typora\typora-user-images\image-20200316185925947.png" alt="" />&lt;figcaption>image-20200316185925947&lt;/figcaption>
&lt;/figure>
&lt;p>带头节点单链表优点： 链表的第一个位置和其他位置的操作统一 空表和非空表的操作统一&lt;/p>
&lt;h4 id="单链表的基本操作">单链表的基本操作&lt;/h4>
&lt;p>建立：头插、尾插&lt;/p>
&lt;p>查找：按序号查找&amp;amp;按值查找&lt;/p>
&lt;p>插入：按序号查找+插入（前插/后插）&lt;/p>
&lt;p>前插与后插的转换：插入前交换节点内容&lt;/p>
&lt;p>删除：按序号查找+删除&lt;/p>
&lt;p>删除给定节点*p:交换节点内容+删除&lt;/p>
&lt;p>表长&lt;/p>
&lt;h3 id="双链表">双链表&lt;/h3>
&lt;p>双链表可以看作是：一个带头节点的单链表+另一个不带头节点的单链表；所以其头节点并不能统一操作。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321134928900.png" alt="" />&lt;figcaption>image-20200321134928900&lt;/figcaption>
&lt;/figure>
&lt;p>插入&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321135430055.png" alt="" />&lt;figcaption>image-20200321135430055&lt;/figcaption>
&lt;/figure>
&lt;p>删除&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321135550537.png" alt="" />&lt;figcaption>image-20200321135550537&lt;/figcaption>
&lt;/figure>
&lt;h3 id="循环链表">循环链表&lt;/h3>
&lt;h4 id="循环单链表">循环单链表&lt;/h4>
&lt;p>统一插入删除操作&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321140308993.png" alt="" />&lt;figcaption>image-20200321140308993&lt;/figcaption>
&lt;/figure>
&lt;p>判空&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321140626882.png" alt="" />&lt;figcaption>image-20200321140626882&lt;/figcaption>
&lt;/figure>
&lt;h4 id="循环双链表">循环双链表&lt;/h4>
&lt;p>统一插入删除操作；找尾节点更快&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321140412496.png" alt="" />&lt;figcaption>image-20200321140412496&lt;/figcaption>
&lt;/figure>
&lt;p>判空&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321140700205.png" alt="" />&lt;figcaption>image-20200321140700205&lt;/figcaption>
&lt;/figure>
&lt;h3 id="静态链表">静态链表&lt;/h3>
&lt;p>使用数组实现链表&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200321141133827.png" alt="" />&lt;figcaption>image-20200321141133827&lt;/figcaption>
&lt;/figure>
&lt;h2 id="顺序表和链表的对比">顺序表和链表的对比&lt;/h2>
&lt;h3 id="相同点">相同点&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>顺序表&lt;/th>
&lt;th>单链表&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>逻辑结构&lt;/td>
&lt;td>属于线性表&lt;/td>
&lt;td>属于线性表&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="不同点">不同点&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>顺序表&lt;/th>
&lt;th>单链表&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>存取方式&lt;/td>
&lt;td>顺序存取、随机存取（计算位置直接存取）&lt;/td>
&lt;td>顺序存取&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>物理结构（数据的存储）&lt;/td>
&lt;td>数据元素&lt;/td>
&lt;td>数据元素&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>物理结构（数据之间的关系）&lt;/td>
&lt;td>数据元素之间的相邻性&lt;/td>
&lt;td>下一个元素的指针&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>操作（插入，删除）&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>插入删除位置指针已知O(1)，插入删除位置指针未知O(n)&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>操作（查找）&lt;/td>
&lt;td>按值查找O(n),按序号查找O(1)&lt;/td>
&lt;td>按值、按序号查找都是O(n)&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>内存空间&lt;/td>
&lt;td>预分配（静态分配浪费空间，动态分配效率低）&lt;/td>
&lt;td>按需分配，但指针使用额外空间&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="怎样选择线性表">怎样选择线性表&lt;/h3>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>&lt;/th>
&lt;th>顺序表&lt;/th>
&lt;th>单链表&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>存储&lt;/td>
&lt;td>规模难以估计&lt;/td>
&lt;td>&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>存储&lt;/td>
&lt;td>存储密度大&lt;/td>
&lt;td>*&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>效率&lt;/td>
&lt;td>按序号访问&lt;/td>
&lt;td>*&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>效率&lt;/td>
&lt;td>插入和删除操作多&lt;/td>
&lt;td>&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>环境&lt;/td>
&lt;td>基于数组&lt;/td>
&lt;td>*&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>环境&lt;/td>
&lt;td>基于指针&lt;/td>
&lt;td>&lt;/td>
&lt;td>*&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="一些操作的实现">一些操作的实现&lt;/h3>
&lt;h4 id="求最大最小值">求最大最小值&lt;/h4>
&lt;h4 id="置逆">置逆&lt;/h4>
&lt;h5 id="顺序表置逆">顺序表置逆&lt;/h5>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322202739574.png" alt="" />&lt;figcaption>image-20200322202739574&lt;/figcaption>
&lt;/figure>
&lt;h5 id="单链表置逆">单链表置逆&lt;/h5>
&lt;p>将头部的节点依次插入到原尾节点后面&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322203711682.png" alt="" />&lt;figcaption>image-20200322203711682&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322203827639.png" alt="" />&lt;figcaption>image-20200322203827639&lt;/figcaption>
&lt;/figure>
&lt;h3 id="两路归并">两路归并&lt;/h3>
&lt;p>合并两个有序线性表&lt;/p>
&lt;h4 id="顺序表两路归并">顺序表两路归并&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322204315858.png" alt="" />&lt;figcaption>image-20200322204315858&lt;/figcaption>
&lt;/figure>
&lt;h4 id="单链表两路归并">单链表两路归并&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322204629850.png" alt="" />&lt;figcaption>image-20200322204629850&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322204737429.png" alt="" />&lt;figcaption>image-20200322204737429&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200322204852015.png" alt="" />&lt;figcaption>image-20200322204852015&lt;/figcaption>
&lt;/figure></description></item><item><title>数据结构与算法的基本概念</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="绪论">绪论&lt;/h1>
&lt;h2 id="数据结构的基本概念">数据结构的基本概念&lt;/h2>
&lt;h3 id="基本概念和术语">基本概念和术语&lt;/h3>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200316002505193.png" alt="" />&lt;figcaption>image-20200316002505193&lt;/figcaption>
&lt;/figure>
&lt;h4 id="数据">数据&lt;/h4>
&lt;p>信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合&lt;/p>
&lt;h4 id="数据对象">数据对象&lt;/h4>
&lt;p>具有相同性质的数据元素的集合，是数据的一个子集数据元素数据的基本单位，通常作为一个整体进行考虑和处理&lt;/p>
&lt;h4 id="数据项">数据项&lt;/h4>
&lt;p>构成数据元素的不可分割的最小单位&lt;/p>
&lt;h4 id="数据类型">数据类型&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/截图_2020031600212821SS.png" />&lt;/p>
&lt;h3 id="数据结构的三要素">数据结构的三要素&lt;/h3>
&lt;p>数据不是孤立的，他们存在着某种关系，这种&lt;strong>相互关系&lt;/strong>我们叫做&lt;strong>结构&lt;/strong>&lt;/p>
&lt;p>&lt;strong>数据结构&lt;/strong>是相互之间存在—种或多种特定关系的数据元素的集合&lt;/p>
&lt;p>&lt;strong>数据结构三要素&lt;/strong>：逻辑结构、物理结构、数据的运算&lt;/p>
&lt;h4 id="逻辑结构">逻辑结构&lt;/h4>
&lt;p>分为：线性结构、非线性结构（集合、树形结构、图状结构）&lt;/p>
&lt;p>与数据间的逻辑有关，与数据在计算机中如何存储无关&lt;/p>
&lt;h4 id="物理结构">物理结构&lt;/h4>
&lt;p>也称&lt;strong>存储结构&lt;/strong>&lt;/p>
&lt;p>数据在计算机中的存储，包括数据元素在计算机中的存储、数据元素间关系的存储&lt;/p>
&lt;p>分为：顺序存储、链式存储、索引存储、散列存储&lt;/p>
&lt;h4 id="数据的运算">数据的运算&lt;/h4>
&lt;p>运算（操作）包括运算的定义和实现，运算的定义针对逻辑结构，运算的实现针对存储结构&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/截图_202003160162706SS.png" />&lt;/p>
&lt;h2 id="算法和算法评价">算法和算法评价&lt;/h2>
&lt;h3 id="算法的基本概念">算法的基本概念&lt;/h3>
&lt;h5 id="算法">算法&lt;/h5>
&lt;p>对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。&lt;/p>
&lt;p>算法的特性：有穷，可行，确定，输入，输出&lt;/p>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>算法（指导者）&lt;/th>
&lt;th>程序（实施者）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有很多个算法。&lt;/td>
&lt;td>程序是某种程序设计语言对算法的具体实现。&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>必须有穷&lt;/td>
&lt;td>可以无穷&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>必须正确&lt;/td>
&lt;td>可以错误&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>可以用伪代码，程序语言等描述&lt;/td>
&lt;td>只能由程序语言编写并运行&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="算法效率的度量">算法效率的度量&lt;/h3>
&lt;h4 id="好算法的标准">好算法的标准&lt;/h4>
&lt;p>&lt;strong>正确性&lt;/strong>算法应能够正确地解决求解问题&lt;/p>
&lt;p>&lt;strong>可读性&lt;/strong>算法应具有良好的可读性，以帮助人们理解&lt;/p>
&lt;p>&lt;strong>健壮性&lt;/strong>输入非法数据时，算法能适应的做出反应或进行处理&lt;/p>
&lt;p>&lt;strong>效率与存储量&lt;/strong>效率是指算法执行时间，存储量需求是指算法执行过程中所需最大存储空间&lt;/p>
&lt;h4 id="时间复杂度">时间复杂度&lt;/h4>
&lt;h5 id="语句频度">语句频度&lt;/h5>
&lt;p>该条语句可能重复执行的次数&lt;/p>
&lt;h5 id="tn">T(n)&lt;/h5>
&lt;p>所有语句的频度之和，其中n为问题的规模&lt;/p>
&lt;h5 id="时间复杂度-1">时间复杂度&lt;/h5>
&lt;p>T(n)=O(f(n))，其中O表示T(n)与f(n)在&lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span>时为同阶无穷大。即两者相同数量级。&lt;/p>
&lt;p>最坏时间复杂度、最好时间复杂度、平均时间复杂度&lt;/p>
&lt;p>加法规则：&lt;span class="math inline">\(T(n)=T 1(n)+T 2(n)=O(f(n))+O(g(n))=O(\max (f(n), g(n))\)&lt;/span>&lt;/p>
&lt;p>乘法规则：&lt;span class="math inline">\(T(n)=T 1(n) * T 2(n)=O(f(n)) * O(g(n))=O(f(n) * g(n))\)&lt;/span>&lt;/p>
&lt;p>通常采用基本运算频度（最深撑循环中语句执行次数）采分析算法时间复杂度&lt;/p>
&lt;p>常见时间复杂度：&lt;/p>
&lt;p>&lt;span class="math inline">\(O(1)&amp;lt;O\left(\log _{2} n\right)&amp;lt;O(n)&amp;lt;O\left(n \log _{2} n\right)&amp;lt;O\left(n^{2}\right)&amp;lt;O\left(n^{3}\right)&amp;lt;O\left(2^{n}\right)&amp;lt;O(n !)&amp;lt;O\left(n^{n}\right)\)&lt;/span>&lt;/p>
&lt;h4 id="空间复杂度">空间复杂度&lt;/h4>
&lt;p>算法消耗的存储空间，记&lt;span class="math inline">\(S(n)=O(g(n))\)&lt;/span>&lt;/p>
&lt;p>即，除本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储为实现算法所需的一些信息的辅助空阆。&lt;/p>
&lt;p>&lt;strong>算法原地工作&lt;/strong>时指算法所需辅助空间为常量，O（1）&lt;/p></description></item><item><title>数据结构总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="树">树&lt;/h1>
&lt;h2 id="二叉树">二叉树&lt;/h2>
&lt;h2 id="二叉树搜索树">二叉树搜索树&lt;/h2>
&lt;h2 id="平衡二叉搜索树avl树">平衡二叉搜索树（AVL树）&lt;/h2>
&lt;p>参考：https://zhuanlan.zhihu.com/p/34899732 参考：https://oi-wiki.org/ds/avl/ 参考：https://www.jianshu.com/p/65c90aa1236d 参考：https://blog.csdn.net/wanderlustLee/article/details/81297253&lt;/p>
&lt;p>AVL树是，在二叉搜索树的前提下，能保证平衡的树。&lt;/p>
&lt;h3 id="avl树特点">AVL树特点&lt;/h3>
&lt;ul>
&lt;li>二叉搜索树的特点：对树上的任意节点，其左子树上的值都小于当前节点的值，其右子树上的值都大约当前节点的值&lt;/li>
&lt;li>平衡：对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）&lt;/li>
&lt;/ul>
&lt;h3 id="avl树的基本操作功能">AVL树的基本操作/功能&lt;/h3>
&lt;ul>
&lt;li>二叉搜索树的操作：插入/删除/搜索，可能还包括找上一个/下一个节点&lt;/li>
&lt;li>维持树的平衡&lt;/li>
&lt;/ul>
&lt;h3 id="维持树的平衡">维持树的平衡&lt;/h3>
&lt;h5 id="平衡条件是什么">平衡条件是什么？&lt;/h5>
&lt;p>对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）&lt;/p>
&lt;h5 id="什么原因会失去平衡哪些节点会失去平衡">什么原因会失去平衡，哪些节点会失去平衡？&lt;/h5>
&lt;p>假设当前的树已经平衡。当AVL树进行&lt;strong>插入/删除操作&lt;/strong>时，可能造成某些节点左右子树高度的变动，破坏树的平衡。 具体的说，插入/删除位置的&lt;strong>祖先节点可能会失去平衡&lt;/strong>。所以插入删除完成后，需要逆着查找路径，依次维护祖先节点的平衡性。&lt;/p>
&lt;h5 id="如何使失去平衡的某个节点恢复平衡">如何使失去平衡的某个节点恢复平衡？&lt;/h5>
&lt;p>我们要做的操作是，调整该节点处的左右子树高度，使其重新平衡。形象的描述就是要进行&lt;strong>旋转操作&lt;/strong>，使其重新平衡。&lt;/p>
&lt;p>左旋操作、右旋操作示意图：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/735527-1b4deeefc83a6e16.jpg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>实际上，一次旋转操作并不能保证使失去平衡的树恢复平衡。&lt;/p>
&lt;h5 id="不平衡情况">不平衡情况&lt;/h5>
&lt;p>前面说了插入/删除节点可能导致祖先节点失去平衡。以插入节点为例（删除类似），祖先节点具体&lt;strong>会有4种不平衡情况&lt;/strong>：LL、RR、LR、RL。下面具体说明。&lt;/p>
&lt;h6 id="在左孩子的左子树插入节点导致不平衡ll">在左孩子的左子树插入节点导致不平衡LL&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20144254.jpg" alt="" />&lt;figcaption>批注 2020-06-11 144254&lt;/figcaption>
&lt;/figure>
&lt;p>这种情况只需在失去平衡的节点Y处，进行一次左旋操作即可。&lt;/p>
&lt;h6 id="在右孩子的右子树插入节点导致不平衡rr">在右孩子的右子树插入节点导致不平衡RR&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20144827.jpg" alt="" />&lt;figcaption>批注 2020-06-11 144827&lt;/figcaption>
&lt;/figure>
&lt;p>这种情况只需在失去平衡的节点X处，进行一次右旋操作即可。&lt;/p>
&lt;h6 id="在左孩子的右子树插入节点导致不平衡lr">在左孩子的右子树插入节点导致不平衡LR&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20145834.jpg" alt="" />&lt;figcaption>批注 2020-06-11 145834&lt;/figcaption>
&lt;/figure>
&lt;p>这种情况需在失去平衡的节点的左子节点X处，先进行一次左旋操作，再在当前节点Y进行一次右旋操作即可。&lt;/p>
&lt;h6 id="在右孩子的左子树插入节点导致不平衡rl">在右孩子的左子树插入节点导致不平衡RL&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20150123.jpg" alt="" />&lt;figcaption>批注 2020-06-11 150123&lt;/figcaption>
&lt;/figure>
&lt;p>这种情况需在失去平衡的节点的右子节点处，先进行一次右旋操作，再在当前节点进行一次左旋操作即可。&lt;/p>
&lt;h3 id="java实现插入删除和中序遍历">java实现：（插入/删除和中序遍历）&lt;/h3>
&lt;div class="sourceCode" id="cb1">&lt;pre class="sourceCode java">&lt;code class="sourceCode java">&lt;span id="cb1-1">&lt;a href="#cb1-1">&lt;/a>&lt;span class="kw">package&lt;/span>&lt;span class="im"> com.jingmin.datastructure;&lt;/span>&lt;/span>
&lt;span id="cb1-2">&lt;a href="#cb1-2">&lt;/a>&lt;/span>
&lt;span id="cb1-3">&lt;a href="#cb1-3">&lt;/a>&lt;span class="kw">import&lt;/span>&lt;span class="im"> java.util.Scanner;&lt;/span>&lt;/span>
&lt;span id="cb1-4">&lt;a href="#cb1-4">&lt;/a>&lt;span class="kw">import&lt;/span>&lt;span class="im"> java.util.Stack;&lt;/span>&lt;/span>
&lt;span id="cb1-5">&lt;a href="#cb1-5">&lt;/a>&lt;/span>
&lt;span id="cb1-6">&lt;a href="#cb1-6">&lt;/a>&lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-7">&lt;a href="#cb1-7">&lt;/a> &lt;span class="co">* &lt;/span>&lt;span class="an">@author &lt;/span>&lt;span class="co">:&lt;/span> wangjm&lt;/span>
&lt;span id="cb1-8">&lt;a href="#cb1-8">&lt;/a> &lt;span class="co">*&lt;/span> &lt;span class="co">@&lt;/span>date &lt;span class="co">:&lt;/span> &lt;span class="co">2020/6/11&lt;/span> &lt;span class="co">16:38&lt;/span>&lt;/span>
&lt;span id="cb1-9">&lt;a href="#cb1-9">&lt;/a> &lt;span class="co">*&lt;/span> AVL树&lt;span class="co">(&lt;/span>插入&lt;span class="co">/&lt;/span>删除操作和中序遍历）&lt;/span>
&lt;span id="cb1-10">&lt;a href="#cb1-10">&lt;/a> &lt;span class="co">*&lt;/span> &lt;span class="kw">&amp;lt;p&amp;gt;&lt;/span>&lt;/span>
&lt;span id="cb1-11">&lt;a href="#cb1-11">&lt;/a> &lt;span class="co">*&lt;/span> 参考（过程和逻辑）：https&lt;span class="co">://&lt;/span>zhuanlan&lt;span class="co">.&lt;/span>zhihu&lt;span class="co">.&lt;/span>com&lt;span class="co">/&lt;/span>p&lt;span class="co">/34899732&lt;/span>&lt;/span>
&lt;span id="cb1-12">&lt;a href="#cb1-12">&lt;/a> &lt;span class="co">*&lt;/span> 参考（类结构和部分实现）：https&lt;span class="co">://&lt;/span>blog&lt;span class="co">.&lt;/span>csdn&lt;span class="co">.&lt;/span>net&lt;span class="co">/&lt;/span>qq_25806863&lt;span class="co">/&lt;/span>article&lt;span class="co">/&lt;/span>details&lt;span class="co">/74755131&lt;/span>&lt;/span>
&lt;span id="cb1-13">&lt;a href="#cb1-13">&lt;/a> &lt;span class="co">*&lt;/span> 相关题目&lt;span class="co">:&lt;/span> https&lt;span class="co">://&lt;/span>www&lt;span class="co">.&lt;/span>nowcoder&lt;span class="co">.&lt;/span>com&lt;span class="co">/&lt;/span>pat&lt;span class="co">/5/&lt;/span>problem&lt;span class="co">/4117&lt;/span>&lt;/span>
&lt;span id="cb1-14">&lt;a href="#cb1-14">&lt;/a> &lt;span class="co">*&lt;/span> &lt;span class="kw">&amp;lt;p&amp;gt;&lt;/span>&lt;/span>
&lt;span id="cb1-15">&lt;a href="#cb1-15">&lt;/a> &lt;span class="co">*&lt;/span> 注意：java里没有指针，在子节点的方法中，想修改父亲节点的对子节点的引用，需要借助递归+返回值&lt;/span>
&lt;span id="cb1-16">&lt;a href="#cb1-16">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-17">&lt;a href="#cb1-17">&lt;/a>&lt;span class="kw">public&lt;/span> &lt;span class="kw">class&lt;/span> AVLTree {&lt;/span>
&lt;span id="cb1-18">&lt;a href="#cb1-18">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-19">&lt;a href="#cb1-19">&lt;/a> &lt;span class="co">*&lt;/span> AVL树的根&lt;/span>
&lt;span id="cb1-20">&lt;a href="#cb1-20">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-21">&lt;a href="#cb1-21">&lt;/a> Node1024 root;&lt;/span>
&lt;span id="cb1-22">&lt;a href="#cb1-22">&lt;/a>&lt;/span>
&lt;span id="cb1-23">&lt;a href="#cb1-23">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-24">&lt;a href="#cb1-24">&lt;/a> &lt;span class="co">*&lt;/span> 插入操作&lt;/span>
&lt;span id="cb1-25">&lt;a href="#cb1-25">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-26">&lt;a href="#cb1-26">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">insert&lt;/span>(&lt;span class="dt">int&lt;/span> n) {&lt;/span>
&lt;span id="cb1-27">&lt;a href="#cb1-27">&lt;/a> root = &lt;span class="fu">insert&lt;/span>(root, n);&lt;/span>
&lt;span id="cb1-28">&lt;a href="#cb1-28">&lt;/a> }&lt;/span>
&lt;span id="cb1-29">&lt;a href="#cb1-29">&lt;/a>&lt;/span>
&lt;span id="cb1-30">&lt;a href="#cb1-30">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-31">&lt;a href="#cb1-31">&lt;/a> &lt;span class="co">*&lt;/span> 删除操作&lt;/span>
&lt;span id="cb1-32">&lt;a href="#cb1-32">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-33">&lt;a href="#cb1-33">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">delete&lt;/span>(&lt;span class="dt">int&lt;/span> n) {&lt;/span>
&lt;span id="cb1-34">&lt;a href="#cb1-34">&lt;/a> root = &lt;span class="fu">delete&lt;/span>(root, n);&lt;/span>
&lt;span id="cb1-35">&lt;a href="#cb1-35">&lt;/a> }&lt;/span>
&lt;span id="cb1-36">&lt;a href="#cb1-36">&lt;/a>&lt;/span>
&lt;span id="cb1-37">&lt;a href="#cb1-37">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">static&lt;/span> Node1024 &lt;span class="fu">insert&lt;/span>(Node1024 node, &lt;span class="dt">int&lt;/span> n) {&lt;/span>
&lt;span id="cb1-38">&lt;a href="#cb1-38">&lt;/a> &lt;span class="kw">if&lt;/span> (node == &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-39">&lt;a href="#cb1-39">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">new&lt;/span> &lt;span class="fu">Node1024&lt;/span>(n);&lt;/span>
&lt;span id="cb1-40">&lt;a href="#cb1-40">&lt;/a> }&lt;/span>
&lt;span id="cb1-41">&lt;a href="#cb1-41">&lt;/a> &lt;span class="co">//递归插入&lt;/span>&lt;/span>
&lt;span id="cb1-42">&lt;a href="#cb1-42">&lt;/a> &lt;span class="kw">if&lt;/span> (n &amp;lt; node.&lt;span class="fu">value&lt;/span>) {&lt;/span>
&lt;span id="cb1-43">&lt;a href="#cb1-43">&lt;/a> node.&lt;span class="fu">lChild&lt;/span> = &lt;span class="fu">insert&lt;/span>(node.&lt;span class="fu">lChild&lt;/span>, n);&lt;/span>
&lt;span id="cb1-44">&lt;a href="#cb1-44">&lt;/a> } &lt;span class="kw">else&lt;/span> &lt;span class="kw">if&lt;/span> (n &amp;gt; node.&lt;span class="fu">value&lt;/span>) {&lt;/span>
&lt;span id="cb1-45">&lt;a href="#cb1-45">&lt;/a> node.&lt;span class="fu">rChild&lt;/span> = &lt;span class="fu">insert&lt;/span>(node.&lt;span class="fu">rChild&lt;/span>, n);&lt;/span>
&lt;span id="cb1-46">&lt;a href="#cb1-46">&lt;/a> }&lt;/span>
&lt;span id="cb1-47">&lt;a href="#cb1-47">&lt;/a> &lt;span class="co">//使当前节点保持平衡&lt;/span>&lt;/span>
&lt;span id="cb1-48">&lt;a href="#cb1-48">&lt;/a> &lt;span class="co">// 注意，insert()是个递归函数，所以随后也逆着查找路径，逐级维护各祖先节点的平衡。&lt;/span>&lt;/span>
&lt;span id="cb1-49">&lt;a href="#cb1-49">&lt;/a> node = &lt;span class="fu">reBalance&lt;/span>(node);&lt;/span>
&lt;span id="cb1-50">&lt;a href="#cb1-50">&lt;/a> &lt;span class="co">//更新当前节点高度(就算插入后仍然平衡，但是高度可能会改变）&lt;/span>&lt;/span>
&lt;span id="cb1-51">&lt;a href="#cb1-51">&lt;/a> node.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-52">&lt;a href="#cb1-52">&lt;/a> &lt;span class="kw">return&lt;/span> node;&lt;/span>
&lt;span id="cb1-53">&lt;a href="#cb1-53">&lt;/a> }&lt;/span>
&lt;span id="cb1-54">&lt;a href="#cb1-54">&lt;/a>&lt;/span>
&lt;span id="cb1-55">&lt;a href="#cb1-55">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">static&lt;/span> Node1024 &lt;span class="fu">delete&lt;/span>(Node1024 node, &lt;span class="dt">int&lt;/span> n) {&lt;/span>
&lt;span id="cb1-56">&lt;a href="#cb1-56">&lt;/a> &lt;span class="kw">if&lt;/span> (node == &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-57">&lt;a href="#cb1-57">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">null&lt;/span>;&lt;/span>
&lt;span id="cb1-58">&lt;a href="#cb1-58">&lt;/a> }&lt;/span>
&lt;span id="cb1-59">&lt;a href="#cb1-59">&lt;/a> &lt;span class="co">//如果要删除的不是当前节点，递归去子节点删除&lt;/span>&lt;/span>
&lt;span id="cb1-60">&lt;a href="#cb1-60">&lt;/a> &lt;span class="kw">if&lt;/span> (n &amp;lt; node.&lt;span class="fu">value&lt;/span>) {&lt;/span>
&lt;span id="cb1-61">&lt;a href="#cb1-61">&lt;/a> node.&lt;span class="fu">lChild&lt;/span> = &lt;span class="fu">delete&lt;/span>(node.&lt;span class="fu">lChild&lt;/span>, n);&lt;/span>
&lt;span id="cb1-62">&lt;a href="#cb1-62">&lt;/a> } &lt;span class="kw">else&lt;/span> &lt;span class="kw">if&lt;/span> (n &amp;gt; node.&lt;span class="fu">value&lt;/span>) {&lt;/span>
&lt;span id="cb1-63">&lt;a href="#cb1-63">&lt;/a> node.&lt;span class="fu">rChild&lt;/span> = &lt;span class="fu">delete&lt;/span>(node.&lt;span class="fu">rChild&lt;/span>, n);&lt;/span>
&lt;span id="cb1-64">&lt;a href="#cb1-64">&lt;/a> } &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-65">&lt;a href="#cb1-65">&lt;/a> &lt;span class="co">//如果删除的就是本节点，考虑本节点是叶子/单链/满分支&lt;/span>&lt;/span>
&lt;span id="cb1-66">&lt;a href="#cb1-66">&lt;/a> &lt;span class="kw">if&lt;/span> (node.&lt;span class="fu">lChild&lt;/span> != &lt;span class="kw">null&lt;/span> &amp;amp;&amp;amp; node.&lt;span class="fu">rChild&lt;/span> != &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-67">&lt;a href="#cb1-67">&lt;/a> &lt;span class="co">//满分支情况&lt;/span>&lt;/span>
&lt;span id="cb1-68">&lt;a href="#cb1-68">&lt;/a> &lt;span class="co">//去右子树找下一个节点(一定是个叶子），换到当前位置&lt;/span>&lt;/span>
&lt;span id="cb1-69">&lt;a href="#cb1-69">&lt;/a> Node1024 min = node.&lt;span class="fu">rChild&lt;/span>;&lt;/span>
&lt;span id="cb1-70">&lt;a href="#cb1-70">&lt;/a> &lt;span class="kw">while&lt;/span> (min.&lt;span class="fu">lChild&lt;/span> != &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-71">&lt;a href="#cb1-71">&lt;/a> min = min.&lt;span class="fu">lChild&lt;/span>;&lt;/span>
&lt;span id="cb1-72">&lt;a href="#cb1-72">&lt;/a> }&lt;/span>
&lt;span id="cb1-73">&lt;a href="#cb1-73">&lt;/a> min.&lt;span class="fu">rChild&lt;/span> = &lt;span class="fu">delete&lt;/span>(node.&lt;span class="fu">rChild&lt;/span>, min.&lt;span class="fu">value&lt;/span>);&lt;/span>
&lt;span id="cb1-74">&lt;a href="#cb1-74">&lt;/a> min.&lt;span class="fu">lChild&lt;/span> = node.&lt;span class="fu">lChild&lt;/span>;&lt;/span>
&lt;span id="cb1-75">&lt;a href="#cb1-75">&lt;/a> node = min;&lt;/span>
&lt;span id="cb1-76">&lt;a href="#cb1-76">&lt;/a> } &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-77">&lt;a href="#cb1-77">&lt;/a> &lt;span class="co">//单链/叶子情况&lt;/span>&lt;/span>
&lt;span id="cb1-78">&lt;a href="#cb1-78">&lt;/a> node = (node.&lt;span class="fu">lChild&lt;/span> != &lt;span class="kw">null&lt;/span>) ? node.&lt;span class="fu">lChild&lt;/span> : node.&lt;span class="fu">rChild&lt;/span>;&lt;/span>
&lt;span id="cb1-79">&lt;a href="#cb1-79">&lt;/a> }&lt;/span>
&lt;span id="cb1-80">&lt;a href="#cb1-80">&lt;/a> }&lt;/span>
&lt;span id="cb1-81">&lt;a href="#cb1-81">&lt;/a> &lt;span class="co">//叶子节点删掉就没了，不需要如下操作。&lt;/span>&lt;/span>
&lt;span id="cb1-82">&lt;a href="#cb1-82">&lt;/a> &lt;span class="kw">if&lt;/span> (node != &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-83">&lt;a href="#cb1-83">&lt;/a> &lt;span class="co">//重新平衡&lt;/span>&lt;/span>
&lt;span id="cb1-84">&lt;a href="#cb1-84">&lt;/a> node = &lt;span class="fu">reBalance&lt;/span>(node);&lt;/span>
&lt;span id="cb1-85">&lt;a href="#cb1-85">&lt;/a> &lt;span class="co">//更新当前节点高度&lt;/span>&lt;/span>
&lt;span id="cb1-86">&lt;a href="#cb1-86">&lt;/a> node.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-87">&lt;a href="#cb1-87">&lt;/a> }&lt;/span>
&lt;span id="cb1-88">&lt;a href="#cb1-88">&lt;/a> &lt;span class="kw">return&lt;/span> node;&lt;/span>
&lt;span id="cb1-89">&lt;a href="#cb1-89">&lt;/a> }&lt;/span>
&lt;span id="cb1-90">&lt;a href="#cb1-90">&lt;/a>&lt;/span>
&lt;span id="cb1-91">&lt;a href="#cb1-91">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> Node1024 &lt;span class="fu">reBalance&lt;/span>(Node1024 node) {&lt;/span>
&lt;span id="cb1-92">&lt;a href="#cb1-92">&lt;/a> &lt;span class="dt">int&lt;/span> factor = node.&lt;span class="fu">getFactor&lt;/span>();&lt;/span>
&lt;span id="cb1-93">&lt;a href="#cb1-93">&lt;/a> &lt;span class="kw">if&lt;/span> (factor &amp;gt; &lt;span class="dv">1&lt;/span>) {&lt;/span>
&lt;span id="cb1-94">&lt;a href="#cb1-94">&lt;/a> &lt;span class="kw">if&lt;/span> (node.&lt;span class="fu">lChild&lt;/span>.&lt;span class="fu">getFactor&lt;/span>() &amp;gt; &lt;span class="dv">0&lt;/span>) {&lt;/span>
&lt;span id="cb1-95">&lt;a href="#cb1-95">&lt;/a> &lt;span class="co">//LL不平衡情形，单次右旋&lt;/span>&lt;/span>
&lt;span id="cb1-96">&lt;a href="#cb1-96">&lt;/a> node = &lt;span class="fu">rightRotate&lt;/span>(node);&lt;/span>
&lt;span id="cb1-97">&lt;a href="#cb1-97">&lt;/a> } &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-98">&lt;a href="#cb1-98">&lt;/a> &lt;span class="co">//LR不平衡情形，先左旋，再右旋&lt;/span>&lt;/span>
&lt;span id="cb1-99">&lt;a href="#cb1-99">&lt;/a> node.&lt;span class="fu">lChild&lt;/span> = &lt;span class="fu">leftRotate&lt;/span>(node.&lt;span class="fu">lChild&lt;/span>);&lt;/span>
&lt;span id="cb1-100">&lt;a href="#cb1-100">&lt;/a> node = &lt;span class="fu">rightRotate&lt;/span>(node);&lt;/span>
&lt;span id="cb1-101">&lt;a href="#cb1-101">&lt;/a> }&lt;/span>
&lt;span id="cb1-102">&lt;a href="#cb1-102">&lt;/a> } &lt;span class="kw">else&lt;/span> &lt;span class="kw">if&lt;/span> (factor &amp;lt; -&lt;span class="dv">1&lt;/span>) {&lt;/span>
&lt;span id="cb1-103">&lt;a href="#cb1-103">&lt;/a> &lt;span class="kw">if&lt;/span> (node.&lt;span class="fu">rChild&lt;/span>.&lt;span class="fu">getFactor&lt;/span>() &amp;gt; &lt;span class="dv">0&lt;/span>) {&lt;/span>
&lt;span id="cb1-104">&lt;a href="#cb1-104">&lt;/a> &lt;span class="co">//RL不平衡情形，先右旋，再左旋&lt;/span>&lt;/span>
&lt;span id="cb1-105">&lt;a href="#cb1-105">&lt;/a> node.&lt;span class="fu">rChild&lt;/span> = &lt;span class="fu">rightRotate&lt;/span>(node.&lt;span class="fu">rChild&lt;/span>);&lt;/span>
&lt;span id="cb1-106">&lt;a href="#cb1-106">&lt;/a> node = &lt;span class="fu">leftRotate&lt;/span>(node);&lt;/span>
&lt;span id="cb1-107">&lt;a href="#cb1-107">&lt;/a> } &lt;span class="kw">else&lt;/span> {&lt;/span>
&lt;span id="cb1-108">&lt;a href="#cb1-108">&lt;/a> &lt;span class="co">//RR不平衡情形，单次左旋&lt;/span>&lt;/span>
&lt;span id="cb1-109">&lt;a href="#cb1-109">&lt;/a> node = &lt;span class="fu">leftRotate&lt;/span>(node);&lt;/span>
&lt;span id="cb1-110">&lt;a href="#cb1-110">&lt;/a> }&lt;/span>
&lt;span id="cb1-111">&lt;a href="#cb1-111">&lt;/a> }&lt;/span>
&lt;span id="cb1-112">&lt;a href="#cb1-112">&lt;/a> &lt;span class="kw">return&lt;/span> node;&lt;/span>
&lt;span id="cb1-113">&lt;a href="#cb1-113">&lt;/a> }&lt;/span>
&lt;span id="cb1-114">&lt;a href="#cb1-114">&lt;/a>&lt;/span>
&lt;span id="cb1-115">&lt;a href="#cb1-115">&lt;/a>&lt;/span>
&lt;span id="cb1-116">&lt;a href="#cb1-116">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-117">&lt;a href="#cb1-117">&lt;/a> &lt;span class="co">*&lt;/span> 右旋操作&lt;/span>
&lt;span id="cb1-118">&lt;a href="#cb1-118">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-119">&lt;a href="#cb1-119">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> Node1024 &lt;span class="fu">rightRotate&lt;/span>(Node1024 root) {&lt;/span>
&lt;span id="cb1-120">&lt;a href="#cb1-120">&lt;/a> &lt;span class="co">//右旋操作&lt;/span>&lt;/span>
&lt;span id="cb1-121">&lt;a href="#cb1-121">&lt;/a> Node1024 left = root.&lt;span class="fu">lChild&lt;/span>;&lt;/span>
&lt;span id="cb1-122">&lt;a href="#cb1-122">&lt;/a> root.&lt;span class="fu">lChild&lt;/span> = left.&lt;span class="fu">rChild&lt;/span>;&lt;/span>
&lt;span id="cb1-123">&lt;a href="#cb1-123">&lt;/a> left.&lt;span class="fu">rChild&lt;/span> = root;&lt;/span>
&lt;span id="cb1-124">&lt;a href="#cb1-124">&lt;/a> &lt;span class="co">//更新高度(root旋转到了较下面的位置，要先更新高度）&lt;/span>&lt;/span>
&lt;span id="cb1-125">&lt;a href="#cb1-125">&lt;/a> root.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-126">&lt;a href="#cb1-126">&lt;/a> left.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-127">&lt;a href="#cb1-127">&lt;/a> &lt;span class="co">//返回新的上级节点&lt;/span>&lt;/span>
&lt;span id="cb1-128">&lt;a href="#cb1-128">&lt;/a> &lt;span class="kw">return&lt;/span> left;&lt;/span>
&lt;span id="cb1-129">&lt;a href="#cb1-129">&lt;/a> }&lt;/span>
&lt;span id="cb1-130">&lt;a href="#cb1-130">&lt;/a>&lt;/span>
&lt;span id="cb1-131">&lt;a href="#cb1-131">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-132">&lt;a href="#cb1-132">&lt;/a> &lt;span class="co">*&lt;/span> 左旋操作&lt;/span>
&lt;span id="cb1-133">&lt;a href="#cb1-133">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-134">&lt;a href="#cb1-134">&lt;/a> &lt;span class="kw">private&lt;/span> &lt;span class="dt">static&lt;/span> Node1024 &lt;span class="fu">leftRotate&lt;/span>(Node1024 root) {&lt;/span>
&lt;span id="cb1-135">&lt;a href="#cb1-135">&lt;/a> &lt;span class="co">//左旋操作&lt;/span>&lt;/span>
&lt;span id="cb1-136">&lt;a href="#cb1-136">&lt;/a> Node1024 right = root.&lt;span class="fu">rChild&lt;/span>;&lt;/span>
&lt;span id="cb1-137">&lt;a href="#cb1-137">&lt;/a> root.&lt;span class="fu">rChild&lt;/span> = right.&lt;span class="fu">lChild&lt;/span>;&lt;/span>
&lt;span id="cb1-138">&lt;a href="#cb1-138">&lt;/a> right.&lt;span class="fu">lChild&lt;/span> = root;&lt;/span>
&lt;span id="cb1-139">&lt;a href="#cb1-139">&lt;/a> &lt;span class="co">//更新高度&lt;/span>&lt;/span>
&lt;span id="cb1-140">&lt;a href="#cb1-140">&lt;/a> root.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-141">&lt;a href="#cb1-141">&lt;/a> right.&lt;span class="fu">setHeight&lt;/span>();&lt;/span>
&lt;span id="cb1-142">&lt;a href="#cb1-142">&lt;/a> &lt;span class="kw">return&lt;/span> right;&lt;/span>
&lt;span id="cb1-143">&lt;a href="#cb1-143">&lt;/a> }&lt;/span>
&lt;span id="cb1-144">&lt;a href="#cb1-144">&lt;/a>&lt;/span>
&lt;span id="cb1-145">&lt;a href="#cb1-145">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-146">&lt;a href="#cb1-146">&lt;/a> &lt;span class="co">*&lt;/span> 中序遍历&lt;/span>
&lt;span id="cb1-147">&lt;a href="#cb1-147">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-148">&lt;a href="#cb1-148">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="bu">String&lt;/span> &lt;span class="fu">inOrderTraversal&lt;/span>() {&lt;/span>
&lt;span id="cb1-149">&lt;a href="#cb1-149">&lt;/a> &lt;span class="kw">if&lt;/span> (&lt;span class="kw">this&lt;/span>.&lt;span class="fu">root&lt;/span> == &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-150">&lt;a href="#cb1-150">&lt;/a> &lt;span class="kw">return&lt;/span> &lt;span class="kw">null&lt;/span>;&lt;/span>
&lt;span id="cb1-151">&lt;a href="#cb1-151">&lt;/a> }&lt;/span>
&lt;span id="cb1-152">&lt;a href="#cb1-152">&lt;/a> Node1024 node = root;&lt;/span>
&lt;span id="cb1-153">&lt;a href="#cb1-153">&lt;/a> &lt;span class="bu">Stack&lt;/span>&amp;lt;Node1024&amp;gt; stack = &lt;span class="kw">new&lt;/span> &lt;span class="bu">Stack&lt;/span>&amp;lt;&amp;gt;();&lt;/span>
&lt;span id="cb1-154">&lt;a href="#cb1-154">&lt;/a> &lt;span class="bu">StringBuilder&lt;/span> sb = &lt;span class="kw">new&lt;/span> &lt;span class="bu">StringBuilder&lt;/span>();&lt;/span>
&lt;span id="cb1-155">&lt;a href="#cb1-155">&lt;/a> &lt;span class="kw">while&lt;/span> (node != &lt;span class="kw">null&lt;/span> || !stack.&lt;span class="fu">isEmpty&lt;/span>()) {&lt;/span>
&lt;span id="cb1-156">&lt;a href="#cb1-156">&lt;/a> &lt;span class="kw">while&lt;/span> (node != &lt;span class="kw">null&lt;/span>) {&lt;/span>
&lt;span id="cb1-157">&lt;a href="#cb1-157">&lt;/a> stack.&lt;span class="fu">push&lt;/span>(node);&lt;/span>
&lt;span id="cb1-158">&lt;a href="#cb1-158">&lt;/a> node = node.&lt;span class="fu">lChild&lt;/span>;&lt;/span>
&lt;span id="cb1-159">&lt;a href="#cb1-159">&lt;/a> }&lt;/span>
&lt;span id="cb1-160">&lt;a href="#cb1-160">&lt;/a> &lt;span class="kw">if&lt;/span> (!stack.&lt;span class="fu">isEmpty&lt;/span>()) {&lt;/span>
&lt;span id="cb1-161">&lt;a href="#cb1-161">&lt;/a> node = stack.&lt;span class="fu">pop&lt;/span>();&lt;/span>
&lt;span id="cb1-162">&lt;a href="#cb1-162">&lt;/a> sb.&lt;span class="fu">append&lt;/span>(node.&lt;span class="fu">value&lt;/span>).&lt;span class="fu">append&lt;/span>(&lt;span class="st">&amp;quot; &amp;quot;&lt;/span>);&lt;/span>
&lt;span id="cb1-163">&lt;a href="#cb1-163">&lt;/a> node = node.&lt;span class="fu">rChild&lt;/span>;&lt;/span>
&lt;span id="cb1-164">&lt;a href="#cb1-164">&lt;/a> }&lt;/span>
&lt;span id="cb1-165">&lt;a href="#cb1-165">&lt;/a> }&lt;/span>
&lt;span id="cb1-166">&lt;a href="#cb1-166">&lt;/a> &lt;span class="kw">if&lt;/span> (sb.&lt;span class="fu">length&lt;/span>() &amp;gt; &lt;span class="dv">0&lt;/span>) {&lt;/span>
&lt;span id="cb1-167">&lt;a href="#cb1-167">&lt;/a> sb.&lt;span class="fu">setLength&lt;/span>(sb.&lt;span class="fu">length&lt;/span>() - &lt;span class="dv">1&lt;/span>);&lt;/span>
&lt;span id="cb1-168">&lt;a href="#cb1-168">&lt;/a> }&lt;/span>
&lt;span id="cb1-169">&lt;a href="#cb1-169">&lt;/a> &lt;span class="kw">return&lt;/span> sb.&lt;span class="fu">toString&lt;/span>();&lt;/span>
&lt;span id="cb1-170">&lt;a href="#cb1-170">&lt;/a> }&lt;/span>
&lt;span id="cb1-171">&lt;a href="#cb1-171">&lt;/a>&lt;/span>
&lt;span id="cb1-172">&lt;a href="#cb1-172">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-173">&lt;a href="#cb1-173">&lt;/a> &lt;span class="co">*&lt;/span> 测试&lt;/span>
&lt;span id="cb1-174">&lt;a href="#cb1-174">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-175">&lt;a href="#cb1-175">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">static&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">main&lt;/span>(&lt;span class="bu">String&lt;/span>[] args) {&lt;/span>
&lt;span id="cb1-176">&lt;a href="#cb1-176">&lt;/a> &lt;span class="bu">Scanner&lt;/span> scanner = &lt;span class="kw">new&lt;/span> &lt;span class="bu">Scanner&lt;/span>(&lt;span class="bu">System&lt;/span>.&lt;span class="fu">in&lt;/span>);&lt;/span>
&lt;span id="cb1-177">&lt;a href="#cb1-177">&lt;/a> &lt;span class="dt">int&lt;/span> n = scanner.&lt;span class="fu">nextInt&lt;/span>();&lt;/span>
&lt;span id="cb1-178">&lt;a href="#cb1-178">&lt;/a> AVLTree tree = &lt;span class="kw">new&lt;/span> &lt;span class="fu">AVLTree&lt;/span>();&lt;/span>
&lt;span id="cb1-179">&lt;a href="#cb1-179">&lt;/a> &lt;span class="kw">for&lt;/span> (&lt;span class="dt">int&lt;/span> i = &lt;span class="dv">0&lt;/span>; i &amp;lt; n; i++) {&lt;/span>
&lt;span id="cb1-180">&lt;a href="#cb1-180">&lt;/a> tree.&lt;span class="fu">insert&lt;/span>(scanner.&lt;span class="fu">nextInt&lt;/span>());&lt;/span>
&lt;span id="cb1-181">&lt;a href="#cb1-181">&lt;/a> }&lt;/span>
&lt;span id="cb1-182">&lt;a href="#cb1-182">&lt;/a> scanner.&lt;span class="fu">close&lt;/span>();&lt;/span>
&lt;span id="cb1-183">&lt;a href="#cb1-183">&lt;/a> &lt;span class="bu">System&lt;/span>.&lt;span class="fu">out&lt;/span>.&lt;span class="fu">println&lt;/span>(tree.&lt;span class="fu">root&lt;/span>.&lt;span class="fu">value&lt;/span>);&lt;/span>
&lt;span id="cb1-184">&lt;a href="#cb1-184">&lt;/a>&lt;span class="co">// System.out.println(tree.inOrderTraversal());&lt;/span>&lt;/span>
&lt;span id="cb1-185">&lt;a href="#cb1-185">&lt;/a>&lt;span class="co">// System.out.println(&amp;quot;Delete 80:&amp;quot;);&lt;/span>&lt;/span>
&lt;span id="cb1-186">&lt;a href="#cb1-186">&lt;/a>&lt;span class="co">// tree.delete(80);&lt;/span>&lt;/span>
&lt;span id="cb1-187">&lt;a href="#cb1-187">&lt;/a>&lt;span class="co">// System.out.println(tree.inOrderTraversal());&lt;/span>&lt;/span>
&lt;span id="cb1-188">&lt;a href="#cb1-188">&lt;/a>&lt;span class="co">// System.out.println(&amp;quot;Delete 88:&amp;quot;);&lt;/span>&lt;/span>
&lt;span id="cb1-189">&lt;a href="#cb1-189">&lt;/a>&lt;span class="co">// tree.delete(88);&lt;/span>&lt;/span>
&lt;span id="cb1-190">&lt;a href="#cb1-190">&lt;/a>&lt;span class="co">// System.out.println(tree.inOrderTraversal());&lt;/span>&lt;/span>
&lt;span id="cb1-191">&lt;a href="#cb1-191">&lt;/a>&lt;span class="co">// System.out.println(&amp;quot;Delete 70:&amp;quot;);&lt;/span>&lt;/span>
&lt;span id="cb1-192">&lt;a href="#cb1-192">&lt;/a>&lt;span class="co">// tree.delete(70);&lt;/span>&lt;/span>
&lt;span id="cb1-193">&lt;a href="#cb1-193">&lt;/a>&lt;span class="co">// System.out.println(tree.inOrderTraversal());&lt;/span>&lt;/span>
&lt;span id="cb1-194">&lt;a href="#cb1-194">&lt;/a> }&lt;/span>
&lt;span id="cb1-195">&lt;a href="#cb1-195">&lt;/a>}&lt;/span>
&lt;span id="cb1-196">&lt;a href="#cb1-196">&lt;/a>&lt;/span>
&lt;span id="cb1-197">&lt;a href="#cb1-197">&lt;/a>&lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-198">&lt;a href="#cb1-198">&lt;/a> &lt;span class="co">*&lt;/span> AVL树节点&lt;/span>
&lt;span id="cb1-199">&lt;a href="#cb1-199">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-200">&lt;a href="#cb1-200">&lt;/a>&lt;span class="kw">class&lt;/span> Node1024 {&lt;/span>
&lt;span id="cb1-201">&lt;a href="#cb1-201">&lt;/a> &lt;span class="dt">int&lt;/span> height;&lt;/span>
&lt;span id="cb1-202">&lt;a href="#cb1-202">&lt;/a> &lt;span class="dt">int&lt;/span> value;&lt;/span>
&lt;span id="cb1-203">&lt;a href="#cb1-203">&lt;/a> Node1024 lChild, rChild;&lt;/span>
&lt;span id="cb1-204">&lt;a href="#cb1-204">&lt;/a>&lt;/span>
&lt;span id="cb1-205">&lt;a href="#cb1-205">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="fu">Node1024&lt;/span>(&lt;span class="dt">int&lt;/span> value) {&lt;/span>
&lt;span id="cb1-206">&lt;a href="#cb1-206">&lt;/a> &lt;span class="kw">this&lt;/span>.&lt;span class="fu">value&lt;/span> = value;&lt;/span>
&lt;span id="cb1-207">&lt;a href="#cb1-207">&lt;/a> &lt;span class="kw">this&lt;/span>.&lt;span class="fu">height&lt;/span> = &lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb1-208">&lt;a href="#cb1-208">&lt;/a> }&lt;/span>
&lt;span id="cb1-209">&lt;a href="#cb1-209">&lt;/a>&lt;/span>
&lt;span id="cb1-210">&lt;a href="#cb1-210">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-211">&lt;a href="#cb1-211">&lt;/a> &lt;span class="co">*&lt;/span> 更新节点的高度&lt;/span>
&lt;span id="cb1-212">&lt;a href="#cb1-212">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-213">&lt;a href="#cb1-213">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">void&lt;/span> &lt;span class="fu">setHeight&lt;/span>() {&lt;/span>
&lt;span id="cb1-214">&lt;a href="#cb1-214">&lt;/a> &lt;span class="dt">int&lt;/span> lHeight = &lt;span class="kw">this&lt;/span>.&lt;span class="fu">lChild&lt;/span> == &lt;span class="kw">null&lt;/span> ? &lt;span class="dv">0&lt;/span> : &lt;span class="kw">this&lt;/span>.&lt;span class="fu">lChild&lt;/span>.&lt;span class="fu">height&lt;/span>;&lt;/span>
&lt;span id="cb1-215">&lt;a href="#cb1-215">&lt;/a> &lt;span class="dt">int&lt;/span> rHeight = &lt;span class="kw">this&lt;/span>.&lt;span class="fu">rChild&lt;/span> == &lt;span class="kw">null&lt;/span> ? &lt;span class="dv">0&lt;/span> : &lt;span class="kw">this&lt;/span>.&lt;span class="fu">rChild&lt;/span>.&lt;span class="fu">height&lt;/span>;&lt;/span>
&lt;span id="cb1-216">&lt;a href="#cb1-216">&lt;/a> &lt;span class="kw">this&lt;/span>.&lt;span class="fu">height&lt;/span> = &lt;span class="dv">1&lt;/span> + (lHeight &amp;gt; rHeight ? lHeight : rHeight);&lt;/span>
&lt;span id="cb1-217">&lt;a href="#cb1-217">&lt;/a> }&lt;/span>
&lt;span id="cb1-218">&lt;a href="#cb1-218">&lt;/a>&lt;/span>
&lt;span id="cb1-219">&lt;a href="#cb1-219">&lt;/a> &lt;span class="co">/**&lt;/span>&lt;/span>
&lt;span id="cb1-220">&lt;a href="#cb1-220">&lt;/a> &lt;span class="co">*&lt;/span> 计算平衡因子&lt;/span>
&lt;span id="cb1-221">&lt;a href="#cb1-221">&lt;/a> &lt;span class="co">*/&lt;/span>&lt;/span>
&lt;span id="cb1-222">&lt;a href="#cb1-222">&lt;/a> &lt;span class="kw">public&lt;/span> &lt;span class="dt">int&lt;/span> &lt;span class="fu">getFactor&lt;/span>() {&lt;/span>
&lt;span id="cb1-223">&lt;a href="#cb1-223">&lt;/a> &lt;span class="dt">int&lt;/span> lHeight = &lt;span class="kw">this&lt;/span>.&lt;span class="fu">lChild&lt;/span> == &lt;span class="kw">null&lt;/span> ? &lt;span class="dv">0&lt;/span> : &lt;span class="kw">this&lt;/span>.&lt;span class="fu">lChild&lt;/span>.&lt;span class="fu">height&lt;/span>;&lt;/span>
&lt;span id="cb1-224">&lt;a href="#cb1-224">&lt;/a> &lt;span class="dt">int&lt;/span> rHeight = &lt;span class="kw">this&lt;/span>.&lt;span class="fu">rChild&lt;/span> == &lt;span class="kw">null&lt;/span> ? &lt;span class="dv">0&lt;/span> : &lt;span class="kw">this&lt;/span>.&lt;span class="fu">rChild&lt;/span>.&lt;span class="fu">height&lt;/span>;&lt;/span>
&lt;span id="cb1-225">&lt;a href="#cb1-225">&lt;/a> &lt;span class="kw">return&lt;/span> lHeight - rHeight;&lt;/span>
&lt;span id="cb1-226">&lt;a href="#cb1-226">&lt;/a> }&lt;/span>
&lt;span id="cb1-227">&lt;a href="#cb1-227">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="c实现仅插入操作">c++实现：（仅插入操作）&lt;/h3>
&lt;div class="sourceCode" id="cb2">&lt;pre class="sourceCode cpp">&lt;code class="sourceCode cpp">&lt;span id="cb2-1">&lt;a href="#cb2-1">&lt;/a>&lt;span class="co">//来源：牛客网牛友提交的答案&lt;/span>&lt;/span>
&lt;span id="cb2-2">&lt;a href="#cb2-2">&lt;/a>&lt;span class="co">//https://www.nowcoder.com/profile/4547010/codeBookDetail?submissionId=8196767&lt;/span>&lt;/span>
&lt;span id="cb2-3">&lt;a href="#cb2-3">&lt;/a>&lt;span class="pp">#include &lt;/span>&lt;span class="im">&amp;lt;iostream&amp;gt;&lt;/span>&lt;/span>
&lt;span id="cb2-4">&lt;a href="#cb2-4">&lt;/a>&lt;span class="pp">#include &lt;/span>&lt;span class="im">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;/span>
&lt;span id="cb2-5">&lt;a href="#cb2-5">&lt;/a>&lt;span class="pp">#include &lt;/span>&lt;span class="im">&amp;lt;string&amp;gt;&lt;/span>&lt;/span>
&lt;span id="cb2-6">&lt;a href="#cb2-6">&lt;/a>&lt;span class="kw">using&lt;/span> &lt;span class="kw">namespace&lt;/span> std;&lt;/span>
&lt;span id="cb2-7">&lt;a href="#cb2-7">&lt;/a> &lt;/span>
&lt;span id="cb2-8">&lt;a href="#cb2-8">&lt;/a>&lt;span class="kw">struct&lt;/span> node&lt;/span>
&lt;span id="cb2-9">&lt;a href="#cb2-9">&lt;/a>{&lt;/span>
&lt;span id="cb2-10">&lt;a href="#cb2-10">&lt;/a> &lt;span class="dt">int&lt;/span> v,h;&lt;/span>
&lt;span id="cb2-11">&lt;a href="#cb2-11">&lt;/a> node *l,*r;&lt;/span>
&lt;span id="cb2-12">&lt;a href="#cb2-12">&lt;/a>};&lt;/span>
&lt;span id="cb2-13">&lt;a href="#cb2-13">&lt;/a> &lt;/span>
&lt;span id="cb2-14">&lt;a href="#cb2-14">&lt;/a>node tree[&lt;span class="dv">22&lt;/span>];&lt;/span>
&lt;span id="cb2-15">&lt;a href="#cb2-15">&lt;/a>&lt;span class="dt">int&lt;/span> sum;&lt;/span>
&lt;span id="cb2-16">&lt;a href="#cb2-16">&lt;/a> &lt;/span>
&lt;span id="cb2-17">&lt;a href="#cb2-17">&lt;/a>&lt;span class="dt">int&lt;/span> H(node *a)&lt;/span>
&lt;span id="cb2-18">&lt;a href="#cb2-18">&lt;/a>{&lt;/span>
&lt;span id="cb2-19">&lt;a href="#cb2-19">&lt;/a> &lt;span class="cf">return&lt;/span> a?(a-&amp;gt;h):(-&lt;span class="dv">1&lt;/span>);&lt;/span>
&lt;span id="cb2-20">&lt;a href="#cb2-20">&lt;/a>}&lt;/span>
&lt;span id="cb2-21">&lt;a href="#cb2-21">&lt;/a> &lt;/span>
&lt;span id="cb2-22">&lt;a href="#cb2-22">&lt;/a>node *LL(node *k1)&lt;/span>
&lt;span id="cb2-23">&lt;a href="#cb2-23">&lt;/a>{&lt;/span>
&lt;span id="cb2-24">&lt;a href="#cb2-24">&lt;/a> node *k2 = k1-&amp;gt;l;&lt;/span>
&lt;span id="cb2-25">&lt;a href="#cb2-25">&lt;/a> k1-&amp;gt;l = k2-&amp;gt;r;&lt;/span>
&lt;span id="cb2-26">&lt;a href="#cb2-26">&lt;/a> k2-&amp;gt;r = k1;&lt;/span>
&lt;span id="cb2-27">&lt;a href="#cb2-27">&lt;/a> k1-&amp;gt;h = max(H(k1-&amp;gt;l),H(k1-&amp;gt;r))+&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb2-28">&lt;a href="#cb2-28">&lt;/a> k2-&amp;gt;h = max(H(k2-&amp;gt;l),H(k2-&amp;gt;r))+&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb2-29">&lt;a href="#cb2-29">&lt;/a> &lt;span class="cf">return&lt;/span> k2;&lt;/span>
&lt;span id="cb2-30">&lt;a href="#cb2-30">&lt;/a>}&lt;/span>
&lt;span id="cb2-31">&lt;a href="#cb2-31">&lt;/a> &lt;/span>
&lt;span id="cb2-32">&lt;a href="#cb2-32">&lt;/a>node *RR(node *k1)&lt;/span>
&lt;span id="cb2-33">&lt;a href="#cb2-33">&lt;/a>{&lt;/span>
&lt;span id="cb2-34">&lt;a href="#cb2-34">&lt;/a> node *k2 = k1-&amp;gt;r;&lt;/span>
&lt;span id="cb2-35">&lt;a href="#cb2-35">&lt;/a> k1-&amp;gt;r = k2-&amp;gt;l;&lt;/span>
&lt;span id="cb2-36">&lt;a href="#cb2-36">&lt;/a> k2-&amp;gt;l = k1;&lt;/span>
&lt;span id="cb2-37">&lt;a href="#cb2-37">&lt;/a> k1-&amp;gt;h = max(H(k1-&amp;gt;l),H(k1-&amp;gt;r))+&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb2-38">&lt;a href="#cb2-38">&lt;/a> k2-&amp;gt;h = max(H(k2-&amp;gt;l),H(k2-&amp;gt;r))+&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb2-39">&lt;a href="#cb2-39">&lt;/a> &lt;span class="cf">return&lt;/span> k2;&lt;/span>
&lt;span id="cb2-40">&lt;a href="#cb2-40">&lt;/a>}&lt;/span>
&lt;span id="cb2-41">&lt;a href="#cb2-41">&lt;/a> &lt;/span>
&lt;span id="cb2-42">&lt;a href="#cb2-42">&lt;/a>node *LR(node *k1)&lt;/span>
&lt;span id="cb2-43">&lt;a href="#cb2-43">&lt;/a>{&lt;/span>
&lt;span id="cb2-44">&lt;a href="#cb2-44">&lt;/a> k1-&amp;gt;l = RR(k1-&amp;gt;l);&lt;/span>
&lt;span id="cb2-45">&lt;a href="#cb2-45">&lt;/a> &lt;span class="cf">return&lt;/span> LL(k1);&lt;/span>
&lt;span id="cb2-46">&lt;a href="#cb2-46">&lt;/a>}&lt;/span>
&lt;span id="cb2-47">&lt;a href="#cb2-47">&lt;/a> &lt;/span>
&lt;span id="cb2-48">&lt;a href="#cb2-48">&lt;/a>node *RL(node *k1)&lt;/span>
&lt;span id="cb2-49">&lt;a href="#cb2-49">&lt;/a>{&lt;/span>
&lt;span id="cb2-50">&lt;a href="#cb2-50">&lt;/a> k1-&amp;gt;r = LL(k1-&amp;gt;r);&lt;/span>
&lt;span id="cb2-51">&lt;a href="#cb2-51">&lt;/a> &lt;span class="cf">return&lt;/span> RR(k1);&lt;/span>
&lt;span id="cb2-52">&lt;a href="#cb2-52">&lt;/a>}&lt;/span>
&lt;span id="cb2-53">&lt;a href="#cb2-53">&lt;/a> &lt;/span>
&lt;span id="cb2-54">&lt;a href="#cb2-54">&lt;/a>node *insertnode(node *root,&lt;span class="dt">int&lt;/span> x)&lt;/span>
&lt;span id="cb2-55">&lt;a href="#cb2-55">&lt;/a>{&lt;/span>
&lt;span id="cb2-56">&lt;a href="#cb2-56">&lt;/a> &lt;span class="cf">if&lt;/span>(root==&lt;span class="dv">0&lt;/span>)&lt;/span>
&lt;span id="cb2-57">&lt;a href="#cb2-57">&lt;/a> {&lt;/span>
&lt;span id="cb2-58">&lt;a href="#cb2-58">&lt;/a> root = &amp;amp;tree[sum++];&lt;/span>
&lt;span id="cb2-59">&lt;a href="#cb2-59">&lt;/a> root-&amp;gt;l = root-&amp;gt;r = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb2-60">&lt;a href="#cb2-60">&lt;/a> root-&amp;gt;v = x;&lt;/span>
&lt;span id="cb2-61">&lt;a href="#cb2-61">&lt;/a> root-&amp;gt;h = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb2-62">&lt;a href="#cb2-62">&lt;/a> }&lt;/span>
&lt;span id="cb2-63">&lt;a href="#cb2-63">&lt;/a> &lt;span class="cf">else&lt;/span> &lt;span class="cf">if&lt;/span>(x &amp;lt; root-&amp;gt;v)&lt;/span>
&lt;span id="cb2-64">&lt;a href="#cb2-64">&lt;/a> {&lt;/span>
&lt;span id="cb2-65">&lt;a href="#cb2-65">&lt;/a> root-&amp;gt;l = insertnode(root-&amp;gt;l, x);&lt;/span>
&lt;span id="cb2-66">&lt;a href="#cb2-66">&lt;/a> &lt;span class="cf">if&lt;/span>(H(root-&amp;gt;l) - H(root-&amp;gt;r)==&lt;span class="dv">2&lt;/span>)&lt;/span>
&lt;span id="cb2-67">&lt;a href="#cb2-67">&lt;/a> root = (x &amp;lt; root-&amp;gt;l-&amp;gt;v)?LL(root):LR(root);&lt;/span>
&lt;span id="cb2-68">&lt;a href="#cb2-68">&lt;/a> }&lt;/span>
&lt;span id="cb2-69">&lt;a href="#cb2-69">&lt;/a> &lt;span class="cf">else&lt;/span>&lt;/span>
&lt;span id="cb2-70">&lt;a href="#cb2-70">&lt;/a> {&lt;/span>
&lt;span id="cb2-71">&lt;a href="#cb2-71">&lt;/a> root-&amp;gt;r = insertnode(root-&amp;gt;r, x);&lt;/span>
&lt;span id="cb2-72">&lt;a href="#cb2-72">&lt;/a> &lt;span class="cf">if&lt;/span>(H(root-&amp;gt;r) - H(root-&amp;gt;l)==&lt;span class="dv">2&lt;/span>)&lt;/span>
&lt;span id="cb2-73">&lt;a href="#cb2-73">&lt;/a> root = (x &amp;gt; root-&amp;gt;r-&amp;gt;v)?RR(root):RL(root);&lt;/span>
&lt;span id="cb2-74">&lt;a href="#cb2-74">&lt;/a> }&lt;/span>
&lt;span id="cb2-75">&lt;a href="#cb2-75">&lt;/a> root-&amp;gt;h = max(H(root-&amp;gt;l), H(root-&amp;gt;r))+&lt;span class="dv">1&lt;/span>;&lt;/span>
&lt;span id="cb2-76">&lt;a href="#cb2-76">&lt;/a> &lt;span class="cf">return&lt;/span> root;&lt;/span>
&lt;span id="cb2-77">&lt;a href="#cb2-77">&lt;/a>}&lt;/span>
&lt;span id="cb2-78">&lt;a href="#cb2-78">&lt;/a> &lt;/span>
&lt;span id="cb2-79">&lt;a href="#cb2-79">&lt;/a>&lt;span class="dt">int&lt;/span> main()&lt;/span>
&lt;span id="cb2-80">&lt;a href="#cb2-80">&lt;/a>{&lt;/span>
&lt;span id="cb2-81">&lt;a href="#cb2-81">&lt;/a> &lt;span class="dt">int&lt;/span> n;&lt;/span>
&lt;span id="cb2-82">&lt;a href="#cb2-82">&lt;/a> node *root = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb2-83">&lt;a href="#cb2-83">&lt;/a> scanf(&lt;span class="st">&amp;quot;&lt;/span>&lt;span class="sc">%d&lt;/span>&lt;span class="st">&amp;quot;&lt;/span>,&amp;amp;n);&lt;/span>
&lt;span id="cb2-84">&lt;a href="#cb2-84">&lt;/a> &lt;span class="cf">for&lt;/span>(&lt;span class="dt">int&lt;/span> i=&lt;span class="dv">0&lt;/span>;i&amp;lt;n;i++)&lt;/span>
&lt;span id="cb2-85">&lt;a href="#cb2-85">&lt;/a> {&lt;/span>
&lt;span id="cb2-86">&lt;a href="#cb2-86">&lt;/a> &lt;span class="dt">int&lt;/span> x;&lt;/span>
&lt;span id="cb2-87">&lt;a href="#cb2-87">&lt;/a> scanf(&lt;span class="st">&amp;quot;&lt;/span>&lt;span class="sc">%d&lt;/span>&lt;span class="st">&amp;quot;&lt;/span>,&amp;amp;x);&lt;/span>
&lt;span id="cb2-88">&lt;a href="#cb2-88">&lt;/a> root = insertnode(root,x);&lt;/span>
&lt;span id="cb2-89">&lt;a href="#cb2-89">&lt;/a> }&lt;/span>
&lt;span id="cb2-90">&lt;a href="#cb2-90">&lt;/a> printf(&lt;span class="st">&amp;quot;&lt;/span>&lt;span class="sc">%d\n&lt;/span>&lt;span class="st">&amp;quot;&lt;/span>,root-&amp;gt;v);&lt;/span>
&lt;span id="cb2-91">&lt;a href="#cb2-91">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h1 id="图">图&lt;/h1>
&lt;h2 id="图的逻辑结构">图的逻辑结构&lt;/h2>
&lt;h2 id="图的存储结构">图的存储结构&lt;/h2>
&lt;h4 id="邻接矩阵">邻接矩阵&lt;/h4>
&lt;h4 id="邻接表">邻接表&lt;/h4>
&lt;p>邻接表将邻接矩阵的每行改为单链表存储,具有 n 个顶点,可以用 n 个单链表构成的链表数组存放。 每个 单链表链接一个顶点发出的所有边结点,链表长度即为对应的 顶点的度数。&lt;/p>
&lt;h4 id="邻接多重边表">邻接多重边表&lt;/h4>
&lt;p>邻接多重边表的存储结构不再以顶点为中心,而是以边为 中心。 每条边用一个边结点表示,每个边结点 包含两个端点信息、 和对应两个端点的下一条边结点的指针。 所需存储空间与邻接表相同,但是克服了边属性修改需要两次 的操作的问题。&lt;/p>
&lt;h4 id="半边数据结构">半边数据结构&lt;/h4>
&lt;h4 id="其他图的存储结构">其他图的存储结构&lt;/h4>
&lt;h5 id="三维网格">三维网格&lt;/h5>
&lt;p>节点：三维网格的网格（或网格点）表示节点，用3维数组存储。&lt;/p>
&lt;p>边：每个网格（或网格点）只和周围的6个网格（网格点）邻接。这样的存储结构只能包含边的邻接关系信息，不能包含权值信息。&lt;/p>
&lt;p>可另外使用6个三维网格，单独存储每个网格（网格点）上下左右前后6条邻接边的权值信息。&lt;/p>
&lt;h5 id="三维网格模型的压缩存储csr">三维网格模型的压缩存储CSR&lt;/h5>
&lt;p>CSR：compressed storage format&lt;/p>
&lt;p>&lt;a href="http://sourcedb.ict.cas.cn/cn/ictthesis/200907/P020090722590003844310.pdf">参考&lt;/a>&lt;/p>
&lt;h1 id="散列">散列&lt;/h1>
&lt;h2 id="散列的概念">散列的概念&lt;/h2>
&lt;p>&lt;strong>散列&lt;/strong>是一种算法（更像是一种思想）。&lt;/p>
&lt;p>&lt;strong>散列函数&lt;/strong>是将&lt;strong>一系列输入&lt;/strong>映射到&lt;strong>有限的存储空间&lt;/strong>的函数。&lt;/p>
&lt;p>不同的输入可能会散列成相同的输出（发生&lt;strong>碰撞/冲突&lt;/strong>），所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的&lt;a href="https://baike.baidu.com/item/消息摘要/4547744">消息摘要&lt;/a>的函数。&lt;/p>
&lt;h2 id="散列的存取过程">散列的存取过程&lt;/h2>
&lt;h3 id="散列的存入操作">散列的存入操作&lt;/h3>
&lt;p>向散列映射的存储空间中存内容前，先&lt;strong>计算散列函数/散列值/地址序标&lt;/strong>。 如果&lt;strong>没有发生碰撞&lt;/strong>（即散列值对应的存储地址中还没有存入内容），&lt;strong>直接&lt;/strong>向对应的存储地址中&lt;strong>写入内容&lt;/strong>； 如果&lt;strong>发生了碰撞&lt;/strong>，按下面几种&lt;strong>处理冲突&lt;/strong>的方法，&lt;strong>寻找新的存储地址&lt;/strong>，直到找到空着的存储地址，向其中&lt;strong>写入内容&lt;/strong>。&lt;/p>
&lt;h3 id="散列的取出操作">散列的取出操作&lt;/h3>
&lt;p>与散列的存入过程类似，只是要注意，根据散列值/地址序标取内容时，要判断一下是未发生碰撞前存入的值，还是第几次碰撞的值，然后对应取出。&lt;/p>
&lt;h2 id="处理冲突的方法">处理冲突的方法&lt;/h2>
&lt;p>参考：https://baike.baidu.com/item/hash/390310&lt;/p>
&lt;p>参考：https://blog.csdn.net/zeb_perfect/article/details/52574915&lt;/p>
&lt;h3 id="开放寻址法">开放寻址法&lt;/h3>
&lt;p>Hi=(H(key) + di) MOD m,i=1,2,…，k(k&amp;lt;=m-1)，其中H(key)为&lt;a href="https://baike.baidu.com/item/散列函数">散列函数&lt;/a>，m为&lt;a href="https://baike.baidu.com/item/散列表">散列表&lt;/a>长，di为增量序列，可有下列三种取法：&lt;/p>
&lt;p>1)． di=1,2,3,…，m-1，称线性探测再散列；&lt;/p>
&lt;p>2)． di=1&lt;sup>2,-1&lt;/sup>2,2&lt;sup>2,-2&lt;/sup>2,3&lt;sup>2,…，±k&lt;/sup>2,(k&amp;lt;=m/2)称二次探测再散列；&lt;/p>
&lt;p>3)． di=&lt;a href="https://baike.baidu.com/item/伪随机数">伪随机数&lt;/a>序列，称伪随机探测再散列。&lt;/p>
&lt;blockquote>
&lt;p>注：但是牛客网题目：平方探测的查找式子是(key + step * step) % size 而不是(key % size + step * step)%size&lt;/p>
&lt;/blockquote>
&lt;h3 id="再散列法">再散列法&lt;/h3>
&lt;p>Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。&lt;/p>
&lt;h3 id="链地址法拉链法">链地址法（拉链法）&lt;/h3>
&lt;p>&lt;em>HashMap&lt;/em> 就是&lt;em>使用&lt;/em>链地址法来&lt;em>解决冲突&lt;/em>的（jdk8中采用平衡树来替代链表存储&lt;em>冲突&lt;/em>的元素，但&lt;em>hash&lt;/em>() &lt;em>方法&lt;/em>原理相同）。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20160918154444663" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>拉链法的优缺点： 优点： ①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； ②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； ③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； ④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 缺点： 指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。&lt;/p>
&lt;h3 id="建立一个公共溢出区">建立一个公共溢出区&lt;/h3>
&lt;p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。&lt;/p>
&lt;h1 id="树状数组">树状数组&lt;/h1>
&lt;p>参考：https://zhuanlan.zhihu.com/p/25185969&lt;/p>
&lt;p>参考*：https://oi-wiki.org/ds/fenwick/&lt;/p>
&lt;p>树状数组可以用来求&lt;strong>数组的区间和&lt;/strong>与&lt;strong>前缀和&lt;/strong>。（虽然稍稍增加了单点修改的时间）&lt;/p>
&lt;h2 id="树状数组c">树状数组C[]&lt;/h2>
&lt;p>原始数组a[],其中各元素&lt;span class="math inline">\(a_i\)&lt;/span>是所需数据。&lt;/p>
&lt;p>树状数组c[],其中各元素&lt;span class="math inline">\(c_i\)&lt;/span>管理了一定范围内的a[j:i]元素。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-c57150473a48e2ce46e4a206da5fda21_1200x500.jpg" alt="" />&lt;figcaption>树状数组详细讲解，不会算法也能看懂哦~&lt;/figcaption>
&lt;/figure>
&lt;p>c1 = a1 c2 = a1 + a2 c3 = a3 c4 = a1 + a2 + a3 + a4 c5 = a5 c6 = a5 + a6 c7 = a7 c8 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8&lt;/p>
&lt;p>c[1]管理的是a[1]； c[2] 管理的是a[1] &amp;amp; a[2] ； c[3]管理的是a[3]； c[4]管理的是a[1] &amp;amp; a[2] &amp;amp; a[3] &amp;amp; a[4]； c[5] 管理的是a[5]； c[6] 管理的是a[5] &amp;amp; a[6] ； c[7]管理的是 a[7]； c[8]管理的是 a[1] &amp;amp; a[2] &amp;amp; a[3] &amp;amp; a[4] &amp;amp; a[5] &amp;amp; a[6] &amp;amp; a[7] &amp;amp; a[8]；&lt;/p>
&lt;h3 id="c_i管理元素的个数">&lt;span class="math inline">\(c_i\)&lt;/span>管理元素的个数&lt;/h3>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/fenwick1.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>c[]中元素&lt;span class="math inline">\(c_i\)&lt;/span>具体管理了几个a[]中元素，&lt;strong>由数组标号的二进制形式末尾0的个数决定&lt;/strong>。 例如， &lt;span class="math inline">\(1_{(10)}=1_{(2)}\)&lt;/span>末尾没有0，管理2^0=1个元素 &lt;span class="math inline">\(2_{(10)}=10_{(2)}\)&lt;/span>末尾1个0，管理2^1=2个元素 &lt;span class="math inline">\(3_{(10)}=11_{(2)}\)&lt;/span>末尾没有0，管理2^0=1个元素 &lt;span class="math inline">\(4_{(10)}=100_{(2)}\)&lt;/span>末尾2个0，管理2^2=4个元素 &lt;span class="math inline">\(5_{(10)}=101_{(2)}\)&lt;/span>末尾没有0，管理2^0=1个元素 &lt;span class="math inline">\(6_{(10)}=110_{(2)}\)&lt;/span>末尾1个0，管理2^1=2个元素 &lt;span class="math inline">\(7_{(10)}=111_{(2)}\)&lt;/span>末尾没有0，管理2^0=1个元素 &lt;span class="math inline">\(8_{(10)}=1000_{(2)}\)&lt;/span>末尾3个0，管理2^3=8个元素&lt;/p>
&lt;p>那么怎么获取二进制数末尾0的个数？ 还记得计算机中原码和补码的相互转换吗？ 正数的原码和补码是相同的。 负数的原/补码转换有两种方法： 方法1：表示成2进制，按位取反（不包含符号位），最后再+1 方法2：表示成2进制，从末尾开始向高位，末尾的连续的0和第一个1不变，然后剩下的高位数字都取反（不包含符号位）&lt;/p>
&lt;p>二进制负数的原码补码的相互转换方法2给了我们灵感。转换后高位都取反，中间1个1不变，低位都是0不变。&lt;/p>
&lt;p>比如一个数n=4（带符号32位太长了，这里简单点用8位） n的原码（正数）：&lt;span class="math inline">\(4_{(10)}=100_{(2)}=00000100_{(2)}\)&lt;/span> &lt;strong>n的补码&lt;/strong>：&lt;span class="math inline">\(4_{(10)}=100_{(2)}=00000100_{(2)}\)&lt;/span> -n的原码(负数）:&lt;span class="math inline">\(-4_{(10)}=-100_{(2)}=10000100_{(2)}\)&lt;/span> &lt;strong>-n的补码&lt;/strong>: &lt;span class="math inline">\(\text{补}[-4_{(10)}]=\text{补}[-100_{(2)}]=11111100_{(2)}\)&lt;/span>&lt;/p>
&lt;p>计算机中都是补码运算，&lt;strong>相反数补码按位与&lt;/strong>，即n &amp;amp; (-n)，只保留了最低位开始的第1个1.从而得到了这个数二进制形式末尾0的个数，或者管理的元素个数。&lt;/p>
&lt;p>回到树状数组，将此操作（&lt;strong>相反数补码按位与&lt;/strong>）写成函数，用来获取&lt;span class="math inline">\(c_i\)&lt;/span>管理a[j:i]元素个数&lt;/p>
&lt;div class="sourceCode" id="cb3">&lt;pre class="sourceCode c">&lt;code class="sourceCode c">&lt;span id="cb3-1">&lt;a href="#cb3-1">&lt;/a>&lt;span class="dt">int&lt;/span> lowbit(&lt;span class="dt">int&lt;/span> x) {&lt;/span>
&lt;span id="cb3-2">&lt;a href="#cb3-2">&lt;/a> &lt;span class="co">// 算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数&lt;/span>&lt;/span>
&lt;span id="cb3-3">&lt;a href="#cb3-3">&lt;/a> &lt;span class="co">//相反数补码按位与&lt;/span>&lt;/span>
&lt;span id="cb3-4">&lt;a href="#cb3-4">&lt;/a> &lt;span class="cf">return&lt;/span> x &amp;amp; -x;&lt;/span>
&lt;span id="cb3-5">&lt;a href="#cb3-5">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="单点修改">单点修改&lt;/h3>
&lt;p>由于我们没有维护a[]，而是维护了树状数组c[]，修改&lt;span class="math inline">\(a_i\)&lt;/span>对应于修改c[]中所有管理&lt;span class="math inline">\(a_i\)&lt;/span>的元素。&lt;/p>
&lt;div class="sourceCode" id="cb4">&lt;pre class="sourceCode c">&lt;code class="sourceCode c">&lt;span id="cb4-1">&lt;a href="#cb4-1">&lt;/a>&lt;span class="dt">void&lt;/span> add(&lt;span class="dt">int&lt;/span> x, &lt;span class="dt">int&lt;/span> k) {&lt;/span>
&lt;span id="cb4-2">&lt;a href="#cb4-2">&lt;/a> &lt;span class="cf">while&lt;/span> (x &amp;lt;= n) { &lt;span class="co">// 不能越界&lt;/span>&lt;/span>
&lt;span id="cb4-3">&lt;a href="#cb4-3">&lt;/a> c[x] = c[x] + k;&lt;/span>
&lt;span id="cb4-4">&lt;a href="#cb4-4">&lt;/a> x = x + lowbit(x);&lt;/span>
&lt;span id="cb4-5">&lt;a href="#cb4-5">&lt;/a> }&lt;/span>
&lt;span id="cb4-6">&lt;a href="#cb4-6">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="求前缀和">求前缀和&lt;/h3>
&lt;p>求前缀和a[1:i]，从c[i]对应的位置开始加，向靠近0的位置找管理不到的（找到上级就不管它的下级了）&lt;/p>
&lt;div class="sourceCode" id="cb5">&lt;pre class="sourceCode c">&lt;code class="sourceCode c">&lt;span id="cb5-1">&lt;a href="#cb5-1">&lt;/a>&lt;span class="dt">int&lt;/span> getsum(&lt;span class="dt">int&lt;/span> x) { &lt;span class="co">// a[1]……a[x]的和&lt;/span>&lt;/span>
&lt;span id="cb5-2">&lt;a href="#cb5-2">&lt;/a> &lt;span class="dt">int&lt;/span> ans = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb5-3">&lt;a href="#cb5-3">&lt;/a> &lt;span class="cf">while&lt;/span> (x &amp;gt;= &lt;span class="dv">1&lt;/span>) {&lt;/span>
&lt;span id="cb5-4">&lt;a href="#cb5-4">&lt;/a> ans = ans + c[x];&lt;/span>
&lt;span id="cb5-5">&lt;a href="#cb5-5">&lt;/a> x = x - lowbit(x);&lt;/span>
&lt;span id="cb5-6">&lt;a href="#cb5-6">&lt;/a> }&lt;/span>
&lt;span id="cb5-7">&lt;a href="#cb5-7">&lt;/a> &lt;span class="cf">return&lt;/span> ans;&lt;/span>
&lt;span id="cb5-8">&lt;a href="#cb5-8">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;h2 id="树状数组t1-t2">树状数组T1[], T2[]&lt;/h2>
&lt;h3 id="区间修改区间求和">区间修改&amp;amp;区间求和&lt;/h3>
&lt;p>原始数组a[],其中各元素&lt;span class="math inline">\(a_i\)&lt;/span>是所需数据。 假设数组b[]是a[]的差分数组，则&lt;span class="math inline">\(a_i = \Sigma_{j=1}^i b_i\)&lt;/span> ，也即b[]的前缀和为&lt;span class="math inline">\(a_i\)&lt;/span>&lt;/p>
&lt;p>a[]的前缀和&lt;span class="math inline">\(\Sigma_{i=1}^r a_i\)&lt;/span>，经数学推导，可以表示为&lt;span class="math inline">\(\Sigma_{i=1}^r b_i\)&lt;/span>和&lt;span class="math inline">\(\Sigma_{i=1}^r (i \cdot b_i)\)&lt;/span>的线性运算，分别用b[]和d[]维护。证明：&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{array}{l} \sum_{i=1}^{r} a_{i} \\ =\sum_{i=1}^{r} \sum_{j=1}^{i} b_{j} \\ =\sum_{i=1}^{r} b_{i} \times(r-i+1) \\ =\sum_{i=1}^{r} b_{i} \times(r+1)-\sum_{i=1}^{r} b_{i} \times i \end{array}\)&lt;/span>&lt;/p>
&lt;p>即a[]的前缀和 可以用 b[]前缀和与d[]前缀和表示。 a[]的区间和也可以表示为两个前缀和的相减。&lt;/p>
&lt;p>综上，a[]可以用其差分数组b[]表示，a[]的前缀和可以用b[]的前缀和与d[]的前缀和表示。&lt;/p>
&lt;p>前面两节我们介绍了使用树状数组c[]表示a[]作&lt;a href="#单点修改">单点修改&lt;/a>和求&lt;a href="#前缀和">前缀和&lt;/a>。 那么我们同样可以用树状数组t1[],t2[]表示b[],d[]。&lt;/p>
&lt;div class="sourceCode" id="cb6">&lt;pre class="sourceCode c">&lt;code class="sourceCode c">&lt;span id="cb6-1">&lt;a href="#cb6-1">&lt;/a>&lt;span class="dt">int&lt;/span> t1[MAXN], t2[MAXN], n;&lt;/span>
&lt;span id="cb6-2">&lt;a href="#cb6-2">&lt;/a>&lt;/span>
&lt;span id="cb6-3">&lt;a href="#cb6-3">&lt;/a>&lt;span class="kw">inline&lt;/span> &lt;span class="dt">int&lt;/span> lowbit(&lt;span class="dt">int&lt;/span> x) { &lt;span class="cf">return&lt;/span> x &amp;amp; (-x); }&lt;/span>
&lt;span id="cb6-4">&lt;a href="#cb6-4">&lt;/a>&lt;/span>
&lt;span id="cb6-5">&lt;a href="#cb6-5">&lt;/a>&lt;span class="dt">void&lt;/span> add(&lt;span class="dt">int&lt;/span> k, &lt;span class="dt">int&lt;/span> v) {&lt;/span>
&lt;span id="cb6-6">&lt;a href="#cb6-6">&lt;/a> &lt;span class="dt">int&lt;/span> v1 = k * v;&lt;/span>
&lt;span id="cb6-7">&lt;a href="#cb6-7">&lt;/a> &lt;span class="cf">while&lt;/span> (k &amp;lt;= n) {&lt;/span>
&lt;span id="cb6-8">&lt;a href="#cb6-8">&lt;/a> t1[k] += v, t2[k] += v1;&lt;/span>
&lt;span id="cb6-9">&lt;a href="#cb6-9">&lt;/a> k += lowbit(k);&lt;/span>
&lt;span id="cb6-10">&lt;a href="#cb6-10">&lt;/a> }&lt;/span>
&lt;span id="cb6-11">&lt;a href="#cb6-11">&lt;/a>}&lt;/span>
&lt;span id="cb6-12">&lt;a href="#cb6-12">&lt;/a>&lt;/span>
&lt;span id="cb6-13">&lt;a href="#cb6-13">&lt;/a>&lt;span class="dt">int&lt;/span> getsum(&lt;span class="dt">int&lt;/span> *t, &lt;span class="dt">int&lt;/span> k) {&lt;/span>
&lt;span id="cb6-14">&lt;a href="#cb6-14">&lt;/a> &lt;span class="dt">int&lt;/span> ret = &lt;span class="dv">0&lt;/span>;&lt;/span>
&lt;span id="cb6-15">&lt;a href="#cb6-15">&lt;/a> &lt;span class="cf">while&lt;/span> (k) {&lt;/span>
&lt;span id="cb6-16">&lt;a href="#cb6-16">&lt;/a> ret += t[k];&lt;/span>
&lt;span id="cb6-17">&lt;a href="#cb6-17">&lt;/a> k -= lowbit(k);&lt;/span>
&lt;span id="cb6-18">&lt;a href="#cb6-18">&lt;/a> }&lt;/span>
&lt;span id="cb6-19">&lt;a href="#cb6-19">&lt;/a> &lt;span class="cf">return&lt;/span> ret;&lt;/span>
&lt;span id="cb6-20">&lt;a href="#cb6-20">&lt;/a>}&lt;/span>
&lt;span id="cb6-21">&lt;a href="#cb6-21">&lt;/a>&lt;/span>
&lt;span id="cb6-22">&lt;a href="#cb6-22">&lt;/a>&lt;span class="dt">void&lt;/span> add1(&lt;span class="dt">int&lt;/span> l, &lt;span class="dt">int&lt;/span> r, &lt;span class="dt">int&lt;/span> v) {&lt;/span>
&lt;span id="cb6-23">&lt;a href="#cb6-23">&lt;/a> add(l, v), add(r + &lt;span class="dv">1&lt;/span>, -v); &lt;span class="co">// 将区间加差分为两个前缀加&lt;/span>&lt;/span>
&lt;span id="cb6-24">&lt;a href="#cb6-24">&lt;/a>}&lt;/span>
&lt;span id="cb6-25">&lt;a href="#cb6-25">&lt;/a>&lt;/span>
&lt;span id="cb6-26">&lt;a href="#cb6-26">&lt;/a>&lt;span class="dt">long&lt;/span> &lt;span class="dt">long&lt;/span> getsum1(&lt;span class="dt">int&lt;/span> l, &lt;span class="dt">int&lt;/span> r) {&lt;/span>
&lt;span id="cb6-27">&lt;a href="#cb6-27">&lt;/a> &lt;span class="cf">return&lt;/span> (r + &lt;span class="dv">1&lt;/span>) * getsum(t1, r) - &lt;span class="dv">1&lt;/span> * l * getsum(t1, l - &lt;span class="dv">1&lt;/span>) -&lt;/span>
&lt;span id="cb6-28">&lt;a href="#cb6-28">&lt;/a> (getsum(t2, r) - getsum(t2, l - &lt;span class="dv">1&lt;/span>));&lt;/span>
&lt;span id="cb6-29">&lt;a href="#cb6-29">&lt;/a>}&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>注意：现在已经无法直接获取到&lt;span class="math inline">\(a_i\)&lt;/span>,只能求a[]在区间上的和。&lt;/p></description></item><item><title>树和二叉树</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="树和二叉树">树和二叉树&lt;/h1>
&lt;h2 id="树和森林">树和森林&lt;/h2>
&lt;h3 id="树的基本概念">树的基本概念&lt;/h3>
&lt;h4 id="树的定义">树的定义&lt;/h4>
&lt;p>树是一种逻辑结构&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410215743659.png" alt="" />&lt;figcaption>image-20200410215743659&lt;/figcaption>
&lt;/figure>
&lt;p>树是n（n≥0）个&lt;strong>结点的有限集合&lt;/strong>，n=0时，称为空树。&lt;/p>
&lt;p>而任意&lt;strong>非空树应满足&lt;/strong>： 1）有且仅有一个特定的称为根的结点。 2）当n&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树。&lt;/p>
&lt;p>&lt;strong>树的特点&lt;/strong>之一：n个结点的树中只有n-1条边&lt;/p>
&lt;h4 id="树基本术语">树基本术语&lt;/h4>
&lt;p>&lt;strong>祖先节点&lt;/strong>和&lt;strong>子孙节点&lt;/strong>&lt;/p>
&lt;p>&lt;strong>双亲节点&lt;/strong>和&lt;strong>孩子节点&lt;/strong>&lt;/p>
&lt;p>&lt;strong>兄弟节点&lt;/strong>&lt;/p>
&lt;p>&lt;strong>节点的度&lt;/strong>：树中一个结点的子结点的个数&lt;/p>
&lt;p>&lt;strong>树的度&lt;/strong>：树中最大的节点度数称为树的度&lt;/p>
&lt;p>&lt;strong>分支结点&lt;/strong>：度大于0的结点（子节点个数大于0的节点）&lt;/p>
&lt;p>&lt;strong>叶子结点&lt;/strong>：度为0的结点&lt;/p>
&lt;p>&lt;strong>节点的层次&lt;/strong>：从根节点开始数，根为第一层（也有的教材中定为0层）&lt;/p>
&lt;p>&lt;strong>节点的高度&lt;/strong>：节点到叶子节点所有路径上包含节点个数的最大值。&lt;/p>
&lt;p>&lt;strong>节点的深度&lt;/strong>：从根节点到该节点唯一的路径上包含的节点个数，根节点深度为1&lt;/p>
&lt;p>&lt;strong>树的高度（深度）&lt;/strong>：树中结点的最大层数&lt;/p>
&lt;p>&lt;strong>有序树&lt;/strong>和&lt;strong>无序树&lt;/strong>&lt;/p>
&lt;p>&lt;strong>路径&lt;/strong>：树中&lt;strong>两个结点之间的路径&lt;/strong>是由这两个结点之间所经过的&lt;strong>结点序列&lt;/strong>构成的。路径是有方向的，从上到下；不同兄弟树中节点不存在路径。&lt;/p>
&lt;p>&lt;strong>路径长度&lt;/strong>：路径上所经历&lt;strong>边的个数&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>森林&lt;/strong>：m（m≥0）棵互不相交的树的集合&lt;/p>
&lt;h4 id="树的性质">树的性质&lt;/h4>
&lt;ul>
&lt;li>树中的结点数等于所有结点的度数加1&lt;/li>
&lt;li>度为m的树中第层上至多有&lt;span class="math inline">\(m^{i-1}\)&lt;/span>个结点（i≥1）&lt;/li>
&lt;li>高度为h的m叉树至多有&lt;span class="math inline">\((m^h-1)/(m-1)\)&lt;/span>个结点(由等比数列前n项和公式获得)&lt;/li>
&lt;li>具有n个结点的m叉树的最小高度为&lt;span class="math inline">\(\left\lceil\log _{\mathrm{m}}(\mathrm{n}(m-1)+1)\right\rceil\)&lt;/span>，这是由上一条性质反推出来的&lt;/li>
&lt;/ul>
&lt;h3 id="树的存储结构">树的存储结构&lt;/h3>
&lt;h3 id="树和森林的遍历">树和森林的遍历&lt;/h3>
&lt;h3 id="树和森林及二叉树的转换">树和森林及二叉树的转换&lt;/h3>
&lt;h3 id="树的应用并查集">树的应用——并查集&lt;/h3>
&lt;h2 id="二叉树">二叉树&lt;/h2>
&lt;h3 id="二叉树的基本概念">二叉树的基本概念&lt;/h3>
&lt;h4 id="定义及特点">定义及特点&lt;/h4>
&lt;h4 id="二叉树的存储结构">二叉树的存储结构&lt;/h4>
&lt;h3 id="二叉树的遍历">二叉树的遍历&lt;/h3>
&lt;h3 id="线索二叉树">线索二叉树&lt;/h3>
&lt;h3 id="二叉树的应用">二叉树的应用&lt;/h3>
&lt;h4 id="二叉排序树">二叉排序树&lt;/h4>
&lt;h4 id="平衡二叉树">平衡二叉树&lt;/h4>
&lt;h4 id="哈夫曼树及哈夫曼编码">哈夫曼树及哈夫曼编码&lt;/h4></description></item><item><title>算法总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="算法总结">算法总结&lt;/h1>
&lt;h2 id="算法">算法&lt;/h2>
&lt;h3 id="什么是算法">什么是算法&lt;/h3>
&lt;p>从字面上来说，**算法也就是用于计算的方法。是用来解决某些问题的方法。**通过这个方法，可以达到想要的计算结果。它就像我们小时候学些的一些数学公式和解题步骤。&lt;/p>
&lt;h3 id="算法特征">算法特征&lt;/h3>
&lt;p>算法，一般有5个特征：&lt;/p>
&lt;ul>
&lt;li>有穷性：
算法的执行步骤、时间、都是有限的。不会无休止的一直执行下去。&lt;/li>
&lt;li>确切性：
算法的每一步都必须有明确的定义和描述。&lt;/li>
&lt;li>输入：
一个算法应该有相应的输入条件，就像我们小时候做的应用题，已知什么什么。来求某个结果，已知部分便是输入条件。&lt;/li>
&lt;li>输出：
算法必须有明确的结果输出。没有结果，那这个算法是没有任何意义的。&lt;/li>
&lt;li>可行性：
算法的步骤必须是可行的，无法执行的则没有意义，也解决不了任何问题&lt;/li>
&lt;/ul>
&lt;h3 id="算法分类">算法分类&lt;/h3>
&lt;p>按照算法的应用来分：算法可以分为基本算法、几何算法、加密/解密算法、查找算法、图表数据分析算法等。
按照算法的思路（思想）来分：算法可以分为递推算法、递归算法、穷举算法、分治算法等。&lt;/p>
&lt;h2 id="按算法的应用来划分">按算法的应用来划分&lt;/h2>
&lt;h3 id="基本算法常规的循环迭代递归">基本算法：常规的循环、迭代、递归&lt;/h3>
&lt;h4 id="递归循环迭代遍历的区别">递归、循环、迭代、遍历的区别&lt;/h4>
&lt;p>程序的运行快慢一般与其中重复执行的代码息息相关，而“重复执行”的方式又分为以下4种：&lt;/p>
&lt;ul>
&lt;li>递归：一个函数反复调用自身的行为，特指函数本身；&lt;/li>
&lt;li>循环：满足一定条件下，重复执行某些行为，如while结构；&lt;/li>
&lt;li>迭代：按某种规则执行一个序列中的每一项，每次执行的结果又作为下次执行的初始值，直到满足某个精度或条件；&lt;/li>
&lt;li>递推：由前一项可以推出后一项，是从前面的已知结果推出未知结果。当前一项的结果作为后一项的初始值时，就成了迭代。（有时候和迭代混用）&lt;/li>
&lt;li>遍历：按某种规则访问图形结构中每一个节点，特指图形结构。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>说明例子：&lt;/p>
&lt;p>【递归】&lt;/p>
&lt;p>你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。&lt;/p>
&lt;p>【循环】&lt;/p>
&lt;p>你去小卖铺买了一个玩具，拿回家后孩子不喜欢，你也没问他为什么不喜欢。然后你又去同一个小卖铺买了一个玩具，拿回家后孩子又不喜欢。。。如此往复 10 次，孩子才满意。&lt;/p>
&lt;p>每次去买玩具的目标、行为都一样，这叫循环。&lt;/p>
&lt;p>【迭代】&lt;/p>
&lt;p>你去小卖铺买了个一个玩具，拿回家后孩子不喜欢。你耐心的询问后得知他喜欢乐高的玩具，于是你就去大超市给他买了乐高，回家后孩子还是不喜欢，耐心询问后得知他喜欢乐高玩具中最贵的那个玩具，于是你就去奢侈品商店给他买了乐高限量版玩具，拿回家后孩子很满意。&lt;/p>
&lt;p>每次去买玩具都跟上一次不一样，或是有了新的目标，或是缩小了搜寻范围，这叫迭代。&lt;/p>
&lt;p>来源：CyrusCao_知乎_&lt;a href="https://www.zhihu.com/question/20278387/answer/109266159">https://www.zhihu.com/question/20278387/answer/109266159&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>递归、迭代、循环常常可以转换，且转换后程序的效率不一定相同。递归由于效率低的问题，经常要求转换成循环结构的非递归形式。&lt;/p>
&lt;p>&lt;a href="https://blog.51cto.com/1661518/1396943">递归、分治策略、动态规划以及贪心算法之间的关系&lt;/a>&lt;/p>
&lt;h4 id="最大公因数">最大公因数&lt;/h4>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E8%BE%97%E8%BD%AC%E7%9B%B8%E5%87%8F">辗转相减法&lt;/a>是一种简便的求出两数最大公约数的方法。由其可推出辗转相除法。&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&amp;amp;fromid=4625352">辗转相除法&lt;/a>求&lt;strong>两正整数&lt;/strong>的迭代次数较少。&lt;/p>
&lt;p>&lt;strong>辗转相除,使余数消失的那个除数&lt;/strong>就是最大公因数&lt;/p>
&lt;h6 id="算法流程">算法流程&lt;/h6>
&lt;p>gcb(m,n): m&amp;gt;n, r 是 m ÷ n 的余数，
若r不为0， 继续gcd(n,r);
若r为0，则n是最大公因数&lt;/p>
&lt;h6 id="递归法">递归法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">divisor&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>m &lt;span style="color:#f92672">%&lt;/span> n &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> n&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> divisor&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">,&lt;/span>m &lt;span style="color:#f92672">%&lt;/span> n&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="迭代法">迭代法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">gcd&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> b&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#75715e">//如果相等
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">==&lt;/span>b&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//保证大数除以小数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> l&lt;span style="color:#f92672">,&lt;/span>x&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">,&lt;/span>y&lt;span style="color:#f92672">=&lt;/span>b&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">&amp;gt;&lt;/span>b&lt;span style="color:#f92672">){&lt;/span>
x&lt;span style="color:#f92672">=&lt;/span>b&lt;span style="color:#f92672">;&lt;/span>
y&lt;span style="color:#f92672">=&lt;/span>a&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//迭代出现余数为0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">((&lt;/span>l&lt;span style="color:#f92672">=(&lt;/span>y&lt;span style="color:#f92672">%&lt;/span>x&lt;span style="color:#f92672">))!=&lt;/span>0&lt;span style="color:#f92672">){&lt;/span>
y&lt;span style="color:#f92672">=&lt;/span>x&lt;span style="color:#f92672">;&lt;/span>
x&lt;span style="color:#f92672">=&lt;/span>l&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> x&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="迭代法2更优雅">迭代法2（更优雅）&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">getMaxFactor&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">((&lt;/span>a &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">%&lt;/span> b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> b&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">((&lt;/span>b &lt;span style="color:#f92672">=&lt;/span> b &lt;span style="color:#f92672">%&lt;/span> a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="迭代法3再优雅一点">迭代法3（再优雅一点）&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">GCD&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;span style="color:#66d9ef">if&lt;/span>(b) &lt;span style="color:#66d9ef">while&lt;/span>((a &lt;span style="color:#f92672">%=&lt;/span> b) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (b &lt;span style="color:#f92672">%=&lt;/span> a));
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="最小公倍数">最小公倍数&lt;/h4>
&lt;p>设两个数是a,b最大公约数是p,最小公倍数是q
那么有这样的关系:ab=pq&lt;/p>
&lt;p>所以可以先求最大公因数，再求最小公倍数&lt;/p>
&lt;h6 id="递归法-1">递归法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">GCD&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">%&lt;/span> b &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">?&lt;/span> b : GCD(b, a &lt;span style="color:#f92672">%&lt;/span> b);
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">LCM&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b)
{
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">*&lt;/span> b &lt;span style="color:#f92672">/&lt;/span> GCD(a, b);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="迭代法-1">迭代法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">GCD&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;span style="color:#66d9ef">if&lt;/span>(b) &lt;span style="color:#66d9ef">while&lt;/span>((a &lt;span style="color:#f92672">%=&lt;/span> b) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (b &lt;span style="color:#f92672">%=&lt;/span> a));
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">LCM&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a, &lt;span style="color:#66d9ef">int&lt;/span> b) {
&lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">*&lt;/span> b &lt;span style="color:#f92672">/&lt;/span> GCD(a, b);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="判定素数">判定素数&lt;/h4>
&lt;h6 id="循环法">循环法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> &lt;span style="color:#a6e22e">isPrime&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> num&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>num &lt;span style="color:#f92672">&amp;lt;&lt;/span> 2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>num &lt;span style="color:#f92672">==&lt;/span> 2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>num &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 3&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">*&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> num&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">+=&lt;/span> 2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>num &lt;span style="color:#f92672">%&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="循环法以空间换时间">循环法（以空间换时间）&lt;/h6>
&lt;p>此方法适合一次生成，多次使用&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> &lt;span style="color:#a6e22e">findPrime&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> numList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span> &lt;span style="color:#75715e">//index is range from 0 to n
&lt;/span>&lt;span style="color:#75715e">&lt;/span> numList&lt;span style="color:#f92672">[&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span> &lt;span style="color:#75715e">// avoid mistake
&lt;/span>&lt;span style="color:#75715e">&lt;/span> numList&lt;span style="color:#f92672">[&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> numList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">// delete the multiple of prime numList[i], pirme = false
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>numList&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> i&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> numList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">+=&lt;/span> i&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
numList&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> numList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="卡拉兹猜想">卡拉兹猜想&lt;/h4>
&lt;p>&lt;strong>考拉兹猜想&lt;/strong>（英语：Collatz conjecture），又称为&lt;strong>奇偶归一猜想&lt;/strong>、&lt;strong>3n+1猜想&lt;/strong>、&lt;strong>冰雹猜想&lt;/strong>、&lt;strong>角谷猜想&lt;/strong>、&lt;strong>哈塞猜想&lt;/strong>、&lt;strong>乌拉姆猜想&lt;/strong>或&lt;strong>叙拉古猜想&lt;/strong>，是指对于每一个&lt;a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%95%B4%E6%95%B0">正整数&lt;/a>，如果它是&lt;a href="https://zh.wikipedia.org/wiki/%E5%A5%87%E6%95%B0">奇数&lt;/a>，则对它乘3再加1，如果它是&lt;a href="https://zh.wikipedia.org/wiki/%E5%81%B6%E6%95%B0">偶数&lt;/a>，则对它&lt;a href="https://zh.wikipedia.org/wiki/%E9%99%A4%E4%BB%A5%E4%BA%8C">除以2&lt;/a>，如此循环，最终都能够得到1。&lt;/p>
&lt;p>这是一种迭代&lt;/p>
&lt;h6 id="迭代法-2">迭代法&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">collatz&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">&amp;gt;&lt;/span> 1&lt;span style="color:#f92672">){&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">print&lt;/span>&lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34;\t-&amp;gt;\t&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
n &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> 2 &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">?&lt;/span> n &lt;span style="color:#f92672">/&lt;/span> 2 &lt;span style="color:#f92672">:&lt;/span> n &lt;span style="color:#f92672">*&lt;/span> 3 &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">print&lt;/span>&lt;span style="color:#f92672">(&lt;/span>1&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="图形结构的算法遍历树和图的遍历方法">图形结构的算法：遍历：树和图的遍历方法&lt;/h3>
&lt;p>深度优先、广度优先、层次遍历，适用于树和图的遍历。只不过，对于图而言，要多用一个数组标记每一个节点是否访问过，防止重复遍历。&lt;/p>
&lt;h4 id="dfs">DFS&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-fc4b34a14f9310b4b2d37904cc195a70_720w.jpg" alt="img" style="zoom:33%;" />&lt;/p>
&lt;p>深度优先遍历/搜索（DFS），其对节点的访问过程是：首先不断向前递推然后回溯的过程，符合递归的思想，可以很容易的写成递归函数。所以DFS有2种写法：递归形式、非递归形式。&lt;/p>
&lt;h5 id="dfs递归形式">DFS递归形式&lt;/h5>
&lt;p>深度优先搜索的递归写法，比非递归的更常用（如果是图的话，要添加visit标记是否已访问过，如果是树的话不需要）&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">visited &lt;span style="color:#f92672">=&lt;/span> set()
&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(node, visited):
visited&lt;span style="color:#f92672">.&lt;/span>add(node)
&lt;span style="color:#75715e"># process current node here.&lt;/span>
&lt;span style="color:#f92672">...&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> next_node &lt;span style="color:#f92672">in&lt;/span> node:
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> next_node &lt;span style="color:#f92672">in&lt;/span> visited:
dfs(next_node, visited)
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="dfs非递归形式">DFS非递归形式&lt;/h5>
&lt;p>深度优先搜索的非递归写法，一般用栈实现&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>(tree):
&lt;span style="color:#66d9ef">if&lt;/span> tree&lt;span style="color:#f92672">.&lt;/span>root &lt;span style="color:#f92672">is&lt;/span> None:
&lt;span style="color:#66d9ef">return&lt;/span> []
visited, stack &lt;span style="color:#f92672">=&lt;/span> [], [tree&lt;span style="color:#f92672">.&lt;/span>root]
&lt;span style="color:#66d9ef">while&lt;/span> stack:
node &lt;span style="color:#f92672">=&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>pop(&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
visited&lt;span style="color:#f92672">.&lt;/span>add(node)
process(node)
nodes &lt;span style="color:#f92672">=&lt;/span> generate_related_nodes(node)
stack&lt;span style="color:#f92672">.&lt;/span>append(nodes)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>图的深度优先遍历（Deep First Search），递归形式&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 深度优先遍历
&lt;/span>&lt;span style="color:#75715e"> * @param s 表示遍历的源点
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DFS&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> s&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//访问源点s
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited&lt;span style="color:#f92672">[&lt;/span>s&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//循环访问邻接的顶点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//arc是m*2的二维数组，表示无向图有m条边，每条边连接2个顶点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> arc&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> s &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//先访问邻接点的邻接点，再回过头来下一次循环
&lt;/span>&lt;span style="color:#75715e">&lt;/span> DFS&lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> s &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
DFS&lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="bfs">BFS&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-0788630b7a158c742ad4434f42c1847d_720w.jpg" alt="img" style="zoom:33%;" />&lt;/p>
&lt;p>一般的广度优先遍历（Breadth First Search），广度优先遍历非递归，使用队列实现&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-python" data-lang="python">&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">bfs&lt;/span>(graph, start, end):
queue, visited &lt;span style="color:#f92672">=&lt;/span> [], set() &lt;span style="color:#75715e">#visited用来判重，树结构不需要，&lt;/span>
&lt;span style="color:#75715e"># 因为访问过的结点以后不会被访问到&lt;/span>
queue&lt;span style="color:#f92672">.&lt;/span>append([start])
visited&lt;span style="color:#f92672">.&lt;/span>add(start)
&lt;span style="color:#66d9ef">while&lt;/span> queue:
node &lt;span style="color:#f92672">=&lt;/span> queue&lt;span style="color:#f92672">.&lt;/span>pop(&lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#75715e"># 取队列头元素&lt;/span>
visited&lt;span style="color:#f92672">.&lt;/span>add(node)
process(node)
nodes &lt;span style="color:#f92672">=&lt;/span> generate_related_nodes(node)
queue&lt;span style="color:#f92672">.&lt;/span>append(nodes) &lt;span style="color:#75715e"># push进队列&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="树的算法">树的算法&lt;/h3>
&lt;h4 id="二叉树的遍历">二叉树的遍历&lt;/h4>
&lt;p>&lt;strong>参考&lt;/strong>&lt;a href="https://www.cnblogs.com/dolphin0520/archive/2011/08/25/2153720.html">二叉树的非递归遍历&lt;/a>&lt;/p>
&lt;p>一个二叉树节点最少包含如下三个属性：节点内容，左子节点句柄，右子节点句柄&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BinaryTree&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> T value&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> BinaryTree left&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> BinaryTree right&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>按一定的顺序访问二叉树的所有节点，称为&lt;strong>二叉树的遍历&lt;/strong>，按访问节点的顺序分为：前序遍历，中序遍历，后序遍历，层次遍历。按实现方式可分为：递归实现，非递归实现。&lt;/p>
&lt;p>其实想一下，二叉树遍历(前序/中序/后序，除了层次遍历），都符合树深度优先遍历（DFS）。仔细看一下，二叉树前序遍历的代码就是DFS的代码（只不过二叉树固定两个子节点，就没有用for循环，而是写了两次递归调用）。对于非递归形式，也一致。&lt;/p>
&lt;h5 id="前序递归遍历">前序递归遍历&lt;/h5>
&lt;p>先访问当前节点，再访问左子树，然后访问右子树&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> String &lt;span style="color:#a6e22e">preOrderTraversalRecursive&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">toString&lt;/span>&lt;span style="color:#f92672">()&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">(&lt;/span>left &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> left&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">preOrderTraversalRecursive&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">(&lt;/span>right &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> right&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">preOrderTraversalRecursive&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="前序非递归遍历">前序非递归遍历&lt;/h5>
&lt;p>借助循环和栈可以控制节点访问顺序，模仿递归代码的执行顺序，实现非递归代码。&lt;/p>
&lt;p>实现：循环判断当前节点是否为空，栈是否为空&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">preOrder2&lt;/span>(BinTree &lt;span style="color:#f92672">*&lt;/span>root) &lt;span style="color:#75715e">//非递归前序遍历
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinTree&lt;span style="color:#f92672">*&amp;gt;&lt;/span> s;
BinTree &lt;span style="color:#f92672">*&lt;/span>p&lt;span style="color:#f92672">=&lt;/span>root;
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">!=&lt;/span>NULL&lt;span style="color:#f92672">||!&lt;/span>s.empty())
{
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">!=&lt;/span>NULL)
{
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>data&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
s.push(p);
p&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lchild;
}
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>s.empty())
{
p&lt;span style="color:#f92672">=&lt;/span>s.top();
s.pop();
p&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rchild;
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="中序递归遍历">中序递归遍历&lt;/h5>
&lt;p>先访问左子树，再访问当前节点，然后访问右子树&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inOrder1&lt;/span>(BinTree &lt;span style="color:#f92672">*&lt;/span>root) &lt;span style="color:#75715e">//递归中序遍历
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">if&lt;/span>(root&lt;span style="color:#f92672">!=&lt;/span>NULL)
{
inOrder1(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lchild);
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>data&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
inOrder1(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rchild);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="中序非递归遍历">中序非递归遍历&lt;/h5>
&lt;p>循环判断当前节点是否为空，以及栈是否为空来实现&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">inOrder2&lt;/span>(BinTree &lt;span style="color:#f92672">*&lt;/span>root) &lt;span style="color:#75715e">//非递归中序遍历
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>BinTree&lt;span style="color:#f92672">*&amp;gt;&lt;/span> s;
BinTree &lt;span style="color:#f92672">*&lt;/span>p&lt;span style="color:#f92672">=&lt;/span>root;
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">!=&lt;/span>NULL&lt;span style="color:#f92672">||!&lt;/span>s.empty())
{
&lt;span style="color:#66d9ef">while&lt;/span>(p&lt;span style="color:#f92672">!=&lt;/span>NULL)
{
s.push(p);
p&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lchild;
}
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>s.empty())
{
p&lt;span style="color:#f92672">=&lt;/span>s.top();
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>data&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
s.pop();
p&lt;span style="color:#f92672">=&lt;/span>p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rchild;
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="后序递归遍历">后序递归遍历&lt;/h5>
&lt;p>先访问左子树和右子树，再访问当前节点&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">postOrder1&lt;/span>(BinTree &lt;span style="color:#f92672">*&lt;/span>root) &lt;span style="color:#75715e">//递归后序遍历
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">if&lt;/span>(root&lt;span style="color:#f92672">!=&lt;/span>NULL)
{
postOrder1(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lchild);
postOrder1(root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>rchild);
cout&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>root&lt;span style="color:#f92672">-&amp;gt;&lt;/span>data&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="后序非递归遍历">后序非递归遍历&lt;/h5>
&lt;p>后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。下面介绍两种思路。&lt;/p>
&lt;p>&lt;strong>第一种思路&lt;/strong>：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，&lt;strong>每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。&lt;strong>因此&lt;/strong>需要多设置一个变量标识该结点是否是第一次出现在栈顶&lt;/strong>。&lt;/p>
&lt;details>
&lt;summary>思路一code：节点第二次出现在栈顶时，才访问它&lt;/summary>
&lt;pre>
void postOrder2(BinTree *root) //非递归后序遍历
{
stack&lt;BTNode*> s;
BinTree *p=root;
BTNode *temp;
while(p!=NULL||!s.empty())
{
while(p!=NULL) //沿左子树一直往下搜索，直至出现没有左子树的结点
{
BTNode *btn=(BTNode *)malloc(sizeof(BTNode));
btn->btnode=p;
btn->isFirst=true;
s.push(btn);
p=p->lchild;
}
if(!s.empty())
{
temp=s.top();
s.pop();
if(temp->isFirst==true) //表示是第一次出现在栈顶
{
temp->isFirst=false;
s.push(temp);
p=temp->btnode->rchild;
}
else//第二次出现在栈顶
{
cout&lt;&lt;temp->btnode->data&lt;&lt;"";
p=NULL;
}
}
}
}
&lt;/pre>
&lt;/details>
&lt;p>&lt;strong>第二种思路&lt;/strong>：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。&lt;/p>
&lt;details>
&lt;summary>思路二code：入栈时保证右孩子先入栈，左孩子后入栈&lt;/summary>
&lt;pre>
void postOrder3(BinTree *root) //非递归后序遍历
{
stack&lt;BinTree*> s;
BinTree *cur; //当前结点
BinTree *pre=NULL; //前一次访问的结点
s.push(root);
while(!s.empty())
{
cur=s.top();
if((cur->lchild==NULL&amp;&amp;cur->rchild==NULL)||
(pre!=NULL&amp;&amp;(pre==cur->lchild||pre==cur->rchild)))
{
cout&lt;&lt;cur->data&lt;&lt;""; //如果当前结点没有孩子结点或者孩子节点都已被访问过
s.pop();
pre=cur;
}
else
{
if(cur->rchild!=NULL)
s.push(cur->rchild);
if(cur->lchild!=NULL)
s.push(cur->lchild);
}
}
}
&lt;/pre>
&lt;/details>
&lt;h5 id="层次遍历bfs">层次遍历/BFS&lt;/h5>
&lt;p>参考：&lt;a href="https://zhuanlan.zhihu.com/p/81647245">BFS、DFS和剪枝 1&lt;/a>&lt;/p>
&lt;p>二叉树的层次遍历属于BFS（层次遍历）的一种，参考&lt;a href="#BFS">BFS&lt;/a>代码即可。&lt;/p>
&lt;h4 id="由遍历结果重建二叉树">由遍历结果重建二叉树&lt;/h4>
&lt;h5 id="由前序和中序遍历序列重建二叉树">由前序和中序遍历序列重建二叉树&lt;/h5>
&lt;p>参考：https://zhuanlan.zhihu.com/p/37265145&lt;/p>
&lt;p>**问题描述：**输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建出如下图所示的二叉树并输出它的头结点。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20200204135006.png" alt="">&lt;/p>
&lt;p>&lt;strong>解题思路：&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20200204135942.png" alt="">&lt;/p>
&lt;p>在二叉树的前序遍历序列中，第一个数字总是树的根结点的值。但在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。因此我们需要扫描中序遍历序列，才能找到根结点的值。&lt;/p>
&lt;p>　　前序遍历序列的第一个数字1就是根结点的值。扫描中序遍历序列，就能确定根结点的值的位置。根据中序遍历特点，在根结点的值1前面的3个数字都是左子树结点的值，位于1后面的数字都是右子树结点的值。&lt;/p>
&lt;p>综上，我们&lt;strong>可以分别找到根、左、右子树&lt;/strong>的前序遍历序列和中序遍历序列。
我们&lt;strong>也可以用同样的方法分别去构建左右子树&lt;/strong>。换句话说，这是一个&lt;strong>递归&lt;/strong>的过程。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#66d9ef">int&lt;/span> pre_order_arry[n];
&lt;span style="color:#66d9ef">int&lt;/span> in_order_arry[n];
&lt;span style="color:#75715e">/* n为前序遍历和中序遍历子序列长度，pos1为前序数组下标，pos2为后序下标 */&lt;/span>
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">PrintPostOrder&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pos1, &lt;span style="color:#66d9ef">int&lt;/span> pos2, &lt;span style="color:#66d9ef">int&lt;/span> n)
{
&lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
{
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pre_order_arry[pos1];
&lt;span style="color:#66d9ef">return&lt;/span>;
}
&lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (; pre_order_arry[pos1] &lt;span style="color:#f92672">!=&lt;/span> in_order_arry[pos2 &lt;span style="color:#f92672">+&lt;/span> i]; i&lt;span style="color:#f92672">++&lt;/span>);
PrintPostOrder(pos1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, pos2, i);
PrintPostOrder(pos1 &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, pos2 &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, n &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> pre_order_arry[pos1];
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然我们也可以根据前序和中序构造出二叉树，进而求出后序。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="color:#75715e">/* 该函数返回二叉树的根节点 */&lt;/span>
Node &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">Create&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> pos1, &lt;span style="color:#66d9ef">int&lt;/span> pos2, &lt;span style="color:#66d9ef">int&lt;/span> n)
{
Node &lt;span style="color:#f92672">*&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (pre_order_arry[pos1] &lt;span style="color:#f92672">==&lt;/span> in_order_arry[pos2&lt;span style="color:#f92672">+&lt;/span>i])
{
p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Node(pre_order_arry[pos1]);
p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>left &lt;span style="color:#f92672">=&lt;/span> Create(pos1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, pos2, i);
p&lt;span style="color:#f92672">-&amp;gt;&lt;/span>right &lt;span style="color:#f92672">=&lt;/span> Create(pos1 &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, pos2 &lt;span style="color:#f92672">+&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, n &lt;span style="color:#f92672">-&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> p;
}
}
&lt;span style="color:#66d9ef">return&lt;/span> p;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="判断某序列是否为二叉搜索树的前序遍历">判断某序列是否为二叉搜索树的前序遍历&lt;/h5>
&lt;p>问题描述：给一个序列，它&lt;strong>可能是一个正二叉搜索树的前序遍历&lt;/strong>，也&lt;strong>可能是一个逆二叉搜索树的前序遍历&lt;/strong>，也&lt;strong>可能什么都不是&lt;/strong>。题目要求&lt;strong>给出判断结果&lt;/strong>，如果是前序的话，还要求&lt;strong>给出后序遍历&lt;/strong>的结果。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4082">题目链接&lt;/a>&lt;/p>
&lt;h6 id="方法1-根据二叉搜索树前序遍历序列的特点来重建树构造后序">方法1 根据二叉搜索树前序遍历序列的特点来重建树/构造后序&lt;/h6>
&lt;p>正二叉搜索树有这样的特点：左子树上的值都比当前节点的值小，右子树上的值都大于等于（这道题包括等于的情况）当前节点 来 重建树/构造后序。
正二叉搜索树前序遍历的特点：第一个值是根节点；其后几个比第一个值小的都在左子树上；随后剩下的值比第一个值都大，都在右子树上。如果以上情况不成立，则给定的序列不是正二叉搜素树的前序遍历。对于左子树和右子树，同样递归判断。
逆二叉搜索树的情况与正二叉搜索树的情况类似。&lt;/p>
&lt;details>
&lt;summary>方法1代码：根据二叉搜索树前序遍历序列的特点来重建树/构造后序&lt;/summary>
&lt;pre>
//不重建树，递归判断，同时构造后序
//牛客网牛友的提交 https://www.nowcoder.com/profile/986803/codeBookDetail?submissionId=5237150
#include &lt;iostream>
using namespace std;
int pre[1001];
int post[1001];
int n;
bool bst(int begin,int end,int postBegin){
int length=end-begin;
if(length==1){
post[postBegin]=pre[begin];
return true;
}
if(length==0){
return true;
}
int mid=begin+1;
while(pre[mid]&lt;pre[begin]&amp;&amp;mid&lt;end){
mid++;
}
int last=mid;
while(last&lt;end){
if(pre[last]&lt;pre[begin]){
return false;
}
else{
last++;
}
}
post[postBegin+length-1]=pre[begin];
return bst(begin+1,mid,postBegin)&amp;&amp;bst(mid,end,postBegin+(mid-begin)-1);
}
bool mbst(int begin,int end,int postBegin){
int length=end-begin;
if(length==1){
post[postBegin]=pre[begin];
return true;
}
if(length==0){
return true;
}
int mid=begin+1;
while(pre[mid]>=pre[begin]&amp;&amp;mid&lt;end){
mid++;
}
int last=mid;
while(last&lt;end){
if(pre[last]>=pre[begin]){
return false;
}
else{
last++;
}
}
post[postBegin+length-1]=pre[begin];
return mbst(begin+1,mid,postBegin)&amp;&amp;mbst(mid,end,postBegin+(mid-begin)-1);
}
int main(){
//freopen("test.txt","r",stdin);
cin>>n;
for(int i=0;i&lt;n;i++){
scanf("%d",pre+i);
}
if(bst(0,n,0)){
printf("YES\n");
for(int i=0;i&lt;n;i++){
if(i!=n-1){
printf("%d ",post[i]);
}
else{
printf("%d",post[i]);
}
}
}
else if(mbst(0,n,0)){
printf("YES\n");
for(int i=0;i&lt;n;i++){
if(i!=n-1){
printf("%d ",post[i]);
}
else{
printf("%d",post[i]);
}
}
}
else{
printf("NO");
}
return 0;
}
&lt;/pre>
&lt;/details>
&lt;h6 id="方法2-根据前序中序遍历对应的二叉树的唯一性来做">方法2 根据前序+中序遍历对应的二叉树的唯一性来做&lt;/h6>
&lt;p>假设给定的序列是二叉搜索树的前序序列，那么排序一下同时也得到了二叉搜索树的中序序列。
我们知道，已知前序+中序，对应的二叉树是唯一的。那么原问题就可以转化为：&lt;a href="#%E7%94%B1%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">由前序+中序遍历重建二叉树/输出后序的问题&lt;/a>&lt;/p>
&lt;details>
&lt;summary>方法2代码：根据前序+中序遍历对应的二叉树的唯一性来做&lt;/summary>
&lt;pre>
//已知前序+中序（隐含），对应的二叉树是唯一的。那么我们可以按前序序列的插入顺序重建二叉搜索树
//牛客网讨论区：https://www.nowcoder.com/questionTerminal/8bcd661314744321b55dce1c1bfa8c54
//下面是牛客网讨论区，RicardoZi的讨论代码：
#include &lt;cstdio>
#include &lt;vector>
using namespace std;
struct Node{
int value;
Node *left, *right;
};
void Insert(Node* &amp;root, int data){
if(root == NULL){
root = new Node;
root -> value = data;
root -> left = NULL;
root -> right = NULL;
return;
}
if(data &lt; root->value) Insert(root->left, data);
else Insert(root->right, data);
}
void PreOrder(Node* root, vector&lt;int>&amp; v){
if(root == NULL) return;
v.push_back(root->value);
PreOrder(root->left, v);
PreOrder(root->right, v);
}
void PreMirrorOrder(Node* root, vector&lt;int>&amp; v){
if(root == NULL) return;
v.push_back(root->value);
PreMirrorOrder(root->right, v);
PreMirrorOrder(root->left, v);
}
void PostOrder(Node* root, vector&lt;int>&amp; v){
if(root == NULL) return;
PostOrder(root->left, v);
PostOrder(root->right, v);
v.push_back(root->value);
}
void PostMirrorOrder(Node* root, vector&lt;int>&amp; v){
if(root == NULL) return;
PostMirrorOrder(root->right, v);
PostMirrorOrder(root->left, v);
v.push_back(root->value);
}
int main(){
int n;
Node* s = NULL;
scanf("%d", &amp;n);
vector&lt;int> num, pre, preM, post, postM;
for(int i=0; i&lt;n; i++){
int data;
scanf("%d", &amp;data);
num.push_back(data);
Insert(s, data);
}
PreOrder(s, pre);
if(num == pre){
PostOrder(s, post);
printf("YES\n");
for(unsigned int i=0; i&lt;post.size(); i++){
printf("%d", post[i]);
if(i &lt; post.size()-1) printf(" ");
}
}
else{
PreMirrorOrder(s, preM);
if(num == preM){
PostMirrorOrder(s, postM);
printf("YES\n");
for(unsigned int i=0; i&lt;postM.size(); i++){
printf("%d", postM[i]);
if(i &lt; postM.size()-1) printf(" ");
}
}
else printf("NO\n");
}
return 0;
}
&lt;/pre>
&lt;/details>
&lt;h5 id="根据中序遍历的栈操作顺序重建二叉树">根据中序遍历的栈操作顺序重建二叉树&lt;/h5>
&lt;p>问题描述：An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20200204134923.png" alt="">&lt;/p>
&lt;p>注意二叉树中序遍历时节点入栈顺序与二叉树前序遍历节点访问顺序一致（即，所有 &lt;strong>Push 的节点组成的序列就是这棵树的先序遍历序列&lt;/strong>）。
&lt;strong>中序遍历序列&lt;/strong>可以模拟栈操作获得，前序序列可以根据节点入栈顺序获得，于是问题转为&lt;a href="#%E7%94%B1%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91">从一棵树的先序遍历序列和中序遍历序列生成这棵树&lt;/a>。&lt;/p>
&lt;h3 id="图的算法">图的算法&lt;/h3>
&lt;h4 id="连通子图">连通子图&lt;/h4>
&lt;p>求解无向图的连通子图，一般有两种方法，一种是BFS或DFS遍历，另一种是并查集&lt;/p>
&lt;h5 id="连通子图个数dfs方式">连通子图个数（DFS方式）&lt;/h5>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e">* 求连通子图个数
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">countConnectedSubGraph&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//new数组默认都是false
&lt;/span>&lt;span style="color:#75715e">&lt;/span> visited &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span>&lt;span style="color:#f92672">[&lt;/span>nodeNum &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> nodeNum&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
result&lt;span style="color:#f92672">++;&lt;/span>
DFS&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> result&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e">* 深度优先遍历
&lt;/span>&lt;span style="color:#75715e">* @param s 表示遍历的源点
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">DFS&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> s&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
visited&lt;span style="color:#f92672">[&lt;/span>s&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> arc&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> s &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
DFS&lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">==&lt;/span> s &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>visited&lt;span style="color:#f92672">[&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
DFS&lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="图中两顶点是否连通并查集方式">图中两顶点是否连通(并查集方式)&lt;/h5>
&lt;p>举例说明如下，假如一个图有9个顶点，7条边：(2,4),(5,7),(1,3),(8,9),(1,2),(5,6),(2,3)。&lt;/p>
&lt;p>我们可以给每个顶点建立一个集合，表示最开始时他不知道任何顶点与它连通 。以后每次给出一条边(a, b)，则a所在的子图与b所在的子图就连通了，将a所在集合与b所在集合合并。对于样例数据的操作全过程如下：&lt;/p>
&lt;p>初始状态：{1} {2} {3} {4} {5} {6} {7} {8} {9}&lt;/p>
&lt;p>输入关系 分离集合&lt;/p>
&lt;p>(2,4) {2,4}{1} {3} {5} {6} {7} {8} {9}&lt;/p>
&lt;p>(5,7) {2,4} {5,7} {1} {3} {6} {8} {9}&lt;/p>
&lt;p>(1,3) {1,3} {2,4} {5,7}{6} {8} {9}&lt;/p>
&lt;p>(8,9) {1,3} {2,4} {5,7} {8,9}{6}&lt;/p>
&lt;p>(1,2) {1,2,3,4} {5,7} {8,9}{6}&lt;/p>
&lt;p>(5,6) {1,2,3,4} {5,6,7} {8,9}&lt;/p>
&lt;p>(2,3) {1,2,3,4} {5,6,7} {8,9}&lt;/p>
&lt;p>算法需要以下几个子过程：&lt;/p>
&lt;p>(1) 开始时，为每个顶点建立一个集合；&lt;/p>
&lt;p>(2) 得到一个关系a b，合并相应集合；&lt;/p>
&lt;p>(3) 此外我们还需要判断两个顶点是否在同一个集合中，这就涉及到如何标识集合的问题。我们可以在每个集合中选一个代表标识集合（这里选集合中最小的顶点号作为集合/子图号）。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 存放每个顶点的组号，用于并查集判断两顶点是否连通
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> father&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">setArc&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> arc&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">this&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">arc&lt;/span> &lt;span style="color:#f92672">=&lt;/span> arc&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//更新图连通状态
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> arc&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">length&lt;/span>&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//存在一条边（a，b），则a，b顶点在同一个连通子图中，子图号默认使用其中最小的顶点号
&lt;/span>&lt;span style="color:#75715e">&lt;/span> union&lt;span style="color:#f92672">(&lt;/span>arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>0&lt;span style="color:#f92672">],&lt;/span> arc&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">][&lt;/span>1&lt;span style="color:#f92672">]);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 存在一条边（a，b），则a，b顶点在同一个连通子图中，子图号默认使用其中最小的顶点号
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">union&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> b&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> findFather&lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> y &lt;span style="color:#f92672">=&lt;/span> findFather&lt;span style="color:#f92672">(&lt;/span>b&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>x &lt;span style="color:#f92672">&amp;lt;&lt;/span> y&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
father&lt;span style="color:#f92672">[&lt;/span>y&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> x&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
father&lt;span style="color:#f92672">[&lt;/span>x&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> y&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 寻找顶点a所在的连通子图号（默认以子图中最小的顶点号指代）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findFather&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>a &lt;span style="color:#f92672">!=&lt;/span> father&lt;span style="color:#f92672">[&lt;/span>a&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
a &lt;span style="color:#f92672">=&lt;/span> father&lt;span style="color:#f92672">[&lt;/span>a&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> a&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>递归实现&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c++" data-lang="c++">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">findroot&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> num,&lt;span style="color:#66d9ef">int&lt;/span> JH[])
{
&lt;span style="color:#66d9ef">if&lt;/span>(JH[num]&lt;span style="color:#f92672">==-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> num;
&lt;span style="color:#66d9ef">else&lt;/span>
{
&lt;span style="color:#66d9ef">int&lt;/span> temp&lt;span style="color:#f92672">=&lt;/span>findroot(JH[num],JH);
JH[num]&lt;span style="color:#f92672">=&lt;/span>temp;
&lt;span style="color:#66d9ef">return&lt;/span> temp;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="最短路径">最短路径&lt;/h4>
&lt;p>&lt;strong>最短路径&lt;/strong>问题是&lt;a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E8%AE%BA">图论&lt;/a>研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。算法具体的形式包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>确定起点的最短路径问题&lt;/strong> - 即已知起始结点，求最短路径的问题。适合使用&lt;a href="https://zh.wikipedia.org/wiki/Dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法&lt;/a>。&lt;/li>
&lt;li>&lt;strong>确定终点的最短路径问题&lt;/strong> - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在&lt;a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E5%90%91%E5%9C%96">无向图&lt;/a>中该问题与确定起点的问题完全等同，在&lt;a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E5%90%91%E5%9B%BE">有向图&lt;/a>中该问题等同于把所有路径方向反转的确定起点的问题。&lt;/li>
&lt;li>&lt;strong>确定起点终点的最短路径问题&lt;/strong> - 即已知起点和终点，求两结点之间的最短路径。&lt;/li>
&lt;li>&lt;strong>全局最短路径问题&lt;/strong> - 求图中所有的最短路径。适合使用&lt;a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall算法&lt;/a>。&lt;/li>
&lt;/ul>
&lt;p>用于解决最短路径问题的算法被称做“最短路径算法”，有时被简称作“路径算法”。最常用的路径算法有：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/Dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/A%E6%98%9F%E7%AE%97%E6%B3%95">A*算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/Bellman-Ford%E7%AE%97%E6%B3%95">Bellman-Ford算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/SPFA%E7%AE%97%E6%B3%95">SPFA算法&lt;/a>（Bellman-Ford算法的改进版本）&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95">Floyd-Warshall算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/w/index.php?title=Johnson%E7%AE%97%E6%B3%95&amp;amp;action=edit&amp;amp;redlink=1">Johnson算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/w/index.php?title=Bi-Direction_BFS%E7%AE%97%E6%B3%95&amp;amp;action=edit&amp;amp;redlink=1">Bi-Direction BFS算法&lt;/a>&lt;/li>
&lt;/ul>
&lt;h5 id="dijkstra算法">Dijkstra算法&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20161228204431629.gif" alt="">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>所有顶点集为V。
&lt;strong>引入一个辅助数组(&lt;a href="http://baike.baidu.com/edit/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989?dl=2#">vector&lt;/a>)D&lt;/strong>，每个元素D[i] 表示源点v到其它每个顶点$v_i$的长度。&lt;/p>
&lt;p>例如，D[3] = 2表示从起始点到顶点3的路径相对最小长度为2。这里强调相对就是说在算法执行过程中D的值是在不断逼近最终结果但在过程中不一定就等于最终长度。&lt;/p>
&lt;p>&lt;strong>引入一个辅助集合S&lt;/strong>：表示已找到最短距离的顶点集。（一般也用数组实现）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>D的初始状态&lt;/strong>为：
若从源点v到$v_i$ 有弧（即从 v到 $v_i$存在连接边），则D[i]为弧上的权值（即为从v 到&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img"> 的边的权值）；
若从源点v 到&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img">没有弧, 则置D[i] 为∞。
&lt;strong>S的初始状态&lt;/strong>为$\varnothing$
&lt;strong>置源点到源点的距离为0&lt;/strong>: D[v] = 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>找&lt;strong>最短的路径（长度）&lt;/strong>：D[j] = Min{ D[i] |$v_i$ ∈V-S } ，此路径为$(v,v_j)$, 即到顶点j 距离最短。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将&lt;strong>对应的顶点j加入到S集&lt;/strong>，表示源点v到顶点j已是最短路径&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>更新V-S集顶点k的D值&lt;/strong>：对于${v_k|v_k \subset V-S}$,源点v到终点$v_k$, 最短路径要么是$(v,v_k)$, 要么是$(v,v_j,v_k)$。 即要么不经过顶点j，要么经过顶点j。那么当$D[j] + arc[v][j] &amp;lt; D[k]$时, 更新$D[k] =D[j] + arc[v][j]$ 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若V-S集不为空，回到第三步，从非S集中继续寻找最短路径D[j]; 否则结束。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>算法简化描述如下：&lt;/p>
&lt;p>1）令arcs表示弧上的权值。若弧不存在，则置arcs为∞（在本程序中为MAXCOST）。S为已找到的从v 出发的的终点的集合，初始状态为空集。那么，从v 出发到图上其余各顶点&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img"> 可能达到的长度的初值为D=arcs[Locate Vex(G,&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img"> )]，&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img"> ∈V；&lt;/p>
&lt;p>2）选择&lt;img src="http://d.hiphotos.baidu.com/baike/pic/item/43a7d933c895d143c689ac6270f082025baf07f7.jpg" alt="img"> ，使得D&lt;img src="http://d.hiphotos.baidu.com/baike/pic/item/4bed2e738bd4b31c144addfa84d6277f9e2ff879.jpg" alt="img"> =Min{ D |&lt;img src="http://h.hiphotos.baidu.com/baike/pic/item/242dd42a2834349bd43c21c4caea15ce36d3bebd.jpg" alt="img"> ∈V-S } ；&lt;/p>
&lt;p>3）修改从v 出发的到集合V-S中任一顶点&lt;img src="http://a.hiphotos.baidu.com/baike/pic/item/63d9f2d3572c11df01a2f762602762d0f703c204.jpg" alt="img"> 的最短路径长度。&lt;/p>
&lt;pre>&lt;code class="language-flow" data-lang="flow">start=&amp;gt;start: Start:&amp;gt;http://www.google.com[blank]
end=&amp;gt;end: End
inputSource=&amp;gt;inputoutput: 输入源点
setupDS=&amp;gt;operation: 初始化当前各顶点到源点的最短距离D={∞,...}，标记各顶点到源点还不是最短visited={false,...}
input=&amp;gt;inputoutput: 输入各顶点的权值v[],顶点间距离c[][],源点
findMinDist=&amp;gt;subroutine: 从没有visited的顶点中，寻找到源点距离最短的顶点k
visitK=&amp;gt;operation: 标记顶点k已找到源点的最短距离：visited[k]=true
updateUnVisited=&amp;gt;subroutine: 更新未visited的顶点到源点的当前最短距离D[]
haveUnVisitedOrNot=&amp;gt;condition: 还有未visited的顶点吗？
start-&amp;gt;inputSource-&amp;gt;setupDS-&amp;gt;input-&amp;gt;findMinDist
findMinDist-&amp;gt;visitK-&amp;gt;updateUnVisited-&amp;gt;haveUnVisitedOrNot
haveUnVisitedOrNot(yes)-&amp;gt;findMinDist
haveUnVisitedOrNot(no)-&amp;gt;end
&lt;/code>&lt;/pre>&lt;p>&lt;strong>举个例子&lt;/strong>：&lt;/p>
&lt;p>对于无向图图g有4个顶点，5条边，顶点号为：0，1，2，3，边集{(start,end, distance,cost)} = {(0,1,1,20), (0,2,2,20), (0,3,4,10),(1,3,3,30), (2,3,1,20)}&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20200213105726.png" alt="">&lt;/p>
&lt;p>假设要找从顶点0到顶点3的最短距离，花销，以及具体路径。下面是单源点最短路径Dijkstra算法的过程：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>各顶点是否找到最但距离：visited[]&lt;/th>
&lt;th>源点（顶点0）到各顶点的距离： D[]&lt;/th>
&lt;th>源点（顶点0）到各顶点的花销： C[]&lt;/th>
&lt;th>各顶点的前一个顶点： P[]&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>初始化&lt;/td>
&lt;td>false, false, false, false&lt;/td>
&lt;td>$\infty$,$\infty$,$\infty$,$\infty$&lt;/td>
&lt;td>$\infty$,$\infty$,$\infty$,$\infty$&lt;/td>
&lt;td>-1, - 1, -1, -1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>源点&lt;/strong>（顶点0）默认已找到最短距离,&lt;br />加入到visited[],&lt;br />同时更新D,C,P&lt;/td>
&lt;td>&lt;strong>true&lt;/strong>，false, false, false&lt;/td>
&lt;td>&lt;strong>0,1,2,4&lt;/strong>&lt;br />顶点0到顶点0距离为0，&lt;br />顶点0到其他顶点有直接的边，边上的距离值设为顶点0到其他顶点的距离&lt;/td>
&lt;td>&lt;strong>0,20,20,10&lt;/strong>&lt;br />顶点0到顶点0花销为0，&lt;br />顶点0到其他顶点有直接的边，边上的花销值设为顶点0到其他顶点的花销&lt;/td>
&lt;td>-1, &lt;strong>0, 0, 0&lt;/strong>&lt;br />顶点0到其他顶点有直接的边，其他顶点都是从源点直接到达的，它们的前一个顶点都是源点0&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选!visited[]且D,C最小值对应的顶点（&lt;strong>顶点1&lt;/strong>），&lt;br />加入到visited[],&lt;br />同时更新D,C,P&lt;/td>
&lt;td>true,&lt;strong>true&lt;/strong>,false,false&lt;/td>
&lt;td>0,1,2,&lt;strong>3&lt;/strong>&lt;br />从源点0出发通过顶点1，再到达顶点3，比原来D[3]值更小&lt;/td>
&lt;td>0,20,20,&lt;strong>50&lt;/strong>&lt;br />D值变化，根据路径变化同步修改C值&lt;/td>
&lt;td>-1, 0, 0, &lt;strong>1&lt;/strong>&lt;br />前面从源点0到顶点3的距离和花销发生变化的原因是路径发生了改变：从源点0出发通过顶点1，再到达顶点3，即顶点3的前一个顶点是1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选!visited[]且D,C最小值对应的顶点（&lt;strong>顶点2&lt;/strong>），&lt;br />加入到visited[],&lt;br />同时更新D,C,P&lt;/td>
&lt;td>true,true,&lt;strong>true&lt;/strong>,false&lt;/td>
&lt;td>0,1,2,3&lt;/td>
&lt;td>0,20,20,&lt;strong>40&lt;/strong>&lt;br />从源点0出发通过顶点2，再到达顶点3，和原来D[3]值一样大，但经过顶点2后C[3]更小&lt;/td>
&lt;td>-1, 0, 0, &lt;strong>2&lt;/strong>&lt;br />路径发生了改变：从源点0出发通过顶点2，再到达顶点3，即顶点3的前一个顶点是1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>选!visited[]且D,C最小值对应的顶点（&lt;strong>顶点3&lt;/strong>），&lt;br />加入到visited[],&lt;br />同时更新D,C,P&lt;/td>
&lt;td>true,true,true,&lt;strong>true&lt;/strong>&lt;/td>
&lt;td>0,1,2,3&lt;/td>
&lt;td>0,20,20,40&lt;/td>
&lt;td>-1, 0, 0, 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>没有顶点!visited[]&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>则从源点0到顶点3的最短距离为D[3] = 3, 同时最小花销为C[3] = 40.&lt;/p>
&lt;p>从各顶点的前一个顶点： P[] = {-1, 0, 0, 2},我们可以看出，顶点3的前一个顶点P[3] = 2, 顶点2的前一个顶点P[2] = 0, 顶点0的前一个顶点P[0] = -1, -1表示没有前一个顶点，即3&amp;lt;-2&amp;lt;-0,即从源点0到顶点3的最短路径为0-&amp;gt;2-&amp;gt;3.&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span>&lt;span style="color:#75715e">&amp;lt;stdlib.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#define max1 10000000 &lt;/span>&lt;span style="color:#75715e">//原词条这里的值太大，导致溢出，后面比较大小时会出错
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> a[&lt;span style="color:#ae81ff">1000&lt;/span>][&lt;span style="color:#ae81ff">1000&lt;/span>];
&lt;span style="color:#66d9ef">int&lt;/span> d[&lt;span style="color:#ae81ff">1000&lt;/span>];&lt;span style="color:#75715e">//d表示源节点到该节点的最小距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> p[&lt;span style="color:#ae81ff">1000&lt;/span>];&lt;span style="color:#75715e">//p标记访问过的节点
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i, j, k;
&lt;span style="color:#66d9ef">int&lt;/span> m;&lt;span style="color:#75715e">//m代表边数
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n;&lt;span style="color:#75715e">//n代表点数
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#66d9ef">int&lt;/span> min1;
&lt;span style="color:#66d9ef">int&lt;/span> x,y,z;
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d%d%d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>x,&lt;span style="color:#f92672">&amp;amp;&lt;/span>y,&lt;span style="color:#f92672">&amp;amp;&lt;/span>z);
a[x][y]&lt;span style="color:#f92672">=&lt;/span>z;
a[y][x]&lt;span style="color:#f92672">=&lt;/span>z;
}
&lt;span style="color:#66d9ef">for&lt;/span>( i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n; i&lt;span style="color:#f92672">++&lt;/span>)
d[i]&lt;span style="color:#f92672">=&lt;/span>max1;
d[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
min1 &lt;span style="color:#f92672">=&lt;/span> max1;
&lt;span style="color:#75715e">//下面这个for循环的功能类似冒泡排序，目的是找到未访问节点中d[j]值最小的那个节点，
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//作为下一个访问节点，用k标记
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>p[j]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>d[j]&lt;span style="color:#f92672">&amp;lt;&lt;/span>min1)
{
min1&lt;span style="color:#f92672">=&lt;/span>d[j];
k&lt;span style="color:#f92672">=&lt;/span>j;
}
&lt;span style="color:#75715e">//p[k]=d[k]; // 这是原来的代码，用下一 条代码替代。初始时，执行到这里k=1，而d[1]=0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//从而p[1]等于0，这样的话，上面的循环在之后的每次执行之后，k还是等于1。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> p[k] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//置1表示第k个节点已经访问过了
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(a[k][j]&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;amp;&amp;amp;!&lt;/span>p[j]&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span>d[j]&lt;span style="color:#f92672">&amp;gt;&lt;/span>d[k]&lt;span style="color:#f92672">+&lt;/span>a[k][j])
d[j]&lt;span style="color:#f92672">=&lt;/span>d[k]&lt;span style="color:#f92672">+&lt;/span>a[k][j];
}
&lt;span style="color:#75715e">//最终输出从源节点到其他每个节点的最小距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
printf(&lt;span style="color:#e6db74">&amp;#34;%d-&amp;gt;&amp;#34;&lt;/span>,d[i]);
printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,d[n]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>相似的实现&lt;strong>大学经典教材&amp;laquo;数据结构&amp;raquo;(C语言版 严蔚敏 吴为民 编著) 中该算法的实现&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">/*
&lt;/span>&lt;span style="color:#75715e">测试数据 教科书 P189 G6 的邻接矩阵 其中 数字 1000000 代表无穷大
&lt;/span>&lt;span style="color:#75715e">6
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 10 100000 30 100
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 5 1000000 1000000 1000000
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 1000000 50 1000000 1000000
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 1000000 1000000 1000000 10
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 1000000 20 1000000 60
&lt;/span>&lt;span style="color:#75715e">1000000 1000000 1000000 1000000 1000000 1000000
&lt;/span>&lt;span style="color:#75715e">结果：
&lt;/span>&lt;span style="color:#75715e">D[0] D[1] D[2] D[3] D[4] D[5]
&lt;/span>&lt;span style="color:#75715e"> 0 1000000 10 50 30 60
&lt;/span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#define MAX 1000000
&lt;/span>&lt;span style="color:#75715e">&lt;/span>using namespace std;
&lt;span style="color:#66d9ef">int&lt;/span> arcs[&lt;span style="color:#ae81ff">10&lt;/span>][&lt;span style="color:#ae81ff">10&lt;/span>];&lt;span style="color:#75715e">//邻接矩阵
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> D[&lt;span style="color:#ae81ff">10&lt;/span>];&lt;span style="color:#75715e">//保存最短路径长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> p[&lt;span style="color:#ae81ff">10&lt;/span>][&lt;span style="color:#ae81ff">10&lt;/span>];&lt;span style="color:#75715e">//路径
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> final[&lt;span style="color:#ae81ff">10&lt;/span>];&lt;span style="color:#75715e">//若final[i] = 1则说明 顶点vi已在集合S中
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//顶点个数
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> v0 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//源点
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> v,w;
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">ShortestPath_DIJ&lt;/span>()
{
&lt;span style="color:#66d9ef">for&lt;/span> (v &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; v &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; v&lt;span style="color:#f92672">++&lt;/span>) &lt;span style="color:#75715e">//循环 初始化
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
final[v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; D[v] &lt;span style="color:#f92672">=&lt;/span> arcs[v0][v];
&lt;span style="color:#66d9ef">for&lt;/span> (w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; w &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w&lt;span style="color:#f92672">++&lt;/span>) p[v][w] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;&lt;span style="color:#75715e">//设空路径
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (D[v] &lt;span style="color:#f92672">&amp;lt;&lt;/span> MAX) {p[v][v0] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; p[v][v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;}
}
D[v0] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; final[v0]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//初始化 v0顶点属于集合S
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//开始主循环 每次求得v0到某个顶点v的最短路径 并加v到集合S中
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">int&lt;/span> min &lt;span style="color:#f92672">=&lt;/span> MAX;
&lt;span style="color:#66d9ef">for&lt;/span> (w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; w &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#75715e">//我认为的核心过程--选点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>final[w]) &lt;span style="color:#75715e">//如果w顶点在V-S中
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
&lt;span style="color:#75715e">//这个过程最终选出的点 应该是选出当前V-S中与S有关联边
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//且权值最小的顶点 书上描述为 当前离V0最近的点
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (D[w] &lt;span style="color:#f92672">&amp;lt;&lt;/span> min) {v &lt;span style="color:#f92672">=&lt;/span> w; min &lt;span style="color:#f92672">=&lt;/span> D[w];}
}
}
final[v] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//选出该点后加入到合集S中
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (w &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; w &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; w&lt;span style="color:#f92672">++&lt;/span>)&lt;span style="color:#75715e">//更新当前最短路径和距离
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
&lt;span style="color:#75715e">/*在此循环中 v为当前刚选入集合S中的点
&lt;/span>&lt;span style="color:#75715e"> 则以点V为中间点 考察 d0v+dvw 是否小于 D[w] 如果小于 则更新
&lt;/span>&lt;span style="color:#75715e"> 比如加进点 3 则若要考察 D[5] 是否要更新 就 判断 d(v0-v3) + d(v3-v5) 的和是否小于D[5]
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>final[w] &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (min&lt;span style="color:#f92672">+&lt;/span>arcs[v][w]&lt;span style="color:#f92672">&amp;lt;&lt;/span>D[w]))
{
D[w] &lt;span style="color:#f92672">=&lt;/span> min &lt;span style="color:#f92672">+&lt;/span> arcs[v][w];
&lt;span style="color:#75715e">// p[w] = p[v];
&lt;/span>&lt;span style="color:#75715e">&lt;/span> p[w][w] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">//p[w] = p[v] +　[w]
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
}
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> n;
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>)
{
cin &lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> arcs[i][j];
}
}
ShortestPath_DIJ();
&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) printf(&lt;span style="color:#e6db74">&amp;#34;D[%d] = %d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,i,D[i]);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="a算法">A*算法&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20161228204449060.gif" alt="">&lt;/p>
&lt;p>A* 算法使用了启发式信息：到目标的距离&lt;/p>
&lt;p>&lt;em>Dijkstra&lt;/em> 算法和它的升级版 A* 算法得到的结果是一样的，即所有节点的值在更新后是相同的。&lt;/p>
&lt;p>香侬告诉我们，信息可以消除不确定性。其实，信息还可以提高算法的效率。因为我们都有这样的经验：信息越充分，决策越容易成功。&lt;em>&lt;em>A&lt;/em> 算法仅仅将非常简单的启发式信息引入了Dijkstra 算法，就能大幅降低待处理节点的数量，从而极大的提高了效率。&lt;/em>*&lt;/p>
&lt;p>&lt;em>&lt;em>A&lt;/em> 算法详解&lt;/em>*&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>译文摘录：&lt;/p>
&lt;blockquote>
&lt;h3 id="概述">概述&lt;/h3>
&lt;p>虽然掌握了 A* 算法的人认为它容易，但是对于初学者来说， A* 算法还是很复杂的。&lt;/p>
&lt;h3 id="搜索区域the-search-area">搜索区域(The Search Area)&lt;/h3>
&lt;p>我们假设某人要从 A 点移动到 B 点，但是这两点之间被一堵墙隔开。如图 1 ，绿色是 A ，红色是 B ，中间蓝色是墙。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image001.jpg" alt="image001.jpg">&lt;/p>
&lt;p>图 1&lt;/p>
&lt;p>你应该注意到了，我们把要搜寻的区域划分成了正方形的格子。这是寻路的第一步，简化搜索区域，就像我们这里做的一样。这个特殊的方法把我们的搜索区域简化为了 2 维数组。数组的每一项代表一个格子，它的状态就是可走 (walkalbe) 和不可走 (unwalkable) 。通过计算出从 A 到 B需要走过哪些方格，就找到了路径。一旦路径找到了，人物便从一个方格的中心移动到另一个方格的中心，直至到达目的地。&lt;/p>
&lt;p>方格的中心点我们成为“节点 (nodes) ”。如果你读过其他关于 A* 寻路算法的文章，你会发现人们常常都在讨论节点。为什么不直接描述为方格呢？因为我们有可能把搜索区域划为为其他多变形而不是正方形，例如可以是六边形，矩形，甚至可以是任意多变形。而节点可以放在任意多边形里面，可以放在多变形的中心，也可以放在多边形的边上。我们使用这个系统，因为它最简单。&lt;/p>
&lt;h3 id="开始搜索starting-the-search">开始搜索(Starting the Search)&lt;/h3>
&lt;p>一旦我们把搜寻区域简化为一组可以量化的节点后，就像上面做的一样，我们下一步要做的便是查找最短路径。在 A* 中，我们从起点开始，检查其相邻的方格，然后向四周扩展，直至找到目标。&lt;/p>
&lt;p>我们这样开始我们的寻路旅途：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从起点 A 开始，并把它就加入到一个由方格组成的 open list( 开放列表 ) 中。这个 open list 有点像是一个购物单。当然现在 open list 里只有一项，它就是起点 A ，后面会慢慢加入更多的项。 Open list 里的格子是路径可能会是沿途经过的，也有可能不经过。基本上 open list 是一个待检查的方格列表。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>查看与起点 A 相邻的方格 ( 忽略其中墙壁所占领的方格，河流所占领的方格及其他非法地形占领的方格 ) ，把其中可走的 (walkable) 或可到达的 (reachable) 方格也加入到 open list 中。把起点 A 设置为这些方格的父亲 (parent node 或 parent square) 。当我们在追踪路径时，这些父节点的内容是很重要的。稍后解释。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把 A 从 open list 中移除，加入到 close list( 封闭列表 ) 中， close list 中的每个方格都是现在不需要再关注的。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>如下图所示，深绿色的方格为起点，它的外框是亮蓝色，表示该方格被加入到了 close list 。与它相邻的黑色方格是需要被检查的，他们的外框是亮绿色。每个黑方格都有一个灰色的指针指向他们的父节点，这里是起点 A 。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image002.jpg" alt="image002.jpg">&lt;/p>
&lt;p>图 2 。&lt;/p>
&lt;p>下一步，我们需要从 open list 中选一个与起点 A 相邻的方格，按下面描述的一样或多或少的重复前面的步骤。但是到底选择哪个方格好呢？具有最小 F 值的那个。&lt;/p>
&lt;h3 id="路径排序path-sorting">路径排序(Path Sorting)&lt;/h3>
&lt;p>计算出组成路径的方格的关键是下面这个等式：&lt;/p>
&lt;p>F = G + H&lt;/p>
&lt;p>这里，&lt;/p>
&lt;p>G = 从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。&lt;/p>
&lt;p>H = 从指定的方格移动到终点 B 的估算成本。这个通常被称为试探法，有点让人混淆。为什么这么叫呢，因为这是个猜测。直到我们找到了路径我们才会知道真正的距离，因为途中有各种各样的东西 ( 比如墙壁，水等 ) 。本教程将教你一种计算 H 的方法，你也可以在网上找到其他方法。&lt;/p>
&lt;p>我们的路径是这么产生的：反复遍历 open list ，选择 F 值最小的方格。这个过程稍后详细描述。我们还是先看看怎么去计算上面的等式。&lt;/p>
&lt;p>如上所述， G 是从起点Ａ移动到指定方格的移动代价。在本例中，横向和纵向的移动代价为 10 ，对角线的移动代价为 14 。之所以使用这些数据，是因为实际的对角移动距离是 2 的平方根，或者是近似的 1.414 倍的横向或纵向移动代价。使用 10 和 14 就是为了简单起见。比例是对的，我们避免了开放和小数的计算。这并不是我们没有这个能力或是不喜欢数学。使用这些数字也可以使计算机更快。稍后你便会发现，如果不使用这些技巧，寻路算法将很慢。&lt;/p>
&lt;p>既然我们是沿着到达指定方格的路径来计算 G 值，那么计算出该方格的 G 值的方法就是找出其父亲的 G 值，然后按父亲是直线方向还是斜线方向加上 10 或 14 。随着我们离开起点而得到更多的方格，这个方法会变得更加明朗。&lt;/p>
&lt;p>有很多方法可以估算 H 值。这里我们使用 Manhattan 方法，计算从当前方格横向或纵向移动到达目标所经过的方格数，忽略对角移动，然后把总数乘以 10 。之所以叫做 Manhattan 方法，是因为这很像统计从一个地点到另一个地点所穿过的街区数，而你不能斜向穿过街区。重要的是，计算 H 是，要忽略路径中的障碍物。这是对剩余距离的估算值，而不是实际值，因此才称为试探法。&lt;/p>
&lt;p>把 G 和 H 相加便得到 F 。我们第一步的结果如下图所示。每个方格都标上了 F ， G ， H 的值，就像起点右边的方格那样，左上角是 F ，左下角是 G ，右下角是 H 。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image003.jpg" alt="image003.jpg">&lt;/p>
&lt;p>图 3&lt;/p>
&lt;p>好，现在让我们看看其中的一些方格。在标有字母的方格， G = 10 。这是因为水平方向从起点到那里只有一个方格的距离。与起点直接相邻的上方，下方，左方的方格的 G 值都是 10 ，对角线的方格 G 值都是 14 。&lt;/p>
&lt;p>H 值通过估算起点于终点 ( 红色方格 ) 的 Manhattan 距离得到，仅作横向和纵向移动，并且忽略沿途的墙壁。使用这种方式，起点右边的方格到终点有 3 个方格的距离，因此 H = 30 。这个方格上方的方格到终点有 4 个方格的距离 ( 注意只计算横向和纵向距离 ) ，因此 H = 40 。对于其他的方格，你可以用同样的方法知道 H 值是如何得来的。&lt;/p>
&lt;p>每个方格的 F 值，再说一次，直接把 G 值和 H 值相加就可以了。&lt;/p>
&lt;h3 id="继续搜索continuing-the-search">继续搜索(Continuing the Search)&lt;/h3>
&lt;p>为了继续搜索，我们从 open list 中选择 F 值最小的 ( 方格 ) 节点，然后对所选择的方格作如下操作：&lt;/p>
&lt;ol start="4">
&lt;li>
&lt;p>把它从 open list 里取出，放到 close list 中。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>检查所有与它相邻的方格，忽略其中在 close list 中或是不可走 (unwalkable) 的方格 ( 比如墙，水，或是其他非法地形 ) ，如果方格不在open lsit 中，则把它们加入到 open list 中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>把我们选定的方格设置为这些新加入的方格的父亲。&lt;/p>
&lt;ol start="6">
&lt;li>如果某个相邻的方格已经在 open list 中，则检查这条路径是否更优，也就是说经由当前方格 ( 我们选中的方格 ) 到达那个方格是否具有更小的 G 值。如果没有，不做任何操作。&lt;/li>
&lt;/ol>
&lt;p>相反，如果 G 值更小，则把那个方格的父亲设为当前方格 ( 我们选中的方格 ) ，然后重新计算那个方格的 F 值和 G 值。如果你还是很混淆，请参考下图。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image004.jpg" alt="image004.jpg">&lt;/p>
&lt;p>图 4&lt;/p>
&lt;p>Ok ，让我们看看它是怎么工作的。在我们最初的 9 个方格中，还有 8 个在 open list 中，起点被放入了 close list 中。在这些方格中，起点右边的格子的 F 值 40 最小，因此我们选择这个方格作为下一个要处理的方格。它的外框用蓝线打亮。&lt;/p>
&lt;p>首先，我们把它从 open list 移到 close list 中 ( 这就是为什么用蓝线打亮的原因了 ) 。然后我们检查与它相邻的方格。它右边的方格是墙壁，我们忽略。它左边的方格是起点，在 close list 中，我们也忽略。其他 4 个相邻的方格均在 open list 中，我们需要检查经由这个方格到达那里的路径是否更好，使用 G 值来判定。让我们看看上面的方格。它现在的 G 值为 14 。如果我们经由当前方格到达那里， G 值将会为 20(其中 10 为到达当前方格的 G 值，此外还要加上从当前方格纵向移动到上面方格的 G 值 10) 。显然 20 比 14 大，因此这不是最优的路径。如果你看图你就会明白。直接从起点沿对角线移动到那个方格比先横向移动再纵向移动要好。&lt;/p>
&lt;p>当把 4 个已经在 open list 中的相邻方格都检查后，没有发现经由当前方格的更好路径，因此我们不做任何改变。现在我们已经检查了当前方格的所有相邻的方格，并也对他们作了处理，是时候选择下一个待处理的方格了。&lt;/p>
&lt;p>因此再次遍历我们的 open list ，现在它只有 7 个方格了，我们需要选择 F 值最小的那个。有趣的是，这次有两个方格的 F 值都 54 ，选哪个呢？没什么关系。从速度上考虑，选择最后加入 open list 的方格更快。这导致了在寻路过程中，当靠近目标时，优先使用新找到的方格的偏好。但是这并不重要。 ( 对相同数据的不同对待，导致两中版本的 A* 找到等长的不同路径 ) 。&lt;/p>
&lt;p>我们选择起点右下方的方格，如下图所示。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image005.jpg" alt="image005.jpg">&lt;/p>
&lt;p>图 5&lt;/p>
&lt;p>这次，当我们检查相邻的方格时，我们发现它右边的方格是墙，忽略之。上面的也一样。&lt;/p>
&lt;p>我们把墙下面的一格也忽略掉。为什么？因为如果不穿越墙角的话，你不能直接从当前方格移动到那个方格。你需要先往下走，然后再移动到那个方格，这样来绕过墙角。 ( 注意：穿越墙角的规则是可选的，依赖于你的节点是怎么放置的 )&lt;/p>
&lt;p>这样还剩下 5 个相邻的方格。当前方格下面的 2 个方格还没有加入 open list ，所以把它们加入，同时把当前方格设为他们的父亲。在剩下的3 个方格中，有 2 个已经在 close list 中 ( 一个是起点，一个是当前方格上面的方格，外框被加亮的 ) ，我们忽略它们。最后一个方格，也就是当前方格左边的方格，我们检查经由当前方格到达那里是否具有更小的 G 值。没有。因此我们准备从 open list 中选择下一个待处理的方格。&lt;/p>
&lt;p>不断重复这个过程，直到把终点也加入到了 open list 中，此时如下图所示。&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image006.jpg" alt="image006.jpg">&lt;/p>
&lt;p>图 6&lt;/p>
&lt;p>注意，在起点下面 2 格的方格的父亲已经与前面不同了。之前它的 G 值是 28 并且指向它右上方的方格。现在它的 G 值为 20 ，并且指向它正上方的方格。这在寻路过程中的某处发生，使用新路径时 G 值经过检查并且变得更低，因此父节点被重新设置， G 和 F 值被重新计算。尽管这一变化在本例中并不重要，但是在很多场合中，这种变化会导致寻路结果的巨大变化。&lt;/p>
&lt;p>那么我们怎么样去确定实际路径呢？很简单，从终点开始，按着箭头向父节点移动，这样你就被带回到了起点，这就是你的路径。如下图所示。从起点 A 移动到终点 B 就是简单从路径上的一个方格的中心移动到另一个方格的中心，直至目标。就是这么简单！&lt;/p>
&lt;p>&lt;img src="http://www.cppblog.com/images/cppblog_com/christanxw/image007.jpg" alt="image007.jpg">&lt;/p>
&lt;p>图 7&lt;/p>
&lt;h3 id="a算法总结summary-of-the-a-method">A&lt;em>算法总结(Summary of the A&lt;/em> Method)&lt;/h3>
&lt;p>Ok ，现在你已经看完了整个的介绍，现在我们把所有步骤放在一起：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>把起点加入 open list 。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重复如下过程：&lt;/p>
&lt;p>a. 遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。&lt;/p>
&lt;p>b. 把这个节点移到 close list 。&lt;/p>
&lt;p>c. 对当前方格的 8 个相邻方格的每一个方格？&lt;/p>
&lt;p>​ ◆ 如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。&lt;/p>
&lt;p>​ ◆ 如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的 F ， G 和 H 值。&lt;/p>
&lt;p>​ ◆ 如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。如果你的 open list 是按 F 值排序的话，改变后你可能需要重新排序。&lt;/p>
&lt;p>d. 停止，当你&lt;/p>
&lt;p>​ ◆ 把终点加入到了 open list 中，此时路径已经找到了，或者&lt;/p>
&lt;p>​ ◆ 查找终点失败，并且 open list 是空的，此时没有路径。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;h5 id="dijkstra算法和a算法的比较">Dijkstra算法和A*算法的比较&lt;/h5>
&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Dijkstra's_algorithm">Dijkstra算法&lt;/a>和&lt;a href="http://blog.vckbase.com/panic/archive/2005/03/20/3778.html">A* 算法&lt;/a>都是&lt;a href="http://baike.baidu.com/view/349189.htm">最短路径&lt;/a>问题的常用算法，下面就对这两种算法的特点进行一下比较。
1.Dijkstra算法计算源点到其他所有点的最短路径长度，A* 关注点到点的最短路径(包括具体路径)。
2.Dijkstra算法建立在较为抽象的图论层面，A* 算法可以更轻松地用在诸如游戏地图寻路中。
3.Dijkstra算法的实质是广度优先搜索，是一种发散式的搜索，所以空间复杂度和时间复杂度都比较高。对路径上的当前点，A* 算法不但记录其到源点的代价，还计算当前点到目标点的期望代价，是一种启发式算法，也可以认为是一种深度优先的算法。
4.由第一点，当目标点很多时，A* 算法会带入大量重复数据和复杂的估价函数，所以如果不要求获得具体路径而只比较路径长度时，Dijkstra算法会成为更好的选择。&lt;/p>
&lt;h5 id="floyd-warshall算法">Floyd-Warshall算法&lt;/h5>
&lt;p>参考：https://www.cnblogs.com/wangyuliang/p/9216365.html&lt;/p>
&lt;p>参考：&lt;a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd#:~:text=Floyd-Warshall%E7%AE%97%E6%B3%95%EF%BC%88Floyd-,O(N%5E2)%E3%80%82">https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd#:~:text=Floyd%2DWarshall%E7%AE%97%E6%B3%95%EF%BC%88Floyd%2D,O(N%5E2)%E3%80%82&lt;/a>&lt;/p>
&lt;p>Floyd算法是求多源最短路径的算法。一次获取所有的两点之间最短距离。&lt;/p>
&lt;h6 id="过程">过程&lt;/h6>
&lt;p>现在需要一个数据结构来存储图的信息，我们仍然可以用一个4*4的矩阵（二维数组e）来存储。比如1号城市到2号城市的路程为2，则设e[1][2]的值为2。2号城市无法到达4号城市，则设置e[2][4]的值为∞。另外此处约定一个城市自己是到自己的也是0，例如e[1][1]为0，具体如下。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/1033450-20180623095252434-1650383278.png" alt="img">&lt;/p>
&lt;p>当任意两点之间不允许经过第三个点时，这些城市之间最短路程就是初始路程，如下。&lt;/p>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1033450/201806/1033450-20180623095300910-62980415.png" alt="img">&lt;/p>
&lt;p>​&lt;/p>
&lt;p>假如现在只允许经过1号顶点，求任意两点之间的最短路程，应该如何求呢？只需判断e[i][1]+e[1][j]是否比e[i][j]要小即可。e[i][j]表示的是从i号顶点到j号顶点之间的路程。e[i][1]+e[1][j]表示的是从i号顶点先到1号顶点，再从1号顶点到j号顶点的路程之和。其中i是1~n循环，j也是1~n循环，代码实现如下。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span> (j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">if&lt;/span> (e[i][j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> e[i][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> e[&lt;span style="color:#ae81ff">1&lt;/span>][j])
e[i][j] &lt;span style="color:#f92672">=&lt;/span> e[i][&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">+&lt;/span> e[&lt;span style="color:#ae81ff">1&lt;/span>][j];
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在只允许经过1号顶点的情况下，任意两点之间的最短路程更新为：&lt;/p>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1033450/201806/1033450-20180623101149549-789864301.png" alt="img">&lt;/p>
&lt;p>​ 通过上图我们发现：在只通过1号顶点中转的情况下，3号顶点到2号顶点（e[3][2]）、4号顶点到2号顶点（e[4][2]）以及4号顶点到3号顶点（e[4][3]）的路程都变短了。&lt;/p>
&lt;p>​ 接下来继续求在只允许经过1和2号两个顶点的情况下任意两点之间的最短路程。如何做呢？我们需要在只允许经过1号顶点时任意两点的最短路程的结果下，再判断如果经过2号顶点是否可以使得i号顶点到j号顶点之间的路程变得更短。即判断e[i][2]+e[2][j]是否比e[i][j]要小，代码实现为如下。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">//经过1号顶点
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (e[i][j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> e[i][&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>e[&lt;span style="color:#ae81ff">1&lt;/span>][j]) e[i][j]&lt;span style="color:#f92672">=&lt;/span>e[i][&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>e[&lt;span style="color:#ae81ff">1&lt;/span>][j];
&lt;span style="color:#75715e">//经过2号顶点
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span> (e[i][j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> e[i][&lt;span style="color:#ae81ff">2&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>e[&lt;span style="color:#ae81ff">2&lt;/span>][j]) e[i][j]&lt;span style="color:#f92672">=&lt;/span>e[i][&lt;span style="color:#ae81ff">2&lt;/span>]&lt;span style="color:#f92672">+&lt;/span>e[&lt;span style="color:#ae81ff">2&lt;/span>][j];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在只允许经过1和2号顶点的情况下，任意两点之间的最短路程更新为：&lt;/p>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1033450/201806/1033450-20180623101203935-1282201243.png" alt="img">&lt;/p>
&lt;p>​ 通过上图得知，在相比只允许通过1号顶点进行中转的情况下，这里允许通过1和2号顶点进行中转，使得e[1][3]和e[4][3]的路程变得更短了。&lt;/p>
&lt;p>​ 同理，继续在只允许经过1、2和3号顶点进行中转的情况下，求任意两点之间的最短路程。任意两点之间的最短路程更新为：&lt;/p>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1033450/201806/1033450-20180623101217444-482921737.png" alt="img">&lt;/p>
&lt;p>​ 最后允许通过所有顶点作为中转，任意两点之间最终的最短路程为：&lt;/p>
&lt;p>&lt;img src="https://images2018.cnblogs.com/blog/1033450/201806/1033450-20180623101226080-1736008850.png" alt="img">&lt;/p>
&lt;p>​ 整个算法过程虽然说起来很麻烦，但是代码实现却非常简单，核心代码只有五行：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">for&lt;/span>(k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;k&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(e[i][j]&lt;span style="color:#f92672">&amp;gt;&lt;/span>e[i][k]&lt;span style="color:#f92672">+&lt;/span>e[k][j])
e[i][j]&lt;span style="color:#f92672">=&lt;/span>e[i][k]&lt;span style="color:#f92672">+&lt;/span>e[k][j];
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码的基本思想就是：最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">#include&lt;/span>
&lt;span style="color:#75715e">int main()&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
&lt;span style="color:#66d9ef">int&lt;/span> e[&lt;span style="color:#ae81ff">10&lt;/span>][&lt;span style="color:#ae81ff">10&lt;/span>],k,i,j,n,m,t1,t2,t3;
&lt;span style="color:#66d9ef">int&lt;/span> inf&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">99999999&lt;/span>; &lt;span style="color:#75715e">//用inf(infinity的缩写)存储一个我们认为的正无穷值
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//读入n和m，n表示顶点个数，m表示边的条数
&lt;/span>&lt;span style="color:#75715e">&lt;/span> scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>n,&lt;span style="color:#f92672">&amp;amp;&lt;/span>m);
&lt;span style="color:#75715e">//初始化
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(i&lt;span style="color:#f92672">==&lt;/span>j) e[i][j]&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">else&lt;/span> e[i][j]&lt;span style="color:#f92672">=&lt;/span>inf;
&lt;span style="color:#75715e">//读入边
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>m;i&lt;span style="color:#f92672">++&lt;/span>)
{
scanf(&lt;span style="color:#e6db74">&amp;#34;%d %d %d&amp;#34;&lt;/span>,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t1,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t2,&lt;span style="color:#f92672">&amp;amp;&lt;/span>t3);
e[t1][t2]&lt;span style="color:#f92672">=&lt;/span>t3;
}
&lt;span style="color:#75715e">//Floyd-Warshall算法核心语句
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;k&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;k&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
&lt;span style="color:#66d9ef">if&lt;/span>(e[i][j]&lt;span style="color:#f92672">&amp;gt;&lt;/span>e[i][k]&lt;span style="color:#f92672">+&lt;/span>e[k][j] )
e[i][j]&lt;span style="color:#f92672">=&lt;/span>e[i][k]&lt;span style="color:#f92672">+&lt;/span>e[k][j];
&lt;span style="color:#75715e">//输出最终的结果
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>(i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;i&lt;span style="color:#f92672">++&lt;/span>)
{
&lt;span style="color:#66d9ef">for&lt;/span>(j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n;j&lt;span style="color:#f92672">++&lt;/span>)
{
printf(&lt;span style="color:#e6db74">&amp;#34;%10d&amp;#34;&lt;/span>,e[i][j]);
}
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
}
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="最长路径">最长路径&lt;/h4>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/89823606">图的最长路径 –BFS,树,图&lt;/a>&lt;/p>
&lt;p>我们先把图的遍历过程看作是一个遍历树，起点随机：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-fd73feeaf4505da8f31b3d4eed121daf_720w.jpg" alt="img">&lt;/p>
&lt;p>这里强调：&lt;strong>遍历树的根节点肯定在最高遍历树上（废话），而且该节点遍历的最深的叶子节点肯定是最高遍历树的根节点（可能有多个）&lt;/strong> 可以看成，随机选取的节点就是从最高遍历树中的某个节点开始进行搜索的&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-695f8767a201fdd00eec6b31c11baa59_720w.jpg" alt="img">&lt;/p>
&lt;p>以上图为例，随机选取一个节点，广度优先遍历（这样可以知道哪些节点层数最深），找到深度最深（最后遍历）的节点，多个的话可以随机选一个，然后基于这个最后的节点为起始节点，重新进行遍历，记录层数，就是图的直径（最长路径）了。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/questionTerminal/f793ad2e0c7344efa8b6c18d10d4b67b">牛客网JacobGo！的讨论&lt;/a>&lt;/p>
&lt;p>从任意一个节点开始进行深度优先遍历，找到离他最远的节点（可能不止一个，记为集合A）；第二步：再从A中任意选一个节点出发进行深度优先遍历，找到离他最远的节点（记为集合B），最后最深根就是这两个集合的并集。&lt;/p>
&lt;h2 id="按算法的思路来划分算法思想">按算法的思路来划分（算法思想）&lt;/h2>
&lt;p>参考：&lt;a href="https://zhuanlan.zhihu.com/p/36903717">常用算法指南(一)基本算法思想&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/zuzZ/p/8178950.html">八大算法思想&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://www.w3xue.com/exp/article/201812/14238.html">12种常见算法思想汇总&lt;/a>&lt;/p>
&lt;ul>
&lt;li>穷举算法思想;&lt;/li>
&lt;li>递推算法思想;&lt;/li>
&lt;li>递归算法思想;&lt;/li>
&lt;li>分治算法思想;&lt;/li>
&lt;li>概率算法思想;&lt;/li>
&lt;/ul>
&lt;h3 id="递归的思想">递归的思想&lt;/h3>
&lt;h4 id="递归的思想-1">递归的思想&lt;/h4>
&lt;p>简单说，递归就是一个函数反复的“自己调用自己”。&lt;/p>
&lt;p>&lt;img src="https://images2015.cnblogs.com/blog/431521/201604/431521-20160403154526066-1979046455.png" alt="img" style="zoom:50%;" />&lt;/p>
&lt;h5 id="递归的要求">递归的要求&lt;/h5>
&lt;p>把问题分解成规模更小，但和原问题有着相同解法的问题。
存在一个能让递归调用退出的简单出口。&lt;/p>
&lt;p>注意：分治的思想是把问题分解成规模更小的问题（不一定是相同解法/类型的问题）&lt;/p>
&lt;h5 id="递归的过程">递归的过程&lt;/h5>
&lt;p>1)递推:把复杂的问题的求解推到比原问题简单一些的问题的求解;
2)回归:当获得最简单的情况后, 逐步返回, 依次得到复杂的解&lt;/p>
&lt;h5 id="递归的优点">递归的优点&lt;/h5>
&lt;p>递归代码一般比较精炼，便于阅读。&lt;/p>
&lt;h5 id="递归的缺点">递归的缺点&lt;/h5>
&lt;p>需要系统堆栈，且压入栈的内容得不到释放，所以空间消耗要比非递归代码要大很多。
而且，如果递归深度太大，可能会造成栈溢出&lt;/p>
&lt;h5 id="递归的实现机制">递归的实现机制&lt;/h5>
&lt;p>递归导致一个函数反复调用自己，我们知道函数调用是通过一个栈来实现的。（局部变量或其引用也保存在栈上）
在大多数机器上，每次调用函数时大致要做三个工作：调用前先保存寄存器，并在返回时恢复；复制实参；程序必须转向一个新位置执行。
所以函数调用的压栈操作：保存局部变量、寄存器值、返回地址、实参。
函数嵌套或递归调用，则压入栈中的数据会很多；栈中较底部的变量/引用的对象都没被释放，开销大且可能栈溢出。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/1186132-d814e6146a13bb2d.png" alt="img">&lt;/p>
&lt;p>为了防止无穷递归现象，有些语言是规定栈的长度的，比如python语言规定堆栈的长度不能超过1000。
还有就是当规 模很大的时候，尽量不使用递归，而改为非递归的形式。
或者优化成尾递归的形式。&lt;/p>
&lt;p>注：这里的实现机制是c语言、java等的机制；Lisp等提倡递归使用的语言并不适用&lt;/p>
&lt;h5 id="递归的效率">递归的效率&lt;/h5>
&lt;p>从上面&lt;a href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6">递归的实现机制&lt;/a>来看，递归函数反复调用自己，现场的保存与恢复非常消耗栈内存以及时间。
递归把问题分解成规模更小，但和原问题有着相同解法的问题的过程中，遇到同样的子问题会重复计算浪费时间。（这一点可以通过边递归边保存结果来优化）&lt;/p>
&lt;h5 id="递归的复杂度分析">递归的复杂度分析&lt;/h5>
&lt;p>&lt;a href="https://blog.csdn.net/so_geili/article/details/53444816">算法导论&amp;mdash;&amp;mdash;递归算法的时间复杂度求解&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/python27/archive/2011/12/09/2282486.html">递归算法的时间复杂度终结篇&lt;/a>&lt;/p>
&lt;h3 id="递归与非递归的转换">递归与非递归的转换&lt;/h3>
&lt;p>参考：&lt;a href="https://www.cnblogs.com/bakari/p/5349383.html">漫谈递归转非递归&lt;/a>&lt;/p>
&lt;p>参考：https://blog.csdn.net/Shunrei/article/details/5680579&lt;/p>
&lt;p>参考：https://www.cnblogs.com/TECHNOLOGYer/p/4776496.html&lt;/p>
&lt;p>&lt;a href="#%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92%E6%A6%82%E5%BF%B5">简单递归&lt;/a>，不借助栈，用直接转换法，或消除尾递归的方式转换为非递归。&lt;/p>
&lt;p>复杂递归，借助栈，转换为非递归。&lt;/p>
&lt;h3 id="简单递归转非递归直接转换法不借助栈法">简单递归转非递归：直接转换法/不借助栈法&lt;/h3>
&lt;p>简单递归转换为非递归：如果是尾递归，直接转换；其他简单递归，可以直接转换，也可以先转尾递归再转换为非递归。&lt;/p>
&lt;h4 id="简单递归概念">简单递归概念&lt;/h4>
&lt;p>单向递归/线性递归/简单递归：指递归调用的过程总是&lt;strong>朝着一个方向进行&lt;/strong>（如果函数１调用了函数２,而函数２又调用了函数１,则这种情况不属于单向递归。斐波那契数列的递归求解可转用一个迭代法实现）。
这类递归一般&lt;strong>可以找到递推公式&lt;/strong>（这也就引申出分治思想和动态规划），可以&lt;strong>使用直接转换法&lt;/strong>转换为非递归，并不需要借助栈，所以又叫&lt;strong>简单递归&lt;/strong>。&lt;/p>
&lt;h4 id="尾递归概念">尾递归概念&lt;/h4>
&lt;p>尾递归函数是以&lt;strong>递归调用结尾&lt;/strong>的函数，函数的调用返回都集中在尾部（最后一步操作是递归），&lt;strong>是单向递归的特例&lt;/strong>。&lt;/p>
&lt;h4 id="直接转换法">直接转换法&lt;/h4>
&lt;p>&lt;strong>直接转换法&lt;/strong>将简单递归(包括尾递归）转换为循环，并使用一些变量保存中间结果。（不借助栈）&lt;/p>
&lt;h5 id="尾递归的直接转换">尾递归的直接转换&lt;/h5>
&lt;p>尾递归在尾部调用，&lt;strong>其实是具有迭代特性&lt;/strong>的递归，时间复杂度为O(n).那么一定要有迭代的统计步数。我们记录当统计步数到达临界条件时，就退出.&lt;/p>
&lt;p>尾递归可以直接地改成迭代的形式。很多编译器都能够将尾递归的形式优化成循环的形式。&lt;/p>
&lt;h5 id="非尾递归的直接转换法">非尾递归的直接转换法&lt;/h5>
&lt;p>一般是根据递推关系来转换&lt;/p>
&lt;p>比如斐波那契数列：fib(n) = fib(n-1) + fib(n-2)&lt;/p>
&lt;p>递归形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fib&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">||&lt;/span>n&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;span style="color:#75715e">//简单情形，递归出口
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> n;
}&lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">//递归调用：最后一个动作时是加法（不是尾递归）
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> fib(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>fib(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据递推关系，直接转换为非递归&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fib&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;span style="color:#66d9ef">if&lt;/span>(n &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;span style="color:#66d9ef">int&lt;/span> twoBack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> oneBack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> cur;
&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#f92672">=&lt;/span> n; i&lt;span style="color:#f92672">++&lt;/span>) {
cur &lt;span style="color:#f92672">=&lt;/span> twoBack &lt;span style="color:#f92672">+&lt;/span> oneBack;
twoBack &lt;span style="color:#f92672">=&lt;/span> oneBack;
oneBack &lt;span style="color:#f92672">=&lt;/span> cur;
}
&lt;span style="color:#66d9ef">return&lt;/span> cur;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="直接转换补充思路先转尾递归再转非递归">直接转换补充思路：先转尾递归，再转非递归&lt;/h5>
&lt;p>&lt;strong>简单递归问题&lt;/strong>，如阶乘问题和斐波那契数列数列问题。这些问题，&lt;strong>一般都可以优化成尾递归的形式&lt;/strong>，再转换成迭代形式（循环结构）。&lt;/p>
&lt;p>比如斐波那契数列：fib(n) = fib(n-1) + fib(n-2)&lt;/p>
&lt;p>递归形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fib&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;span style="color:#66d9ef">if&lt;/span>(n&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">||&lt;/span>n&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;span style="color:#75715e">//简单情形，递归出口
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> n;
}&lt;span style="color:#66d9ef">else&lt;/span> {
&lt;span style="color:#75715e">//递归调用：最后一个动作时是加法（不是尾递归）
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> fib(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>fib(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>);
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>尾递归：统计步数从简单情境递增到n&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fact&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> ret)
{
&lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> n;
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">==&lt;/span> n)
&lt;span style="color:#66d9ef">return&lt;/span> i&lt;span style="color:#f92672">*&lt;/span>ret;
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> fact(n, i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, ret&lt;span style="color:#f92672">*&lt;/span>i);
}
&lt;span style="color:#75715e">//调用过程
&lt;/span>&lt;span style="color:#75715e">//fact(5, 1, 1)
&lt;/span>&lt;span style="color:#75715e">//fact(5, 2, 1)
&lt;/span>&lt;span style="color:#75715e">//fact(5, 3, 2)
&lt;/span>&lt;span style="color:#75715e">//fact(5, 4, 6)
&lt;/span>&lt;span style="color:#75715e">//fact(5, 5, 24)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尾递归：统计步数从n递减到简单情境&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">fact1&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n, &lt;span style="color:#66d9ef">int&lt;/span> i, &lt;span style="color:#66d9ef">int&lt;/span> ret)
{
&lt;span style="color:#66d9ef">if&lt;/span> (n &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> ret;
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> fact1(n&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, ret &lt;span style="color:#f92672">*&lt;/span> i);
}
&lt;span style="color:#75715e">//调用过程
&lt;/span>&lt;span style="color:#75715e">//fact1(5, 1, 1)
&lt;/span>&lt;span style="color:#75715e">//fact1(4, 2, 1)
&lt;/span>&lt;span style="color:#75715e">//fact1(3, 3, 2)
&lt;/span>&lt;span style="color:#75715e">//fact1(2, 4, 6)
&lt;/span>&lt;span style="color:#75715e">//fact1(1, 5, 24)
&lt;/span>&lt;span style="color:#75715e">//fact1(0, 6, 120)
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尾递归效率已经和迭代差不多了。&lt;/p>
&lt;p>进一步，使用尾递归直接转换为迭代。略&lt;/p>
&lt;h3 id="复杂递归转非递归间接转换法借助栈法">复杂递归转非递归：间接转换法/借助栈法&lt;/h3>
&lt;p>参考：https://www.cnblogs.com/zhaoshuai1215/p/3164698.html&lt;/p>
&lt;p>参考：https://www.cnblogs.com/zhaoshuai1215/p/3165699.html&lt;/p>
&lt;p>复杂递归/树形递归：一般是同一类递归，这类递归转非递归必须要借助栈。可以将递归问题看作一棵树，例如快速排序，整个排序问题分割成左右两部分，每一部分又分割成两部分，类似于二叉树。递归问题的求解可以是由树根到叶子的自顶向下方式求解，如快排，也可以是由叶子节点到根节点的自底向上方式求解。再进一步，&lt;strong>可以把递归问题的求解方式按照树的遍历方式分成三种，分别是前序遍历、中序遍历和后序遍历&lt;/strong>。&lt;/p>
&lt;p>实际上，借助栈，将可以将所有递归转化为非递归。（PS：简单递归的情况严格意义上来说不能看做是一种情况）。&lt;/p>
&lt;p>借助栈为非递归有两种转化方法：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>借助堆栈模拟递归的执行过程&lt;/strong>。这种方法几乎是通用的方法，因为递归本身就是通过栈实现的，用栈模拟函数调用是一种很自然的方法。&lt;/li>
&lt;li>&lt;strong>借助堆栈的循环结构算法/类二叉树非递归遍历算法&lt;/strong>。这种方法常常适用于某些局部变量有依赖关系，且需要重复执行的场景，例如二叉树的遍历算法。递归函数可以写出递归调用树，再根据访问各节点的次序，类比二叉树的前序、中序、后序非递归遍历，写出相应的代码。&lt;/li>
&lt;/ul>
&lt;h5 id="借助堆栈模拟递归的执行过程">借助堆栈模拟递归的执行过程&lt;/h5>
&lt;p>参考：https://www.cnblogs.com/bakari/p/5349383.html&lt;/p>
&lt;p>递归的过程其实是编译器帮我们处理了压栈和出栈的操作，&lt;strong>转换为非递归函数就需要另外建栈，手动地处理压栈和出栈&lt;/strong>。&lt;/p>
&lt;p>因此，我们可以很自然的想到：&lt;strong>借助堆栈模拟递归的执行过程&lt;/strong>。这种方法几乎是&lt;strong>通用&lt;/strong>的方法，因为递归本身就是通过堆栈实现的，我们只要把递归函数调用的局部变量和相应的状态放入到一个栈结构中，在函数调用和返回时做好push和pop操作，就可以了（后面是一个模拟快排的例子）。&lt;/p>
&lt;h6 id="快排的模拟递归示例">快排的模拟递归示例&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">qsort&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a[],&lt;span style="color:#66d9ef">int&lt;/span> l,&lt;span style="color:#66d9ef">int&lt;/span> r){
&lt;span style="color:#75715e">//boundary case
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(l&lt;span style="color:#f92672">&amp;gt;=&lt;/span>r)
&lt;span style="color:#66d9ef">return&lt;/span>;
&lt;span style="color:#75715e">//state 0
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> mid&lt;span style="color:#f92672">=&lt;/span>partition(a,l,r);
qsort(a,l,mid&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;span style="color:#75715e">//state 1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> qsort(a,mid&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>,r);
&lt;span style="color:#75715e">//state 2
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>模拟递归调用过程。因为递归本身就是通过堆栈实现的，我们只要把递归函数调用的局部变量和相应的状态放入到一个栈结构中，在函数调用和返回时做好push和pop操作，就可以了&lt;/p>
&lt;p>快排的非递归实现（根据递归结构设置了几个状态）&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">struct&lt;/span> recorc{
&lt;span style="color:#66d9ef">int&lt;/span> l,r,mid; &lt;span style="color:#75715e">//local virables.
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> state;
}stack[&lt;span style="color:#ae81ff">100000&lt;/span>];
&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">nun_recursive_qsort&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a[],&lt;span style="color:#66d9ef">int&lt;/span> l,&lt;span style="color:#66d9ef">int&lt;/span> r){
&lt;span style="color:#66d9ef">int&lt;/span> state&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>,top&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
&lt;span style="color:#66d9ef">int&lt;/span> mid;
&lt;span style="color:#66d9ef">while&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(l&lt;span style="color:#f92672">&amp;gt;=&lt;/span>r){ &lt;span style="color:#75715e">//boundary case, return previous level
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(top &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">break&lt;/span>;&lt;span style="color:#75715e">//end of recursion
&lt;/span>&lt;span style="color:#75715e">&lt;/span> top&lt;span style="color:#f92672">--&lt;/span>;
l&lt;span style="color:#f92672">=&lt;/span>stack[top].l;&lt;span style="color:#75715e">//end of function, update to previous state
&lt;/span>&lt;span style="color:#75715e">&lt;/span> r&lt;span style="color:#f92672">=&lt;/span>stack[top].r;
mid&lt;span style="color:#f92672">=&lt;/span>stack[top].mid;
state&lt;span style="color:#f92672">=&lt;/span>stack[top].state;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(state &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>){
mid&lt;span style="color:#f92672">=&lt;/span>partition(a,l,r);
stack[top].l&lt;span style="color:#f92672">=&lt;/span>l; &lt;span style="color:#75715e">//recutsive call, push current state into stack
&lt;/span>&lt;span style="color:#75715e">&lt;/span> stack[top].r&lt;span style="color:#f92672">=&lt;/span>r;
stack[top].mid&lt;span style="color:#f92672">=&lt;/span>mid;
stack[top].state&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
top&lt;span style="color:#f92672">++&lt;/span>;
r&lt;span style="color:#f92672">=&lt;/span>mid&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
state&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">//don&amp;#39;t forget to update state value
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(state &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>){
stack[top].l&lt;span style="color:#f92672">=&lt;/span>l;
stack[top].r&lt;span style="color:#f92672">=&lt;/span>r; &lt;span style="color:#75715e">//recursive call, push current state into stack
&lt;/span>&lt;span style="color:#75715e">&lt;/span> stack[top].mid&lt;span style="color:#f92672">=&lt;/span>mid;
stack[top].state&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
top&lt;span style="color:#f92672">++&lt;/span>;
l&lt;span style="color:#f92672">=&lt;/span>mid&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
state&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>(state &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>){
&lt;span style="color:#66d9ef">if&lt;/span>(top &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)
&lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">//end of recursion
&lt;/span>&lt;span style="color:#75715e">&lt;/span> top&lt;span style="color:#f92672">--&lt;/span>;
l&lt;span style="color:#f92672">=&lt;/span>stack[top].l;
r&lt;span style="color:#f92672">=&lt;/span>stack[top].r;
mid&lt;span style="color:#f92672">=&lt;/span>stack[top].mid;
state&lt;span style="color:#f92672">=&lt;/span>stack[top].state;
}
}
}
&lt;span style="color:#75715e">//借助堆栈人工模拟快排
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="模拟递归函数执行的模板">模拟递归函数执行的模板&lt;/h6>
&lt;p>比如递归函数的形式：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">recursive&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> x&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//前导代码
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>hhh&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//递归结束条件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//...
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>xxx&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//其他情况
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//递归,并做一些操作
&lt;/span>&lt;span style="color:#75715e">&lt;/span> operation&lt;span style="color:#f92672">(&lt;/span>recursive&lt;span style="color:#f92672">(&lt;/span>x&lt;span style="color:#f92672">+&lt;/span>offset&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//收尾代码
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>递推的过程，其实是：递推+回溯&lt;/p>
&lt;p>使用循环模拟执行过程：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">nonRecursive&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> x&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Stack&lt;span style="color:#f92672">&amp;lt;&lt;/span>States&lt;span style="color:#f92672">&amp;gt;&lt;/span> stack &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Stack&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
states &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">。。。&lt;/span>
stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>states&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//回溯
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(!&lt;/span>stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">isEmpty&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
states &lt;span style="color:#f92672">=&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">pop&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//向下递推的情况
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(!{&lt;/span>递归结束条件&lt;span style="color:#f92672">})&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//前导代码
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//当前状态入栈
&lt;/span>&lt;span style="color:#75715e">&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">push&lt;/span>&lt;span style="color:#f92672">(&lt;/span>states&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//递归结束条件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>hhh&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//其他情况
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>xxx&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//收尾代码
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//。。。
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="借助堆栈的循环结构算法树的非递归遍历算法">借助堆栈的循环结构算法/树的非递归遍历算法&lt;/h5>
&lt;p>还是以快排算法为例，根据&lt;a href="#%E5%BF%AB%E6%8E%92%E7%9A%84%E9%80%92%E5%BD%92%E7%A4%BA%E4%BE%8B">快排算法的递归示例&lt;/a>，它的递归调用树是二叉树前序遍历的形式。&lt;/p>
&lt;p>那么我们只需要把二叉树的前序遍历代码搬过来，partition()过程替换visit()过程即可。&lt;/p>
&lt;h3 id="动态规划的思想">动态规划的思想&lt;/h3>
&lt;p>参考：算法笔记-胡凡：提高篇（5）——动态规划专题&lt;/p>
&lt;h4 id="动态规划的递归写法和递推写法">动态规划的递归写法和递推写法&lt;/h4>
&lt;p>动态规划是一种精妙的思想，它没有固定的写法，使用非常灵活，常常需要具体问题具体分析。直接讨论动态规划的概念不是很好的学习方式，先接触一些经典模型，穿插动态规划概念的理解，会有更好的效果。&lt;/p>
&lt;h5 id="动态规划的概念">动态规划的概念&lt;/h5>
&lt;p>动态规划（Dynamic Programming, DP)是一种用来解决**&lt;a href="#%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93%E8%B7%AF%E5%BE%84/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.md">最优化问题&lt;/a>**的算法思想。&lt;/p>
&lt;p>&lt;strong>最优化问题的形式&lt;/strong>&lt;/p>
&lt;p>max/min 目标函数F()
st. 限制条件（等式、不等式、变量范围限制）&lt;/p>
&lt;p>简单来说，&lt;u>动态规划将一个复杂问题分解成若干个子问题，通过综合子问题的最优解来得到原问题的最优解&lt;/u>。（区别分治法：分治法也要综合其子问题的解，但不要求选择其中的最优解）
需要注意的是，&lt;u>动态规划会将每个求解的子问题的解记录下来&lt;/u>，这样下次碰到同样的子问题时，就可以直接使用之前记录的结果，不必重复计算。虽然动态规划采用这种方式来提高计算效率，但不能说这种做法时动态规划的核心。&lt;/p>
&lt;p>动态规划可以使用递归和递推的方式实现，其中递归写法又称作记忆化搜索。&lt;/p>
&lt;h5 id="动态规划的递归写法记忆化搜索">动态规划的递归写法/记忆化搜索&lt;/h5>
&lt;p>重叠子问题TODO&lt;/p>
&lt;h5 id="动态规划的递推写法">动态规划的递推写法&lt;/h5>
&lt;p>最优子结构TODO&lt;/p>
&lt;h4 id="青蛙跳台阶5">青蛙跳台阶&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/h4>
&lt;h5 id="普通跳台阶">普通跳台阶&lt;/h5>
&lt;p>一只青蛙可以一次跳 1 级台阶或者一次跳 2 级台阶，$例如$：&lt;/p>
&lt;p>跳上第 1 级台阶只有一种跳法：直接跳 1 级即可。
跳上第 2 级台阶有两种跳法：每次跳 1 级，跳两次；或者一次跳 2 级。
问要跳上第 n 级台阶有多少种跳法？&lt;/p>
&lt;p>很多人喜欢正向思考，使用暴力求解，但往往这是一个很复杂的问题。我们可以反过来思考：&lt;/p>
&lt;p>如果我们要跳上第 n 级台阶，该怎么跳？此时问题就简单多了，答案是，要么从第 n−1 级台阶跳一级上来，要么从第 n−2 级台阶跳两级上来，除此，青蛙再也没有其他的方法可以跳上第 n 级台阶。&lt;/p>
&lt;p>我们令 f(n)f(n) 表示从第一级台阶跳上第 nn 级台阶有几种跳法。则有如下递推公式：&lt;/p>
&lt;p>f(n)=f(n−1)+f(n−2)&lt;/p>
&lt;p>是不是很熟悉，它不&lt;strong>就是斐波那契数列&lt;/strong>吗，（C语言）代码就很简单啦：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">jumpFloor&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;span style="color:#66d9ef">int&lt;/span> g &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>, f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;span style="color:#66d9ef">while&lt;/span> (number&lt;span style="color:#f92672">--&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
f &lt;span style="color:#f92672">+=&lt;/span> g;
g &lt;span style="color:#f92672">=&lt;/span> f &lt;span style="color:#f92672">-&lt;/span> g;
}
&lt;span style="color:#66d9ef">return&lt;/span> g;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="变态跳台阶">变态跳台阶&lt;/h5>
&lt;p>变态跳台阶问题是这样的：如果青蛙可以一次跳 1 级，也可以一次跳 2 级，一次跳 3 级，…，一次跳 n 级。问要跳上第 nn 级台阶有多少种跳法？&lt;/p>
&lt;p>同样的，我们采用逆向思维，将问题改为：跳上第 n 级台阶该怎么跳？答案如下：&lt;/p>
&lt;p>要跳上第 n级台阶，可以从第 n−1级台阶一次跳上来，也可以可以从第 n−2 级台阶一次跳上来，也可以可以从第 n−3级台阶一次跳上来，…，也可以可以从第 1级台阶一次跳上来。那么问题就很简单啦，同样的，令 f(n) 表示从第一级台阶跳上第 n级台阶有几种跳法。则有如下递推公式：
f(n)=f(n−1)+f(n−2)+&amp;hellip;+f(1)&lt;/p>
&lt;p>同时，f(n−1)也可以表示如下：
f(n−1)=f(n−2)+f(n−3)+&amp;hellip;+f(1)&lt;/p>
&lt;p>所以，由上面两个公式可知：
f(n)=2f(n−1)=4f(n−2)=8f(n−3)=&amp;hellip;&lt;/p>
&lt;p>即：
f(n)=2f(n−1)=2^2 f(n−2)=2^3 f(n−3)=&amp;hellip;=2^(n−1) f(n−(n−1))=2^(n−1) f(1)&lt;/p>
&lt;p>因为 f(1)=1f(1)=1，所以 f(n)=2^(n−1) f(n)=2^(n−1)。
C语言代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">square&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> a) { &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">*&lt;/span> a; }
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">power2&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) { &lt;span style="color:#75715e">// 计算2的n次方
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">==&lt;/span> n) &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;span style="color:#66d9ef">return&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">?&lt;/span> square(power2(n&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>))&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> square(power2(n&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>));
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">jumpFloorII&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> number) {
&lt;span style="color:#66d9ef">return&lt;/span> power2(number &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="装错信封问题错排问题">装错信封问题（错排问题）&lt;/h4>
&lt;p>错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的&lt;strong>装错信封的问题&lt;/strong>。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况？又比如四人各写一张贺年卡互相赠送，有多少种赠送方法？自己写的贺年卡不能送给自己，所以也是典型的&lt;strong>错排问题&lt;/strong>。&lt;/p>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F">&lt;strong>错排问题&lt;/strong>&lt;/a>，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。&lt;/p>
&lt;p>当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.&lt;/p>
&lt;p>第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；&lt;/p>
&lt;p>第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；&lt;/p>
&lt;p>综上得到&lt;strong>递推公式&lt;/strong>：&lt;/p>
&lt;p>D(n) = (n-1) [D(n-2) + D(n-1)]&lt;/p>
&lt;p>特殊地，D(1) = 0, D(2) = 1.&lt;/p>
&lt;p>可&lt;a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E5%85%AC%E5%BC%8F">推导&lt;/a>其&lt;strong>通项公式&lt;/strong>为D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].此即&lt;strong>错排公式&lt;/strong>&lt;/p>
&lt;h4 id="约瑟夫问题选大王问题">约瑟夫问题/选大王问题&lt;/h4>
&lt;h5 id="约瑟夫问题">约瑟夫问题&lt;/h5>
&lt;p>据说著名&lt;em>&lt;strong>历史学家 Josephus有过以下的故事:在罗马人占领乔塔帕特后，39 个&lt;/strong>&lt;/em>人与Josephus及他的朋友躲到一个洞中，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人，该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。&lt;/p>
&lt;p>首先从一个人开始，越过k-2个人(因为第一个人已经被越过)，并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。&lt;/p>
&lt;p>然而Josephus 和他的朋友并不想遵从。问题是，给定了人数总和，一开始要站在什么地方才能避免被处决?Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，成了最后剩下的2个人，于是逃过了这场死亡游戏。&lt;/p>
&lt;h5 id="选大王问题">选大王问题&lt;/h5>
&lt;p>链接：https://www.nowcoder.com/questionTerminal/84789c61e87f4290a544d5eb60226f05
来源：牛客网&lt;/p>
&lt;ul>
&lt;li>&lt;strong>问题描述：&lt;/strong>
有n只猴子，按顺时针方向围成一圈选大王(编号从1到n)，从第1号开始报数，一直数到m，数到m的猴子退出圈外，剩下的猴子再接着从 1 开始报数。就这样，直到圈内只剩下一只猴子时，这个猴子就是猴王。现在告诉你 n 和 m，请帮忙求出哪一只猴子能当大王。&lt;/li>
&lt;li>&lt;strong>输入描述:&lt;/strong>
输入包含多组数据。每组数据包含两个正整数 n 和m（1≤ m &amp;lt; n ≤ 10000）。&lt;/li>
&lt;li>&lt;strong>输出描述:&lt;/strong>
对应每一组输入，输出猴王的编号 i（1≤i≤n）。&lt;/li>
&lt;/ul>
&lt;h6 id="常规解法">常规解法&lt;/h6>
&lt;p>构建一个列表，按照报数顺序依次 删除元素，直到只剩下一个元素&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 常规算法
&lt;/span>&lt;span style="color:#75715e"> * 序列为 1,2，... ，n
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Josephus&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">){&lt;/span>
List&lt;span style="color:#f92672">&amp;lt;&lt;/span>Integer&lt;span style="color:#f92672">&amp;gt;&lt;/span> monkeys&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">++){&lt;/span>
monkeys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span>&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">&amp;gt;&lt;/span>1&lt;span style="color:#f92672">){&lt;/span>
pos&lt;span style="color:#f92672">+=&lt;/span>m&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
pos&lt;span style="color:#f92672">%=&lt;/span>n&lt;span style="color:#f92672">;&lt;/span>
monkeys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">(&lt;/span>pos&lt;span style="color:#f92672">);&lt;/span>
n&lt;span style="color:#f92672">--;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> monkeys&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>0&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="递归解法">递归解法&lt;/h6>
&lt;p>假设 对于n,m 已知 k 是当前需要的人，当前序列为
0，1，&amp;hellip; ，k-1, &lt;strong>k&lt;/strong> , k+1, &amp;hellip; , n-1
那么剩下的人分别为
0，1，&amp;hellip; ，k-1, k+1, &amp;hellip; , n-1
接下来需要从 k+1 处开始报数，不妨对 k 以前的数 +n, 即：
n, n+1, &amp;hellip; , n+k-1, k+1, &amp;hellip; , n-1
按照报数顺序排列：
k+1, &amp;hellip; , n，n+1, &amp;hellip; , n+k-1
这个序列可看出，仅比正常序列 0，1，&amp;hellip; , n-2 多了 k+1&lt;/p>
&lt;p>所以有：
假设 josephus(n,m)是序列 0，1，&amp;hellip; , n-1循环报数最终剩下的人，
则 josephus(n-1,m)为序列 0，1，&amp;hellip; , n-2循环报数最终剩下的人
josephus(n,m)= josephus(n-1,m)+k+1
考虑到运用上述公式时，是对 n,m序列 对k之前的数+n得到的，
因此应当修正为&lt;/p>
&lt;pre>&lt;code>josephus(n,m)=（ josephus(n-1,m)+k+1）%n
&lt;/code>&lt;/pre>&lt;p>如此即可还原到原始序列。&lt;/p>
&lt;p>又因为对于任意 n,m ,初始k值我们是可以求解得到的&lt;/p>
&lt;pre>&lt;code>k=(m%n)-1
&lt;/code>&lt;/pre>&lt;p>所以&lt;/p>
&lt;pre>&lt;code>josephus(n,m)=（ josephus(n-1,m)+(m%n)）%n
josephus(n,m)=（ josephus(n-1,m)+m）%n
&lt;/code>&lt;/pre>&lt;p>至此已形成递归
递归截至条件也显而易见&lt;/p>
&lt;pre>&lt;code>josephus(1,m)=0
&lt;/code>&lt;/pre>&lt;p>&lt;strong>注意&lt;/strong>
此解法针对的是 0, 1, 2, &amp;hellip; , n-1的序列，
但约瑟夫环一般是从1 开始的，即 1, 2， &amp;hellip; , n
所以我们利用 josephus(n,m)求出的结果要 +1才是最终结果。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
Scanner scanner&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> Scanner&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">hasNext&lt;/span>&lt;span style="color:#f92672">()){&lt;/span>
&lt;span style="color:#75715e">//递归算法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span> JosephusRecursive&lt;span style="color:#f92672">(&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">(),&lt;/span> scanner&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextInt&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">)+&lt;/span>1 &lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#75715e">//常规算法
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// System.out.println( Josephus( scanner.nextInt(), scanner.nextInt() ));
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 递归算法
&lt;/span>&lt;span style="color:#75715e"> * 序列为 0,1,2，... ，n-1
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">JosephusRecursive&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span>&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">==&lt;/span>1&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">(&lt;/span>JosephusRecursive&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">,&lt;/span>m&lt;span style="color:#f92672">)+&lt;/span>m&lt;span style="color:#f92672">)%&lt;/span>n&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="递归衍生循环">递归衍生循环&lt;/h6>
&lt;p>由 递归法 可知&lt;/p>
&lt;pre>&lt;code>josephus(n,m)=（ josephus(n-1,m)+m）%n
josephus(1,m)=0
&lt;/code>&lt;/pre>&lt;p>因此有&lt;/p>
&lt;pre>&lt;code>josephus(n+1,m)=（ josephus(n,m)+m）%（n+1）
&lt;/code>&lt;/pre>&lt;p>将 josephus( ) 简记为 J( )&lt;/p>
&lt;pre>&lt;code>J ( n+1, m ) = ( J ( n, m ) + m ) % ( n+1)
&lt;/code>&lt;/pre>&lt;p>由此可以将递归改成循环&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 递归衍生循环
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">JosephusCycle&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">,&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> m&lt;span style="color:#f92672">){&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> r&lt;span style="color:#f92672">=&lt;/span>0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>2&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n&lt;span style="color:#f92672">;&lt;/span>i&lt;span style="color:#f92672">++){&lt;/span>
r &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>r&lt;span style="color:#f92672">+&lt;/span>m&lt;span style="color:#f92672">)%&lt;/span>i&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//由于该方法为递归思想推算过来的，上述算法执行完后的结果仍然为 针对序列 0， 1， ... , n-1推算的结果，
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 因此最终结果需要 +1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> r&lt;span style="color:#f92672">+&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法虽然是从递推的结果进一步通过数算得来的，但是结论反而可以当作一个公式用，只是逻辑上讲没什么道理。&lt;/p>
&lt;h4 id="最长不下降子序列">最长不下降子序列&lt;/h4>
&lt;p>参考：算法笔记-胡凡曾磊-提高篇（5）动态规划专题&lt;/p>
&lt;p>最长不下降子序列（longest increasing sequence, LIS)问题：&lt;/p>
&lt;p>在一个序列中，找到一个最长的子序列（可以不连续），使得这个子序列是不下降（非递减）的。&lt;/p>
&lt;p>例如，给一个序列A = {1,2,3,-1,-2,7,9}, 它的最长不下降子序列是{1,2,3,7,9}，长度为5。当然它还有其他一些非降子序列，比如{1,2,3}, {-2,7,9}等，但都不是最长的。&lt;/p>
&lt;p>&lt;strong>枚举法&lt;/strong>：我们可以用最原始的方法来枚举每种情况。即每个元素有取和不取两种方式。然后判断是否为不下降子序列。
如果是不下降子序列，则更新最大长度。直达枚举完所有情况，得到最长不下降子序列长度。
对于n个元素，每个元素取/不取，有$2^n$种情况，算法复杂度为$O(2^n)$. 这显然是不能承受的。&lt;/p>
&lt;p>实际上以上枚举包含了大量重复计算。下面先看动态规划解法。&lt;/p>
&lt;p>&lt;strong>动态规划法&lt;/strong>：令dp[i] 表示以A[i]结尾的最长不下降子序列长度。还是和枚举法一样，考虑每个元素取/不取。对A[i] 来说，就会有两种情况：
取A[i]: 如果A[i]大于等于之前的某个元素A[j], 且dp[i]&amp;lt;dp[j]+1,则需要更新dp[i] = dp[j]+1, 即将A[i]纳入当前最长子序列。($\forall j&amp;lt;i, dp[i] = max{dp[j]+1}$)
不取A[i]:如果A[i]小于之前的所有元素A[j]，或者dp[i]&amp;lt;dp[j]+1时，不更新dp[i],即不将A[i]纳入当前最长子序列。&lt;/p>
&lt;p>得到动态规划的状态转移方程：
$dp[i] = max{dp[j]+1, dp[i] }, \forall j&amp;lt;i $
边界条件：
$dp[i] = 1, \forall i$&lt;/p>
&lt;p>举例： A[1:4] = {1,5,-1,3},假设已知道以A[1],A[2],A[3]的最长不下降子序列为{1},{1,5}, {-1},长度分别为1，2，1.
为求A[4]结尾的最长不下降子序列，考虑将A[4]接到A[1],A[2],A[3]的最长不下降子序列的后面，看看最长子序列能否变得更长。
A[4] : 喂，A[1],我可以站你后面，形成更长的LIS吗
A[1]: 我看看，你比我高，当然可以。这样我们组成的最长子序列就是{1,3}了
A[4]: 喂，A[2]，我可以站你后面，形成更长的LIS吗
A[2]: 你那么矮，还是算了。我这里本来就有2了，你就算来了也不增加LIS长度。
A[4]: 喂，A[3]，我可以站你后面，形成更长的LIS吗
A[3]: 我看看，你比我高，当然可以。这样我们组成的最长子序列就是{-1,3}了
还有一种情况，比如A[1:4] = {1,2,3,-4},则A[1],A[2],A[3]都嫌A[4]矮，A[4]只能孤零零一人形成以A[4]结尾的最长子序列{-4}。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">//dp[i]表示以a[i]结尾的最长不下降子序列长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>count&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#75715e">//边界条件：dp[i] = 1;
&lt;/span>&lt;span style="color:#75715e">//状态转移方程： dp[i] = max(dp[j]+1,dp[i]) , j = 0,1,,i-1, 当[j] &amp;lt;= a[i],
&lt;/span>&lt;span style="color:#75715e">// dp[i] = dp[i], 当所有a[j]都 &amp;gt; a[i]
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> count&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> max &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> count&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> i&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>a&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> a&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">&amp;gt;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">])&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
max &lt;span style="color:#f92672">=&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> max &lt;span style="color:#f92672">?&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">:&lt;/span> max&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>max&lt;span style="color:#f92672">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="例1">例1&lt;/h5>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4084">题目链接&lt;/a>&lt;/p>
&lt;h4 id="背包问题">背包问题&lt;/h4>
&lt;p>参考1(入门和掌握）：算法笔记-胡凡：提高篇（5）——动态规划专题
参考2（进阶：背包九讲）：https://www.cnblogs.com/jbelial/articles/2116074.html
参考（参考2的转载）：https://zhuanlan.zhihu.com/p/139368825
参考（参考2的迁移）：https://www.kancloud.cn/kancloud/pack/70125&lt;/p>
&lt;h5 id="01背包问题">01背包问题&lt;/h5>
&lt;p>01背包问题是这样的：有n件物品，每件物品的重量w[i],价值c[i]。现有一个背包，容量为V，问如何选择物品装入背包，使装入背包物品的总价值最大？&lt;/p>
&lt;h6 id="背包的初始化条件">背包的初始化条件&lt;/h6>
&lt;p>不同的初始化条件决定了dp数组的意义：
是装入的总价值的最大值（不一定恰好装满）
还是装入的总价值（但一定装满）&lt;/p>
&lt;p>具体的讲，初始化的问题（可用数学归纳法证明状态的转移过程：见bilibili大雪菜背包九讲专题）：&lt;/p>
&lt;p>对于滚动数组/一维数组，$dp[0:m]$都初始化为0，则$dp[m]$中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满）
对于滚动数组/一维数组，$dp[1:m]$都初始化为$-INF$，$dp[0] = 0$, 则$dp[m$]中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值
对于二维数组，$dp[0:n][0:m]$都初始化为0，则$dp[n][m]$中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满）
对于二维数组，$dp[0:n][1:m]$都初始化为$-INF$，$dp[1:n][0] = 0$, 则$dp[n][m]$中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值&lt;/p>
&lt;h6 id="例1-用零钱凑一定的金额">例1 用零钱凑一定的金额&lt;/h6>
&lt;p>给n张零钱，面值分别为v[i]，问如何选择零钱，凑成给定的金额V。如果有多种方法，使用面值尽量小的，张数多的方法。&lt;/p>
&lt;p>&lt;a href="https://www.nowcoder.com/pat/5/problem/4119">原题链接&lt;/a>&lt;/p>
&lt;p>这道题目属于：背包问题-01背包问题-01满背包问题&lt;/p>
&lt;p>从最优化问题的角度考虑，&lt;/p>
&lt;p>可以看作是如下的最优化问题（方法1）：&lt;/p>
&lt;p>&lt;strong>限制条件&lt;/strong>：
变量i 属于[1,n],
面值v[i] 属于{v[1]:v[n]}
选择的面值之和必须&lt;strong>恰好为&lt;/strong>给定的金额V
&lt;strong>目标函数&lt;/strong>：
使用的零钱张数（最多）&lt;/p>
&lt;p>也可以看作是如下的最优化问题（方法2）：&lt;/p>
&lt;p>&lt;strong>限制条件&lt;/strong>：
变量i 属于[1,n],
面值v[i] 属于{v[1]:v[n]}
选择的零钱总额&lt;strong>小于等于&lt;/strong>给定的金额V
&lt;strong>目标函数&lt;/strong>：
使用的零钱总额（最大）&lt;/p>
&lt;p>如上面所示，可以写成两种最优化问题，那么就有各自对应的状态转移方程和递推方法。具体解法见PAT习题.md#动态规划#背包问题#例1.&lt;/p>
&lt;h5 id="完全背包问题">完全背包问题&lt;/h5>
&lt;p>//TODO&lt;/p>
&lt;h4 id="数位dp">数位DP&lt;/h4>
&lt;p>参考：牛客网讨论区：https://www.nowcoder.com/questionTerminal/eb1e0fc83a25461e93b8bf2039e871b9
参考：wust_wenhao的csdn博客 : &lt;a href="https://blog.csdn.net/wust_zzwh/article/details/52100392">https://blog.csdn.net/wust_zzwh/article/details/52100392&lt;/a>
参考：oi-wiki数位dp： &lt;a href="https://oi-wiki.org/dp/number/">https://oi-wiki.org/dp/number/&lt;/a>&lt;/p>
&lt;p>数位 DP 问题往往都是这样的题型，给定一个闭区间 $[l,r]$，让你求这个区间中满足 &lt;strong>某种条件&lt;/strong> 的数的总数。&lt;/p>
&lt;p>首先我们将问题转化成更加简单的形式。设$ans_i$ 表示在区间 $[1,i]$中满足条件的数的数量，那么所求的答案就是$ans_r - ans_{l-1}$ 。&lt;/p>
&lt;p>数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了。&lt;/p>
&lt;p>枚举方法：从高位开始递归计数 + 记忆化搜索&lt;/p>
&lt;p>但是枚举的过程中要注意枚举上界的问题。&lt;/p>
&lt;p>对于一个小于n 的数，它从高到低肯定出现某一位，这一位之前的所有位都和 n上的位相等。而这一位上的数值小于 n这一位上对应的数值。
那么从高位开始枚举。这一位之前和这一位，每一位的枚举都是受限的。而这一位之后，每一位都可以枚举0-9.&lt;/p>
&lt;h5 id="数1n中出现1的个数">数[1,N]中出现1的个数&lt;/h5>
&lt;h6 id="方法1-动态规划dp法">方法1 动态规划DP法&lt;/h6>
&lt;p>数1-N中出现1的个数，即给定一个闭区间 $[1,N]$，让你求这个区间中 所有数里的1 的总数。&lt;/p>
&lt;p>首先，我们可以从高位开始递归枚举所有的情况。然后通过记忆化存储，转化为递归型动态规划。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.BufferedReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.IOException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.InputStreamReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 数位dp的实质就是换一种暴力枚举的方式，使得新的枚举方式满足dp的性质，然后记忆化就可以了。
&lt;/span>&lt;span style="color:#75715e"> * 其枚举方式：控制上界枚举，从最高位开始往下枚举
&lt;/span>&lt;span style="color:#75715e"> * 枚举上界：例如N=213，从百位开始枚举：百位可能的情况有0,1,2.然后每一位枚举都不能让枚举的这个数超过上界213（下界就是0或者1，这个次要），
&lt;/span>&lt;span style="color:#75715e"> * 当百位枚举了1，那么十位枚举就是从0到9，因为百位1已经比上界2小了，后面数位枚举什么都不可能超过上界。
&lt;/span>&lt;span style="color:#75715e"> * 所以问题就在于：当高位枚举刚好达到上界时，那么紧接着的一位枚举就有上界限制了。
&lt;/span>&lt;span style="color:#75715e"> * 具体的这里如果百位枚举了2，那么十位的枚举情况就是0到1，如果前两位枚举了21，最后一位之是0到3
&lt;/span>&lt;span style="color:#75715e"> * (这一点正好对于代码模板里的一个变量limit 专门用来判断枚举范围)。
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1038_2&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[]&lt;/span> bit &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>12&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[][]&lt;/span> dp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">[&lt;/span>12&lt;span style="color:#f92672">][&lt;/span>12&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> IOException &lt;span style="color:#f92672">{&lt;/span>
BufferedReader br &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedReader&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> InputStreamReader&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">readLine&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>solve&lt;span style="color:#f92672">(&lt;/span>n&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">solve&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> n&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">!=&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
bit&lt;span style="color:#f92672">[&lt;/span>i&lt;span style="color:#f92672">++]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
n &lt;span style="color:#f92672">/=&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">// return dfs(--i, 0, true);
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> k &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> k &lt;span style="color:#f92672">&amp;lt;&lt;/span> 12&lt;span style="color:#f92672">;&lt;/span> k&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> 12&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
dp&lt;span style="color:#f92672">[&lt;/span>k&lt;span style="color:#f92672">][&lt;/span>j&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> dfs1&lt;span style="color:#f92672">(--&lt;/span>i&lt;span style="color:#f92672">,&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 从高位开始递归计数1的出现次数
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @param pos 当前位 pos=0表示个位，pos=1表示十位，pos=2表示百位，依次类推
&lt;/span>&lt;span style="color:#75715e"> * @param highState 从最高位到当前位已经累计1的个数（不包括当前位）
&lt;/span>&lt;span style="color:#75715e"> * @param limit 当前位是否有枚举上界的标记。 如果高位枚举达到了上界，那么当前位枚举时也有限制。
&lt;/span>&lt;span style="color:#75715e"> * @return
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">dfs&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> highState&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> limit&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>pos &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> highState&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//当前位枚举上界
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> up &lt;span style="color:#f92672">=&lt;/span> limit &lt;span style="color:#f92672">?&lt;/span> bit&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">:&lt;/span> 9&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//从高位向低位递推枚举所有可能的情况（状态），综合所有的情况回归
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> up&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> dfs&lt;span style="color:#f92672">(&lt;/span>pos &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">?&lt;/span> highState &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">:&lt;/span> highState&lt;span style="color:#f92672">,&lt;/span> limit &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> up&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> count&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 从高位开始递归计数1的出现次数(递归函数进行记忆化存储,转化为动态规划)
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @param pos 当前位 pos=0表示个位，pos=1表示十位，pos=2表示百位，依次类推
&lt;/span>&lt;span style="color:#75715e"> * @param highState 从最高位到当前位已经累计1的个数（不包括当前位）
&lt;/span>&lt;span style="color:#75715e"> * @param limit 当前位是否有枚举上界的标记。 如果高位枚举达到了上界，那么当前位枚举时也有限制。
&lt;/span>&lt;span style="color:#75715e"> * dp[pos][highState] 保存从最高位开始到当前位pos（不包含当前位），已有1的个数
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">dfs1&lt;/span>&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> pos&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> highState&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">boolean&lt;/span> limit&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//递归结束条件
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>pos &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> highState&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//使用记忆的值，!limit防止发生状态冲突
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(!&lt;/span>limit &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">][&lt;/span>highState&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> dp&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">][&lt;/span>highState&lt;span style="color:#f92672">];&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//当前位枚举上界
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> up &lt;span style="color:#f92672">=&lt;/span> limit &lt;span style="color:#f92672">?&lt;/span> bit&lt;span style="color:#f92672">[&lt;/span>pos&lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#f92672">:&lt;/span> 9&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//从高位向低位递推枚举所有可能的情况（状态），综合所有的情况回归
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> up&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> dfs1&lt;span style="color:#f92672">(&lt;/span>pos &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> 1 &lt;span style="color:#f92672">?&lt;/span> highState &lt;span style="color:#f92672">+&lt;/span> 1 &lt;span style="color:#f92672">:&lt;/span> highState&lt;span style="color:#f92672">,&lt;/span> limit &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> i &lt;span style="color:#f92672">==&lt;/span> up&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> count&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h6 id="方法2-排列组合法">方法2 排列组合法&lt;/h6>
&lt;p>参考（牛客网讨论区 琉璃の璀璨 的讨论）：https://www.nowcoder.com/questionTerminal/eb1e0fc83a25461e93b8bf2039e871b9&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#f92672">package&lt;/span> com.jingmin.advanced2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.BufferedReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.IOException&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> java.io.InputStreamReader&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * @author : wangjm
&lt;/span>&lt;span style="color:#75715e"> * @date : 2020/6/23 21:17
&lt;/span>&lt;span style="color:#75715e"> * @discription : https://www.nowcoder.com/pat/5/problem/4088
&lt;/span>&lt;span style="color:#75715e"> * 数1-N之间出现1的个数
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 方法： 排列组合的方法（求每一位的1的个数/通项公式法）
&lt;/span>&lt;span style="color:#75715e"> * 参考（牛客网讨论区 琉璃の璀璨 的讨论）：https://www.nowcoder.com/questionTerminal/eb1e0fc83a25461e93b8bf2039e871b9
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为1在1~n所有数中
&lt;/span>&lt;span style="color:#75715e"> * 个位数上有1的个数+十位数上有1的个数+...+亿位数上有1的个数+...
&lt;/span>&lt;span style="color:#75715e"> * 自己动手亲自找一遍规律就能得出答案：
&lt;/span>&lt;span style="color:#75715e"> * 首先，找规律：
&lt;/span>&lt;span style="color:#75715e"> * 13
&lt;/span>&lt;span style="color:#75715e"> * 个位数为1：1 11
&lt;/span>&lt;span style="color:#75715e"> * 十位数为1：10 11 12 13
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为： 2+4=6
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 23
&lt;/span>&lt;span style="color:#75715e"> * 个位数为1：1 11 21
&lt;/span>&lt;span style="color:#75715e"> * 十位数为1：10 11 12 13 14 15 16 17 18 19
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为：3+10=13
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 345
&lt;/span>&lt;span style="color:#75715e"> * 个位数为1：1 11 21 31 41 51 61 71 81 91 101 111 121 131 141 ...341
&lt;/span>&lt;span style="color:#75715e"> * 十位数为1：10 11 12 13 14 15 16 17 18 19 ...311 312 ...319
&lt;/span>&lt;span style="color:#75715e"> * 百位数为1：100 101...199
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为：100+40+35=175
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 进而可得通项：
&lt;/span>&lt;span style="color:#75715e"> * 通项：求某一位的1的个数
&lt;/span>&lt;span style="color:#75715e"> * 高n位 * 本位权（比如百位就乘100）+ 0 （本位小于1）
&lt;/span>&lt;span style="color:#75715e"> * 高n位 * 本位权 + 1 * 本位权 （本位大于1）
&lt;/span>&lt;span style="color:#75715e"> * 高n位 * 本位权 + 低n位 + 1 （本位等于1）
&lt;/span>&lt;span style="color:#75715e"> * 也就是说，某位（各位，十位...）1的总个数可能与其高位，低位以及自己的
&lt;/span>&lt;span style="color:#75715e"> * 值有关，具体对应情况如上
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 例如算12345：
&lt;/span>&lt;span style="color:#75715e"> * 个位1：1234*1+1（个位&amp;gt;=1加1）
&lt;/span>&lt;span style="color:#75715e"> * 十位1：123*10+10
&lt;/span>&lt;span style="color:#75715e"> * 百位1：12*100+100
&lt;/span>&lt;span style="color:#75715e"> * 千位1：1*1000+1000
&lt;/span>&lt;span style="color:#75715e"> * 万位1：2345+1
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为：8121
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 例如算23012：
&lt;/span>&lt;span style="color:#75715e"> * 个位1：2301*1+1
&lt;/span>&lt;span style="color:#75715e"> * 十位1：230*10+2+1 （十位=1加低位即2然后加1）
&lt;/span>&lt;span style="color:#75715e"> * 百位1：23*100 （百位为0加0）
&lt;/span>&lt;span style="color:#75715e"> * 千位1：2*1000+1000
&lt;/span>&lt;span style="color:#75715e"> * 万位1：10000
&lt;/span>&lt;span style="color:#75715e"> * 1的总个数为：19905
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 通俗来说，某位（个位，十位..）上1的个数=
&lt;/span>&lt;span style="color:#75715e"> * 基础数+当前位为&amp;gt;1，&amp;lt;1，=1时的情况，
&lt;/span>&lt;span style="color:#75715e"> * 而基础数为当前位前面的高位*当前位
&lt;/span>&lt;span style="color:#75715e"> * （例如：23012，当 当前位为百位时，基础数=23（前高位）*100+上面讨论的情况）
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Advanced1038&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>&lt;span style="color:#f92672">(&lt;/span>String&lt;span style="color:#f92672">[]&lt;/span> args&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#66d9ef">throws&lt;/span> IOException &lt;span style="color:#f92672">{&lt;/span>
BufferedReader br &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BufferedReader&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">new&lt;/span> InputStreamReader&lt;span style="color:#f92672">(&lt;/span>System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">in&lt;/span>&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> Integer&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">parseInt&lt;/span>&lt;span style="color:#f92672">(&lt;/span>br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">readLine&lt;/span>&lt;span style="color:#f92672">());&lt;/span>
br&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">close&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> count &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#75715e">//从个位开始
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> bit &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> base &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#f92672">(&lt;/span>10 &lt;span style="color:#f92672">*&lt;/span> base&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> base&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>bit &lt;span style="color:#f92672">!=&lt;/span> 0 &lt;span style="color:#f92672">||&lt;/span> high &lt;span style="color:#f92672">!=&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>bit &lt;span style="color:#f92672">&amp;gt;&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#f92672">(&lt;/span>high &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">*&lt;/span> base&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>bit &lt;span style="color:#f92672">==&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> high &lt;span style="color:#f92672">*&lt;/span> base &lt;span style="color:#f92672">+&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
count &lt;span style="color:#f92672">+=&lt;/span> high &lt;span style="color:#f92672">*&lt;/span> base&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
bit &lt;span style="color:#f92672">=&lt;/span> high &lt;span style="color:#f92672">%&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
high &lt;span style="color:#f92672">=&lt;/span> high &lt;span style="color:#f92672">/&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
base &lt;span style="color:#f92672">*=&lt;/span> 10&lt;span style="color:#f92672">;&lt;/span>
low &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">%&lt;/span> base&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
System&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">out&lt;/span>&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">println&lt;/span>&lt;span style="color:#f92672">(&lt;/span>count&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="排序">排序&lt;/h2>
&lt;p>参考：https://www.cnblogs.com/onepixel/p/7674659.html&lt;/p>
&lt;h3 id="排序概览">排序概览&lt;/h3>
&lt;h5 id="排序分类">排序分类&lt;/h5>
&lt;p>十种常见排序算法可以分为两大类：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>比较类排序&lt;/strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。&lt;/li>
&lt;li>&lt;strong>非比较类排序&lt;/strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/849589-20190306165258970-1789860540.png" alt="img">&lt;/p>
&lt;h5 id="算法复杂度">算法复杂度&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/849589-20180402133438219-1946132192.png" alt="img">&lt;/p>
&lt;h5 id="相关概念">相关概念&lt;/h5>
&lt;ul>
&lt;li>&lt;strong>稳定&lt;/strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。&lt;/li>
&lt;li>&lt;strong>不稳定&lt;/strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。&lt;/li>
&lt;li>&lt;strong>时间复杂度&lt;/strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。&lt;/li>
&lt;li>**空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。&lt;/li>
&lt;/ul>
&lt;h3 id="比较类排序">比较类排序&lt;/h3>
&lt;p>通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。&lt;/p>
&lt;h4 id="插入排序">插入排序&lt;/h4>
&lt;p>&lt;strong>插入排序&lt;/strong>（英语：Insertion Sort）是一种简单直观的&lt;a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法&lt;/a>。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。&lt;/p>
&lt;p>包括：&lt;a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序&lt;/a>，二分插入排序（又称折半插入排序），&lt;a href="https://baike.baidu.com/item/%E9%93%BE%E8%A1%A8">链表&lt;/a>插入排序。&lt;/p>
&lt;p>平均来说插入排序算法的&lt;strong>时间复杂度为O(n^2）&lt;/strong>。&lt;/p>
&lt;p>属于&lt;strong>稳定排序&lt;/strong>的一种（通俗地讲，就是两个相等的数不会交换位置） 。&lt;/p>
&lt;p>&lt;strong>就地排序&lt;/strong>: 在原输入数组上进行后移赋值操作，所需开辟的辅助空间跟输入数组规模无关，所以空间复杂度为：O(1)&lt;/p>
&lt;h5 id="直接插入排序">直接插入排序&lt;/h5>
&lt;p>一般来说，&lt;strong>插入排序&lt;/strong>都采用in-place在数组上实现。具体算法描述如下：&lt;/p>
&lt;ol>
&lt;li>从第一个元素开始，该元素可以认为已经被排序&lt;/li>
&lt;li>取出下一个元素，在已经排序的元素序列中从后向前扫描&lt;/li>
&lt;li>如果该元素（已排序）大于新元素，将该元素移到下一位置&lt;/li>
&lt;li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置&lt;/li>
&lt;li>将新元素插入到该位置后&lt;/li>
&lt;li>重复步骤2~5&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java"> &lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 直接插入排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">directInsertSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
T tmp &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> tmp&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">compareTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> tmp&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。
最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的&lt;strong>比较操作&lt;/strong>需（n-1）次即可。
最坏情况就是，序列是降序排列，那么此时需要进行的&lt;strong>比较&lt;/strong>共有n(n-1)/2次。
插入排序的&lt;strong>赋值操作&lt;/strong>是比较操作的次数加上 (n-1）次。
平均来说插入排序算法的&lt;strong>时间复杂度为O(n^2）&lt;/strong>。
因而，插入排序&lt;strong>不适合对于数据量比较大的排序应用&lt;/strong>。&lt;/p>
&lt;p>如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以&lt;strong>插入排序是稳定的&lt;/strong>。&lt;/p>
&lt;h5 id="二分插入排序">二分插入排序&lt;/h5>
&lt;p>（1）计算 0 ~ i-1 的中间点，用 i 索引处的元素与中间值进行比较，如果 i 索引处的元素大，说明要插入的这个元素应该在中间值和刚加入i索引之间，反之，就是在刚开始的位置 到中间值的位置，这样很简单的完成了折半；&lt;/p>
&lt;p>（2）在相应的半个范围里面找插入的位置时，不断的用（1）步骤缩小范围，不停的折半，范围依次缩小为 1/2 1/4 1/8 &amp;hellip;&amp;hellip;.快速的确定出第 i 个元素要插在什么地方；&lt;/p>
&lt;p>（3）确定位置之后，将整个序列后移，并将元素插入到相应位置。&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 二分搜索插入排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">binarySearchInsertSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
T tmp &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> low &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> high &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> mid &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>low &lt;span style="color:#f92672">&amp;lt;=&lt;/span> high&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
mid &lt;span style="color:#f92672">=&lt;/span> low &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">(&lt;/span>high &lt;span style="color:#f92672">-&lt;/span> low&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>tmp&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">compareTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>mid&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
high &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
low &lt;span style="color:#f92672">=&lt;/span> mid &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> low&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>low&lt;span style="color:#f92672">,&lt;/span> tmp&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://www.cnblogs.com/heyuquan/p/insert-sort.html">二分法查找的插入排序的算法复杂度&lt;/a>&lt;/p>
&lt;ol>
&lt;li>
&lt;p>时间复杂度：O(n^2)&lt;/p>
&lt;p>二分查找插入位置，因为不是查找相等值，而是基于比较查插入合适的位置，所以必须查到最后一个元素才知道插入位置。
&lt;strong>二分查找&lt;/strong>最坏时间复杂度：当2^X&amp;gt;=n时，查询结束，所以查询的次数就为x，而x等于log2n（以2为底，n的对数）。即O(log2n)。所以，二分查找排序比较次数为：x=log2n&lt;/p>
&lt;p>&lt;strong>二分查找插入排序&lt;/strong>耗时的操作有：比较 + 后移赋值。时间复杂度如下：&lt;/p>
&lt;ol>
&lt;li>最好情况：查找的位置是有序区的最后一位后面一位，则无须进行后移赋值操作，其比较次数为：log2n 。即O(log2n)&lt;/li>
&lt;li>最坏情况：查找的位置是有序区的第一个位置，则需要的比较次数为：log2n，需要的赋值操作次数为&lt;a href="http://zhidao.baidu.com/link?url=D1uGyXzk3biP8YR-tKHq1_YHgZZmojMd0XzWlPxSWoYdhaTZdlRyd-FXaVqGNaYpgVHe0Lh3mMKPCwNH2E5C6q">n(n-1)/2&lt;/a>加上 (n-1) 次。即O(n^2)&lt;/li>
&lt;li>渐进时间复杂度（平均时间复杂度）：O(n^2)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>空间复杂度：O(1)&lt;/p>
&lt;p>从实现原理可知，二分查找插入排序是在原输入数组上进行后移赋值操作的（称“就地排序”），所需开辟的辅助空间跟输入数组规模无关，所以空间复杂度为：O(1)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h5 id="链接插入排序">链接插入排序&lt;/h5>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 链接插入排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">linkedInsertSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>LinkedList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
T tmp &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> 1&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> tmp&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">compareTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j&lt;span style="color:#f92672">--)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> 1&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">remove&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="希尔排序">希尔排序&lt;/h5>
&lt;p>思想：分治策略&lt;/p>
&lt;p>希尔排序是一种&lt;strong>分组直接插入排序方法&lt;/strong>，其原理是：先将整个序列分割成若干小的子序列，再分别对子序列进行直接插入排序，使得原来序列成为基本有序。这样通过对较小的序列进行插入排序，然后对基本有序的数列进行插入排序，能够提高插入排序算法的效率。&lt;/p>
&lt;p>具体如下（实现为升序）：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>先取一个小于n的整数d1作为第一个增量，将所有距离为d1的倍数的记录放在同一个组中，把无序数组分割为若干个子序列。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在各子序列内进行直接插入排序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后取第二个增量d2&amp;lt;d1，重复步骤1~2，直至所取的增量dt=1(dt&amp;lt;dt-l&amp;lt;…&amp;lt;d2&amp;lt;d1)，即所有记录放在同一组中进行直接插入排序为止。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 希尔排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">shellSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>n &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 1&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#75715e">//以n为间隔，对子list进行直接插入排序
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i&lt;span style="color:#f92672">++)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
directInsertSort&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">,&lt;/span> i&lt;span style="color:#f92672">,&lt;/span> n&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
n &lt;span style="color:#f92672">=&lt;/span> n &lt;span style="color:#f92672">/&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 直接插入排序(指定开始位置，和间隔）
&lt;/span>&lt;span style="color:#75715e"> * &amp;lt;p&amp;gt;
&lt;/span>&lt;span style="color:#75715e"> * 若startPos = 1, interval = 3, 则对list的1,4,7,...号元素排序
&lt;/span>&lt;span style="color:#75715e"> * 若startPos = 0, interval = 1, 则为全list的直接插入排序
&lt;/span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;span style="color:#75715e"> * @param list 待排序列表（为了提高效率，这里指定为ArrayList）
&lt;/span>&lt;span style="color:#75715e"> * @param startPos 开始位置
&lt;/span>&lt;span style="color:#75715e"> * @param interval 以interval为间隔
&lt;/span>&lt;span style="color:#75715e"> * @param &amp;lt;T&amp;gt; 待排序元素类型
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">directInsertSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> startPos&lt;span style="color:#f92672">,&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> interval&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> n &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> startPos &lt;span style="color:#f92672">+&lt;/span> interval&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n&lt;span style="color:#f92672">;&lt;/span> i &lt;span style="color:#f92672">+=&lt;/span> interval&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
T tmp &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> interval&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#f92672">(;&lt;/span> j &lt;span style="color:#f92672">&amp;gt;=&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> tmp&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">compareTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span> j &lt;span style="color:#f92672">-=&lt;/span> interval&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> interval&lt;span style="color:#f92672">,&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">set&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">+&lt;/span> interval&lt;span style="color:#f92672">,&lt;/span> tmp&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>希尔排序是按照不同步长对元素进行&lt;a href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序&lt;/a>，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的&lt;a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">时间复杂度&lt;/a>会比o(n^2)好一些。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>时间复杂度: O(nlog2n)&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;p>希尔排序耗时的操作有：比较 + 后移赋值。时间复杂度如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>最好情况：序列是升序排列，在这种情况下，需要进行的比较操作需（n-1）次。后移赋值操作为0次。即O(n)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最坏情况：O(nlog2n)。(维基百科上最坏是O(n^2))&lt;/p>
&lt;/li>
&lt;li>
&lt;p>渐进时间复杂度（平均时间复杂度）：O(nlog2n)&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>​ 增量选取：希尔排序的时间复杂度与增量的选取有关，但是现今仍然没有人能找出希尔排序的精确下界。一般的选择原则是：取上一个增量的一半作为此次序列的划分增量。首次选择序列长度的一半为增量。（因此也叫&lt;strong>缩小增量排序&lt;/strong>）&lt;/p>
&lt;p>​ &lt;strong>平均时间复杂度：O(nlog2n)&lt;/strong>，希尔排序在最坏的情况下和平均情况下执行效率相差不是很多，与此同时快速排序（O(log2n)）在最坏的情况下执行的效率会非常差。专家们提倡，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>空间复杂度：O(1)&lt;/p>
&lt;p>从实现原理可知，希尔排序是在原输入数组上进行后移赋值操作的（称“&lt;strong>就地排序&lt;/strong>”），所需开辟的辅助空间跟输入数组规模无关，所以&lt;strong>空间复杂度为：O(1)&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>稳定性&lt;/strong>：希尔排序是&lt;strong>不稳定的&lt;/strong>。因为在进行分组时，相同元素可能分到不同组中，改变相同元素的相对顺序。&lt;/p>
&lt;p>&lt;strong>优化改进&lt;/strong>：根据实际运行情况，我们也可以将希尔排序中查找插入位置部分的代码替换为二分查找方式。&lt;/p>
&lt;h4 id="归并排序">归并排序&lt;/h4>
&lt;p>&lt;a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序&lt;/a>（MERGE-SORT）是建立在&lt;strong>归并操作&lt;/strong>上的一种有效的排序算法,该算法是采用&lt;strong>分治法&lt;/strong>（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路&lt;a href="https://baike.baidu.com/item/%E5%BD%92%E5%B9%B6/253741">归并&lt;/a>。归并排序是一种稳定的排序方法。&lt;/p>
&lt;p>&lt;strong>归并操作&lt;/strong>(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。
如　设有数列{6，202，100，301，38，8，1}
初始状态：6,202,100,301,38,8,1
第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；
第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；
第三次归并后：{1,6,8,38,100,202,301},比较次数：4；
总的比较次数为：3+4+4=11；
逆序数为14；&lt;/p>
&lt;p>归并排序的过程如下：
第一步：申请空间，使其大小为两个已经&lt;a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F">排序&lt;/a>序列之和，该空间用来存放合并后的序列
第二步：设定两个&lt;a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针&lt;/a>，最初位置分别为两个已经排序序列的起始位置
第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针超出序列尾
将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p>
&lt;p>递归代码：&lt;/p>
&lt;pre>&lt;code>public static int[] mergeSort(int[] nums, int l, int h) {
if (l == h)
return new int[] { nums[l] };
int mid = l + (h - l) / 2;
int[] leftArr = mergeSort(nums, l, mid); //左有序数组
int[] rightArr = mergeSort(nums, mid + 1, h); //右有序数组
int[] newNum = new int[leftArr.length + rightArr.length]; //新有序数组
int m = 0, i = 0, j = 0;
while (i &amp;lt; leftArr.length &amp;amp;&amp;amp; j &amp;lt; rightArr.length) {
newNum[m++] = leftArr[i] &amp;lt; rightArr[j] ? leftArr[i++] : rightArr[j++];
}
while (i &amp;lt; leftArr.length)
newNum[m++] = leftArr[i++];
while (j &amp;lt; rightArr.length)
newNum[m++] = rightArr[j++];
return newNum;
}
&lt;/code>&lt;/pre>&lt;p>非递归代码：&lt;/p>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-java" data-lang="java">&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 归并排序
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">mergeSort&lt;/span>&lt;span style="color:#f92672">(&lt;/span>ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> 2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">//总list长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> listLen &lt;span style="color:#f92672">=&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">();&lt;/span>
&lt;span style="color:#75715e">//子list长度
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> subLen &lt;span style="color:#f92672">=&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> newList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>subLen &lt;span style="color:#f92672">&amp;lt;&lt;/span> listLen&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
newList &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>8&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> subLen&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;lt;&lt;/span> listLen&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
newList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>merge&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> subLen&lt;span style="color:#f92672">,&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> subLen&lt;span style="color:#f92672">),&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> subLen&lt;span style="color:#f92672">,&lt;/span> i&lt;span style="color:#f92672">)));&lt;/span>
i &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> subLen&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>listLen &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> subLen&lt;span style="color:#f92672">))&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
newList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>merge&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> subLen&lt;span style="color:#f92672">,&lt;/span> i &lt;span style="color:#f92672">-&lt;/span> subLen&lt;span style="color:#f92672">),&lt;/span> list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> subLen&lt;span style="color:#f92672">,&lt;/span> listLen&lt;span style="color:#f92672">)));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
newList&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">-&lt;/span> 2 &lt;span style="color:#f92672">*&lt;/span> subLen&lt;span style="color:#f92672">,&lt;/span> listLen&lt;span style="color:#f92672">));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
subLen &lt;span style="color:#f92672">=&lt;/span> subLen &lt;span style="color:#f92672">*&lt;/span> 2&lt;span style="color:#f92672">;&lt;/span>
list &lt;span style="color:#f92672">=&lt;/span> newList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> newList&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#75715e">/**
&lt;/span>&lt;span style="color:#75715e"> * 两路归并操作：将两个list合为一个list
&lt;/span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T &lt;span style="color:#66d9ef">extends&lt;/span> Comparable&lt;span style="color:#f92672">&amp;gt;&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">merge&lt;/span>&lt;span style="color:#f92672">(&lt;/span>List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list1&lt;span style="color:#f92672">,&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
ArrayList&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> list &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ArrayList&lt;span style="color:#f92672">&amp;lt;&amp;gt;(&lt;/span>16&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">,&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> 0&lt;span style="color:#f92672">;&lt;/span>
T tmp1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">,&lt;/span> tmp2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">&amp;lt;&lt;/span> list1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> j &lt;span style="color:#f92672">&amp;lt;&lt;/span> list2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
tmp1 &lt;span style="color:#f92672">=&lt;/span> list1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">);&lt;/span>
tmp2 &lt;span style="color:#f92672">=&lt;/span> list2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">get&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">);&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>tmp1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">compareTo&lt;/span>&lt;span style="color:#f92672">(&lt;/span>tmp2&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> 0&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>tmp1&lt;span style="color:#f92672">);&lt;/span>
i&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">add&lt;/span>&lt;span style="color:#f92672">(&lt;/span>tmp2&lt;span style="color:#f92672">);&lt;/span>
j&lt;span style="color:#f92672">++;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>i &lt;span style="color:#f92672">!=&lt;/span> list1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>i&lt;span style="color:#f92672">,&lt;/span> list1&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">(&lt;/span>j &lt;span style="color:#f92672">!=&lt;/span> list2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">())&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
list&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">addAll&lt;/span>&lt;span style="color:#f92672">(&lt;/span>list2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">subList&lt;/span>&lt;span style="color:#f92672">(&lt;/span>j&lt;span style="color:#f92672">,&lt;/span> list2&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">size&lt;/span>&lt;span style="color:#f92672">()));&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#66d9ef">return&lt;/span> list&lt;span style="color:#f92672">;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>归并&lt;a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F">排序&lt;/a>是&lt;strong>稳定的&lt;/strong>排序.即相等的元素的顺序不会改变.&lt;/p>
&lt;h4 id="交换排序">交换排序&lt;/h4>
&lt;h5 id="冒泡排序">冒泡排序&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/849589-20171015223238449-2146169197.gif" alt="img">&lt;/p>
&lt;h5 id="快速排序">快速排序&lt;/h5>
&lt;p>参考：&lt;a href="https://juejin.im/post/5d507199e51d4561cc25f00c">八大排序-快速排序（搞定面试之手写快排）&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">百度百科-快速排序算法&lt;/a>&lt;/p>
&lt;h6 id="原理">原理&lt;/h6>
&lt;p>快速排序的核心思想是分治：选择数组中某个数作为基数，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数都比基数小，另外一部分的所有数都都比基数大，然后再按此方法对这两部分数据分别进行快速排序，循环递归，最终使整个数组变成有序。&lt;/p>
&lt;h6 id="基数选择">基数选择&lt;/h6>
&lt;p>由于快速排序需要选定一个基数进行划分排序，关于基数选择有很多方式，而基数选择直接关系到快排的效率。事实上，选取基准元素应该遵循平衡子问题的原则：即使得划分后的两个子序列的长度尽量相同本篇以待排序数组首元素作为基数进行说明。本篇以最常见的使用数组首元素作为基数进行快速排序原理说明。&lt;/p>
&lt;h6 id="一趟排序">一趟排序&lt;/h6>
&lt;p>以数组int n[] = { 6, 5, 2, 7, 3, 9, 8, 4, 10, 1 }为例：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/16c823bbc67ba62d" alt="img">&lt;/p>
&lt;p>以第一个数字6作为基数，使用双指针i,j进行双向遍历：&lt;/p>
&lt;ul>
&lt;li>1、i从左往右寻找第一位大于基数（6）的数字，j从右往左寻找第一位小于基数（6）的数字；&lt;/li>
&lt;li>2、找到后将两个数字进行交换。继续循环交换直到i&amp;gt;=j结束循环；&lt;/li>
&lt;li>3、最终指针i=j,此时交换基数和i(j)指向的数字即可将数组划分为小于基数（6）/基数（6）/大于基数（6）的三部分，即完成一趟快排；&lt;/li>
&lt;/ul>
&lt;h6 id="伪代码">伪代码&lt;/h6>
&lt;p>见编码注释&lt;/p>
&lt;h6 id="编码实践">编码实践&lt;/h6>
&lt;pre>&lt;code>public class Test {
public static void main(String[] args) {
int n[] = { 6, 5, 2, 7, 3, 9, 8, 4, 10, 1 };
quicksort(n);
System.out.print(&amp;quot;快排结果：&amp;quot;);
for (int m : n) {
System.out.print(m + &amp;quot; &amp;quot;);
}
}
public static void quicksort(int n[]) {
sort(n, 0, n.length - 1);
}
public static void sort(int n[], int l, int r) {
if (l &amp;lt; r) {
// 一趟快排，并返回交换后基数的下标
int index = patition(n, l, r);
// 递归排序基数左边的数组
sort(n, l, index - 1);
// 递归排序基数右边的数组
sort(n, index + 1, r);
}
}
public static int patition(int n[], int l, int r) {
// p为基数，即待排序数组的第一个数
int p = n[l];
int i = l;
int j = r;
while (i &amp;lt; j) {
// 从右往左找第一个小于基数的数
while (n[j] &amp;gt;= p &amp;amp;&amp;amp; i &amp;lt; j) {
j--;
}
// 从左往右找第一个大于基数的数
while (n[i] &amp;lt;= p &amp;amp;&amp;amp; i &amp;lt; j) {
i++;
}
// 找到后交换两个数
swap(n, i, j);
}
// 使划分好的数分布在基数两侧
swap(n, l, i);
return i;
}
private static void swap(int n[], int i, int j) {
int temp = n[i];
n[i] = n[j];
n[j] = temp;
}
}
复制代码
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>结果&lt;/li>
&lt;/ul>
&lt;pre>&lt;code>快排结果：1 2 3 4 5 6 7 8 9 10
复制代码
&lt;/code>&lt;/pre>&lt;h4 id="选择排序">选择排序&lt;/h4>
&lt;h5 id="简单选择排序">简单选择排序&lt;/h5>
&lt;p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。&lt;/p>
&lt;h5 id="堆排序">堆排序&lt;/h5>
&lt;p>参考：&lt;a href="https://www.runoob.com/w3cnote/heap-sort.html">堆排序&lt;/a>&lt;/p>
&lt;p>&lt;strong>堆&lt;/strong>是一种特殊的树,它每个结点都有一个值，堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。就类似一堆东西一样，按照由大到小（或由小到大）“堆”起来。&lt;/p>
&lt;p>&lt;strong>堆排序&lt;/strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：&lt;/p>
&lt;ol>
&lt;li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；&lt;/li>
&lt;li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；&lt;/li>
&lt;/ol>
&lt;p>堆排序的平均时间复杂度为 Ο(nlogn)。&lt;/p>
&lt;h6 id="算法步骤">算法步骤&lt;/h6>
&lt;ol>
&lt;li>创建一个堆 H[0……n-1]；&lt;/li>
&lt;li>把堆首（最大值）和堆尾互换；&lt;/li>
&lt;li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；&lt;/li>
&lt;li>重复步骤 2，直到堆的尺寸为 1。&lt;/li>
&lt;/ol>
&lt;h6 id="堆排序动图示例">堆排序动图示例&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/heapSort.gif" alt="img">&lt;/p>
&lt;h6 id="堆排序分步示例">堆排序分步示例&lt;/h6>
&lt;p>参考：&lt;a href="https://blog.csdn.net/sxhelijian/article/details/50295637">数据结构示例——堆排序过程&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://blog.csdn.net/sxhelijian/article/details/50118439">数据结构例程——选择排序之堆排序&lt;/a>&lt;/p>
&lt;p>参考：&lt;a href="https://zhuanlan.zhihu.com/p/45725214">算法从入门到“放弃”（10）- 堆排序&lt;/a>&lt;/p>
&lt;p>本文实例引用自&lt;a href="https://link.zhihu.com/?target=https%3A//blog.csdn.net/sxhelijian/article/details/50295637">数据结构示例——堆排序过程&lt;/a>。&lt;/p>
&lt;p>假设我们要对目标数组A {57, 40, 38, 11, 13, 34, 48, 75, 6, 19, 9, 7}进行堆排序。&lt;/p>
&lt;p>首先第一步和第二步，&lt;strong>创建堆&lt;/strong>，这里我们用最大堆；创建过程中，保证调整堆的特性。从最后一个分支的节点开始进行&lt;strong>调整为最大堆&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://pic3.zhimg.com/80/v2-a71cede24ccc2f9c866762b179883772_720w.jpg" alt="img">从右往左，从下至上&lt;/p>
&lt;p>现在得到的最大堆的存储结构如下：&lt;/p>
&lt;p>&lt;img src="https://pic4.zhimg.com/80/v2-732c53b36414354f9c9780dae07a0307_720w.jpg" alt="img">初始堆创建完成&lt;/p>
&lt;p>接着，最后一步，堆排序，进行（n-1）次循环。&lt;/p>
&lt;p>&lt;img src="https://pic2.zhimg.com/80/v2-843070653f31636b46728b4777a0aac9_720w.jpg" alt="img">持续整个过程直至最后一个元素为止&lt;/p>
&lt;p>这个迭代持续直至最后一个元素即完成堆排序步骤。&lt;/p>
&lt;h6 id="参考代码">参考代码&lt;/h6>
&lt;div class="highlight">&lt;pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-c" data-lang="c">&lt;span style="color:#75715e">//来源：https://blog.csdn.net/sxhelijian/article/details/50118439
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;stdio.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;span style="color:#75715e">#define MaxSize 20
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> KeyType; &lt;span style="color:#75715e">//定义关键字类型
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> InfoType[&lt;span style="color:#ae81ff">10&lt;/span>];
&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#75715e">//记录类型
&lt;/span>&lt;span style="color:#75715e">&lt;/span>{
KeyType key; &lt;span style="color:#75715e">//关键字项
&lt;/span>&lt;span style="color:#75715e">&lt;/span> InfoType data; &lt;span style="color:#75715e">//其他数据项,类型为InfoType
&lt;/span>&lt;span style="color:#75715e">&lt;/span>} RecType; &lt;span style="color:#75715e">//排序的记录类型定义
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#75715e">//调整堆
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">sift&lt;/span>(RecType R[],&lt;span style="color:#66d9ef">int&lt;/span> low,&lt;span style="color:#66d9ef">int&lt;/span> high)
{
&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>low,j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>i; &lt;span style="color:#75715e">//R[j]是R[i]的左孩子
&lt;/span>&lt;span style="color:#75715e">&lt;/span> RecType temp&lt;span style="color:#f92672">=&lt;/span>R[i];
&lt;span style="color:#66d9ef">while&lt;/span> (j&lt;span style="color:#f92672">&amp;lt;=&lt;/span>high)
{
&lt;span style="color:#66d9ef">if&lt;/span> (j&lt;span style="color:#f92672">&amp;lt;&lt;/span>high &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> R[j].key&lt;span style="color:#f92672">&amp;lt;&lt;/span>R[j&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>].key) &lt;span style="color:#75715e">//若右孩子较大,把j指向右孩子
&lt;/span>&lt;span style="color:#75715e">&lt;/span> j&lt;span style="color:#f92672">++&lt;/span>; &lt;span style="color:#75715e">//变为2i+1
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (temp.key&lt;span style="color:#f92672">&amp;lt;&lt;/span>R[j].key)
{
R[i]&lt;span style="color:#f92672">=&lt;/span>R[j]; &lt;span style="color:#75715e">//将R[j]调整到双亲结点位置上
&lt;/span>&lt;span style="color:#75715e">&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>j; &lt;span style="color:#75715e">//修改i和j值,以便继续向下筛选
&lt;/span>&lt;span style="color:#75715e">&lt;/span> j&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">*&lt;/span>i;
}
&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">//筛选结束
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
R[i]&lt;span style="color:#f92672">=&lt;/span>temp; &lt;span style="color:#75715e">//被筛选结点的值放入最终位置
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;span style="color:#75715e">//堆排序
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">HeapSort&lt;/span>(RecType R[],&lt;span style="color:#66d9ef">int&lt;/span> n)
{
&lt;span style="color:#66d9ef">int&lt;/span> i;
RecType temp;
&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>n&lt;span style="color:#f92672">/&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>) &lt;span style="color:#75715e">//循环建立初始堆
&lt;/span>&lt;span style="color:#75715e">&lt;/span> sift(R,i,n);
&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>n; i&lt;span style="color:#f92672">&amp;gt;=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>; i&lt;span style="color:#f92672">--&lt;/span>) &lt;span style="color:#75715e">//进行n-1次循环,完成推排序
&lt;/span>&lt;span style="color:#75715e">&lt;/span> {
temp&lt;span style="color:#f92672">=&lt;/span>R[&lt;span style="color:#ae81ff">1&lt;/span>]; &lt;span style="color:#75715e">//将第一个元素同当前区间内R[1]对换
&lt;/span>&lt;span style="color:#75715e">&lt;/span> R[&lt;span style="color:#ae81ff">1&lt;/span>]&lt;span style="color:#f92672">=&lt;/span>R[i];
R[i]&lt;span style="color:#f92672">=&lt;/span>temp;
sift(R,&lt;span style="color:#ae81ff">1&lt;/span>,i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">//筛选R[1]结点,得到i-1个结点的堆
&lt;/span>&lt;span style="color:#75715e">&lt;/span> }
}
&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
{
&lt;span style="color:#66d9ef">int&lt;/span> i,n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>;
RecType R[MaxSize];
KeyType a[]&lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">7&lt;/span>,&lt;span style="color:#ae81ff">9&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">3&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">4&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>};&lt;span style="color:#75715e">//a[0]空闲，不作为关键字
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n; i&lt;span style="color:#f92672">++&lt;/span>)
R[i].key&lt;span style="color:#f92672">=&lt;/span>a[i];
printf(&lt;span style="color:#e6db74">&amp;#34;排序前:&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n; i&lt;span style="color:#f92672">++&lt;/span>)
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,R[i].key);
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
HeapSort(R,n);
printf(&lt;span style="color:#e6db74">&amp;#34;排序后:&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; i&lt;span style="color:#f92672">&amp;lt;=&lt;/span>n; i&lt;span style="color:#f92672">++&lt;/span>)
printf(&lt;span style="color:#e6db74">&amp;#34;%d &amp;#34;&lt;/span>,R[i].key);
printf(&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="非比较类排序">非比较类排序&lt;/h3>
&lt;p>不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。&lt;/p>
&lt;p>非比较类排序有较大限制，一般要求待排序数为整数，且范围固定。&lt;/p>
&lt;h4 id="计数排序">计数排序&lt;/h4>
&lt;p>参考：https://www.cnblogs.com/onepixel/p/7674659.html&lt;/p>
&lt;p>比如输入数字限定为[0,MAX]，用一个数组记录各个数出现的次数。&lt;/p>
&lt;h4 id="桶排序">桶排序&lt;/h4>
&lt;p>参考：https://www.cnblogs.com/onepixel/p/7674659.html&lt;/p>
&lt;p>桶排序算是计数排序的升级版。比如输入数字限定为[0,MAX]，将[0,MAX]分成多个区段，称为桶。将待排数字放入对应的桶中。各桶内排好序后，按桶的顺序输出。&lt;/p>
&lt;h4 id="基数排序">基数排序&lt;/h4>
&lt;p>参考：https://www.cnblogs.com/onepixel/p/7674659.html&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/849589-20171015232453668-1397662527.gif" alt="img">&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>A* 算法详解的原文：https://www.gamedev.net/reference/articles/article2003.asp，译文：https://blog.csdn.net/hitwhylz/article/details/23089415 &lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>该段为CSDN博主「Artprog」的原创文章，遵循 CC 4.0 BY-SA 版权协议,原文链接：https://blog.csdn.net/Artprog/article/details/67049383 &lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>[ &lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>高等数学-多元微积分-曲线积分与曲面积分习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 25 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微积分-曲线积分与曲面积分习题">高等数学-多元微积分-曲线积分与曲面积分习题&lt;/h1>
&lt;h2 id="对弧长的曲线积分">对弧长的曲线积分&lt;/h2>
&lt;h3 id="平面上对弧长的曲线积分">平面上对弧长的曲线积分&lt;/h3>
&lt;h4 id="定积分法计算曲线积分">定积分法计算曲线积分&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908161927973.png" alt="" />&lt;figcaption>image-20200908161927973&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908161943734.png" alt="" />&lt;figcaption>image-20200908161943734&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909080136016.png" alt="" />&lt;figcaption>image-20200909080136016&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909080148446.png" alt="" />&lt;figcaption>image-20200909080148446&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909080204906.png" alt="" />&lt;figcaption>image-20200909080204906&lt;/figcaption>
&lt;/figure>
&lt;p>本题也可以利用奇偶对称性消去积分中的&lt;span class="math inline">\(2xy\)&lt;/span>项，并把曲线表示为$x=t , y = t $的参数方程来做。&lt;/p>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909104603162.png" alt="" />&lt;figcaption>image-20200909104603162&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909104617370.png" alt="" />&lt;figcaption>image-20200909104617370&lt;/figcaption>
&lt;/figure>
&lt;h4 id="奇偶性对称性计算曲线积分">奇偶性对称性计算曲线积分&lt;/h4>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908170857630.png" alt="" />&lt;figcaption>image-20200908170857630&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908170909878.png" alt="" />&lt;figcaption>image-20200908170909878&lt;/figcaption>
&lt;/figure>
&lt;h4 id="替换法计算曲线积分">替换法计算曲线积分&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909081222333.png" alt="" />&lt;figcaption>image-20200909081222333&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909081239333.png" alt="" />&lt;figcaption>image-20200909081239333&lt;/figcaption>
&lt;/figure>
&lt;h3 id="空间中对弧长的曲线积分">空间中对弧长的曲线积分&lt;/h3>
&lt;h4 id="奇偶性对称性计算曲线积分-1">奇偶性对称性计算曲线积分&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909082742684.png" alt="" />&lt;figcaption>image-20200909082742684&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909082815350.png" alt="" />&lt;figcaption>image-20200909082815350&lt;/figcaption>
&lt;/figure>
&lt;h2 id="对坐标的曲线积分">对坐标的曲线积分&lt;/h2>
&lt;h3 id="平面上对坐标的曲线积分">平面上对坐标的曲线积分&lt;/h3>
&lt;h4 id="定积分法计算曲线积分-1">定积分法计算曲线积分&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908173101430.png" alt="" />&lt;figcaption>image-20200908173101430&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908173046204.png" alt="" />&lt;figcaption>image-20200908173046204&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908183019048.png" alt="" />&lt;figcaption>image-20200908183019048&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908183030996.png" alt="" />&lt;figcaption>image-20200908183030996&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909084520590.png" alt="" />&lt;figcaption>image-20200909084520590&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909084540456.png" alt="" />&lt;figcaption>image-20200909084540456&lt;/figcaption>
&lt;/figure>
&lt;p>此题也可以用（格林公式法）将平面上的曲线积分转换为二重积分的方法来做。&lt;/p>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909104958408.png" alt="" />&lt;figcaption>image-20200909104958408&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909105010744.png" alt="" />&lt;figcaption>image-20200909105010744&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909105231456.png" alt="" />&lt;figcaption>image-20200909105231456&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909105249755.png" alt="" />&lt;figcaption>image-20200909105249755&lt;/figcaption>
&lt;/figure>
&lt;p>此题也可通过直观判断&lt;span class="math inline">\(\left(x y^{2}+y\right) d x+\left(x^{2} y+x\right) d y = d(\frac{1}{2} x^2 y^2 +xy)\)&lt;/span>，能写成全微分形式，得到该曲线积分与路径无关的结论，然后利用与路径无关的曲线积分计算方式来做。&lt;/p>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909112108399.png" alt="" />&lt;figcaption>image-20200909112108399&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909112057285.png" alt="" />&lt;figcaption>image-20200909112057285&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909132732006.png" alt="" />&lt;figcaption>image-20200909132732006&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909132750325.png" alt="" />&lt;figcaption>image-20200909132750325&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909132803198.png" alt="" />&lt;figcaption>image-20200909132803198&lt;/figcaption>
&lt;/figure>
&lt;h4 id="平面上曲线积分转换为二重积分格林公式法">平面上曲线积分转换为二重积分（格林公式法）&lt;/h4>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908174735224.png" alt="" />&lt;figcaption>image-20200908174735224&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908174805172.png" alt="" />&lt;figcaption>image-20200908174805172&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909023610788.png" alt="" />&lt;figcaption>image-20200909023610788&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909023623355.png" alt="" />&lt;figcaption>image-20200909023623355&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909023636228.png" alt="" />&lt;figcaption>image-20200909023636228&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909025047400.png" alt="" />&lt;figcaption>image-20200909025047400&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909025102565.png" alt="" />&lt;figcaption>image-20200909025102565&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909074346379.png" alt="" />&lt;figcaption>image-20200909074346379&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909074356443.png" alt="" />&lt;figcaption>image-20200909074356443&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909101412634.png" alt="" />&lt;figcaption>image-20200909101412634&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909101426175.png" alt="" />&lt;figcaption>image-20200909101426175&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909101443444.png" alt="" />&lt;figcaption>image-20200909101443444&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909112841068.png" alt="" />&lt;figcaption>image-20200909112841068&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909112850410.png" alt="" />&lt;figcaption>image-20200909112850410&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909112903715.png" alt="" />&lt;figcaption>image-20200909112903715&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909113826193.png" alt="" />&lt;figcaption>image-20200909113826193&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909113845372.png" alt="" />&lt;figcaption>image-20200909113845372&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909115237702.png" alt="" />&lt;figcaption>image-20200909115237702&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909115251068.png" alt="" />&lt;figcaption>image-20200909115251068&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909140859731.png" alt="" />&lt;figcaption>image-20200909140859731&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909140918590.png" alt="" />&lt;figcaption>image-20200909140918590&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909140940876.png" alt="" />&lt;figcaption>image-20200909140940876&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909142744640.png" alt="" />&lt;figcaption>image-20200909142744640&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909142807551.png" alt="" />&lt;figcaption>image-20200909142807551&lt;/figcaption>
&lt;/figure>
&lt;h4 id="计算与积分路径无关的曲线积分">计算与积分路径无关的曲线积分&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908175347683.png" alt="" />&lt;figcaption>image-20200908175347683&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908175406442.png" alt="" />&lt;figcaption>image-20200908175406442&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908175418177.png" alt="" />&lt;figcaption>image-20200908175418177&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909032236871.png" alt="" />&lt;figcaption>image-20200909032236871&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909032251090.png" alt="" />&lt;figcaption>image-20200909032251090&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909084914602.png" alt="" />&lt;figcaption>image-20200909084914602&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909084928338.png" alt="" />&lt;figcaption>image-20200909084928338&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909100125200.png" alt="" />&lt;figcaption>image-20200909100125200&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909100137193.png" alt="" />&lt;figcaption>image-20200909100137193&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909133819047.png" alt="" />&lt;figcaption>image-20200909133819047&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909133833288.png" alt="" />&lt;figcaption>image-20200909133833288&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909135629890.png" alt="" />&lt;figcaption>image-20200909135629890&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909135702576.png" alt="" />&lt;figcaption>image-20200909135702576&lt;/figcaption>
&lt;/figure>
&lt;h2 id="对面积的曲面积分">对面积的曲面积分&lt;/h2>
&lt;h3 id="转换为二重积分法">转换为二重积分法&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908182101058.png" alt="" />&lt;figcaption>image-20200908182101058&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908182050248.png" alt="" />&lt;figcaption>image-20200908182050248&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909030202414.png" alt="" />&lt;figcaption>image-20200909030202414&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909030222779.png" alt="" />&lt;figcaption>image-20200909030222779&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909030635094.png" alt="" />&lt;figcaption>image-20200909030635094&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909030702416.png" alt="" />&lt;figcaption>image-20200909030702416&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909090022760.png" alt="" />&lt;figcaption>image-20200909090022760&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909090036343.png" alt="" />&lt;figcaption>image-20200909090036343&lt;/figcaption>
&lt;/figure>
&lt;p>提示：该平面写成截距式，易得在3个坐标轴上的截距分别为&lt;span class="math inline">\(1,-\frac{1}{2} ,1\)&lt;/span>&lt;/p>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909103702066.png" alt="" />&lt;figcaption>image-20200909103702066&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909103716653.png" alt="" />&lt;figcaption>image-20200909103716653&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909144054963.png" alt="" />&lt;figcaption>image-20200909144054963&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909144110884.png" alt="" />&lt;figcaption>image-20200909144110884&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909144534743.png" alt="" />&lt;figcaption>image-20200909144534743&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909144520686.png" alt="" />&lt;figcaption>image-20200909144520686&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909145240912.png" alt="" />&lt;figcaption>image-20200909145240912&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909145301082.png" alt="" />&lt;figcaption>image-20200909145301082&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909150143341.png" alt="" />&lt;figcaption>image-20200909150143341&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909150108497.png" alt="" />&lt;figcaption>image-20200909150108497&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909150122149.png" alt="" />&lt;figcaption>image-20200909150122149&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909151954480.png" alt="" />&lt;figcaption>image-20200909151954480&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909152005537.png" alt="" />&lt;figcaption>image-20200909152005537&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909153622789.png" alt="" />&lt;figcaption>image-20200909153622789&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909153636070.png" alt="" />&lt;figcaption>image-20200909153636070&lt;/figcaption>
&lt;/figure>
&lt;h3 id="奇偶性对称性计算曲面积分">奇偶性对称性计算曲面积分&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909102748323.png" alt="" />&lt;figcaption>image-20200909102748323&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909102759017.png" alt="" />&lt;figcaption>image-20200909102759017&lt;/figcaption>
&lt;/figure>
&lt;p>提示：&lt;span class="math inline">\(\iint_{\Sigma} z \mathrm{d} S = \iint_{\Sigma} \sqrt{1-x^2-y^2} \mathrm{d} S= 4 \iint_{\Sigma_1} \sqrt{1-x^2-y^2} \mathrm{d} S = 4 \iint_{\Sigma_1} z \mathrm{d} S = 4 \iint_{\Sigma_1} x \mathrm{d} S\)&lt;/span>&lt;/p>
&lt;h2 id="对坐标的曲面积分">对坐标的曲面积分&lt;/h2>
&lt;h3 id="转化为二重积分法">转化为二重积分法&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908213935545.png" alt="" />&lt;figcaption>image-20200908213935545&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908214009126.png" alt="" />&lt;figcaption>image-20200908214009126&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909170854575.png" alt="" />&lt;figcaption>image-20200909170854575&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909170908903.png" alt="" />&lt;figcaption>image-20200909170908903&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909170919856.png" alt="" />&lt;figcaption>image-20200909170919856&lt;/figcaption>
&lt;/figure>
&lt;p>注意：&lt;span class="math inline">\(\iint_{\Sigma} y^{2} \mathrm{d} z \mathrm{d} x = \iint_{\Sigma} y^{2} \cos\beta dS\)&lt;/span>，显然&lt;span class="math inline">\(\cos\beta\)&lt;/span>是关于xOz是奇函数，可看出对称性&lt;/p>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909173318555.png" alt="" />&lt;figcaption>image-20200909173318555&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909173336222.png" alt="" />&lt;figcaption>image-20200909173336222&lt;/figcaption>
&lt;/figure>
&lt;h3 id="转换为三重积分法高斯公式空间内域与界的关系">转换为三重积分法（高斯公式/空间内域与界的关系）&lt;/h3>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909032022005.png" alt="" />&lt;figcaption>image-20200909032022005&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909032038529.png" alt="" />&lt;figcaption>image-20200909032038529&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909032111867.png" alt="" />&lt;figcaption>image-20200909032111867&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909154711784.png" alt="" />&lt;figcaption>image-20200909154711784&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909154722836.png" alt="" />&lt;figcaption>image-20200909154722836&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909155041073.png" alt="" />&lt;figcaption>image-20200909155041073&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909155056096.png" alt="" />&lt;figcaption>image-20200909155056096&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-注意哈">例4 注意哈&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909165410875.png" alt="" />&lt;figcaption>image-20200909165410875&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909165419290.png" alt="" />&lt;figcaption>image-20200909165419290&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909165432069.png" alt="" />&lt;figcaption>image-20200909165432069&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909171604713.png" alt="" />&lt;figcaption>image-20200909171604713&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909171621318.png" alt="" />&lt;figcaption>image-20200909171621318&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909171801259.png" alt="" />&lt;figcaption>image-20200909171801259&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909171816284.png" alt="" />&lt;figcaption>image-20200909171816284&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909172253261.png" alt="" />&lt;figcaption>image-20200909172253261&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909172502013.png" alt="" />&lt;figcaption>image-20200909172502013&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909172516051.png" alt="" />&lt;figcaption>image-20200909172516051&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-嘿脑细胞要死光了">例8 嘿，脑细胞要死光了&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909175733129.png" alt="" />&lt;figcaption>image-20200909175733129&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909175806000.png" alt="" />&lt;figcaption>image-20200909175806000&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909175826311.png" alt="" />&lt;figcaption>image-20200909175826311&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909181514294.png" alt="" />&lt;figcaption>image-20200909181514294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909181530845.png" alt="" />&lt;figcaption>image-20200909181530845&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909203948135.png" alt="" />&lt;figcaption>image-20200909203948135&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909204004787.png" alt="" />&lt;figcaption>image-20200909204004787&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909204028731.png" alt="" />&lt;figcaption>image-20200909204028731&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909210323065.png" alt="" />&lt;figcaption>image-20200909210323065&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909210342134.png" alt="" />&lt;figcaption>image-20200909210342134&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909212045639.png" alt="" />&lt;figcaption>image-20200909212045639&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909212132309.png" alt="" />&lt;figcaption>image-20200909212132309&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909212310868.png" alt="" />&lt;figcaption>image-20200909212310868&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909212323689.png" alt="" />&lt;figcaption>image-20200909212323689&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909212338770.png" alt="" />&lt;figcaption>image-20200909212338770&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213125688.png" alt="" />&lt;figcaption>image-20200909213125688&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213143472.png" alt="" />&lt;figcaption>image-20200909213143472&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213457215.png" alt="" />&lt;figcaption>image-20200909213457215&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213521231.png" alt="" />&lt;figcaption>image-20200909213521231&lt;/figcaption>
&lt;/figure>
&lt;h3 id="转换为对面积的曲面积分">转换为对面积的曲面积分&lt;/h3>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909180943526.png" alt="" />&lt;figcaption>image-20200909180943526&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909181001097.png" alt="" />&lt;figcaption>image-20200909181001097&lt;/figcaption>
&lt;/figure>
&lt;h2 id="物理应用">物理应用&lt;/h2>
&lt;h3 id="散度">散度&lt;/h3>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908214623383.png" alt="" />&lt;figcaption>image-20200908214623383&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908214644351.png" alt="" />&lt;figcaption>image-20200908214644351&lt;/figcaption>
&lt;/figure>
&lt;p>实际上&lt;span class="math inline">\(\operatorname{div}(\operatorname{grad(f)})=\nabla \cdot(\nabla f)= \Delta f = \frac{\partial^2 f}{\partial x^2}+\frac{\partial^2 f}{\partial y^2}+\frac{\partial^2 f}{\partial z^2}\)&lt;/span>，一般称为拉普拉斯算子&lt;/p>
&lt;h3 id="旋度">旋度&lt;/h3>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213649682.png" alt="" />&lt;figcaption>image-20200909213649682&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213701616.png" alt="" />&lt;figcaption>image-20200909213701616&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200909213709378.png" alt="" />&lt;figcaption>image-20200909213709378&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-多元微积分-曲线积分与曲面积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</link><pubDate>Mon, 20 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微积分-曲线积分与曲面积分">高等数学-多元微积分-曲线积分与曲面积分&lt;/h1>
&lt;p>定积分的积分范围是数轴上的一个区间（线状）； 二重积分的积分范围是平面内的一个闭区域（面状）； 三重积分的积分范围是空间内的一个闭区域（体状）； 本章将积分范围推广到平面以及空间内的一段曲线弧（曲线积分）； 还将积分范围推广到空间内的一片曲面（曲面积分）；&lt;/p>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>积分域&lt;/th>
&lt;th>积分号&lt;/th>
&lt;th>举例&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>线状&lt;/td>
&lt;td>&lt;span class="math inline">\(\int\)&lt;/span>&lt;/td>
&lt;td>定积分&lt;span class="math inline">\(\int_a^b f(x)dx\)&lt;/span>&lt;br />曲线积分&lt;span class="math inline">\(\int_L\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>面状&lt;/td>
&lt;td>&lt;span class="math inline">\(\iint\)&lt;/span>&lt;/td>
&lt;td>二重积分&lt;span class="math inline">\(\iint_D f(x,y) d\sigma\)&lt;/span>&lt;br />曲面积分&lt;span class="math inline">\(\iint_\Sigma\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>体状&lt;/td>
&lt;td>&lt;span class="math inline">\(\iiint\)&lt;/span>&lt;/td>
&lt;td>三重积分&lt;span class="math inline">\(\iiint_\Omega f(x,y,z) dv\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>研究/学习过程： 研究背景 -&amp;gt; 抽象（积分种类） -&amp;gt; 性质 -&amp;gt; 计算 -&amp;gt; 应用&lt;/p>
&lt;h2 id="对弧长的曲线积分第一类曲线积分">对弧长的曲线积分（第一类曲线积分）&lt;/h2>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>空间曲线的质量问题&lt;/p>
&lt;p>元素法： &lt;span class="math inline">\(\forall ds \in L\)&lt;/span> &lt;span class="math inline">\(dm = \rho(x,y)ds\)&lt;/span> &lt;span class="math inline">\(m=\int_L dm = \int_L \rho(x,y) ds\)&lt;/span>&lt;/p>
&lt;p>这里积分是在L上积分，不是上下限； 这里是&lt;span class="math inline">\(ds\)&lt;/span>不是&lt;span class="math inline">\(dx\)&lt;/span>; 所以这是一种新的积分类型&lt;/p>
&lt;h3 id="抽象对弧长的曲线积分概念">抽象（对弧长的曲线积分概念）&lt;/h3>
&lt;p>&lt;span class="math inline">\(\int_L f(x,y)ds\)&lt;/span>称为&lt;span class="math inline">\(f(x,y)\)&lt;/span>在平面内的曲线段L上对弧长的曲线积分。 &lt;span class="math inline">\(\int_L f(x,y,z)ds\)&lt;/span>称为&lt;span class="math inline">\(f(x,y,z)\)&lt;/span>在空间曲线段L上对弧长的曲线积分。&lt;/p>
&lt;h3 id="性质">性质&lt;/h3>
&lt;p>积分的加减 = 加减的积分&lt;/p>
&lt;p>常数可以提出来&lt;/p>
&lt;p>&lt;span class="math inline">\(L = L_1 + L_2\)&lt;/span>则可以分段积分&lt;/p>
&lt;p>积分的绝对值小于等于绝对值的积分&lt;/p>
&lt;p>奇偶性对称性： 1）如果曲线段L关于y轴对称/左右对称（并记右半段为&lt;span class="math inline">\(L_1\)&lt;/span>） 若&lt;span class="math inline">\(f(-x,y) = -f(x,y)\)&lt;/span>，则&lt;span class="math inline">\(\int_L f(x,y) ds = 0\)&lt;/span> 若&lt;span class="math inline">\(f(-x,y) = f(x,y)\)&lt;/span>，则&lt;span class="math inline">\(\int_L f(x,y) ds = 2 \int_{L_1} f(x,y) ds\)&lt;/span>&lt;/p>
&lt;p>2）如果曲线段L关于x轴对称/上下对称（并记上半段为&lt;span class="math inline">\(L_1\)&lt;/span>） 若&lt;span class="math inline">\(f(x,-y) = -f(x,y)\)&lt;/span>，则&lt;span class="math inline">\(\int_L f(x,y) ds = 0\)&lt;/span> 若&lt;span class="math inline">\(f(x,-y) = f(x,y)\)&lt;/span>，则&lt;span class="math inline">\(\int_L f(x,y) ds = 2 \int_{L_1} f(x,y) ds\)&lt;/span>&lt;/p>
&lt;p>3）如果曲线段L关于&lt;span class="math inline">\(y=x\)&lt;/span>对称， 则&lt;span class="math inline">\(\int_L f(x,y) ds = \int_{L} f(y,x) ds\)&lt;/span>&lt;/p>
&lt;h3 id="计算法">计算法&lt;/h3>
&lt;h4 id="替代法">替代法&lt;/h4>
&lt;p>不一定有用。&lt;/p>
&lt;h4 id="定积分法">定积分法&lt;/h4>
&lt;p>平面内对弧长的曲线积分：&lt;/p>
&lt;p>1）用直角坐标表示曲线段L的方程：&lt;span class="math inline">\(y=\varphi(x) \quad (a \le x \le b)\)&lt;/span> &lt;span class="math inline">\(\int_L f(x,y) ds = \int_a^b f[x, \varphi(x)] \sqrt{1+ \varphi^{\prime 2} (x)} dx\)&lt;/span>&lt;/p>
&lt;p>2）用参数方程表示曲线段L：&lt;span class="math inline">\(\left\{\begin{array}{} x=\varphi(t) \\ y =\psi(t)\end{array}\right. \quad (\alpha \le t \le \beta)\)&lt;/span> &lt;span class="math inline">\(\int_L f(x,y) ds = \int_\alpha^\beta f[\varphi(t), \psi(t)] \sqrt{\varphi^{\prime 2} (t) + \psi^{\prime 2}(t)} dt\)&lt;/span> （对弧长的曲线积分中&lt;span class="math inline">\(\alpha\)&lt;/span>必小于等于&lt;span class="math inline">\(\beta\)&lt;/span>，这是因为&lt;span class="math inline">\(ds\)&lt;/span>必为正）&lt;/p>
&lt;p>3）用极坐标表示曲线L的方程：&lt;span class="math inline">\(\rho = \rho(\theta) \quad (\theta_1 \le \theta \le \theta_2)\)&lt;/span> &lt;span class="math inline">\(\int_L f(x,y) ds = \int_{\theta_1}^{\theta_2} f[\rho(\theta), \theta] \sqrt{\rho^2(\theta) + \rho^{\prime 2}(\theta)}d\theta\)&lt;/span>&lt;/p>
&lt;p>我们可以很容易地推广到空间中对弧长的曲线积分：&lt;/p>
&lt;p>1）用参数方程表示空间曲线段L的方程：&lt;span class="math inline">\(\left\{\begin{array}{} x=\varphi(t) \\ y =\psi(t) \\ z = \omega(t) \end{array}\right. \quad (\alpha \le t \le \beta)\)&lt;/span> &lt;span class="math inline">\(\int_L f(x,y,z) ds = \int_\alpha^\beta f[\varphi(x), \psi(y), \omega(t)] \sqrt{\varphi^{\prime 2} (t) + \psi^{\prime 2}(t) + \omega^{\prime 2}(t)} dt\)&lt;/span>&lt;/p>
&lt;h2 id="对坐标的曲线积分第二类曲线积分">对坐标的曲线积分（第二类曲线积分）&lt;/h2>
&lt;h3 id="背景-1">背景&lt;/h3>
&lt;p>变力在曲线上的做功问题&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907001737371.png" alt="image-20200907001737371" /> （一维）双理想情况（做功路径是直的、力是恒力）： &lt;span class="math inline">\(W = |\vec{F}| \cos \theta \cdot |\vec{AB} | = \vec{F} \cdot \vec{AB}\)&lt;/span>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907002738808.png" alt="image-20200907002738808" /> （二维）双不理想情况（做功路径是曲线、力不是恒力）： 设&lt;span class="math inline">\(\vec{F} = \{P(x,y), Q(x,y)\}\)&lt;/span>，用元素法分析： &lt;span class="math inline">\(\forall \vec{ds} \in L, \vec{ds} = \{dx, dy\}\)&lt;/span>， 注意这里的曲线段以及曲线段L以及曲线段的微元都是&lt;strong>有方向的&lt;/strong>。 &lt;span class="math inline">\(dw = \vec{F} \cdot \vec{ds} = (P,Q) \cdot (dx, dy) = P(x,y)dx + Q(x,y)dy\)&lt;/span> &lt;span class="math inline">\(W = \int_L dw = \int_L P(x,y)dx + Q(x,y)dy\)&lt;/span>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907003917756.png" alt="image-20200907003917756" /> （三维）双不理想情况（做功路径是曲线、力不是恒力）： 设&lt;span class="math inline">\(\vec{F} = \{P(x,y,z), Q(x,y,z), R(x,y,z)\}\)&lt;/span>，用元素法分析： &lt;span class="math inline">\(\forall \vec{ds} \in L, \vec{ds} = \{dx, dy, dz\}\)&lt;/span>， 注意这里的曲线段以及曲线段L以及曲线段的微元都是&lt;strong>有方向的&lt;/strong>。 &lt;span class="math inline">\(dw = \vec{F} \cdot \vec{ds} = (P,Q,R) \cdot (dx, dy, dz) = P(x,y,z)dx + Q(x,y,z)dy + R(x,y,z)dz\)&lt;/span> &lt;span class="math inline">\(W = \int_L dw = \int_L P(x,y,z)dx + Q(x,y,z)dy + R(x,y,z) dz\)&lt;/span>&lt;/p>
&lt;h3 id="抽象对坐标的曲线积分概念">抽象（对坐标的曲线积分概念）&lt;/h3>
&lt;p>对于二维平面中的&lt;span class="math inline">\(\int_L P(x,y)dx + Q(x,y)dy\)&lt;/span>, &lt;span class="math inline">\(\int_L P(x,y)dx\)&lt;/span>称为&lt;span class="math inline">\(P(x,y)\)&lt;/span>在&lt;strong>有向&lt;/strong>曲线段L上对坐标的曲线积分； &lt;span class="math inline">\(\int_L Q(x,y)dx\)&lt;/span>称为&lt;span class="math inline">\(Q(x,y)\)&lt;/span>在&lt;strong>有向&lt;/strong>曲线段L上对坐标的曲线积分.&lt;/p>
&lt;p>对于三维空间中的&lt;span class="math inline">\(\int_L P(x,y,z)dx + Q(x,y,z)dy + R(x,y,z)dz\)&lt;/span>, &lt;span class="math inline">\(\int_L P(x,y,z)dx\)&lt;/span>称为&lt;span class="math inline">\(P(x,y,z)\)&lt;/span>在&lt;strong>有向&lt;/strong>曲线段L上对坐标的曲线积分； &lt;span class="math inline">\(\int_L Q(x,y,z)dx\)&lt;/span>称为&lt;span class="math inline">\(Q(x,y,z)\)&lt;/span>在&lt;strong>有向&lt;/strong>曲线段L上对坐标的曲线积分; &lt;span class="math inline">\(\int_L R(x,y,z)dx\)&lt;/span>称为&lt;span class="math inline">\(R(x,y,z)\)&lt;/span>在&lt;strong>有向&lt;/strong>曲线段L上对坐标的曲线积分.&lt;/p>
&lt;h3 id="性质-1">性质&lt;/h3>
&lt;p>积分的加减 = 加减的积分&lt;/p>
&lt;p>常数可以提出来&lt;/p>
&lt;p>&lt;span class="math inline">\(L = L_1 + L_2\)&lt;/span>则可以分段积分&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{L^-} = - \int _L\)&lt;/span>，即有向曲线段取相反方向，（对坐标的曲线）积分结果也取反。&lt;/p>
&lt;p>对坐标的曲线积分可以转化为对弧长的曲线积分/第二类曲线积分可以转换为第一类曲线积分： &lt;span class="math inline">\(\int_L P(x,y)dx + Q(x,y)dy \\= \int_L P(\varphi(t),\psi(t))\varphi^\prime(t)dt + Q(\varphi(t),\psi(t))\psi^\prime(t)dt \\= \int_L P[\varphi(t),\psi(t)]\frac{\varphi^\prime(t)}{\sqrt{\varphi^{\prime 2}(t) + \psi^{\prime 2}(t)}} \cdot\sqrt{\varphi^{\prime 2}(t) + \psi^{\prime 2}(t)}dt + Q[\varphi(t),\psi(t)]\frac{\psi^\prime(t)}{\sqrt{\varphi^{\prime 2}(t) + \psi^{\prime 2}(t)}}\cdot \sqrt{\varphi^{\prime 2}(t) + \psi^{\prime 2}(t)}dt \\ =\int_L P(x,y) \cos \alpha ds + Q(x,y)\cos\beta ds \\ = \int_L (P,Q)\cdot (\cos\alpha ,\cos\beta) ds \\= \int_L \vec{A} \cdot \vec{e_n} ds\)&lt;/span>&lt;/p>
&lt;h3 id="计算法-1">计算法&lt;/h3>
&lt;h4 id="定积分法-1">定积分法&lt;/h4>
&lt;p>1）用直角坐标表示&lt;strong>有向&lt;/strong>曲线段L的方程：&lt;span class="math inline">\(y = \varphi(x)\)&lt;/span> (起点&lt;span class="math inline">\(x=a\)&lt;/span>，终点&lt;span class="math inline">\(x=b\)&lt;/span>) 则二维平面内&lt;span class="math inline">\(\int_L P(x,y)dx + Q(x,y)dy = \int_a^b P[x,\varphi(x)]dx + Q[x,\varphi(x)]\varphi^\prime(x)dx\)&lt;/span> 三维类似。&lt;/p>
&lt;p>2）由参数方程表示&lt;strong>有向&lt;/strong>曲线段L：&lt;span class="math inline">\(\left\{\begin{array}{} x=\varphi(t) \\ y =\psi(t)\end{array}\right.\)&lt;/span>， （起点&lt;span class="math inline">\(t=\alpha\)&lt;/span>，终点&lt;span class="math inline">\(t=\beta\)&lt;/span>） 则二维平面内&lt;span class="math inline">\(\int_L P(x,y)dx + Q(x,y)dy = \int_\alpha^\beta P[\varphi(t),\psi(t)]\varphi^\prime(t)dt + Q[\varphi(t),\psi(t)]\psi^\prime(t)dt\)&lt;/span> （这里下限&lt;span class="math inline">\(\alpha\)&lt;/span>要对应有向曲线段的起点） 三维类似。&lt;/p>
&lt;h4 id="转化为二重积分法格林公式平面的域与界的关系">转化为二重积分法（格林公式/平面的域与界的关系）&lt;/h4>
&lt;p>首先明确&lt;a href="#附录1：域与界的概念与联系公式">二维平面的域与界&lt;/a>的概念与联系公式（格林公式），然后利用格林公式将&lt;strong>闭合有向&lt;/strong>曲线段L上的曲线积分转化为D上的二重积分。&lt;/p>
&lt;h5 id="格林公式">格林公式&lt;/h5>
&lt;p>当1）D为连通区域， 2）L为D的正项边界， 3）&lt;span class="math inline">\(P(x,y), Q(x,y)\)&lt;/span>在D上连续可偏导， 则有（格林公式）： $ _L Pdx + Qdy = _D ( - ) d$&lt;/p>
&lt;p>（若不封闭，可补为封闭图形） （若L不是正向的，则积分前补负号时可取L正向） （若是多连通区域，应包含所有边界）&lt;/p>
&lt;h4 id="转化为曲面积分法斯托克斯公式曲面的域与界的关系">转化为曲面积分法（斯托克斯公式/曲面的域与界的关系）&lt;/h4>
&lt;p>斯托克斯公式可看作是格林公式的推广，格林公式建立起二维平面上域与界的联系，而斯托克斯公式建立起空间曲面域与界的联系。&lt;/p>
&lt;p>这里需要先学习/掌握后面&lt;a href="#对坐标的曲面积分（第一类曲面积分）">对坐标的曲面积分&lt;/a>章节的内容。然后要明确&lt;a href="#附录1：域与界的概念与联系公式">曲面的域与界&lt;/a>的概念与联系公式（斯托克斯公式），然后利用斯托克斯公式将&lt;strong>闭合有向&lt;/strong>曲线段L上的曲线积分转化为曲面积分。&lt;/p>
&lt;h5 id="斯托克斯公式">斯托克斯公式&lt;/h5>
&lt;p>定理 设 &lt;span class="math inline">\(\Gamma\)&lt;/span> 为分段光滑的空间有向闭曲线, $ $是以 &lt;span class="math inline">\(\Gamma\)&lt;/span> 为边界的分片光滑 的有向曲面, &lt;span class="math inline">\(\Gamma\)&lt;/span> 的正向与 &lt;span class="math inline">\(\Sigma\)&lt;/span>的侧符合右手规则, 若函数 &lt;span class="math inline">\(P(x, y, z), Q(x, y, z)\)&lt;/span> 与&lt;span class="math inline">\(R(x, y, z)\)&lt;/span> 在曲面 &lt;span class="math inline">\(\Sigma(\)&lt;/span> 连同边界 &lt;span class="math inline">\(\Gamma)\)&lt;/span> 上具有一阶连续偏导数 , 则有（斯托克斯公式）： &lt;span class="math inline">\(\iint_{\Sigma}\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \mathrm{d} y \mathrm{d} z+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \mathrm{d} z \mathrm{d} x+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;span class="math inline">\(=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;p>（斯托克斯公式建立起： 曲线积分与曲面积分的联系/界与域的联系）&lt;/p>
&lt;p>斯托克斯公式更方便记忆的形式： &lt;span class="math inline">\(\int_{\Sigma}\left|\begin{array}{ccc}\mathrm{d} y \mathrm{d} z &amp;amp; \mathrm{d} z \mathrm{d} x &amp;amp; \mathrm{d} x \mathrm{d} y \\ \frac{\partial}{\partial x} &amp;amp; \frac{\partial}{\partial y} &amp;amp; \frac{\partial}{\partial z} \\ P &amp;amp; Q &amp;amp; R\end{array}\right|=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;p>后面学习了对面积和对坐标的曲面积分的关系后，即&lt;span class="math inline">\(\vec{dS} = \vec{n}dS =( \cos\alpha, \cos\beta, \cos\gamma) dS\)&lt;/span>，斯托克斯公式还可写为： &lt;span class="math inline">\(\int_{\Sigma}\left|\begin{array}{ccc}\cos \alpha &amp;amp; \cos \beta &amp;amp; \cos \gamma \\ \frac{\partial}{\partial x} &amp;amp; \frac{\partial}{\partial y} &amp;amp; \frac{\partial}{\partial z} \\ P &amp;amp; Q &amp;amp; R\end{array}\right| \mathrm{d} S=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;h4 id="平面上与路径无关的曲线积分计算法">平面上与路径无关的曲线积分计算法&lt;/h4>
&lt;p>根据格林公式/平面中域与界的关系 $ _L Pdx + Qdy = _D ( - ) d$可以推出平面中的曲线与积分路径无关的条件（见如下定理）&lt;/p>
&lt;p>定理：若： 1）D为&lt;strong>单&lt;/strong>连通区域， 2）&lt;span class="math inline">\(P(x,y),Q(x,y)\)&lt;/span>在D上连续可偏导， 则有如下4个等价结论： 1）$ _L Pdx + Qdy&lt;span class="math inline">\(与路径无关 2）任意闭曲线\)&lt;/span>C D&lt;span class="math inline">\(，有\)&lt;/span> _C Pdx + Qdy= 0$ 3）$ $ （柯西-黎曼条件） 4）&lt;span class="math inline">\(\exist u(x,y)\)&lt;/span>使得&lt;span class="math inline">\(du = Pdx + Qdy\)&lt;/span>。 （即&lt;span class="math inline">\(\frac{\partial u}{\partial x} = P, \frac{\partial u}{\partial y} = Q\)&lt;/span>）&lt;/p>
&lt;p>上面比较简洁规范的一种结论是$ $ ，它代表了$ _L Pdx + Qdy$与路径无关。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907092107069.png" alt="image-20200907092107069" /> 而曲线积分与路径无关时（$ &lt;span class="math inline">\(），又有如下结论： 1）如果\)&lt;/span> &lt;span class="math inline">\(，则\)&lt;/span>&lt;em>L Pdx + Qdy =&lt;/em>{(x_0,y_0)}^{(x_1,y_1)} Pdx + Qdy = &lt;em>{x_0}^{x_1} P(x,y_0)dx + &lt;/em>{y_0}^{y_1} Q(x_1,y)dy$ 2）如果$ &lt;span class="math inline">\(，且\)&lt;/span>Pdx + Qdy = du&lt;span class="math inline">\(，则\)&lt;/span>&lt;em>L Pdx + Qdy = &lt;/em>{(x_0,y_0)}^{(x_1,y_1)} du = u(x_1,y_1) - u(x_0,y_0)$ 1）如果$ &lt;span class="math inline">\(，则\)&lt;/span>u(x,y) =&lt;em>{(x_0,y_0)}^{(x,y)} Pdx + Qdy = &lt;/em>{x_0}^{x} P(x,y_0)dx + _{y_0}^{y} Q(x,y)dy$&lt;/p>
&lt;h5 id="曲线积分基本定理">曲线积分基本定理&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(\vec{F}(x, y)=P(x, y) \vec{i}+Q(x, y) \vec{j}\)&lt;/span> 是平面区 域 &lt;span class="math inline">\(G\)&lt;/span> 内的一个向量场, 若 &lt;span class="math inline">\(P(x, y)\)&lt;/span> 与 &lt;span class="math inline">\(Q(x, y)\)&lt;/span> 都在 &lt;span class="math inline">\(G\)&lt;/span> 内连续, 且存在一个数量函数&lt;span class="math inline">\(f(x, y),\)&lt;/span> 使得 &lt;span class="math inline">\(\vec{F}=\nabla f,\)&lt;/span> 则曲线积分 &lt;span class="math inline">\(\int_{L} \vec{F} \cdot \mathrm{d} \vec{r}\)&lt;/span> 在 &lt;span class="math inline">\(G\)&lt;/span> 内与路径无关, 且&lt;span class="math inline">\(\int_{L} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{r}=f(B)-f(A)\)&lt;/span>。其中 L 是位于 G 内起点为 A.终点为 B 的任一分段光滑曲线.&lt;/p>
&lt;table style="width:100%;">
&lt;colgroup>
&lt;col style="width: 15%" />
&lt;col style="width: 58%" />
&lt;col style="width: 26%" />
&lt;/colgroup>
&lt;tbody>
&lt;tr class="odd">
&lt;td>微积分基本公式&lt;/td>
&lt;td>&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x=F(b)-F(a)\)&lt;/span>&lt;/td>
&lt;td>其中 &lt;span class="math inline">\(F^{\prime}(x)=f(x)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>曲线积分基本公式&lt;/td>
&lt;td>&lt;span class="math inline">\(\int_{L} \boldsymbol{F} \cdot \mathrm{d} \boldsymbol{r}=f(B)-f(A)\)&lt;/span>&lt;/td>
&lt;td>其中&lt;span class="math inline">\(\vec{F}=\nabla f(x,y)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="空间中与路径无关的曲线积分计算法">空间中与路径无关的曲线积分计算法&lt;/h4>
&lt;p>根据斯托克斯公式&lt;span class="math inline">\(\iint_{\Sigma}\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \mathrm{d} y \mathrm{d} z+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \mathrm{d} z \mathrm{d} x+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;span class="math inline">\(=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 可以推出空间曲线积分与路径无关的条件（见如下定理）&lt;/p>
&lt;p>定理 设空间区域 G 是一维单连通域, 若函数 &lt;span class="math inline">\(P(x, y, z), Q(x, y, z)\)&lt;/span> 与&lt;span class="math inline">\(R(x, y, z)\)&lt;/span> 在 &lt;span class="math inline">\(G\)&lt;/span> 内具有一阶连续偏导数, 则： 空间 曲 线 积分 &lt;span class="math inline">\(\int_{r} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 在 &lt;span class="math inline">\(G\)&lt;/span>内与路径无关(或沿 G 内任意闭曲线的曲线积分为零)&lt;br />
&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\frac{\partial P}{\partial y}=\frac{\partial Q}{\partial x}, \quad \frac{\partial Q}{\partial z}=\frac{\partial R}{\partial y}, \quad \frac{\partial R}{\partial x}=\frac{\partial P}{\partial z}\)&lt;/span>在 G 内恒成立. &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 表达式 &lt;span class="math inline">\(P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 在 &lt;span class="math inline">\(G\)&lt;/span> 内成为某一函数 &lt;span class="math inline">\(u(x, y, z)\)&lt;/span> 的全微分 （同时可求出&lt;span class="math inline">\(u(x, y, z)=\int_{\left(x_{0}, y_{0}, z_{0}\right)}^{(x, y, z)} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>）&lt;/p>
&lt;h2 id="对面积的曲面积分第一类曲面积分">对面积的曲面积分（第一类曲面积分）&lt;/h2>
&lt;h3 id="背景-2">背景&lt;/h3>
&lt;p>空间曲面的质量问题&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907094401769.png" alt="" />&lt;figcaption>image-20200907094401769&lt;/figcaption>
&lt;/figure>
&lt;p>用元素法分析： &lt;span class="math inline">\(\forall dS \subset \Sigma\)&lt;/span> &lt;span class="math inline">\(dm = \rho(x,y,z) dS\)&lt;/span> &lt;span class="math inline">\(m=\iint_\Sigma dm = \iint_\Sigma \rho(x,y,z) dS\)&lt;/span>&lt;/p>
&lt;p>这里是对空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>积分，不是二重积分中对坐标面上的投影&lt;span class="math inline">\(D_{xy}\)&lt;/span>积分，也不是三重积分中对体积&lt;span class="math inline">\(\Omega\)&lt;/span>的积分; 这里的dS是空间曲面的一小块，也不是二重积分中的面积元素&lt;span class="math inline">\(d\sigma\)&lt;/span>; 则这是一种新的积分类型。&lt;/p>
&lt;h3 id="抽象对面积的曲面积分">抽象（对面积的曲面积分）&lt;/h3>
&lt;p>&lt;span class="math inline">\(\iint_\Sigma f(x,y,z) dS\)&lt;/span>，称为&lt;span class="math inline">\(f(x,y,z)\)&lt;/span>在曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>上的对面积的曲面积分&lt;/p>
&lt;h3 id="性质-2">性质&lt;/h3>
&lt;p>积分的加减 = 加减的积分&lt;/p>
&lt;p>常数可以提出来&lt;/p>
&lt;p>&lt;span class="math inline">\(\Sigma = \Sigma_1 + \Sigma_2\)&lt;/span>则可以分块积分&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_\Sigma dS = A\)&lt;/span>，即空间曲面的面积&lt;/p>
&lt;p>奇偶性对称性： 1）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于xOy平面对称（上下对称）（上半曲面记为&lt;span class="math inline">\(\Sigma_1\)&lt;/span>）： 如果&lt;span class="math inline">\(f(x,y,-z) = -f(x,y,z)\)&lt;/span>，则&lt;span class="math inline">\(\iint_\Sigma f dS = 0\)&lt;/span>； 如果&lt;span class="math inline">\(f(x,y,-z) = f(x,y,z)\)&lt;/span>，则&lt;span class="math inline">\(\iint_\Sigma f dS = 2 \iint_{\Sigma_1} f dS\)&lt;/span>； 2）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于yOz平面对称（前后对称）。。。 3）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于zOx平面对称（左右对称）。。。 4）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于y=x柱面对称，则&lt;span class="math inline">\(\iint_\Sigma f(x,y,z) dS = \iint_{\Sigma} f(y,x,z) dS\)&lt;/span> 5）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于z=y柱面对称。。。 6）若空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>关于z=x柱面对称。。。&lt;/p>
&lt;h3 id="计算法-2">计算法&lt;/h3>
&lt;h4 id="替代法-1">替代法&lt;/h4>
&lt;h4 id="二重积分法">二重积分法&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907101228077.png" alt="" />&lt;figcaption>image-20200907101228077&lt;/figcaption>
&lt;/figure>
&lt;p>对于&lt;span class="math inline">\(\iint_\Sigma f(x,y,z) dS\)&lt;/span> 空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>表示为&lt;span class="math inline">\(z=\varphi(x,y)\)&lt;/span>，其中&lt;span class="math inline">\((x,y) \in D_{x,y}\)&lt;/span> &lt;span class="math inline">\(dS= \sqrt{1+z_x^{\prime 2} + z_y^{\prime 2}} d\sigma\)&lt;/span> &lt;span class="math inline">\(\iint_\Sigma f(x,y,z) dS = \iint_{D_{xy}} f[x,y,\varphi(x,y)] \sqrt{1+z_x^{\prime 2} + z_y^{\prime 2}} d\sigma\)&lt;/span>&lt;/p>
&lt;h2 id="对坐标的曲面积分第二类曲面积分">对坐标的曲面积分（第二类曲面积分）&lt;/h2>
&lt;h3 id="背景-3">背景&lt;/h3>
&lt;p>流过曲面的流量问题&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907102647945.png" alt="image-20200907102647945" /> &lt;span class="math inline">\(\vec{v} = \{P(x,y,z), Q(x,y,z), R(x,y,z)\}\)&lt;/span> &lt;span class="math inline">\(\Sigma\)&lt;/span>为有侧曲面（如上图&lt;span class="math inline">\(\vec{n}\)&lt;/span>指明上侧为正） 问单位时间内流入曲面一侧的流量是多少？&lt;/p>
&lt;p>用元素法分析： &lt;span class="math inline">\(\forall \vec{dS} \subset \Sigma\)&lt;/span>，&lt;span class="math inline">\(\vec{dS}\)&lt;/span>的大小表示小面元的面积，方向垂直于小面元（并与曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>同侧）（小面元可看作是平面） 则&lt;span class="math inline">\(\vec{dS}\)&lt;/span>可分解为到三个坐标面的投影(从各坐标轴正向看）： &lt;span class="math inline">\(\vec{dS} = \{dydz,dzdx,dxdy\} = |\vec{dS}| (\cos \alpha, \cos \beta, \cos \gamma)\)&lt;/span> （比如&lt;span class="math inline">\(dydz\)&lt;/span>是&lt;span class="math inline">\(\vec{dS}\)&lt;/span>在yOz平面的投影，&lt;span class="math inline">\(|dydz|\)&lt;/span>表示投影面积，&lt;span class="math inline">\(dydz\)&lt;/span>可正可负，且有&lt;span class="math inline">\(dydz = |\vec{dS}| \cos \alpha\)&lt;/span>） 则单位时间内流入曲面上小微元的流量微元： &lt;span class="math inline">\(d \Phi = \vec{v} \cdot \vec{dS} = Pdydz + Qdzdx + Rdxdy\)&lt;/span> 则单位时间内流入曲面侧得流量： &lt;span class="math inline">\(\Phi = \iint_\Sigma d \Phi = \iint_\Sigma Pdydz + Qdzdx + Rdxdy\)&lt;/span>&lt;/p>
&lt;p>注意：这里是对空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>积分，不是对曲面在坐标轴上的投影&lt;span class="math inline">\(D_{xy},D_{yz},D_{zx}\)&lt;/span>积分（即并不是二重积分），这是一种新的积分类型。&lt;/p>
&lt;h3 id="抽象对坐标的曲面积分的概念">抽象（对坐标的曲面积分的概念）&lt;/h3>
&lt;p>根据&lt;span class="math inline">\(\iint_\Sigma Pdydz + Qdzdx + Rdxdy\)&lt;/span>&lt;/p>
&lt;p>我们把$ _Pdydz&lt;span class="math inline">\(称为\)&lt;/span>P(x,y,z)&lt;span class="math inline">\(在有侧曲面\)&lt;/span>$上对坐标y,z的曲面积分。&lt;/p>
&lt;h3 id="性质-3">性质&lt;/h3>
&lt;p>积分的加减 = 加减的积分&lt;/p>
&lt;p>常数可以提出来&lt;/p>
&lt;p>&lt;span class="math inline">\(\Sigma = \Sigma_1 + \Sigma_2\)&lt;/span>则可以分块积分&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_{\Sigma^-} = -\iint_\Sigma\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_\Sigma Pdydz + Qdzdx + Rdxdy = \iint_\Sigma (P\cos\alpha + Q\cos\beta + R\cos\gamma) dS\)&lt;/span>，即对坐标的曲面积分可以转化为对面积的曲面积分/第二类曲面积分可转化为第一类曲面积分&lt;/p>
&lt;h3 id="计算法-3">计算法&lt;/h3>
&lt;h4 id="二重积分法-1">二重积分法&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907101228077.png" alt="image-20200907101228077" /> 对于&lt;span class="math inline">\(\iint_\Sigma R(x,y,z)dxdy\)&lt;/span> 将曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>表示为&lt;span class="math inline">\(z=\varphi(x,y)\)&lt;/span>， 其中&lt;span class="math inline">\((x,y) \in D_{xy}\)&lt;/span> 则&lt;span class="math inline">\(\iint_\Sigma R(x,y,z)dxdy = \pm \iint_{D_{xy}} R(x,y,z)dxdy\)&lt;/span> 其中当&lt;span class="math inline">\(\cos\gamma&amp;gt;0\)&lt;/span>或者&lt;span class="math inline">\(\Sigma\)&lt;/span>取上侧时，&lt;span class="math inline">\(&amp;quot;\pm&amp;quot;\)&lt;/span>取”+“ 其中当&lt;span class="math inline">\(\cos\gamma&amp;lt;0\)&lt;/span>或者&lt;span class="math inline">\(\Sigma\)&lt;/span>取下侧时，&lt;span class="math inline">\(&amp;quot;\pm&amp;quot;\)&lt;/span>取”-“&lt;/p>
&lt;p>注意： 对坐标的曲面积分&lt;span class="math inline">\(\iint_\Sigma R(x,y,z)dxdy\)&lt;/span>中，&lt;span class="math inline">\(dxdy\)&lt;/span>表示&lt;span class="math inline">\(\vec{dS}\)&lt;/span>的投影，可正可负； 二重积分&lt;span class="math inline">\(\iint_{D_{xy}} R(x,y,z)dxdy\)&lt;/span>中，&lt;span class="math inline">\(dxdy\)&lt;/span>表示面积元素，必取正。&lt;/p>
&lt;h4 id="转化为三重积分法高斯公式域与界的关系">转化为三重积分法（高斯公式/域与界的关系）&lt;/h4>
&lt;p>首先明确&lt;a href="#附录1：域与界的概念与联系公式">三维空间的域与界&lt;/a>的概念与联系公式（高斯公式），然后利用高斯公式将&lt;span class="math inline">\(\Sigma\)&lt;/span>上的曲面积分转化为几何体&lt;span class="math inline">\(\Omega\)&lt;/span>内的三重积分。&lt;/p>
&lt;h5 id="高斯公式">高斯公式&lt;/h5>
&lt;p>若：1）&lt;span class="math inline">\(\Omega\)&lt;/span>为几何体，&lt;span class="math inline">\(\Sigma\)&lt;/span>为外表面， 2）&lt;span class="math inline">\(P(x,y,z), Q(x,y,z),R(x,y,z)\)&lt;/span>在&lt;span class="math inline">\(\Omega\)&lt;/span>内连续可偏导 则&lt;span class="math inline">\(\oiint_\Sigma Pdydz + Qdzdx + Rdxdy = \iiint_\Omega \left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) dv\)&lt;/span>&lt;/p>
&lt;p>（若图形不封闭，可补为封闭体） （若取内表面，积分前加负号变为取外表面）&lt;/p>
&lt;h4 id="仅与曲面边界有关的曲面积分计算法">仅与曲面边界有关的曲面积分计算法&lt;/h4>
&lt;p>仅与曲面边界有关而与曲面内部形状无关的曲面积分，等价于沿任意闭合曲面对坐标的曲面积分为0。&lt;/p>
&lt;p>设 &lt;span class="math inline">\(G\)&lt;/span> 是&lt;a href="#空间二维单连通区域">空间二维单连通区域&lt;/a>, 若 &lt;span class="math inline">\(P(x, y, z), Q(x, y, z)\)&lt;/span> 与 &lt;span class="math inline">\(R(x, y, z)\)&lt;/span>在 G 内具有一阶连续偏导数, 则： 曲面积分&lt;span class="math inline">\(\iint_{\Sigma} P \mathrm{d} y \mathrm{d} z+Q \mathrm{d} z \mathrm{d} x+R \mathrm{d} x \mathrm{d} y\)&lt;/span>在G 内与所取曲面 &lt;span class="math inline">\(\Sigma\)&lt;/span> 无关而只取决于 &lt;span class="math inline">\(\Sigma\)&lt;/span> 的边界曲线(或沿 &lt;span class="math inline">\(G\)&lt;/span> 内任一闭曲面的曲面积分为零) &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}=0\)&lt;/span>在 G 内恒成立. （由&lt;a href="#高斯公式">高斯公式&lt;/a>可证左至右，反证法可证右至左）&lt;/p>
&lt;p>对于这样的曲面积分，在保证曲面边界不变的情况下，可以选取最简单/方便计算的曲面来计算。&lt;/p>
&lt;h2 id="物理应用">物理应用&lt;/h2>
&lt;h3 id="通量">通量&lt;/h3>
&lt;p>我们从前面知道，&lt;strong>对坐标的曲面积分&lt;/strong>的起源/背景是流量问题，即单位时间内通过曲面侧的流量。&lt;/p>
&lt;p>在物理中，根据其物理意义，把&lt;strong>对各个坐标的曲面积分的合并形式&lt;span class="math inline">\(\iint_\Sigma Pdydz + Qdzdx + Rdxdy= \iint_{\Sigma} \vec{A} \cdot \vec{n} \mathrm{d} S\)&lt;/span>定义为通量&lt;/strong>： 设有向量场&lt;span class="math inline">\(\boldsymbol{A}(x, y, z)=P(x, y, z) \boldsymbol i+Q(x, y, z) \boldsymbol{j}+R(x, y, z) \boldsymbol{k}\)&lt;/span>， 其中函数 P ,Q 与 R 均具有一阶连续偏导数, &lt;span class="math inline">\(\Sigma\)&lt;/span> 是场内的一片有向曲面, &lt;span class="math inline">\(\vec{n}\)&lt;/span> 是 &lt;span class="math inline">\(\Sigma\)&lt;/span>在点( &lt;span class="math inline">\(x, y, z)\)&lt;/span> 处的单位法向量, 则积分&lt;span class="math inline">\(\iint_{\Sigma} \vec{A} \cdot \vec{n} \mathrm{d} S\)&lt;/span>称为&lt;strong>向量场 &lt;span class="math inline">\(\vec{A}\)&lt;/span> 通过曲面 &lt;span class="math inline">\(\Sigma\)&lt;/span> 向着指定侧的通量&lt;/strong>(或流量)&lt;/p>
&lt;p>即&lt;strong>物理问题中的通量，就是数学中的对坐标的曲面积分&lt;/strong>。&lt;/p>
&lt;h3 id="散度">散度&lt;/h3>
&lt;p>&lt;a href="#高斯公式">高斯公式&lt;/a>给出了空间几何体的域和界的关系：&lt;span class="math inline">\(\oiint_\Sigma Pdydz + Qdzdx + Rdxdy = \iiint_\Omega \left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) dv\)&lt;/span> 这里&lt;span class="math inline">\(\vec{v} = P\vec{j}+Q\vec{j}+R\vec{k}\)&lt;/span>&lt;/p>
&lt;p>考虑其物理意义： 高斯公式左边：&lt;span class="math inline">\(\iint_\Sigma Pdydz + Qdzdx + Rdxdy= \iint_{\Sigma} \vec{v} \cdot \vec{n} \mathrm{d} S= \iint_{\Sigma} v_n \mathrm{d} S\)&lt;/span> 表示流体的通量：&lt;strong>向量场 &lt;span class="math inline">\(\vec{A}\)&lt;/span> 通过曲面 &lt;span class="math inline">\(\Sigma\)&lt;/span> 向着指定侧的通量&lt;/strong>(或流量)， 若流体不可压缩的情况下，流出的量应当全部由内部产生。 则高斯公式右边：&lt;span class="math inline">\(\iiint_\Omega \left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) dv\)&lt;/span> 应当表示在空间&lt;span class="math inline">\(\Omega\)&lt;/span>内，单位时间内产生的的流体总量。&lt;/p>
&lt;p>我们用&lt;span class="math inline">\(\Omega\)&lt;/span>的体积V去除高斯公式两边： &lt;span class="math inline">\(\frac{1}{V} \oiint_{\Sigma} v_{n} \mathrm{d} S=\frac{1}{V} \iiint_{\Omega}\left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) \mathrm{d} v\)&lt;/span>， 这表示&lt;span class="math inline">\(\Omega\)&lt;/span> 内的源头在单位时间单位体积内所产生的流体质量的平均值. 再根据积分中值定理，去掉右边的积分号： &lt;span class="math inline">\(\frac{1}{V} \oiint_{\Sigma} v_{n} \mathrm{d} S=\left.\left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right)\right|_{(\xi, \eta, \zeta)}\)&lt;/span> 并令&lt;span class="math inline">\(\Omega\)&lt;/span>缩向一点&lt;span class="math inline">\(M(x,y,z)\)&lt;/span>得： &lt;span class="math inline">\(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}=\lim _{\Omega \rightarrow M} \frac{1}{V} \oiint_{\Sigma} v_{n} \mathrm{d} S\)&lt;/span> 则&lt;span class="math inline">\(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\)&lt;/span>表示速度场 &lt;span class="math inline">\(\vec{v}\)&lt;/span>在点 M 的&lt;strong>通量密度/流量密度&lt;/strong>或&lt;strong>散度&lt;/strong>（流量产生密度）,可看做稳定流动的不可压缩流体在点 M 的源头强度.&lt;/p>
&lt;p>记为&lt;span class="math inline">\(\operatorname{div} \vec{v}(M)=\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}=\nabla \cdot \boldsymbol{v}\)&lt;/span>&lt;/p>
&lt;p>则高斯公式也可以写成如下形式： &lt;span class="math inline">\(\iint_{\Omega} \operatorname{div} \boldsymbol{A} \mathrm{d} v=\iint_{\Sigma} A_{n} \mathrm{d} S\)&lt;/span> &lt;span class="math inline">\(\iiint_{\Omega} \nabla \cdot \boldsymbol{A} \mathrm{d} v=\iint_{\Sigma} A_{n} \mathrm{d} S\)&lt;/span>&lt;/p>
&lt;h3 id="环流量">环流量&lt;/h3>
&lt;p>设有向量场&lt;span class="math inline">\(\boldsymbol{A}(x, y, z)=P(x, y, z)\boldsymbol{i}+Q(x, y, z) \boldsymbol{j}+R(x, y, z) \boldsymbol{k}\)&lt;/span>， 其中函数 P.Q 与 R 均连续, &lt;span class="math inline">\(\Gamma\)&lt;/span> 是 A 的定义域内的一条分段光滑的有向闭曲线 , &lt;span class="math inline">\(\tau\)&lt;/span>是 &lt;span class="math inline">\(\Gamma\)&lt;/span> 在点 &lt;span class="math inline">\((x, y, z)\)&lt;/span> 处的单位切向量, 则积分&lt;span class="math inline">\(\oint_{\Gamma} \boldsymbol{A} \cdot \boldsymbol{\tau} \mathrm{d} s=\oint_{\Gamma} \boldsymbol{A} \cdot \mathrm{d} \boldsymbol{r}=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>称为&lt;strong>向量场$ $ 沿有向闭曲线 &lt;span class="math inline">\(\Gamma\)&lt;/span> 的环流量&lt;/strong>. 这体现了向量场沿闭合曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>轨迹的积累。&lt;/p>
&lt;p>即&lt;strong>物理问题中的环流量，就是数学中的对坐标的曲线积分&lt;/strong>。&lt;/p>
&lt;h3 id="旋度">旋度&lt;/h3>
&lt;p>斯托克斯公式给出了空间曲面上域和界的关系： &lt;span class="math inline">\(\iint_{\Sigma}\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \mathrm{d} y \mathrm{d} z+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \mathrm{d} z \mathrm{d} x+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;span class="math inline">\(=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;p>类似于向量场&lt;span class="math inline">\(\vec{A}\)&lt;/span>的通量可以引出向量场&lt;span class="math inline">\(\vec{A}\)&lt;/span>在某一点处的通量密度/散度一样， 通过向量场&lt;span class="math inline">\(\vec{A}\)&lt;/span>的环流量可以引出向量场&lt;span class="math inline">\(\vec{A}\)&lt;/span>在某一点出的旋度概念：&lt;/p>
&lt;p>我们用空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>的面积S去除斯托克斯公式两边： &lt;span class="math inline">\(\frac{1}{S}\iint_{\Sigma}\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \mathrm{d} y \mathrm{d} z+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \mathrm{d} z \mathrm{d} x+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;span class="math inline">\(=\frac{1}{S}\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 根据两种曲面积分的关系，变为： &lt;span class="math inline">\(\frac{1}{S}\iint_{\Sigma}\left[\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \cos\alpha+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \cos\beta+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \cos\gamma\right] dS\)&lt;/span>&lt;span class="math inline">\(=\frac{1}{S}\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 等式右边反映了单位面积上，向量场沿闭合曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>轨迹的积累。 再根据积分中值定理，去掉左边的积分号： &lt;span class="math inline">\(\left.\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \cos\alpha+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \cos\beta+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \cos\gamma\right|_{(\xi, \eta, \zeta)}\)&lt;/span>&lt;span class="math inline">\(=\frac{1}{S}\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 并令曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>缩向一点&lt;span class="math inline">\(M(x,y,z)\)&lt;/span>得： &lt;span class="math inline">\(\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z},\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x},\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right)\cdot (\cos\alpha,\cos\beta, \cos\gamma)=\lim _{\Sigma \rightarrow M} \frac{1}{S}\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span> 等式右边反映了向量场沿某点附近的闭合曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>轨迹的积累。 那么等式左边也反映了向量场沿某点附近的闭合曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>轨迹的积累。 我们可以取等式左边除方向余弦外的部分来表征向量场沿某点附近的闭合曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>轨迹的积累：（将其定义为&lt;strong>旋度&lt;/strong>）&lt;span class="math inline">\(\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right)\boldsymbol i+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right)\boldsymbol j+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \boldsymbol{k}\)&lt;/span>&lt;/p>
&lt;p>记为： &lt;span class="math inline">\(\operatorname{rot} \vec{A}=\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right)\boldsymbol i+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right)\boldsymbol j+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \boldsymbol{k} \\=\nabla \times \vec{A} \\=\left|\begin{array}{ccc} \vec{i} &amp;amp; \vec{j} &amp;amp; \vec{k} \\ \frac{\partial}{\partial x} &amp;amp; \frac{\partial}{\partial y} &amp;amp; \frac{\partial}{\partial z} \\ P &amp;amp; Q &amp;amp; R \end{array}\right|\)&lt;/span>&lt;/p>
&lt;h2 id="附录">附录&lt;/h2>
&lt;h3 id="附录1域与界的概念与联系公式">附录1：域与界的概念与联系公式&lt;/h3>
&lt;h4 id="二维平面内的域与界">二维平面内的域与界&lt;/h4>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907044645881.png" alt="image-20200907044645881" /> 单连通区域D，边界曲线L（有向：逆时针正，顺时针负）&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200907045545653.png" alt="image-20200907045545653" /> 多连通区域D，边界曲线L（有向：外逆内顺位正方向）&lt;/p>
&lt;h4 id="三维空间内的域与界">三维空间内的域与界&lt;/h4>
&lt;p>三维空间的域：几何体&lt;span class="math inline">\(\Omega\)&lt;/span> 三维空间的界：几何体的表面（有方向/侧：向外取正）&lt;/p>
&lt;h4 id="域与界的联系公式">域与界的联系公式&lt;/h4>
&lt;table>
&lt;colgroup>
&lt;col style="width: 7%" />
&lt;col style="width: 18%" />
&lt;col style="width: 21%" />
&lt;col style="width: 52%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>维度&lt;/th>
&lt;th>域&lt;/th>
&lt;th>界&lt;/th>
&lt;th>联系公式&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>一维空间&lt;/td>
&lt;td>[a,b]&lt;/td>
&lt;td>边界为a,b&lt;/td>
&lt;td>牛顿-莱布尼兹公式：&lt;span class="math inline">\(F(b) - F(a) = \int_a^b f(x) dx\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>二维空间&lt;/td>
&lt;td>（平面上的）连通区域D&lt;/td>
&lt;td>（平面上的）有向边界曲线L&lt;/td>
&lt;td>格林公式：$ _L Pdx + Qdy = _D ( - ) d$&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>三维空间&lt;/td>
&lt;td>几何体&lt;span class="math inline">\(\Omega\)&lt;/span>&lt;/td>
&lt;td>外表面&lt;span class="math inline">\(\Sigma\)&lt;/span>&lt;/td>
&lt;td>高斯公式：&lt;span class="math inline">\(\oiint_\Sigma Pdydz + Qdzdx + Rdxdy = \iiint_\Omega \left(\frac{\partial P}{\partial x}+\frac{\partial Q}{\partial y}+\frac{\partial R}{\partial z}\right) dv\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>三维空间&lt;/td>
&lt;td>空间曲面&lt;span class="math inline">\(\Sigma\)&lt;/span>&lt;/td>
&lt;td>（空间中的）边界曲线K&lt;/td>
&lt;td>斯托克斯公式：&lt;br />&lt;span class="math inline">\(\iint_{\Sigma}\left(\frac{\partial R}{\partial y}-\frac{\partial Q}{\partial z}\right) \mathrm{d} y \mathrm{d} z+\left(\frac{\partial P}{\partial z}-\frac{\partial R}{\partial x}\right) \mathrm{d} z \mathrm{d} x+\left(\frac{\partial Q}{\partial x}-\frac{\partial P}{\partial y}\right) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;span class="math inline">\(=\oint_{\Gamma} P \mathrm{d} x+Q \mathrm{d} y+R \mathrm{d} z\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="附录2连通区域">附录2：连通区域&lt;/h3>
&lt;h4 id="平面单连通区域">（平面）单连通区域&lt;/h4>
&lt;p>平面上的单连通区域，简单讲就是内部没有奇点的平面闭区域。&lt;/p>
&lt;h4 id="平面复连通区域多连通区域">（平面）复连通区域/多连通区域&lt;/h4>
&lt;p>平面上的多连通区域，简单讲就是平面区域内部存在奇点或者孔洞。&lt;/p>
&lt;h4 id="空间二维单连通区域">空间二维单连通区域&lt;/h4>
&lt;p>对空间区域 G,如果G 内任一闭曲面所围成的区域全属于 G,则称 G 是空间二维单连通区域。&lt;/p>
&lt;h4 id="空间一维单连通区域">空间一维单连通区域&lt;/h4>
&lt;p>对空间区域 G,如果G 内任一闭曲线总可以张成一片完全属于 G 的曲面，则称 G 为空间一维单连通区域。&lt;/p>
&lt;p>eg：环面：环面是空间二维单连通的，但不是空间一维单连通的。 &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/Torus.jpg" alt="环面- 维基百科，自由的百科全书" />&lt;/p>
&lt;p>eg：两个同心球面之间的区域，是空间一维单连通的，但不是空间二维单连通的。 &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200908092512991.png" alt="image-20200908092512991" />&lt;/p></description></item><item><title>高等数学-多元积分学-重积分习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 15 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元积分学-重积分习题">高等数学-多元积分学-重积分习题&lt;/h1>
&lt;h2 id="考察重积分的定义与性质">考察重积分的定义与性质&lt;/h2>
&lt;h3 id="考察重积分的定义">考察重积分的定义&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807112011942.png" alt="" />&lt;figcaption>image-20200807112011942&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807111955188.png" alt="" />&lt;figcaption>image-20200807111955188&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807112421044.png" alt="" />&lt;figcaption>image-20200807112421044&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807112433583.png" alt="" />&lt;figcaption>image-20200807112433583&lt;/figcaption>
&lt;/figure>
&lt;h3 id="考察重积分的性质">考察重积分的性质&lt;/h3>
&lt;h4 id="考察积分区域对称性与被积函数奇偶性">考察积分区域对称性与被积函数奇偶性&lt;/h4>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807113457486.png" alt="" />&lt;figcaption>image-20200807113457486&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807113437559.png" alt="" />&lt;figcaption>image-20200807113437559&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-这道题凑了另一半出来就比较有灵性了">例2 这道题凑了另一半出来，就比较有灵性了&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808095110758.png" alt="" />&lt;figcaption>image-20200808095110758&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808095127225.png" alt="" />&lt;figcaption>image-20200808095127225&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-关于yx对称的一道题">例3 关于y=x对称的一道题&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809111942648.png" alt="" />&lt;figcaption>image-20200809111942648&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809111926326.png" alt="" />&lt;figcaption>image-20200809111926326&lt;/figcaption>
&lt;/figure>
&lt;h4 id="考察二重积分的中值定理">考察二重积分的中值定理&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808165259530.png" alt="" />&lt;figcaption>image-20200808165259530&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808165348010.png" alt="" />&lt;figcaption>image-20200808165348010&lt;/figcaption>
&lt;/figure>
&lt;h4 id="重积分比较大小">重积分比较大小&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201135688.png" alt="" />&lt;figcaption>image-20200808201135688&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201208106.png" alt="" />&lt;figcaption>image-20200808201208106&lt;/figcaption>
&lt;/figure>
&lt;h2 id="重积分的计算">重积分的计算&lt;/h2>
&lt;h3 id="变换积分次序">变换积分次序&lt;/h3>
&lt;p>不变换积分次序无法计算的情形： &lt;span class="math inline">\(x^{2 n} e^{\pm x^{2}} d x\)&lt;/span> &lt;span class="math inline">\(e^{\frac{1}{x}} d x\)&lt;/span> &lt;span class="math inline">\(\sin \frac{1}{x} d x\)&lt;/span> &lt;span class="math inline">\(\cos \frac{1}{x} d x\)&lt;/span>&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807141218819.png" alt="" />&lt;figcaption>image-20200807141218819&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807141205031.png" alt="" />&lt;figcaption>image-20200807141205031&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807164823663.png" alt="" />&lt;figcaption>image-20200807164823663&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807164806260.png" alt="" />&lt;figcaption>image-20200807164806260&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808114716217.png" alt="" />&lt;figcaption>image-20200808114716217&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808114727891.png" alt="" />&lt;figcaption>image-20200808114727891&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808114742281.png" alt="" />&lt;figcaption>image-20200808114742281&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808131549802.png" alt="" />&lt;figcaption>image-20200808131549802&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808131604097.png" alt="" />&lt;figcaption>image-20200808131604097&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808132216867.png" alt="" />&lt;figcaption>image-20200808132216867&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808132232962.png" alt="" />&lt;figcaption>image-20200808132232962&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808171933771.png" alt="" />&lt;figcaption>image-20200808171933771&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808171947235.png" alt="" />&lt;figcaption>image-20200808171947235&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808203413113.png" alt="" />&lt;figcaption>image-20200808203413113&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808203430828.png" alt="" />&lt;figcaption>image-20200808203430828&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808204323235.png" alt="" />&lt;figcaption>image-20200808204323235&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808204346893.png" alt="" />&lt;figcaption>image-20200808204346893&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808210128808.png" alt="" />&lt;figcaption>image-20200808210128808&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808210143227.png" alt="" />&lt;figcaption>image-20200808210143227&lt;/figcaption>
&lt;/figure>
&lt;h3 id="在直角坐标系计算重积分">在直角坐标系计算重积分&lt;/h3>
&lt;h4 id="直接在直角坐标系计算重积分">直接在直角坐标系计算重积分&lt;/h4>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807143539660.png" alt="" />&lt;figcaption>image-20200807143539660&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807143600156.png" alt="image-20200807143600156" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807143610392.png" alt="image-20200807143610392" />&lt;/p>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807171007515.png" alt="" />&lt;figcaption>image-20200807171007515&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807170936962.png" alt="" />&lt;figcaption>image-20200807170936962&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807170950293.png" alt="" />&lt;figcaption>image-20200807170950293&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807182220512.png" alt="" />&lt;figcaption>image-20200807182220512&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807182201164.png" alt="" />&lt;figcaption>image-20200807182201164&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808092457469.png" alt="" />&lt;figcaption>image-20200808092457469&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808092438239.png" alt="" />&lt;figcaption>image-20200808092438239&lt;/figcaption>
&lt;/figure>
&lt;p>注：此题也可在求坐标系中求解&lt;/p>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808130929748.png" alt="" />&lt;figcaption>image-20200808130929748&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808130944322.png" alt="" />&lt;figcaption>image-20200808130944322&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808173243560.png" alt="" />&lt;figcaption>image-20200808173243560&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808173302022.png" alt="" />&lt;figcaption>image-20200808173302022&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808202817098.png" alt="" />&lt;figcaption>image-20200808202817098&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808202829904.png" alt="" />&lt;figcaption>image-20200808202829904&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808211859465.png" alt="" />&lt;figcaption>image-20200808211859465&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808211913442.png" alt="" />&lt;figcaption>image-20200808211913442&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808225559762.png" alt="" />&lt;figcaption>image-20200808225559762&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808225613294.png" alt="" />&lt;figcaption>image-20200808225613294&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809090150590.png" alt="" />&lt;figcaption>image-20200809090150590&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809090249180.png" alt="" />&lt;figcaption>image-20200809090249180&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809093415467.png" alt="" />&lt;figcaption>image-20200809093415467&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809093448512.png" alt="" />&lt;figcaption>image-20200809093448512&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809093504927.png" alt="" />&lt;figcaption>image-20200809093504927&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809110751106.png" alt="" />&lt;figcaption>image-20200809110751106&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809110807981.png" alt="" />&lt;figcaption>image-20200809110807981&lt;/figcaption>
&lt;/figure>
&lt;h4 id="积分区域边界是参数方程形式计算重积分">积分区域边界是参数方程形式，计算重积分&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808090031368.png" alt="" />&lt;figcaption>image-20200808090031368&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808090018933.png" alt="" />&lt;figcaption>image-20200808090018933&lt;/figcaption>
&lt;/figure>
&lt;h3 id="转换到极坐标系计算重积分">转换到极坐标系计算重积分&lt;/h3>
&lt;p>某些二重积分，满足： 积分区域D的边界用极坐标方程表示比较简单（主要）， 被积函数用极坐标变量&lt;span class="math inline">\(\rho, \theta\)&lt;/span>表示比较简单（次要）， 这个时候，我们可以考虑用极坐标来计算二重积分。&lt;/p>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807140723483.png" alt="" />&lt;figcaption>image-20200807140723483&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807140706285.png" alt="" />&lt;figcaption>image-20200807140706285&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807170117432.png" alt="" />&lt;figcaption>image-20200807170117432&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807170059015.png" alt="" />&lt;figcaption>image-20200807170059015&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807173443870.png" alt="" />&lt;figcaption>image-20200807173443870&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807173430849.png" alt="" />&lt;figcaption>image-20200807173430849&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807233331187.png" alt="" />&lt;figcaption>image-20200807233331187&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807233352058.png" alt="" />&lt;figcaption>image-20200807233352058&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807233409354.png" alt="" />&lt;figcaption>image-20200807233409354&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808083018706.png" alt="" />&lt;figcaption>image-20200808083018706&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808083034747.png" alt="" />&lt;figcaption>image-20200808083034747&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808175340505.png" alt="" />&lt;figcaption>image-20200808175340505&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808175320917.png" alt="" />&lt;figcaption>image-20200808175320917&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201343854.png" alt="" />&lt;figcaption>image-20200808201343854&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201358347.png" alt="" />&lt;figcaption>image-20200808201358347&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201844698.png" alt="" />&lt;figcaption>image-20200808201844698&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808201854877.png" alt="" />&lt;figcaption>image-20200808201854877&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808202438548.png" alt="" />&lt;figcaption>image-20200808202438548&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808221425919.png" alt="" />&lt;figcaption>image-20200808221425919&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808221440158.png" alt="" />&lt;figcaption>image-20200808221440158&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808221957839.png" alt="" />&lt;figcaption>image-20200808221957839&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808221835810.png" alt="" />&lt;figcaption>image-20200808221835810&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808221934990.png" alt="" />&lt;figcaption>image-20200808221934990&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808223148065.png" alt="" />&lt;figcaption>image-20200808223148065&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808223204198.png" alt="" />&lt;figcaption>image-20200808223204198&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-1">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809091532081.png" alt="" />&lt;figcaption>image-20200809091532081&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809091513593.png" alt="" />&lt;figcaption>image-20200809091513593&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809095220571.png" alt="" />&lt;figcaption>image-20200809095220571&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809095236073.png" alt="" />&lt;figcaption>image-20200809095236073&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-此题比较考验功底">例14 此题比较考验功底&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809102840745.png" alt="" />&lt;figcaption>image-20200809102840745&lt;/figcaption>
&lt;/figure>
&lt;p>​ &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809102949023.png" alt="image-20200809102949023" />&lt;/p>
&lt;p>在直角坐标系中求解，注意换元法的使用。 在极坐标系中求解，注意叠加法，可以叠负的（即相减）&lt;/p>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809103642623.png" alt="" />&lt;figcaption>image-20200809103642623&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809103624277.png" alt="" />&lt;figcaption>image-20200809103624277&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809233928592.png" alt="" />&lt;figcaption>image-20200809233928592&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809233948247.png" alt="" />&lt;figcaption>image-20200809233948247&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234045293.png" alt="" />&lt;figcaption>image-20200809234045293&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234055876.png" alt="" />&lt;figcaption>image-20200809234055876&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18">例18&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234645064.png" alt="" />&lt;figcaption>image-20200809234645064&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234712560.png" alt="" />&lt;figcaption>image-20200809234712560&lt;/figcaption>
&lt;/figure>
&lt;p>此题转换到球坐标系更简单&lt;/p>
&lt;h3 id="转换到柱坐标系求重积分">转换到柱坐标系求重积分&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808110012330.png" alt="" />&lt;figcaption>image-20200808110012330&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200808105958160.png" alt="" />&lt;figcaption>image-20200808105958160&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234147640.png" alt="" />&lt;figcaption>image-20200809234147640&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234212111.png" alt="" />&lt;figcaption>image-20200809234212111&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234225390.png" alt="" />&lt;figcaption>image-20200809234225390&lt;/figcaption>
&lt;/figure>
&lt;p>其实此题转换到球坐标系求重积分更简单。&lt;/p>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234350683.png" alt="" />&lt;figcaption>image-20200809234350683&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234413085.png" alt="" />&lt;figcaption>image-20200809234413085&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234459276.png" alt="" />&lt;figcaption>image-20200809234459276&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234526648.png" alt="" />&lt;figcaption>image-20200809234526648&lt;/figcaption>
&lt;/figure>
&lt;h3 id="转换到球坐标系中球重积分">转换到球坐标系中球重积分&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234911133.png" alt="" />&lt;figcaption>image-20200809234911133&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809234939147.png" alt="" />&lt;figcaption>image-20200809234939147&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809235009429.png" alt="" />&lt;figcaption>image-20200809235009429&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200809235040062.png" alt="" />&lt;figcaption>image-20200809235040062&lt;/figcaption>
&lt;/figure>
&lt;h2 id="重积分应用">重积分应用&lt;/h2>
&lt;h3 id="几何应用">几何应用&lt;/h3>
&lt;h4 id="体积">体积&lt;/h4>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807180935913.png" alt="" />&lt;figcaption>image-20200807180935913&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807180957578.png" alt="" />&lt;figcaption>image-20200807180957578&lt;/figcaption>
&lt;/figure>
&lt;h3 id="物理应用">物理应用&lt;/h3>
&lt;h4 id="质心">质心&lt;/h4>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807180324733.png" alt="" />&lt;figcaption>image-20200807180324733&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807180346090.png" alt="" />&lt;figcaption>image-20200807180346090&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-多元积分学-重积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/</link><pubDate>Sun, 12 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元积分学-重积分">高等数学-多元积分学-重积分&lt;/h1>
&lt;p>由一元函数积分学我们知道，定积分是某种形式的和的极限。这种和的极限的概念推广到定义在区域、曲线、曲面上的多元函数的情形，就得到了重积分、曲线积分以及曲面积分的概念。&lt;/p>
&lt;h2 id="二重积分的概念与性质">二重积分的概念与性质&lt;/h2>
&lt;h3 id="二重积分概念的引入">二重积分概念的引入&lt;/h3>
&lt;h4 id="曲顶柱体的体积">曲顶柱体的体积&lt;/h4>
&lt;p>对于平顶柱体体积：体积 = 高 &lt;span class="math inline">\(\times\)&lt;/span> 底面积&lt;/p>
&lt;p>对于曲顶柱体，需要将底面（区域）划分为足够小的区域，用极限理论来讨论。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200804162655119.png" alt="" />&lt;figcaption>image-20200804162655119&lt;/figcaption>
&lt;/figure>
&lt;p>首先,用一组曲线网把 区域D 分成 n 个小闭区域&lt;span class="math inline">\(\Delta \sigma_{1}, \Delta \sigma_{2}, \cdots, \Delta \sigma_{n}\)&lt;/span>. 则曲顶柱体可以看作是以小闭区域为底面的小曲顶柱体组成的。&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x, y)\)&lt;/span> 连续,对于一个很小的小闭区域&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>来说 &lt;span class="math inline">\(, f(x, y)\)&lt;/span> 变化很小,我们可以近似看作小平顶柱体。 从&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>中任取一点&lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right),\)&lt;/span> 以 &lt;span class="math inline">\(f\left(\xi_{i}, \eta_{i}\right)\)&lt;/span> 为高而底面积为&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>的体积为&lt;span class="math inline">\(f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i} \quad(i=1,2, \cdots, n)\)&lt;/span> 则这n个小平顶柱体的总体积为&lt;span class="math inline">\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>，即原曲顶柱体的体积近似为&lt;span class="math inline">\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>。 当这n个小闭区域的直径的最大值（记作&lt;span class="math inline">\(\lambda\)&lt;/span>）趋于0时，取上述和的极限，所得极限自然的定义为曲顶柱面的体积&lt;span class="math inline">\(V=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>&lt;/p>
&lt;p>注：闭区域的直径指区域上任意两点的最大距离。&lt;/p>
&lt;h4 id="平面薄片的质量">平面薄片的质量&lt;/h4>
&lt;p>对于均匀薄片（ 面密度是常数），质量为：质量=面密度 &lt;span class="math inline">\(\times\)&lt;/span> 面积&lt;/p>
&lt;p>对于不均匀的薄片，需要将平面（区域）划分为足够小的区域，用极限理论来讨论。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200804164935491.png" alt="" />&lt;figcaption>image-20200804164935491&lt;/figcaption>
&lt;/figure>
&lt;p>首先,用一组曲线网把 区域D 分成 n 个小闭区域&lt;span class="math inline">\(\Delta \sigma_{1}, \Delta \sigma_{2}, \cdots, \Delta \sigma_{n}\)&lt;/span>. 则平面薄板的质量可以看作是以小闭区域（小块）的质量的总和。&lt;/p>
&lt;p>由于 &lt;span class="math inline">\(\mu(x, y)\)&lt;/span> 连续,对于每个小块（小 块所占的小闭区域 &lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 的直径很小）,这些小块就可以近似地看做均匀薄片. 在 &lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 上任取一点 &lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right)\)&lt;/span>, 以点 &lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right)\)&lt;/span>的面密度为近似面密度，这个小块&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>的近似质量为&lt;span class="math inline">\(\mu\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i} \quad(i=1,2, \cdots, n)\)&lt;/span>。 对这n个小块的质量求和，即平面薄板的近似总质量为&lt;span class="math inline">\(\sum_{i=1}^{n} \mu\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_i\)&lt;/span> 取极限，极限值可自然定义为平面薄板的质量&lt;span class="math inline">\(m=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} \mu\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>&lt;/p>
&lt;h3 id="二重积分的定义">二重积分的定义&lt;/h3>
&lt;h4 id="二重积分的定义-1">二重积分的定义&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 是有界&lt;strong>闭区域&lt;/strong> &lt;span class="math inline">\(D\)&lt;/span> 上的&lt;strong>有界函数&lt;/strong>. 将&lt;strong>闭区域 D 任意分成 n 个小闭区域&lt;/strong>&lt;span class="math inline">\(\Delta \sigma_{1}, \Delta \sigma_{2}, \cdots, \Delta \sigma_{n}\)&lt;/span>，其中 &lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 表示第 &lt;span class="math inline">\(i\)&lt;/span> 个小闭区域，也表示它的面积。&lt;/p>
&lt;p>在&lt;strong>每个 &lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 上任取一点&lt;/strong>&lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right),\)&lt;/span> &lt;strong>作乘积&lt;/strong> &lt;span class="math inline">\(f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}(i=1,2, \cdots, n),\)&lt;/span> &lt;strong>并作和&lt;/strong> &lt;span class="math inline">\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>。&lt;/p>
&lt;p>&lt;strong>若&lt;/strong>各小闭区域&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 的最大直径&lt;span class="math inline">\(\lambda \rightarrow 0\)&lt;/span>时，&lt;strong>和的极限&lt;/strong>&lt;span class="math inline">\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>&lt;strong>总存在&lt;/strong>，且极限值且与区域D划分&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 的分法无关，也与 &lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span> 上&lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right)\)&lt;/span>取法无关 ， 那么&lt;strong>称&lt;/strong>此极限为函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在闭区域 D 上的&lt;strong>二重积分&lt;/strong>，记作&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>&lt;/p>
&lt;p>其中 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 叫做被积函数 , $ f(x, y) $ 叫做被积表达式 ， &lt;span class="math inline">\(\mathrm{d} \sigma\)&lt;/span> 叫做面积元素， ,&lt;span class="math inline">\(x\)&lt;/span> 与 &lt;span class="math inline">\(y\)&lt;/span>叫做积分变量, D 叫做积分区域, &lt;span class="math inline">\(\sum_{i}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span> 叫做积分和.&lt;/p>
&lt;h3 id="二重积分的性质">二重积分的性质&lt;/h3>
&lt;p>（二重积分存在的充分条件）当 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在闭区域 D 上连续时，函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(D\)&lt;/span> 上的二重积分必定存在&lt;/p>
&lt;p>（数乘和加法性质）设 &lt;span class="math inline">\(\alpha\)&lt;/span> 与 &lt;span class="math inline">\(\beta\)&lt;/span> 为常数,则&lt;span class="math inline">\(\iint_{D}[\alpha f(x, y)+\beta g(x, y)] \mathrm{d} \sigma=\alpha \iint_{D} f(x, y) \mathrm{d} \sigma+\beta \iint_{D} g(x, y) \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>（积分区域可加性）若&lt;span class="math inline">\(D\)&lt;/span> 分为两个闭区域 &lt;span class="math inline">\(D_{1}\)&lt;/span> 与 &lt;span class="math inline">\(D_{2}\)&lt;/span>，则&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\iint_{D_{1}} f(x, y) \mathrm{d} \sigma+\iint_{D_{2}} f(x, y) \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>（$ f(x, y)=1$时的几何意义）如果在 &lt;span class="math inline">\(D\)&lt;/span>上 ，$ f(x, y)=1&lt;span class="math inline">\(, 则\)&lt;/span>=&lt;em>{D} 1 =&lt;/em>{D} $ 为 &lt;span class="math inline">\(D\)&lt;/span> 的面积&lt;/p>
&lt;p>（二重积分的比较）如果在 &lt;span class="math inline">\(D\)&lt;/span>上$ f(x, y) g(x, y),$ 那么有&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma \leqslant \iint_{D} g(x, y) \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>（重积分的比较的推论）由于&lt;span class="math inline">\(-|f(x, y)| \leqslant f(x, y) \leqslant|f(x, y)|\)&lt;/span>，所以有&lt;span class="math inline">\(\left|\iint_{D} f(x, y) \mathrm{d} \sigma\right| \leqslant \iint_{D}|f(x, y)| \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>（重积分的最值定理/估值不等式）设 &lt;span class="math inline">\(M\)&lt;/span> 和 &lt;span class="math inline">\(m\)&lt;/span> 分别是 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在闭区域 &lt;span class="math inline">\(D\)&lt;/span> 上的最大值和最小值, &lt;span class="math inline">\(\sigma\)&lt;/span> 是 &lt;span class="math inline">\(D\)&lt;/span>的面积，则有&lt;span class="math inline">\(m \sigma \leqslant \iint_{D} f(x, y) \mathrm{d} \sigma \leqslant M \sigma\)&lt;/span>&lt;/p>
&lt;p>（二重积分的中值定理：可用上一条性质证明）设函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在闭区域 &lt;span class="math inline">\(D\)&lt;/span> 上连续, &lt;span class="math inline">\(\sigma\)&lt;/span> 是 &lt;span class="math inline">\(D\)&lt;/span>的面积，则在 D 上至少存在一点( &lt;span class="math inline">\(\xi, \eta)\)&lt;/span>, 使得&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=f(\xi, \eta) \sigma\)&lt;/span>&lt;/p>
&lt;h4 id="二重积分的积分区域对称性与积分函数奇偶性">二重积分的积分区域对称性与积分函数奇偶性&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200807145403376.png" alt="" />&lt;figcaption>image-20200807145403376&lt;/figcaption>
&lt;/figure>
&lt;p>积分区域D关于y轴对称（左右对称）， 设右侧积分区域为&lt;span class="math inline">\(D_1\)&lt;/span>,则（把y先看作常数，观察被积函数对于x的奇偶性） &lt;span class="math inline">\(\left\{ \begin{aligned}f(-x,y)=-f(x,y), &amp;amp;\Rightarrow \iint_D f(x,y) d\sigma = 0 \\ f(-x,y)= f(x,y), &amp;amp;\Rightarrow \iint_D f(x,y)d\sigma = 2 \iint_{D_1} f(x,y)d\sigma \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;p>积分区域D关于x轴对称（上下对称）， 设上侧积分区域为&lt;span class="math inline">\(D_1\)&lt;/span>，则（把x看作常数，观察被积函数关于y的奇偶性） &lt;span class="math inline">\(\left\{ \begin{aligned}f(x,-y)=-f(x,y), &amp;amp;\Rightarrow \iint_D f(x,y) d\sigma = 0 \\ f(x,-y)= f(x,y), &amp;amp;\Rightarrow \iint_D f(x,y)d\sigma = 2 \iint_{D_1} f(x,y)d\sigma \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;p>积分区域D关于&lt;span class="math inline">\(y=x\)&lt;/span>对称，则： &lt;span class="math inline">\(\iint_{D} f(x, y) d \sigma=\iint f(y, x) d \sigma\)&lt;/span>&lt;/p>
&lt;h4 id="二重积分的积分中值定理">二重积分的积分中值定理&lt;/h4>
&lt;p>若 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 和 &lt;span class="math inline">\(g(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(D\)&lt;/span> 上连续, 且&lt;span class="math inline">\(g(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(D\)&lt;/span> 上不变号, 则存在&lt;span class="math inline">\((\xi, \eta) \in D,\)&lt;/span> 使等式&lt;span class="math inline">\(\iint_{D} f(x, y) g(x, y) \mathrm{d} \sigma=f(\xi, \eta) \iint_{D} g(x, y) \mathrm{d} \sigma\)&lt;/span>成立, 其中 D 是有界连通闭区域.&lt;/p>
&lt;p>（用介值定理可以证明，参考：&lt;a href="https://www.zhihu.com/question/356494233">知乎网友的回答&lt;/a>）&lt;/p>
&lt;h2 id="二重积分的计算">二重积分的计算&lt;/h2>
&lt;p>二重积分的计算，除了用定义计算，一般需要化为两次单积分（定积分）来计算。&lt;/p>
&lt;h3 id="用定义计算二重积分">用定义计算二重积分&lt;/h3>
&lt;p>略&lt;/p>
&lt;h3 id="计算二重积分在直角坐标系化为二次积分">计算二重积分：在直角坐标系化为二次积分&lt;/h3>
&lt;p>下面讨论在直角坐标系中将二重积分化为二次定积分的方法。&lt;/p>
&lt;h4 id="直角坐标系中的二重积分">直角坐标系中的二重积分&lt;/h4>
&lt;p>根据二重积分的定义&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>，对于闭区域D的划分是任意的。如果在直角坐标系中，用平行于坐标轴的直线网来划分 D,那么除了包含边界点的一些小闭区域外,其余的小闭区域都是矩形闭区域.&lt;/p>
&lt;p>设矩形闭区域 &lt;span class="math inline">\(\Delta \sigma,\)&lt;/span> 的边长为 &lt;span class="math inline">\(\Delta x_{j}\)&lt;/span> 和 &lt;span class="math inline">\(\Delta y_{k},\)&lt;/span> 则&lt;span class="math inline">\(\Delta \sigma_{i}=\Delta x_{j} \cdot \Delta y_{k} \cdot\)&lt;/span> 因此在直角坐标系中,有时也把面积元素 &lt;span class="math inline">\(\mathrm{d} \sigma\)&lt;/span> 记作 &lt;span class="math inline">\(\mathrm{d} x \mathrm{d} y,\)&lt;/span>而把（直角坐标系中）二重积分记作&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>其中dxdy 叫做直角坐标系中的面积元素。&lt;/p>
&lt;h4 id="x型区域上二重积分的计算">X型区域上二重积分的计算&lt;/h4>
&lt;p>X型二重积分的积分区域如下图所示：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805092447047.png" alt="" />&lt;figcaption>image-20200805092447047&lt;/figcaption>
&lt;/figure>
&lt;p>其积分区域D可以用如下不等式来表示：&lt;/p>
&lt;p>对于在这种区域上的二重积分，化为先对y积分再对x积分的二次定积分比较简单。（先对y积分时被积函数中出现的x可以当作常数来处理）&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\int_{a}^{b}\left[\int_{\varphi_{1}(x)}^{\varphi_{2}(x)} f(x, y) \mathrm{d} y\right] \mathrm{d} x = \int_{a}^{b} \mathrm{d} x \int_{\varphi_{1}(x)}^{\varphi_{2}(x)} f(x, y) \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;h4 id="y型区域上二重积分的计算">Y型区域上二重积分的计算&lt;/h4>
&lt;p>Y型二重积分的积分区域如下图所示：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805093143863.png" alt="" />&lt;figcaption>image-20200805093143863&lt;/figcaption>
&lt;/figure>
&lt;p>其积分区域D可以用如下不等式来表示： &lt;span class="math inline">\(\psi_{1}(y) \leqslant x \leqslant \psi_{2}(y), c \leqslant y \leqslant d\)&lt;/span>&lt;/p>
&lt;p>对于在这种区域上的二重积分，化为先对x积分再对y积分的二次定积分比较简单。（先对x积分时被积函数中出现的y可以当作常数来处理）&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\int_{c}^{d}\left[\int_{\psi_{1}(y)}^{\psi_{2}(y)} f(x, y) \mathrm{d} x\right] \mathrm{d} y = \int_{c}^{d} \mathrm{d} y \int_{\psi_{1}(y)}^{\psi_{2}(y)} f(x, y) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h4 id="混合型区域上二重积分的计算">混合型区域上二重积分的计算&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805093952237.png" alt="" />&lt;figcaption>image-20200805093952237&lt;/figcaption>
&lt;/figure>
&lt;p>类似这样的混合型区域上的二重积分，可以拆分成多个X型区域或者Y型区域来计算&lt;/p>
&lt;h3 id="计算二重积分直角坐标系转换为极坐标系在极坐标系化为二次积分">计算二重积分：直角坐标系转换为极坐标系，在极坐标系化为二次积分&lt;/h3>
&lt;p>某些二重积分，满足： 积分区域D的边界用极坐标方程表示比较简单（主要）， 被积函数用极坐标变量&lt;span class="math inline">\(\rho, \theta\)&lt;/span>表示比较简单（次要）， 这个时候，我们可以考虑用极坐标来计算二重积分。&lt;/p>
&lt;p>下面讨论在极坐标&lt;/p>
&lt;h4 id="直角坐标系中的二重积分转换为极坐标系中的二重积分">直角坐标系中的二重积分转换为极坐标系中的二重积分&lt;/h4>
&lt;p>根据二重积分的定义&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>，我们考虑在极坐标系的表示。&lt;/p>
&lt;p>二重积分积分区域D的划分是任意的，考虑以极坐标系极轴方向、角向方向划分网格，把积分区域D划分为n个小区域，如下图所示：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805101616790.png" alt="" />&lt;figcaption>image-20200805101616790&lt;/figcaption>
&lt;/figure>
&lt;p>除包含边界点的一些小区域外，小闭区域的&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>面积可如下表示（扇形面积相减）： &lt;span class="math inline">\(\begin{aligned} \Delta \sigma_{i} &amp;amp;=\frac{1}{2}\left(\rho_{i}+\Delta \rho_{i}\right)^{2} \cdot \Delta \theta_{i}-\frac{1}{2} \rho_{i}^{2} \cdot \Delta \theta_{i}=\frac{1}{2}\left(2 \rho_{i}+\Delta \rho_{i}\right) \Delta \rho_{i} \cdot \Delta \theta_{i} \\ &amp;amp;=\frac{\rho_{i}+\left(\rho_{i}+\Delta \rho_{i}\right)}{2} \cdot \Delta \rho_{i} \cdot \Delta \theta_{i}=\bar{\rho}_{i} \cdot \Delta \rho_{i} \cdot \Delta \theta_{i} \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>直角坐标与极坐标之间的关系为： &lt;span class="math inline">\(\left\{\begin{array}{} x = \rho \cos \theta \\ y = \rho \sin \theta\end{array}\right.\)&lt;/span> 则小区域&lt;span class="math inline">\(\Delta \sigma_{i}\)&lt;/span>中一点&lt;span class="math inline">\(\left(\bar{\rho}_{i}, \bar{\theta}_{i}\right)\)&lt;/span>，直角坐标设为 &lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}\right)\)&lt;/span>，则有： &lt;span class="math inline">\(\left\{\begin{array}{} \xi_{i}=\bar{\rho}_{i} \cos \bar{\theta}_{i} \\ \eta_{i}=\bar{\rho}_{i} \sin \bar{\theta}_{i}\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>则根据二重积分定义有：&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\rho_{i} \cos \bar{\theta}_{i}, \bar{\rho}_{i} \sin \bar{\theta}_{i}\right) \bar{\rho}_{i} \cdot \Delta \rho_{i} \cdot \Delta \theta_{i}\)&lt;/span>&lt;/p>
&lt;p>即&lt;strong>极坐标中，二重积分的表示&lt;/strong>为： &lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} \sigma=\iint_{D} f(\rho \cos \theta, \rho \sin \theta) \rho \mathrm{d} \rho \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;p>我们也可以得到二重积分的变量从直角坐标到极坐标的 变换公式： &lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} x \mathrm{d} y=\iint_{D} f(\rho \cos \theta, \rho \sin \theta) \rho \mathrm{d} \rho \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;p>以上也表明,要把二重积分中的变量从直角坐标变换为极坐标，只要 把被积函数中的 x 与 &lt;span class="math inline">\(y\)&lt;/span> 分別换成 &lt;span class="math inline">\(\rho \cos \theta\)&lt;/span> 与 &lt;span class="math inline">\(\rho \sin \theta .\)&lt;/span> 并把直角坐标系 中的面积元素 dxdy 换成极坐标系中的面积元素 &lt;span class="math inline">\(\rho \mathrm{d} \rho \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;h4 id="极坐标系中二重积分的计算">极坐标系中二重积分的计算&lt;/h4>
&lt;p>极坐标系中方便计算的积分区域如下所示： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805104732975.png" alt="image-20200805104732975" />&lt;/p>
&lt;p>其积分区域D可用如下不等式表示： &lt;span class="math inline">\(\varphi_{1}(\theta) \leqslant \rho \leqslant \varphi_{2}(\theta), \alpha \leqslant \theta \leqslant \beta\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\iint_{D} f(\rho \cos \theta, \rho \sin \theta) \rho \mathrm{d} \rho \mathrm{d} \theta=\int_{\alpha}^{\beta}\left[\int_{\varphi_{1}(\theta)}^{\varphi_{2}(\theta)} f(\rho \cos \theta, \rho \sin \theta) \rho \mathrm{d} \rho\right] \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(=\int_{\alpha}^{\beta} \mathrm{d} \theta \int_{\varphi_{1}(\theta)}^{\varphi_{2}(\theta)} f(\rho \cos \theta, \rho \sin \theta) \rho \mathrm{d} \rho\)&lt;/span>&lt;/p>
&lt;p>对于以下的积分区域，可以看作上面情况的特例：&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805105155740.png" alt="image-20200805105155740" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805105217637.png" alt="image-20200805105217637" />&lt;/p>
&lt;p>其积分区域D可用如下不等式表示： 特例型1：&lt;span class="math inline">\(0 \leqslant \rho \leqslant \varphi(\theta), \quad \alpha \leqslant \theta \leqslant \beta\)&lt;/span> 特例型2：&lt;span class="math inline">\(0 \leqslant \rho \leqslant \varphi(\theta), \quad 0 \leqslant \theta \leqslant 2 \pi\)&lt;/span>&lt;/p>
&lt;p>计算方法不变。&lt;/p>
&lt;h3 id="二重积分中坐标系的变换换元">二重积分中坐标系的变换（换元）&lt;/h3>
&lt;p>&lt;strong>定理&lt;/strong>：设 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(x O y\)&lt;/span> 平面上的闭区域 D 上连续, 若变换&lt;span class="math inline">\(T: x=x(u, v), y=y(u, v)\)&lt;/span>将 uOv 平面上的闭区域 D’变为 xOy 平面上的 D， 且满足： （1）$x(u, v), y(u, v) $在 &lt;span class="math inline">\(D^{\prime}\)&lt;/span>上具有一阶连续偏导数 （2）在 D’上雅可比式&lt;span class="math inline">\(J(u, v)=\frac{\partial(x, y)}{\partial(u, v)} \neq 0\)&lt;/span> （3）变换 &lt;span class="math inline">\(T: D^{\prime} \rightarrow D\)&lt;/span> 是一对一的 , 则有&lt;span class="math inline">\(\iint_{D} f(x, y) \mathrm{d} x \mathrm{d} y=\iint_{D^{\prime}} f[x(u, v), y(u, v)]|J(u, v)| \mathrm{d} u \mathrm{d} v\)&lt;/span>，称为二重积分的换元公式。&lt;/p>
&lt;p>（证明见 高等数学 同济 第七版（下））&lt;/p>
&lt;p>注：雅可比行列式&lt;span class="math inline">\(J(u,v) = \left|\begin{array}{ll}x_{u}(u, v) &amp;amp; x_{v}(u, v) \\ y_{u}(u, v) &amp;amp; y_{v}(u, v)\end{array}\right|\)&lt;/span> 上面的定理中出现的是雅可比行列式的绝对值&lt;span class="math inline">\(|J(u,v)|\)&lt;/span>&lt;/p>
&lt;h3 id="二重积分改变积分次序">二重积分改变积分次序&lt;/h3>
&lt;p>二重积分选定合适的坐标系、变换为二次积分，就可以计算求解了。&lt;/p>
&lt;p>&lt;strong>如果变换积分次序，二次积分更好计算（或者不变换积分次序无法计算），可以考虑变换积分次序。&lt;/strong>&lt;/p>
&lt;p>根据积分区域及其边界，可以对二次积分变换积分次序&lt;/p>
&lt;p>不变换积分次序无法计算的情形： &lt;span class="math inline">\(x^{2 n} e^{\pm x^{2}} d x\)&lt;/span> &lt;span class="math inline">\(e^{\frac{1}{x}} d x\)&lt;/span> &lt;span class="math inline">\(\sin \frac{1}{x} d x\)&lt;/span> &lt;span class="math inline">\(\cos \frac{1}{x} d x\)&lt;/span>&lt;/p>
&lt;h2 id="三重积分的概念与性质">三重积分的概念与性质&lt;/h2>
&lt;p>定积分和二重积分作为和的极限的概念，可以很容易推广到三重积分。&lt;/p>
&lt;h3 id="三重积分的定义">三重积分的定义&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 是空间有界闭区域 &lt;span class="math inline">\(\Omega\)&lt;/span> 上的有界函数. 将 &lt;span class="math inline">\(\Omega\)&lt;/span> 任 意分成 &lt;span class="math inline">\(n\)&lt;/span> 个小比区域&lt;span class="math inline">\(\Delta v_{1}, \Delta v_{2}, \cdots, \Delta v_{n}\)&lt;/span>，其中 &lt;span class="math inline">\(\Delta v_{i}\)&lt;/span> 表示第 &lt;span class="math inline">\(i\)&lt;/span> 个小闭区域，也表示它的体积. 在每个 &lt;span class="math inline">\(\Delta v_{i}\)&lt;/span> 上任取一点&lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}, \zeta_{i}\right),\)&lt;/span> 作乘积 &lt;span class="math inline">\(f\left(\xi_{i}, \eta_{i}, \zeta_{i}\right) \Delta v_{i} \quad(i=1,2, \cdots, n),\)&lt;/span>并作和 &lt;span class="math inline">\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}, \zeta_{i}\right) \Delta v_{i}\)&lt;/span>， 如果各小闭区域直径中的最大值 &lt;span class="math inline">\(\lambda \rightarrow 0\)&lt;/span> 时,这和的极限总存在,且与闭区域$ $的分法及点 &lt;span class="math inline">\(\left(\xi_{i}, \eta_{i}, \zeta_{i}\right)\)&lt;/span> 的取法无关,那么称此极限为函数 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 在闭区域 &lt;span class="math inline">\(\Omega\)&lt;/span> 上的三重积分，记作&lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} v=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}, \zeta_{i}\right) \Delta v_{i}\)&lt;/span>&lt;/p>
&lt;p>其中 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 叫做被积函数, &lt;span class="math inline">\(\mathrm{d} v\)&lt;/span> 叫做体积元素, &lt;span class="math inline">\(\Omega\)&lt;/span> 叫做积分区域.&lt;/p>
&lt;h4 id="直角坐标系中的三重积分">直角坐标系中的三重积分&lt;/h4>
&lt;p>在直角坐标系中,如果用平行于坐标面的平面来划分 &lt;span class="math inline">\(\Omega\)&lt;/span>,那么除了包含 &lt;span class="math inline">\(\Omega\)&lt;/span> 的边界点的一些不规则小闭区域外,得到的小闭区域$ v_{i}$ 为长方体。 设长方体小闭区域 &lt;span class="math inline">\(\Delta v_{i}\)&lt;/span> 的边长为 &lt;span class="math inline">\(\Delta x_{j}, \Delta y_{k}\)&lt;/span> 与 &lt;span class="math inline">\(\Delta z_{l},\)&lt;/span> 则 &lt;span class="math inline">\(\Delta v_{i}=\Delta x_{j} \Delta y_{k} \Delta z_{l} .\)&lt;/span> 因 此 在直角坐标系中，有 时也扑体积元素 &lt;span class="math inline">\(d v\)&lt;/span> 记作 &lt;span class="math inline">\(\mathrm{d} x \mathrm{d} y \mathrm{d} z,\)&lt;/span> 而把三重积分记作&lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} x \mathrm{d} y \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;h3 id="三重积分的性质">三重积分的性质&lt;/h3>
&lt;p>三重积分的而行之与&lt;a href="#二重积分的性质">二重积分的性质&lt;/a>一致。&lt;/p>
&lt;p>这里特别注意一下三重积分奇偶性对称性。&lt;/p>
&lt;h4 id="三重积分的积分区域的对称性和被积函数的奇偶性">三重积分的积分区域的对称性和被积函数的奇偶性&lt;/h4>
&lt;p>被积区域&lt;span class="math inline">\(\Omega\)&lt;/span>关于&lt;span class="math inline">\(xOy\)&lt;/span>面对称（上下对称），设上侧区域为&lt;span class="math inline">\(\Omega_1\)&lt;/span>， &lt;span class="math inline">\(\left\{ \begin{aligned}f(x,y,-z)=-f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z) dv = 0 \\ f(x,y,-z)= f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z)dv = 2 \iint_{\Omega_1} f(x,y,z)dv \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;p>被积区域&lt;span class="math inline">\(\Omega\)&lt;/span>关于&lt;span class="math inline">\(yOz\)&lt;/span>面对称（前后对称），设前侧区域为&lt;span class="math inline">\(\Omega_1\)&lt;/span>， &lt;span class="math inline">\(\left\{ \begin{aligned}f(-x,y,z)=-f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z) dv = 0 \\ f(-x,y,z)= f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z)dv = 2 \iint_{\Omega_1} f(x,y,z)dv \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;p>被积区域&lt;span class="math inline">\(\Omega\)&lt;/span>关于&lt;span class="math inline">\(zOx\)&lt;/span>面对称（左右对称），设前侧区域为&lt;span class="math inline">\(\Omega_1\)&lt;/span>， &lt;span class="math inline">\(\left\{ \begin{aligned}f(x,-y,z)=-f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z) dv = 0 \\ f(x,-y,z)= f(x,y,z), &amp;amp;\Rightarrow \iint_\Omega f(x,y,z)dv = 2 \iint_{\Omega_1} f(x,y,z)dv \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="三重积分的中值定理">三重积分的中值定理&lt;/h4>
&lt;p>类似&lt;a href="#二重积分的积分中值定理">二重积分的中值定理&lt;/a>，容易推广到三重积分&lt;/p>
&lt;h2 id="三重积分的计算">三重积分的计算&lt;/h2>
&lt;h3 id="计算三重积分在直角坐标系化为三次积分">计算三重积分：在直角坐标系化为三次积分&lt;/h3>
&lt;p>在直角坐标系中将三重积分化为三次定积分有两种思路：投影法和截平面法&lt;/p>
&lt;h4 id="投影法计算三重积分">投影法计算三重积分&lt;/h4>
&lt;p>将空间区域&lt;span class="math inline">\(\Omega\)&lt;/span>投影到平面闭区域上，如投影到&lt;span class="math inline">\(xOy\)&lt;/span>平面（或者&lt;span class="math inline">\(yOz\)&lt;/span>平面、&lt;span class="math inline">\(xOz\)&lt;/span>平面），对应的投影平面记为&lt;span class="math inline">\(D_{xy}\)&lt;/span>。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805151907554.png" alt="" />&lt;figcaption>image-20200805151907554&lt;/figcaption>
&lt;/figure>
&lt;p>这种情况下，积分区域可表示为： &lt;span class="math inline">\(\Omega=\left\{(x, y, z) \mid z_{1}(x, y) \leqslant z \leqslant z_{2}(x, y),(x, y) \in D_{x y}\right\}\)&lt;/span>&lt;/p>
&lt;p>先将&lt;span class="math inline">\(f(x,y,z)\)&lt;/span>看作z的函数（x，y先当作常数），先计算在z轴的积分，然后计算在投影区域上的二重积分，即： &lt;span class="math inline">\(\iint_{\Omega} f(x, y, z) \mathrm{d} v=\iint_{D_{y}}\left[\int_{z_{1}(x, y)}^{z_{2}\left(x_{y}, y\right)} f(x, y, z) \mathrm{d} z\right] \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>其中二重积分也可以写成二次积分，最终化为三次积分： &lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} v=\int_{a}^{b} \mathrm{d} x \int_{y_{1}(x)}^{y_{2}(x)} \mathrm{d} y \int_{z_{1}(x, y)}^{z_{2}(x, y)} f(x, y, z) \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;h4 id="截平面法计算三重积分">截平面法计算三重积分&lt;/h4>
&lt;p>如果（以竖坐标为例）在竖坐标为z的位置，以平面将积分区域&lt;span class="math inline">\(\Omega\)&lt;/span>截开，则可以根据积分区域边界条件写出截面区域&lt;span class="math inline">\(D_z\)&lt;/span>。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805153756731.png" alt="" />&lt;figcaption>image-20200805153756731&lt;/figcaption>
&lt;/figure>
&lt;p>空间区域可以表示为： &lt;span class="math inline">\(\Omega=\left\{(x, y, z) \mid(x, y) \in D_{z}, c_{1} \leqslant z \leqslant c_{2}\right\}\)&lt;/span>&lt;/p>
&lt;p>我们可以先把z看作定值，计算在截面区域&lt;span class="math inline">\(D_z\)&lt;/span>上的二重积分，然后z轴积分，即： &lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} v=\int_{c_{1}}^{c_{2}} \mathrm{d} z \iint_{D} f(x, y, z) \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>其中二重积分也可以写成二次积分，最终化为三次积分。&lt;/p>
&lt;h3 id="计算三重积分直角坐标系转换为柱坐标系在柱坐标系化为三次积分">计算三重积分：直角坐标系转换为柱坐标系，在柱坐标系化为三次积分&lt;/h3>
&lt;h4 id="直角坐标系与柱坐标系的转换">直角坐标系与柱坐标系的转换&lt;/h4>
&lt;p>在柱坐标系中，按极向、角向、竖轴向，将积分区域&lt;span class="math inline">\(\Omega\)&lt;/span>划分为许多小闭区域除，了含$ $的边界点 的一些不规则小闭区域外, 这种小闭区域都是柱体.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805170856220.png" alt="" />&lt;figcaption>image-20200805170856220&lt;/figcaption>
&lt;/figure>
&lt;p>考虑由 &lt;span class="math inline">\(\rho, \theta\)&lt;/span> 和 &lt;span class="math inline">\(z\)&lt;/span> 各取得微小增量 $d , d$和 $dz $所成的柱体的体积。这个体积等于高与底面 积的乘积. 现在高为 dz、底面积在不计高阶无穷小时为 &lt;span class="math inline">\(\rho \mathrm{d} \rho \mathrm{d} \theta\)&lt;/span> (即极坐标系中的面积元素)，于是得柱坐标系的体积元素&lt;span class="math inline">\(\mathrm{d} v=\rho \mathrm{d} \rho \mathrm{d} \theta \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;p>点在直角坐标系和柱坐标系的坐标关系为： &lt;span class="math inline">\(\left\{\begin{array}{l}x=\rho \cos \theta \\ y=\rho \sin \theta \\ z=z\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>直角坐标系中的三重积分化为柱坐标系中的三重积分&lt;/strong>为：&lt;/p>
&lt;p>&lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} x \mathrm{d} y \mathrm{d} z=\iiint_{\Omega} F(\rho \cos \theta, \rho \sin \theta, z) \rho \mathrm{d} \rho \mathrm{d} \theta \mathrm{d} z=\iiint_{\Omega} F(\rho, \theta, z) \rho \mathrm{d} \rho \mathrm{d} \theta \mathrm{d} z\)&lt;/span>&lt;/p>
&lt;p>其中&lt;span class="math inline">\(F(\rho, \theta, z)=f(\rho \cos \theta, \rho \sin \theta, z)\)&lt;/span>&lt;/p>
&lt;h4 id="柱坐标系中投影法或截面法化为三次积分">柱坐标系中投影法或截面法化为三次积分&lt;/h4>
&lt;p>然后类比直角坐标系中的方法，用投影法或截面法（可能按柱面截取）将三重积分化为三次积分。&lt;/p>
&lt;h3 id="计算三重积分直角坐标系转换为球坐标系在球坐标系化为三次积分">计算三重积分：直角坐标系转换为球坐标系，在球坐标系化为三次积分&lt;/h3>
&lt;h4 id="直角坐标系与球坐标系的转换">直角坐标系与球坐标系的转换&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805171040072.png" alt="" />&lt;figcaption>image-20200805171040072&lt;/figcaption>
&lt;/figure>
&lt;p>点的坐标在直角坐标系和球坐标系的关系为： &lt;span class="math inline">\(\left\{\begin{array}{l}x=O P \cos \theta=r \sin \varphi \cos \theta \\ y=O P \sin \theta=r \sin \varphi \sin \theta \\ z=r \cos \varphi\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>按球坐标系径向和两个角向，将积分区域&lt;span class="math inline">\(\Omega\)&lt;/span>化为许多小闭区域，把积分区域 &lt;span class="math inline">\(\Omega\)&lt;/span> 分成许多小闭区域.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200805172425012.png" alt="" />&lt;figcaption>image-20200805172425012&lt;/figcaption>
&lt;/figure>
&lt;p>考虑由 r, $$ 和 &lt;span class="math inline">\(\theta\)&lt;/span>各取得微小增量 $dr, d$和 $d$所成的六面体的体积。 不计高阶无穷小,可把这个六面体看做长方体,其经线方向的长为 &lt;span class="math inline">\(rd\varphi\)&lt;/span>,纬线方向的宽为&lt;span class="math inline">\(r \sin\varphi d\theta\)&lt;/span>, 向径方向的高为 dr, 于是得球坐标系的体积元素&lt;span class="math inline">\(\mathrm{d} v=r^{2} \sin \varphi \mathrm{d} r \mathrm{d} \varphi \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;p>于是得到三重积分变量从直角坐标系转换到球坐标系的公式： &lt;span class="math inline">\(\iiint_{\Omega} f(x, y, z) \mathrm{d} x \mathrm{d} y \mathrm{d} z=\iiint_{\Omega} F(r, \varphi, \theta) r^{2} \sin \varphi \mathrm{d} r \mathrm{d} \varphi \mathrm{d} \theta\)&lt;/span>&lt;/p>
&lt;h4 id="球坐标系中投影法或截面法化为三次积分">球坐标系中投影法或截面法化为三次积分&lt;/h4>
&lt;p>然后类比直角坐标系中的方法，用投影法或截面法（可能按球面截取）将三重积分化为三次积分。&lt;/p>
&lt;h2 id="二重积分三重积分的计算流程">二重积分、三重积分的计算流程&lt;/h2>
&lt;p>综上，可以归纳二重积分、三重积分的计算流程： 1）作图，明确积分区域与边界。判断用哪种坐标比较简单 2）注意奇偶性，对称性 3）在对应的坐标系中，化为多次积分&lt;/p>
&lt;h2 id="重积分的应用">重积分的应用&lt;/h2>
&lt;p>主要是定积分中元素法的推广。&lt;/p>
&lt;p>应用过程中，如果变换坐标系，可以使积分区域的表达式更简单，被积函数更简单，可以考虑变换坐标系。&lt;/p>
&lt;h3 id="几何应用">几何应用&lt;/h3>
&lt;table>
&lt;colgroup>
&lt;col style="width: 32%" />
&lt;col style="width: 7%" />
&lt;col style="width: 59%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;a href="#曲顶柱体的体积">曲顶柱体的体积&lt;/a>&lt;/th>
&lt;th>二重积分&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;a href="#曲面面积的计算">曲面面积的计算&lt;/a>&lt;/td>
&lt;td>二重积分&lt;/td>
&lt;td>投影的到&lt;span class="math inline">\(xOy\)&lt;/span>面计算：（也可投影到其他面）&lt;br />&lt;span class="math inline">\(A=\iint_{D} \sqrt{1+f_{x}^{2}(x, y)+f_{y}^{2}(x, y)} \mathrm{d} \sigma = \iint_{D} \sqrt{1+\left(\frac{\partial z}{\partial x}\right)^{2}+\left(\frac{\partial z}{\partial y}\right)^{2}} \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="曲面面积的计算">曲面面积的计算&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200806101455954.png" alt="" />&lt;figcaption>image-20200806101455954&lt;/figcaption>
&lt;/figure>
&lt;p>设区域D是被积曲面在&lt;span class="math inline">\(xOy\)&lt;/span>面的投影。将投影区域D划分成许多小闭区域&lt;span class="math inline">\(d \sigma\)&lt;/span>，每个小闭区域对应曲面上的一小块，而这一小块的面积近似于从小块上找个切平面对应的面积&lt;span class="math inline">\(dA\)&lt;/span>。&lt;/p>
&lt;p>根据几何，有如下关系： &lt;span class="math inline">\(\mathrm{d} A=\frac{\mathrm{d} \sigma}{\cos \gamma}\)&lt;/span> 又有： &lt;span class="math inline">\(\cos \gamma=\frac{1}{\sqrt{1+f_{x}^{2}(x, y)+f_{y}^{2}(x, y)}}\)&lt;/span>&lt;/p>
&lt;p>由此可以得到曲面的面积元素： &lt;span class="math inline">\(\mathrm{d} A=\sqrt{1+f_{x}^{2}(x, y)+f_{y}^{2}(x, y)} \mathrm{d} \sigma\)&lt;/span>&lt;/p>
&lt;p>从而曲面的面积为：（曲面投影到&lt;span class="math inline">\(xOy\)&lt;/span>面作为积分区域计算） &lt;span class="math inline">\(A=\iint_{D} \sqrt{1+f_{x}^{2}(x, y)+f_{y}^{2}(x, y)} \mathrm{d} \sigma = \iint_{D} \sqrt{1+\left(\frac{\partial z}{\partial x}\right)^{2}+\left(\frac{\partial z}{\partial y}\right)^{2}} \mathrm{d} x \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>类似的，也可以投影到&lt;span class="math inline">\(yOz\)&lt;/span>平面计算曲面面积： &lt;span class="math inline">\(A=\iint_{D_{y z}} \sqrt{1+\left(\frac{\partial x}{\partial y}\right)^{2}+\left(\frac{\partial x}{\partial z}\right)^{2}} \mathrm{d} y \mathrm{d} z\)&lt;/span> 同样，也可以投影到&lt;span class="math inline">\(xOz\)&lt;/span>平面计算曲面面积： &lt;span class="math inline">\(A=\iint_{D_{\mathrm{ax}}} \sqrt{1+\left(\frac{\partial y}{\partial z}\right)^{2}+\left(\frac{\partial y}{\partial x}\right)^{2}} \mathrm{d} z \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h3 id="物理应用">物理应用&lt;/h3>
&lt;table>
&lt;colgroup>
&lt;col style="width: 32%" />
&lt;col style="width: 7%" />
&lt;col style="width: 59%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;a href="#平面薄片的质量">平面薄片的质量&lt;/a>&lt;/th>
&lt;th>二重积分&lt;/th>
&lt;th>&lt;span class="math inline">\(\iint_{D} \mu(x, y) \mathrm{d} \sigma=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} \mu\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)&lt;/span>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>空间物体的质量&lt;/td>
&lt;td>三重积分&lt;/td>
&lt;td>&lt;span class="math inline">\(\iint_{\Omega} f(x, y, z) \mathrm{d} v\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>平面薄片的质心&lt;/td>
&lt;td>二重积分&lt;/td>
&lt;td>&lt;span class="math inline">\(\bar{x}=\frac{M_{,}}{M}=\frac{\iint_{D} x \mu(x, y) \mathrm{d} \sigma}{\iint_{D} \mu(x, y) \mathrm{d} \sigma}, \quad y=\frac{M_{x}}{M}=\frac{\iint_{D} y \mu(x, y) \mathrm{d} \sigma}{\iint_{D} \mu(x, y) \mathrm{d} \sigma}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>空间物体的质心&lt;/td>
&lt;td>三重积分&lt;/td>
&lt;td>&lt;span class="math inline">\(\bar{x}=\frac{\iint_{\Omega} x \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}, \quad \bar{y}=\frac{\iint_{\Omega} y \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}, \quad \bar{z}=\frac{\iint_{\Omega} y \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>平面薄片的转动惯量&lt;/td>
&lt;td>二重积分&lt;/td>
&lt;td>在&lt;span class="math inline">\(xOy\)&lt;/span>面上的一个平面薄板，&lt;br/>对x轴，对y轴的转动惯量为&lt;span class="math inline">\(I_{x}=\sum_{i=1}^{n} y_{i}^{2} m_{i}, \quad I_{y}=\sum_{i=1}^{n} x_{i}^{2} m_{i}\)&lt;/span>，&lt;br/>对z轴的转动惯量为&lt;span class="math inline">\(I_z=\sum_{i=1}^{n} (x_{i}^{2} + y_{i}^{2}) m_{i} = I_x + I_y\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>空间物体的转动惯量&lt;/td>
&lt;td>三重积分&lt;/td>
&lt;td>空间物体的转动惯量（以z轴为转轴）：&lt;br/>&lt;span class="math inline">\(I_{z}=\iiint_{\Omega}r_{i}^{2} m_i \mathrm{d} m=\iiint_{\Omega}\left(x^{2}+y^{2}\right) \mu(x,y,z) \mathrm{d} v\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>空间物体对质点的引力&lt;/td>
&lt;td>三重积分&lt;/td>
&lt;td>考虑一个体积为&lt;span class="math inline">\(\Omega\)&lt;/span>的物体，对&lt;span class="math inline">\((x_0,y_0,z_0)\)&lt;/span>处单位质点的引力为：&lt;span class="math inline">\(\boldsymbol{F} =\left(\boldsymbol{F}_{x}, \boldsymbol{F}_{y}, \boldsymbol{F}_{z}\right) \\ =\left(\iiint_{\Omega} \frac{\boldsymbol{G} \boldsymbol{\rho}(x, y, z)\left(x-x_{0}\right)}{r^{3}} \mathrm{d} v, \iint_{\Omega} \frac{G \boldsymbol{\rho}(x, y, z)\left(y-y_{0}\right)}{r^{3}} \mathrm{d} v,\iiint_{\Omega} \frac{G \rho(x, y, z)\left(z-z_{0}\right)}{r^{3}} \mathrm{d} v\right)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="质心">质心&lt;/h4>
&lt;p>由力学知道，质点系的质心坐标为：&lt;/p>
&lt;p>&lt;span class="math inline">\(\bar{x}=\frac{M_{y}}{M}=\frac{\sum_{i=1} m_{i} x_{i}}{\sum_{i=1}^{n} m_{i}}, \quad \bar{y}=\frac{M_{x}}{M}=\frac{\sum_{i=1} m_{i} y_{i}}{\sum_{i=1}^{n} m_{i}}\)&lt;/span>&lt;/p>
&lt;p>由质心的定义，我们可以计算如下：&lt;/p>
&lt;p>平面薄片的质心： &lt;span class="math inline">\(\bar{x}=\frac{M_{,}}{M}=\frac{\iint_{D} x \mu(x, y) \mathrm{d} \sigma}{\iint_{D} \mu(x, y) \mathrm{d} \sigma}, \quad \bar{y}=\frac{M_{x}}{M}=\frac{\iint_{D} y \mu(x, y) \mathrm{d} \sigma}{\iint_{D} \mu(x, y) \mathrm{d} \sigma}\)&lt;/span>&lt;/p>
&lt;p>空间物体的质心： &lt;span class="math inline">\(\bar{x}=\frac{\iint_{\Omega} x \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}, \quad \bar{y}=\frac{\iint_{\Omega} y \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}, \quad \bar{z}=\frac{\iint_{\Omega} z \mu(x, y, z) \mathrm{d} v}{\iint_{\Omega} \mu(x, y, z) \mathrm{d} v}\)&lt;/span>&lt;/p>
&lt;h4 id="转动惯量">转动惯量&lt;/h4>
&lt;p>由力学知道，质点系对于某轴的转动惯量为&lt;span class="math inline">\(I=\sum_{i=1}^{n} r_{i}^{2} m_{i}\)&lt;/span>，其中&lt;span class="math inline">\(r_i\)&lt;/span>是各质点到此轴的距离。&lt;/p>
&lt;p>平面薄板的转动惯量： 在&lt;span class="math inline">\(xOy\)&lt;/span>面上的一个平面薄板， 对x轴，对y轴的转动惯量为&lt;span class="math inline">\(I_{x}=\sum_{i=1}^{n} y_{i}^{2} m_{i}, \quad I_{y}=\sum_{i=1}^{n} x_{i}^{2} m_{i}\)&lt;/span>， 对z轴的转动惯量为&lt;span class="math inline">\(I_z=\sum_{i=1}^{n} (x_{i}^{2} + y_{i}^{2}) m_{i} = I_x + I_y\)&lt;/span>&lt;/p>
&lt;p>空间物体的转动惯量（以z轴为转轴）： &lt;span class="math inline">\(I_{z}=\iiint_{\Omega}r_{i}^{2} m_i \mathrm{d} m=\iiint_{\Omega}\left(x^{2}+y^{2}\right) \mu(x,y,z) \mathrm{d} v\)&lt;/span>&lt;/p>
&lt;h4 id="引力">引力&lt;/h4>
&lt;p>两质点间引力大小为&lt;span class="math inline">\(F= \frac{G m_1 m_2}{r^2}\)&lt;/span> ， 包括方向的矢量式为&lt;span class="math inline">\(\overrightarrow{F}= \frac{G m_1 m_2 \overrightarrow{r}}{r^3}=\frac{G m_1 m_2 \overrightarrow{e_r}}{r^2}=\frac{G m_1 m_2 }{r^2} \cdot (\cos \alpha, \cos \beta, \cos \gamma)=(F_x, F_y, F_z)\)&lt;/span>&lt;/p>
&lt;p>考虑一个体积为&lt;span class="math inline">\(\Omega\)&lt;/span>的物体，对&lt;span class="math inline">\((x_0,y_0,z_0)\)&lt;/span>处单位质点的引力为：&lt;span class="math inline">\(\begin{aligned} \boldsymbol{F} &amp;amp;=\left(\boldsymbol{F}_{x}, \boldsymbol{F}_{y}, \boldsymbol{F}_{z}\right) \\ &amp;amp;=\left(\iiint_{\Omega} \frac{\boldsymbol{G} \boldsymbol{\rho}(x, y, z)\left(x-x_{0}\right)}{r^{3}} \mathrm{d} v, \iint_{\Omega} \frac{G \boldsymbol{\rho}(x, y, z)\left(y-y_{0}\right)}{r^{3}} \mathrm{d} v,\iiint_{\Omega} \frac{G \rho(x, y, z)\left(z-z_{0}\right)}{r^{3}} \mathrm{d} v\right)\end{aligned}\)&lt;/span>&lt;/p>
&lt;h2 id="含参变量的积分">含参变量的积分&lt;/h2>
&lt;h3 id="含参变量积分的定义">含参变量积分的定义&lt;/h3>
&lt;p>设 &lt;span class="math inline">\(f(x, y) \text { 是矩形 ( 闭区域 }) R=[a, b] \times[c, d]\)&lt;/span> 血上的连续函数。（这是一个矩形区间，又称直区间）&lt;/p>
&lt;p>&lt;span class="math inline">\(\varphi(x)=\int_{c}^{d} f(x, y) \mathrm{d} y \quad(a \leqslant x \leqslant b)\)&lt;/span>&lt;/p>
&lt;p>这个积分的值依赖于取定的 x 值. 当 x 的值改变时,一般说来这个积分的值也跟着改变. &lt;strong>这个积分确定一个定义在[ a,b]上的 x 的函数&lt;/strong>,x在计算积分的过程中当作常数，通常称作&lt;strong>参变量&lt;/strong>，&lt;span class="math inline">\(\varphi (x)\)&lt;/span>称作&lt;strong>含参变量的积分&lt;/strong>。&lt;/p>
&lt;h3 id="含参变量积分的性质">含参变量积分的性质&lt;/h3>
&lt;p>&lt;strong>定理 1&lt;/strong> （&lt;strong>含参变量积分函数的连续性1&lt;/strong>） 如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在矩形 &lt;span class="math inline">\(R=[a, b] \times[c, d]\)&lt;/span> 上连续, 那么由积分&lt;span class="math inline">\(\int_{c}^{d} f(x, y) \mathrm{d} y\)&lt;/span>确定的函数 &lt;span class="math inline">\(\varphi(x)\)&lt;/span> 在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上也连续.&lt;/p>
&lt;p>(用闭区间连续必一致连续，用以计算&lt;span class="math inline">\(\Delta \varphi\)&lt;/span>也趋于0，即连续。详细证明见 高等数学 同济第七版（下）)&lt;/p>
&lt;p>&lt;strong>定理 2&lt;/strong> （&lt;strong>连续函数在直区间的积分次序可交换性&lt;/strong>） 如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在矩形 &lt;span class="math inline">\(R=[a, b] \times[c, d]\)&lt;/span> 上连续, 那么&lt;span class="math inline">\(\int_{a}^{b}\left[\int_{c}^{d} f(x, y) \mathrm{d} y\right] \mathrm{d} x=\int_{c}^{d}\left[\int_{a}^{b} f(x, y) \mathrm{d} x\right] \mathrm{d} y\)&lt;/span> 也可写成&lt;span class="math inline">\(\int_{a}^{b} \mathrm{d} x \int_{c}^{d} f(x, y) \mathrm{d} y=\int_{c}^{d} \mathrm{d} y \int_{a}^{b} f(x, y) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>（即函数在直区间连续，则积分次序可交换，这是重积分的性质）&lt;/p>
&lt;p>&lt;strong>定理 3&lt;/strong> （&lt;strong>含参变量函数的可微性1&lt;/strong>） 如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 及其偏导数 &lt;span class="math inline">\(f_{x}(x, y)\)&lt;/span> 都在矩形 &lt;span class="math inline">\(R=[a, b] \times[c, d]\)&lt;/span> 上连续, 那么由积分&lt;span class="math inline">\(\int_{c}^{d} f(x, y) \mathrm{d} y\)&lt;/span>确定的函数 &lt;span class="math inline">\(\varphi(x) \text { 在[ } a, b]\)&lt;/span> 上可微分, 并且&lt;span class="math inline">\(\varphi^{\prime}(x)=\frac{\mathrm{d}}{\mathrm{d} x} \int_{c}^{d} f(x, y) \mathrm{d} y=\int_{c}^{d} f_{x}(x, y) \mathrm{d} y\)&lt;/span>&lt;/p>
&lt;p>(用导数的定义、一致连续性、拉格朗日中值定理证明。详细证明见 高等数学 同济第七版（下）)&lt;/p>
&lt;p>&lt;strong>定理 4&lt;/strong> （&lt;strong>含参变量积分函数的连续性2&lt;/strong>） 如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在矩形 &lt;span class="math inline">\(R=[a, b] \times[c, d]\)&lt;/span> 上连续, 函数 &lt;span class="math inline">\(\alpha(x)\)&lt;/span> 与 &lt;span class="math inline">\(\beta(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上连续 &lt;span class="math inline">\(,\)&lt;/span> 且&lt;span class="math inline">\(c \leqslant \alpha(x) \leqslant d, c \leqslant \beta(x) \leqslant d \quad(a \leqslant x \leqslant b)\)&lt;/span>, 那么由&lt;span class="math inline">\(\Phi(x)=\int_{\alpha(x)}^{\beta(x)} f(x, y) \mathrm{d} y\)&lt;/span>确定的函数&lt;span class="math inline">\(\Phi(x)\)&lt;/span>也连续。&lt;/p>
&lt;p>（拆项用定义证，详细证明见 高等数学 同济第七版（下）)&lt;/p>
&lt;p>&lt;strong>定理 5&lt;/strong> （&lt;strong>含参变量函数的可微性2&lt;/strong>） 如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 及其偏导数 &lt;span class="math inline">\(f_{x}(x, y)\)&lt;/span> 都在矩形 &lt;span class="math inline">\(R=[a, b] \times[c, d]\)&lt;/span>上连续, 函数 &lt;span class="math inline">\(\alpha(x)\)&lt;/span> 与 &lt;span class="math inline">\(\beta(x)\)&lt;/span> 都在区间 &lt;span class="math inline">\([a, b]\)&lt;/span> 上可微, 且&lt;span class="math inline">\(c \leqslant \alpha(x) \leqslant d, c \leqslant \beta(x) \leqslant d \quad(a \leqslant x \leqslant b)\)&lt;/span>, 那么由&lt;span class="math inline">\(\Phi(x)=\int_{\alpha(x)}^{\beta(x)} f(x, y) \mathrm{d} y\)&lt;/span>确定的函数&lt;span class="math inline">\(\Phi(x)\)&lt;/span>也在 &lt;span class="math inline">\([a, b]\)&lt;/span> 上可微 &lt;span class="math inline">\(,\)&lt;/span> 且函数的微分为：（莱布尼兹公式） &lt;span class="math inline">\(\begin{aligned} \Phi^{\prime}(x) &amp;amp;=\frac{\mathrm{d}}{\mathrm{d} x} \int_{\alpha(x)}^{\beta(x)} f(x, y) \mathrm{d} y \\ &amp;amp;=\int_{\alpha(x)}^{\beta(x)} f_{x}(x, y) \mathrm{d} y+f[x, \beta(x)] \beta^{\prime}(x)-f[x, \alpha(x)] \alpha^{\prime}(x) \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>（拆项用定义证，详细证明见 高等数学 同济第七版（下）)&lt;/p></description></item><item><title>高等数学-多元微分学习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 08 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微分学习题">高等数学-多元微分学习题&lt;/h1>
&lt;h3 id="考察多元函数定义极限存在连续性可微可偏导泰勒定理">考察多元函数定义、极限存在、连续性、可微、可偏导、泰勒定理&lt;/h3>
&lt;h5 id="多元函数的定义">多元函数的定义&lt;/h5>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702122423759.png" alt="" />&lt;figcaption>image-20200702122423759&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702122611230.png" alt="" />&lt;figcaption>image-20200702122611230&lt;/figcaption>
&lt;/figure>
&lt;h5 id="偏导数的定义">偏导数的定义&lt;/h5>
&lt;p>偏导数是把多元函数其中一元看作变量，其他元看作常数后，求函数的变化率（求导）&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709144415604.png" alt="" />&lt;figcaption>image-20200709144415604&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709144432350.png" alt="" />&lt;figcaption>image-20200709144432350&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710163615194.png" alt="" />&lt;figcaption>image-20200710163615194&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710163631402.png" alt="" />&lt;figcaption>image-20200710163631402&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710231400530.png" alt="" />&lt;figcaption>image-20200710231400530&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710231418304.png" alt="" />&lt;figcaption>image-20200710231418304&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710231429789.png" alt="" />&lt;figcaption>image-20200710231429789&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711000314135.png" alt="" />&lt;figcaption>image-20200711000314135&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711000327726.png" alt="" />&lt;figcaption>image-20200711000327726&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711000344744.png" alt="" />&lt;figcaption>image-20200711000344744&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713145337218.png" alt="" />&lt;figcaption>image-20200713145337218&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713145652539.png" alt="" />&lt;figcaption>image-20200713145652539&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713145725465.png" alt="" />&lt;figcaption>image-20200713145725465&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713162205205.png" alt="" />&lt;figcaption>image-20200713162205205&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713162250977.png" alt="" />&lt;figcaption>image-20200713162250977&lt;/figcaption>
&lt;/figure>
&lt;h5 id="极值的定义">极值的定义&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710232139022.png" alt="" />&lt;figcaption>image-20200710232139022&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710232158542.png" alt="" />&lt;figcaption>image-20200710232158542&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713175333243.png" alt="" />&lt;figcaption>image-20200713175333243&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713180142424.png" alt="" />&lt;figcaption>image-20200713180142424&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713180435932.png" alt="" />&lt;figcaption>image-20200713180435932&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714171451504.png" alt="" />&lt;figcaption>image-20200714171451504&lt;/figcaption>
&lt;/figure>
&lt;h5 id="连续不一定可偏导可偏导不一定连续">连续不一定可偏导，可偏导不一定连续&lt;/h5>
&lt;h6 id="例1-连续不一定可偏导可偏导不一定连续">例1 连续不一定可偏导，可偏导不一定连续&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711093916297.png" alt="" />&lt;figcaption>image-20200711093916297&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711093943298.png" alt="" />&lt;figcaption>image-20200711093943298&lt;/figcaption>
&lt;/figure>
&lt;h5 id="可微必连续">可微必连续&lt;/h5>
&lt;h6 id="例1-证明可微必连续">例1 证明可微必连续&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701161537267.png" alt="image-20200701161537267" style="zoom:67%;" />&lt;/p>
&lt;h5 id="可微必可导">可微必可导&lt;/h5>
&lt;h6 id="例1-证明可微必可偏导">例1 证明可微必可偏导&lt;/h6>
&lt;p>求证：如果函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\((x, y)\)&lt;/span> &lt;strong>可微分&lt;/strong>,那么该函数在点&lt;span class="math inline">\((x, y)\)&lt;/span> 的&lt;strong>偏导数 &lt;span class="math inline">\(\frac{\partial z}{\partial x}\)&lt;/span> 与 &lt;span class="math inline">\(\frac{\partial z}{\partial y}\)&lt;/span> 必定存在&lt;/strong> &lt;span class="math inline">\(,\)&lt;/span> 且函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\((x, y)\)&lt;/span> 的全微分为&lt;span class="math inline">\(\mathrm{d} z=\frac{\partial z}{\partial x} \Delta x+\frac{\partial z}{\partial y} \Delta y\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701153847161.png" alt="" />&lt;figcaption>image-20200701153847161&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-可微必可偏导">例2 可微必可偏导&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711002100508.png" alt="" />&lt;figcaption>image-20200711002100508&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711002115138.png" alt="" />&lt;figcaption>image-20200711002115138&lt;/figcaption>
&lt;/figure>
&lt;h5 id="连续可偏导必可微">连续可偏导必可微&lt;/h5>
&lt;h6 id="例1-证明连续可偏导必可微">例1 证明连续可偏导必可微&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701160132385.png" alt="" />&lt;figcaption>image-20200701160132385&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701160157106.png" alt="" />&lt;figcaption>image-20200701160157106&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713122053068.png" alt="" />&lt;figcaption>image-20200713122053068&lt;/figcaption>
&lt;/figure>
&lt;h5 id="连续性可偏导可微的判断">连续性、可偏导、可微的判断&lt;/h5>
&lt;p>连续性判断： 用连续定义判断：求该点处的极限，若极限值=对应点值，则连续。否则存在某路径极限值&lt;span class="math inline">\(\neq\)&lt;/span>对应点值，在该点不连续。&lt;/p>
&lt;p>可偏导性的判断： 用偏导数的定义判断/求偏导数&lt;/p>
&lt;p>可微的判断： 1）可微的定义判断 2）函数连续可偏导必可微 3）可微必可偏导、可微必连续的逆否命题：不可偏导一定不可微、不连续一定不可微&lt;/p>
&lt;h6 id="例1-函数连续性可偏导性可微的判断">例1 函数连续性、可偏导性、可微的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711094459424.png" alt="" />&lt;figcaption>image-20200711094459424&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711094523571.png" alt="" />&lt;figcaption>image-20200711094523571&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-函数连续性可偏导性可微性的判断">例2 函数连续性、可偏导性、可微性的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711094918489.png" alt="" />&lt;figcaption>image-20200711094918489&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711094933694.png" alt="" />&lt;figcaption>image-20200711094933694&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711094948922.png" alt="" />&lt;figcaption>image-20200711094948922&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-函数连续性的判断">例3 函数连续性的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200712233234132.png" alt="" />&lt;figcaption>image-20200712233234132&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-函数连续性可偏导性的判断">例4 函数连续性、可偏导性的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200712234029517.png" alt="" />&lt;figcaption>image-20200712234029517&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200712234115590.png" alt="" />&lt;figcaption>image-20200712234115590&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-函数连续性可偏导性可微性的判断">例5 函数连续性、可偏导性、可微性的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713121706344.png" alt="" />&lt;figcaption>image-20200713121706344&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713112654421.png" alt="" />&lt;figcaption>image-20200713112654421&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-可微的判断">例6 可微的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2020-7-13-001.png" alt="" />&lt;figcaption>2020-7-13-001&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-可微的判断">例7 可微的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2020-7-13-002.png" alt="" />&lt;figcaption>2020-7-13-002&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-可微的判断">例8 可微的判断&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713143156817.png" alt="" />&lt;figcaption>image-20200713143156817&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713143240883.png" alt="" />&lt;figcaption>image-20200713143240883&lt;/figcaption>
&lt;/figure>
&lt;h4 id="二元函数泰勒定理">二元函数泰勒定理&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714173833094.png" alt="" />&lt;figcaption>image-20200714173833094&lt;/figcaption>
&lt;/figure>
&lt;h3 id="极限的证明与计算">极限的证明与计算&lt;/h3>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200627234136112.png" alt="" />&lt;figcaption>image-20200627234136112&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200627234814941.png" alt="" />&lt;figcaption>image-20200627234814941&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115331124.png" alt="" />&lt;figcaption>image-20200709115331124&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115355220.png" alt="" />&lt;figcaption>image-20200709115355220&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710153926439.png" alt="" />&lt;figcaption>image-20200710153926439&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710154008168.png" alt="" />&lt;figcaption>image-20200710154008168&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/2020-7-12-001.png" alt="" />&lt;figcaption>2020-7-12-001&lt;/figcaption>
&lt;/figure>
&lt;h3 id="偏导数的计算">偏导数的计算&lt;/h3>
&lt;h5 id="普通多元函数偏导数的计算">普通多元函数偏导数的计算&lt;/h5>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630193622716.png" alt="" />&lt;figcaption>image-20200630193622716&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630193722483.png" alt="" />&lt;figcaption>image-20200630193722483&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630194820210.png" alt="" />&lt;figcaption>image-20200630194820210&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710154605029.png" alt="" />&lt;figcaption>image-20200710154605029&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710154631336.png" alt="" />&lt;figcaption>image-20200710154631336&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710163046837.png" alt="" />&lt;figcaption>image-20200710163046837&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710163102165.png" alt="" />&lt;figcaption>image-20200710163102165&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710170255824.png" alt="" />&lt;figcaption>image-20200710170255824&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710170316137.png" alt="" />&lt;figcaption>image-20200710170316137&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711100253125.png" alt="" />&lt;figcaption>image-20200711100253125&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711100317734.png" alt="" />&lt;figcaption>image-20200711100317734&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200712233907028.png" alt="" />&lt;figcaption>image-20200712233907028&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713144242620.png" alt="" />&lt;figcaption>image-20200713144242620&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713144708235.png" alt="" />&lt;figcaption>image-20200713144708235&lt;/figcaption>
&lt;/figure>
&lt;h5 id="多元复合函数偏导数的计算">多元复合函数偏导数的计算&lt;/h5>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701200713256.png" alt="" />&lt;figcaption>image-20200701200713256&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701201025937.png" alt="" />&lt;figcaption>image-20200701201025937&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701201356400.png" alt="" />&lt;figcaption>image-20200701201356400&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630195731232.png" alt="" />&lt;figcaption>image-20200630195731232&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630195748789.png" alt="" />&lt;figcaption>image-20200630195748789&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630200109237.png" alt="" />&lt;figcaption>image-20200630200109237&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630210624138.png" alt="" />&lt;figcaption>image-20200630210624138&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630210717628.png" alt="" />&lt;figcaption>image-20200630210717628&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630211047597.png" alt="" />&lt;figcaption>image-20200630211047597&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200630211557621.png" alt="" />&lt;figcaption>image-20200630211557621&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="C:\Users\wangjm\AppData\Roaming\Typora\typora-user-images\image-20200709115723584.png" alt="" />&lt;figcaption>image-20200709115723584&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115812472.png" alt="" />&lt;figcaption>image-20200709115812472&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115841168.png" alt="" />&lt;figcaption>image-20200709115841168&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115857916.png" alt="" />&lt;figcaption>image-20200709115857916&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709115925231.png" alt="" />&lt;figcaption>image-20200709115925231&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709120026906.png" alt="" />&lt;figcaption>image-20200709120026906&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709120054695.png" alt="" />&lt;figcaption>image-20200709120054695&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709120109524.png" alt="" />&lt;figcaption>image-20200709120109524&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709120119794.png" alt="" />&lt;figcaption>image-20200709120119794&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709142509529.png" alt="" />&lt;figcaption>image-20200709142509529&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709142521539.png" alt="" />&lt;figcaption>image-20200709142521539&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709143454804.png" alt="" />&lt;figcaption>image-20200709143454804&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709143509307.png" alt="" />&lt;figcaption>image-20200709143509307&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709154525460.png" alt="" />&lt;figcaption>image-20200709154525460&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709154545305.png" alt="" />&lt;figcaption>image-20200709154545305&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709155415509.png" alt="" />&lt;figcaption>image-20200709155415509&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709155447245.png" alt="" />&lt;figcaption>image-20200709155447245&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709160119364.png" alt="" />&lt;figcaption>image-20200709160119364&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709160139480.png" alt="" />&lt;figcaption>image-20200709160139480&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18">例18&lt;/h6>
&lt;p>注意一下这里偏导数代入的是不同的值&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709173236549.png" alt="" />&lt;figcaption>image-20200709173236549&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709173254867.png" alt="" />&lt;figcaption>image-20200709173254867&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例19">例19&lt;/h6>
&lt;p>与变限积分函数复合，求偏导&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709174135042.png" alt="" />&lt;figcaption>image-20200709174135042&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709174240062.png" alt="" />&lt;figcaption>image-20200709174240062&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例20">例20&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709234842860.png" alt="" />&lt;figcaption>image-20200709234842860&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709234859286.png" alt="" />&lt;figcaption>image-20200709234859286&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709234911899.png" alt="" />&lt;figcaption>image-20200709234911899&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例21">例21&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710164338334.png" alt="" />&lt;figcaption>image-20200710164338334&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710164317757.png" alt="" />&lt;figcaption>image-20200710164317757&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例22">例22&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711000042513.png" alt="" />&lt;figcaption>image-20200711000042513&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711000059017.png" alt="" />&lt;figcaption>image-20200711000059017&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例23">例23&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711021616926.png" alt="" />&lt;figcaption>image-20200711021616926&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711021632092.png" alt="" />&lt;figcaption>image-20200711021632092&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例24">例24&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711095417822.png" alt="" />&lt;figcaption>image-20200711095417822&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711095435151.png" alt="" />&lt;figcaption>image-20200711095435151&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例25">例25&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711100817437.png" alt="" />&lt;figcaption>image-20200711100817437&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711100836952.png" alt="" />&lt;figcaption>image-20200711100836952&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例26">例26&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711101447402.png" alt="" />&lt;figcaption>image-20200711101447402&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711101524524.png" alt="" />&lt;figcaption>image-20200711101524524&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例27">例27&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711142518827.png" alt="" />&lt;figcaption>image-20200711142518827&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711142540183.png" alt="" />&lt;figcaption>image-20200711142540183&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例28">例28&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711145058043.png" alt="" />&lt;figcaption>image-20200711145058043&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711145114756.png" alt="" />&lt;figcaption>image-20200711145114756&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例29-换元换坐标系">例29 换元/换坐标系&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711174231552.png" alt="" />&lt;figcaption>image-20200711174231552&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711174416018.png" alt="" />&lt;figcaption>image-20200711174416018&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例30-换元换坐标系">例30 换元/换坐标系&lt;/h6>
&lt;p>&lt;strong>拉普拉斯算子&lt;/strong>在直角坐标系与柱坐标系中的转换&lt;/p>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90">拉普拉斯算子的百度百科&lt;/a>&lt;/p>
&lt;p>高数同济第七版P82的证明：&lt;/p>
&lt;p>&lt;img src="C:\Users\wangjm\AppData\Roaming\Typora\typora-user-images\image-20200704084022493.png" alt="image-20200704084022493" style="zoom: 67%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200704084151382.png" alt="image-20200704084151382" style="zoom:67%;" />&lt;/p>
&lt;p>还有csdn上博主的证明（与高数同济7的证明类似）：https://blog.csdn.net/u013102281/article/details/70800631&lt;/p>
&lt;h6 id="例31">例31&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713145045588.png" alt="" />&lt;figcaption>image-20200713145045588&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713145111578.png" alt="" />&lt;figcaption>image-20200713145111578&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例32-换元求偏导">例32 换元求偏导&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713151645364.png" alt="" />&lt;figcaption>image-20200713151645364&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例33">例33&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713151858650.png" alt="" />&lt;figcaption>image-20200713151858650&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713151924146.png" alt="" />&lt;figcaption>image-20200713151924146&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例34">例34&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713154407255.png" alt="" />&lt;figcaption>image-20200713154407255&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例35">例35&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713154521245.png" alt="" />&lt;figcaption>image-20200713154521245&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例36">例36&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713154634020.png" alt="" />&lt;figcaption>image-20200713154634020&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例37">例37&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713154828736.png" alt="" />&lt;figcaption>image-20200713154828736&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例38">例38&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155004931.png" alt="" />&lt;figcaption>image-20200713155004931&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155029885.png" alt="" />&lt;figcaption>image-20200713155029885&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例39">例39&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155411573.png" alt="" />&lt;figcaption>image-20200713155411573&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155430337.png" alt="" />&lt;figcaption>image-20200713155430337&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155500516.png" alt="" />&lt;figcaption>image-20200713155500516&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例40">例40&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713155710640.png" alt="" />&lt;figcaption>image-20200713155710640&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例41">例41&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164313638.png" alt="" />&lt;figcaption>image-20200713164313638&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164329698.png" alt="" />&lt;figcaption>image-20200713164329698&lt;/figcaption>
&lt;/figure>
&lt;h5 id="多元隐函数及方程组的偏导数的计算">多元隐函数及方程组的偏导数的计算&lt;/h5>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212558284.png" alt="" />&lt;figcaption>image-20200701212558284&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212659511.png" alt="" />&lt;figcaption>image-20200701212659511&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212735480.png" alt="" />&lt;figcaption>image-20200701212735480&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212826072.png" alt="" />&lt;figcaption>image-20200701212826072&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212911399.png" alt="" />&lt;figcaption>image-20200701212911399&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709174823501.png" alt="" />&lt;figcaption>image-20200709174823501&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709174847696.png" alt="" />&lt;figcaption>image-20200709174847696&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710152612800.png" alt="" />&lt;figcaption>image-20200710152612800&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710152657856.png" alt="" />&lt;figcaption>image-20200710152657856&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710152709808.png" alt="" />&lt;figcaption>image-20200710152709808&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710153357691.png" alt="" />&lt;figcaption>image-20200710153357691&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710153415151.png" alt="" />&lt;figcaption>image-20200710153415151&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710165737474.png" alt="" />&lt;figcaption>image-20200710165737474&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710165753162.png" alt="" />&lt;figcaption>image-20200710165753162&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710224305058.png" alt="" />&lt;figcaption>image-20200710224305058&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710224325962.png" alt="" />&lt;figcaption>image-20200710224325962&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711144441151.png" alt="" />&lt;figcaption>image-20200711144441151&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711144456888.png" alt="" />&lt;figcaption>image-20200711144456888&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711144509027.png" alt="" />&lt;figcaption>image-20200711144509027&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711153505138.png" alt="" />&lt;figcaption>image-20200711153505138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711153526825.png" alt="" />&lt;figcaption>image-20200711153526825&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711161144323.png" alt="" />&lt;figcaption>image-20200711161144323&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711161210227.png" alt="" />&lt;figcaption>image-20200711161210227&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-1">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711163849897.png" alt="" />&lt;figcaption>image-20200711163849897&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711163919111.png" alt="" />&lt;figcaption>image-20200711163919111&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-1">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711165501946.png" alt="" />&lt;figcaption>image-20200711165501946&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711165515724.png" alt="" />&lt;figcaption>image-20200711165515724&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-1">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164500200.png" alt="" />&lt;figcaption>image-20200713164500200&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15-1">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164614010.png" alt="" />&lt;figcaption>image-20200713164614010&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16-1">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713170815177.png" alt="" />&lt;figcaption>image-20200713170815177&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17-1">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713171146400.png" alt="" />&lt;figcaption>image-20200713171146400&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713171208604.png" alt="" />&lt;figcaption>image-20200713171208604&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18-1">例18&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713172355080.png" alt="" />&lt;figcaption>image-20200713172355080&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713172420207.png" alt="" />&lt;figcaption>image-20200713172420207&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例19-1">例19&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713172633692.png" alt="" />&lt;figcaption>image-20200713172633692&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713172657470.png" alt="" />&lt;figcaption>image-20200713172657470&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例20-1">例20&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713172803624.png" alt="" />&lt;figcaption>image-20200713172803624&lt;/figcaption>
&lt;/figure>
&lt;h3 id="全微分的计算">全微分的计算&lt;/h3>
&lt;h5 id="已知函数或隐函数求全微分">已知函数或隐函数求全微分&lt;/h5>
&lt;p>求多元函数的全微分，可以对函数两边取微分，直接得全微分。 如果是多元隐函数，或者方程组，可以对方程两边求各自由元的偏导数。利用偏导数得全微分。&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701160321599.png" alt="" />&lt;figcaption>image-20200701160321599&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701160424316.png" alt="" />&lt;figcaption>image-20200701160424316&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701160500466.png" alt="" />&lt;figcaption>image-20200701160500466&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-6">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710171131701.png" alt="" />&lt;figcaption>image-20200710171131701&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710171144572.png" alt="" />&lt;figcaption>image-20200710171144572&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710171201393.png" alt="" />&lt;figcaption>image-20200710171201393&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710174148525.png" alt="" />&lt;figcaption>image-20200710174148525&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710174205081.png" alt="" />&lt;figcaption>image-20200710174205081&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710190655625.png" alt="" />&lt;figcaption>image-20200710190655625&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710190627751.png" alt="" />&lt;figcaption>image-20200710190627751&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-4">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711161935902.png" alt="" />&lt;figcaption>image-20200711161935902&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711161957276.png" alt="" />&lt;figcaption>image-20200711161957276&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-3">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713144527388.png" alt="" />&lt;figcaption>image-20200713144527388&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164912265.png" alt="" />&lt;figcaption>image-20200713164912265&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713164941986.png" alt="" />&lt;figcaption>image-20200713164941986&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713165017710.png" alt="" />&lt;figcaption>image-20200713165017710&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-3">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713165329798.png" alt="" />&lt;figcaption>image-20200713165329798&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713165356281.png" alt="" />&lt;figcaption>image-20200713165356281&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713165427769.png" alt="" />&lt;figcaption>image-20200713165427769&lt;/figcaption>
&lt;/figure>
&lt;h5 id="已知部分偏导信息求全微分">已知部分偏导信息求全微分&lt;/h5>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710231039990.png" alt="" />&lt;figcaption>image-20200710231039990&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710231054533.png" alt="" />&lt;figcaption>image-20200710231054533&lt;/figcaption>
&lt;/figure>
&lt;h5 id="已知极限求全微分">已知极限求全微分&lt;/h5>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709141641366.png" alt="" />&lt;figcaption>image-20200709141641366&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709141659190.png" alt="" />&lt;figcaption>image-20200709141659190&lt;/figcaption>
&lt;/figure>
&lt;h5 id="已知全微分求参数">已知全微分求参数&lt;/h5>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713151304137.png" alt="" />&lt;figcaption>image-20200713151304137&lt;/figcaption>
&lt;/figure>
&lt;h3 id="多元微分学代数应用求多元函数极值">多元微分学代数应用：求多元函数极值&lt;/h3>
&lt;p>极值/最值问题，其实就是&lt;strong>最优化问题&lt;/strong>。&lt;/p>
&lt;p>注意：极值问题，&lt;strong>可能取值的的位置&lt;/strong>，包括&lt;strong>驻点、不可导点、边界点&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>无条件极值&lt;/strong>的定义域为&lt;strong>开区域&lt;/strong>，&lt;strong>考虑的是&lt;/strong>定义域内的&lt;strong>驻点&lt;/strong>是否&lt;strong>取极值&lt;/strong>。 &lt;strong>条件极值&lt;/strong>多了约束，考虑的是&lt;strong>有约束&lt;/strong>的情况下是否&lt;strong>取极值&lt;/strong>。（&lt;strong>如果约束&lt;/strong>正好是&lt;strong>对应&lt;/strong>无条件极值的&lt;strong>边界&lt;/strong>，则条件极值&lt;strong>考虑&lt;/strong>的是&lt;strong>边界点&lt;/strong>是否&lt;strong>取极值&lt;/strong>）&lt;/p>
&lt;p>&lt;strong>例如&lt;/strong>求 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在区域 &lt;span class="math inline">\(D=\left\{(x, y) \mid x^{2}+4 y^{2} \leqslant 4\right\}\)&lt;/span> 上的极值/最值。 可以拆成两部分来求： 在区域 &lt;span class="math inline">\(D_1=\left\{(x, y) \mid x^{2}+4 y^{2} &amp;lt; 4\right\}\)&lt;/span> 上找到所有的驻点判断是否取极值（求非条件极值） 在区域 &lt;span class="math inline">\(D_2=\left\{(x, y) \mid x^{2}+4 y^{2} = 4\right\}\)&lt;/span> 上，即给定约束&lt;span class="math inline">\(x^{2}+4 y^{2} = 4\)&lt;/span>的条件下，求函数的极值（求条件极值）&lt;/p>
&lt;p>实际问题中，很多问题只在开区域内取最值，这个时候，可以不考虑在边界上取极值的情况（不用考虑条件极值）&lt;/p>
&lt;h5 id="无条件极值">无条件极值&lt;/h5>
&lt;p>无条件极值要求定义域为开区域&lt;/p>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702141609968.png" alt="" />&lt;figcaption>image-20200702141609968&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702141658206.png" alt="" />&lt;figcaption>image-20200702141658206&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702141724267.png" alt="" />&lt;figcaption>image-20200702141724267&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702161848747.png" alt="" />&lt;figcaption>image-20200702161848747&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702175100751.png" alt="" />&lt;figcaption>image-20200702175100751&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702175142248.png" alt="" />&lt;figcaption>image-20200702175142248&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-7">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709145620862.png" alt="" />&lt;figcaption>image-20200709145620862&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709145647649.png" alt="" />&lt;figcaption>image-20200709145647649&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-6">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710004826182.png" alt="" />&lt;figcaption>image-20200710004826182&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710004844257.png" alt="" />&lt;figcaption>image-20200710004844257&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-5">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711175523494.png" alt="" />&lt;figcaption>image-20200711175523494&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711175542673.png" alt="" />&lt;figcaption>image-20200711175542673&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711175556778.png" alt="" />&lt;figcaption>image-20200711175556778&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-5">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174057577.png" alt="" />&lt;figcaption>image-20200713174057577&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-4">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174313120.png" alt="" />&lt;figcaption>image-20200713174313120&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174444313.png" alt="" />&lt;figcaption>image-20200713174444313&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-4">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174830286.png" alt="" />&lt;figcaption>image-20200713174830286&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174845204.png" alt="" />&lt;figcaption>image-20200713174845204&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200713174923357.png" alt="" />&lt;figcaption>image-20200713174923357&lt;/figcaption>
&lt;/figure>
&lt;h5 id="条件极值">条件极值&lt;/h5>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702142508895.png" alt="" />&lt;figcaption>image-20200702142508895&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702142300367.png" alt="" />&lt;figcaption>image-20200702142300367&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702145537603.png" alt="" />&lt;figcaption>image-20200702145537603&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702145744521.png" alt="" />&lt;figcaption>image-20200702145744521&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702153214607.png" alt="" />&lt;figcaption>image-20200702153214607&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702153235382.png" alt="" />&lt;figcaption>image-20200702153235382&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702153315765.png" alt="" />&lt;figcaption>image-20200702153315765&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200702153506463.png" alt="" />&lt;figcaption>image-20200702153506463&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-8">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710014254265.png" alt="" />&lt;figcaption>image-20200710014254265&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710014312491.png" alt="" />&lt;figcaption>image-20200710014312491&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-8">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711181129008.png" alt="" />&lt;figcaption>image-20200711181129008&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711181146986.png" alt="" />&lt;figcaption>image-20200711181146986&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-7">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711181341127.png" alt="" />&lt;figcaption>image-20200711181341127&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711181403270.png" alt="" />&lt;figcaption>image-20200711181403270&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714094854267.png" alt="" />&lt;figcaption>image-20200714094854267&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-6">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714095236251.png" alt="" />&lt;figcaption>image-20200714095236251&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-5">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714095257751.png" alt="" />&lt;figcaption>image-20200714095257751&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-5">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714095619978.png" alt="" />&lt;figcaption>image-20200714095619978&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-4">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714095639483.png" alt="" />&lt;figcaption>image-20200714095639483&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-2">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714100156436.png" alt="" />&lt;figcaption>image-20200714100156436&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714100220455.png" alt="" />&lt;figcaption>image-20200714100220455&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714100235332.png" alt="" />&lt;figcaption>image-20200714100235332&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-2">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714101350571.png" alt="" />&lt;figcaption>image-20200714101350571&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714101413487.png" alt="" />&lt;figcaption>image-20200714101413487&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-2">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714102547365.png" alt="" />&lt;figcaption>image-20200714102547365&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714102604930.png" alt="" />&lt;figcaption>image-20200714102604930&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-2">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714104559159.png" alt="" />&lt;figcaption>image-20200714104559159&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714104623138.png" alt="" />&lt;figcaption>image-20200714104623138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714104643751.png" alt="" />&lt;figcaption>image-20200714104643751&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15-2">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714110123747.png" alt="" />&lt;figcaption>image-20200714110123747&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714110146199.png" alt="" />&lt;figcaption>image-20200714110146199&lt;/figcaption>
&lt;/figure>
&lt;h3 id="多元微分学几何向量分析应用">多元微分学几何/向量分析应用：&lt;/h3>
&lt;h4 id="空间曲线切向量和曲面法向量">空间曲线切向量和曲面法向量&lt;/h4>
&lt;h5 id="空间曲线切向量的计算">空间曲线切向量的计算&lt;/h5>
&lt;p>切向量为&lt;span class="math inline">\((x_t^\prime, y_t^\prime, z_t^\prime)\)&lt;/span>或者&lt;span class="math inline">\((1,\frac{dy}{dx}, \frac{dz}{dx})\)&lt;/span>&lt;/p>
&lt;p>参考答案是代隐函数方程组求偏导的Jacobi公式。实际上，求解过程一般就是解&lt;span class="math inline">\(\frac{dy}{dx}, \frac{dz}{dx}\)&lt;/span>的线性方程组的过程。&lt;/p>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710000637459.png" alt="" />&lt;figcaption>image-20200710000637459&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710000906166.png" alt="" />&lt;figcaption>image-20200710000906166&lt;/figcaption>
&lt;/figure>
&lt;h5 id="空间曲面法向量的计算">空间曲面法向量的计算&lt;/h5>
&lt;p>空间曲面&lt;span class="math inline">\(F(x,y,z)\)&lt;/span>上任一点法向量为&lt;span class="math inline">\((F_x,F_y,F_z)\)&lt;/span>&lt;/p>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710003635901.png" alt="" />&lt;figcaption>image-20200710003635901&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710003714077.png" alt="" />&lt;figcaption>image-20200710003714077&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710225148524.png" alt="" />&lt;figcaption>image-20200710225148524&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710225203730.png" alt="" />&lt;figcaption>image-20200710225203730&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-9">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710225711507.png" alt="" />&lt;figcaption>image-20200710225711507&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200710225733691.png" alt="" />&lt;figcaption>image-20200710225733691&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-9">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714171630294.png" alt="" />&lt;figcaption>image-20200714171630294&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-8">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714172346614.png" alt="" />&lt;figcaption>image-20200714172346614&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714172406509.png" alt="" />&lt;figcaption>image-20200714172406509&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714172426559.png" alt="" />&lt;figcaption>image-20200714172426559&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-7">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714172716526.png" alt="" />&lt;figcaption>image-20200714172716526&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714172733799.png" alt="" />&lt;figcaption>image-20200714172733799&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714173030959.png" alt="" />&lt;figcaption>image-20200714173030959&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-6">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714173216173.png" alt="" />&lt;figcaption>image-20200714173216173&lt;/figcaption>
&lt;/figure>
&lt;h4 id="向导数与梯度的计算">向导数与梯度的计算&lt;/h4>
&lt;h5 id="方向导数的计算">方向导数的计算&lt;/h5>
&lt;p>（方向导数是个值哦，不是向量；只是因为和梯度联系紧密，放到了这里）&lt;/p>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709150645947.png" alt="" />&lt;figcaption>image-20200709150645947&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709150733278.png" alt="" />&lt;figcaption>image-20200709150733278&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709150806992.png" alt="" />&lt;figcaption>image-20200709150806992&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-12">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714145005840.png" alt="" />&lt;figcaption>image-20200714145005840&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-10">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714145208186.png" alt="" />&lt;figcaption>image-20200714145208186&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714145231469.png" alt="" />&lt;figcaption>image-20200714145231469&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-10">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714145523955.png" alt="" />&lt;figcaption>image-20200714145523955&lt;/figcaption>
&lt;/figure>
&lt;h5 id="梯度的计算">梯度的计算&lt;/h5>
&lt;h6 id="例1-17">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709151252431.png" alt="" />&lt;figcaption>image-20200709151252431&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200709151310235.png" alt="" />&lt;figcaption>image-20200709151310235&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-13">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711002502273.png" alt="" />&lt;figcaption>image-20200711002502273&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200711002516936.png" alt="" />&lt;figcaption>image-20200711002516936&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-11">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714150327874.png" alt="" />&lt;figcaption>image-20200714150327874&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714150354285.png" alt="" />&lt;figcaption>image-20200714150354285&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714150415782.png" alt="" />&lt;figcaption>image-20200714150415782&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-11">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714170902723.png" alt="" />&lt;figcaption>image-20200714170902723&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200714170922899.png" alt="" />&lt;figcaption>image-20200714170922899&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-多元微积分-多元微分学-向量值函数和向量分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/</link><pubDate>Mon, 06 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微积分-多元微分学-向量值函数和向量分析">高等数学-多元微积分-多元微分学-向量值函数和向量分析&lt;/h1>
&lt;h2 id="一元向量值函数-f-d-rightarrow-mathbfrn">一元向量值函数 &lt;span class="math inline">\(f: D \rightarrow \mathbf{R}^{n}\)&lt;/span>&lt;/h2>
&lt;h3 id="一元向量值函数定义">一元向量值函数定义&lt;/h3>
&lt;p>定义 设数集 &lt;span class="math inline">\(D\subset R\)&lt;/span>,则称映射 &lt;span class="math inline">\(f: D \rightarrow \mathbf{R}^{n}\)&lt;/span> 为一元向量值函数, 通常记为&lt;span class="math inline">\(\boldsymbol{r}=\boldsymbol{f}(t), t \in D\)&lt;/span> 其中数集 D 称为函数的定义域, , t称为自变量, &lt;span class="math inline">\(\boldsymbol{r}\)&lt;/span> 称为因变量.&lt;/p>
&lt;p>&lt;strong>例子：空间解析几何的参数方程形式，就是向量值函数&lt;/strong>&lt;/p>
&lt;p>空间曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>的参数方程就是一个一元向量值函数， &lt;span class="math inline">\(\left\{\begin{array}{l}x=\varphi(t) \\ y=\psi(t), \quad t \in[\alpha, \beta] \\ z=\omega(t)\end{array}\right.\)&lt;/span> 也可以写成向量形式： &lt;span class="math inline">\(\boldsymbol{r}=x \boldsymbol{i}+y \boldsymbol{j}+z \boldsymbol{k}, \quad \boldsymbol{f}(t)=\varphi(t) \boldsymbol{i}+\psi(t) \boldsymbol{j}+\omega(t) \boldsymbol{k}\)&lt;/span> 简记为向量方程： &lt;span class="math inline">\(\boldsymbol{r}=\boldsymbol{f}(t), t \in[\alpha, \boldsymbol{\beta}]\)&lt;/span>&lt;/p>
&lt;h3 id="一元向量值函数的极限">一元向量值函数的极限&lt;/h3>
&lt;p>定义 2 设向量值函数 &lt;span class="math inline">\(f(t)\)&lt;/span> 在点 &lt;span class="math inline">\(t_{0}\)&lt;/span> 的某一去心邻域内有定义,如果存在一 个常向量 &lt;span class="math inline">\(\boldsymbol{r}_{0},\)&lt;/span> 对于任意给定的正数 &lt;span class="math inline">\(\varepsilon,\)&lt;/span> 总存在正数 &lt;span class="math inline">\(\delta,\)&lt;/span> 使得当 &lt;span class="math inline">\(t\)&lt;/span> 满足 &lt;span class="math inline">\(0&amp;lt;\left|t-t_{0}\right|&amp;lt;\delta\)&lt;/span>时，对应的函数值 &lt;span class="math inline">\(\boldsymbol{f}(t)\)&lt;/span> 都满足不等式&lt;span class="math inline">\(\left|\boldsymbol{f}(t)-\boldsymbol{r}_{0}\right|&amp;lt;\varepsilon\)&lt;/span>, 那么,常向量 &lt;span class="math inline">\(\boldsymbol{r}_{0},\)&lt;/span> 就叫做向量值函数 &lt;span class="math inline">\(\boldsymbol {f(t)}\)&lt;/span> 当 &lt;span class="math inline">\(t \rightarrow t_{0}\)&lt;/span> 时的极限 &lt;span class="math inline">\(,\)&lt;/span> 记作&lt;span class="math inline">\(\lim _{t \rightarrow t_{0}} \boldsymbol f(t)=\boldsymbol r_{0} \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad \boldsymbol{f}(t) \rightarrow \boldsymbol{r}_{0}, l \rightarrow t_{0}\)&lt;/span>&lt;/p>
&lt;p>向量值函数 &lt;span class="math inline">\(\boldsymbol {f(t)}\)&lt;/span> 当 &lt;span class="math inline">\(t \rightarrow t_{0}\)&lt;/span> 时&lt;strong>极限存在的充分必要条件&lt;/strong>是：三个分量函数 &lt;span class="math inline">\(f_{1}(t), f_{2}(t), f_{3}(t)\)&lt;/span> 当 &lt;span class="math inline">\(t \rightarrow t_{0}\)&lt;/span> 时的极限都存在。 即&lt;span class="math inline">\(\lim _{t \rightarrow t_{0}} \boldsymbol f(t)=\left(\lim _{t \rightarrow t_{0}} f_{1}(t), \lim _{t \rightarrow t_{0}} f_{2}(t), \lim _{t \rightarrow t_{0}} f_{3}(t)\right)\)&lt;/span>&lt;/p>
&lt;h3 id="一元向量值函数的连续性">一元向量值函数的连续性&lt;/h3>
&lt;p>向量值函数 &lt;span class="math inline">\(\boldsymbol {f(t)}\)&lt;/span> 在&lt;span class="math inline">\(t_{0}\)&lt;/span> &lt;strong>连续的充分必要条件&lt;/strong>是：三个分量函数 &lt;span class="math inline">\(f_{1}(t), f_{2}(t), f_{3}(t)\)&lt;/span> 都在在&lt;span class="math inline">\(t_{0}\)&lt;/span> 连续&lt;/p>
&lt;h3 id="一元向量值函数的导数或导向量">一元向量值函数的导数或导向量&lt;/h3>
&lt;p>向量值函数 &lt;span class="math inline">\(\boldsymbol {f(t)}\)&lt;/span> 在&lt;span class="math inline">\(t_{0}\)&lt;/span>的某邻域内有定义， 如果&lt;span class="math inline">\(\lim _{\Delta t \rightarrow 0} \frac{\boldsymbol\Delta r}{\Delta t}=\lim _{\Delta t \rightarrow 0} \frac{\boldsymbol f\left(t_{0}+\Delta t\right)-\boldsymbol f\left(t_{0}\right)}{\Delta t}\)&lt;/span>， 则称这个极限向量是此一元向量值函数的导数或导向量，记为&lt;span class="math inline">\(\boldsymbol{f}^{\prime}\left(t_{0}\right)\)&lt;/span> 或 &lt;span class="math inline">\(\left.\frac{\mathrm{d} \boldsymbol{r}}{\mathrm{d} t}\right|_{t=t_{0}}\)&lt;/span>&lt;/p>
&lt;p>向量值函数 &lt;span class="math inline">\(\boldsymbol {f(t)}\)&lt;/span> 在&lt;span class="math inline">\(t_{0}\)&lt;/span> &lt;strong>可导的充分必要条件&lt;/strong>是：三个分量函数 &lt;span class="math inline">\(f_{1}(t), f_{2}(t), f_{3}(t)\)&lt;/span> 都在在&lt;span class="math inline">\(t_{0}\)&lt;/span> 可导。 即&lt;span class="math inline">\(\boldsymbol{f}^{\prime}\left(t_{0}\right)=f_{1}^{\prime}\left(t_{0}\right) \boldsymbol{i}+f_{2}^{\prime}\left(t_{0}\right) \boldsymbol{j}+f_{3}^{\prime}\left(t_{0}\right) \boldsymbol{k}\)&lt;/span>&lt;/p>
&lt;p>一元向量值函数的&lt;strong>导数运算法则&lt;/strong>，与数量函数的导数运算法则形式相同： &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t} \boldsymbol{C}=\mathbf{0}\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}[c \boldsymbol{u}(t)]=c \boldsymbol{u}^{\prime}(t)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}[\boldsymbol{u}(t) \pm \boldsymbol{v}(t)]=\boldsymbol{u}^{\prime}(t) \pm \boldsymbol{v}^{\prime}(t)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}[\varphi(t) \boldsymbol{u}(t)]=\varphi^{\prime}(t) \boldsymbol{u}(t)+\varphi(t) \boldsymbol{u}^{\prime}(t)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}[\boldsymbol{u}(t) \cdot \boldsymbol{v}(t)]=\boldsymbol{u}^{\prime}(t) \cdot \boldsymbol{v}(t)+\boldsymbol{u}(t) \cdot \boldsymbol{v}^{\prime}(t)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}[\boldsymbol{u}(t) \times \boldsymbol{v}(t)]=\boldsymbol{u}^{\prime}(t) \times \boldsymbol{v}(t)+\boldsymbol{u}(t) \times \boldsymbol{v}^{\prime}(t)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t} \boldsymbol{u}[\varphi(t)]=\varphi^{\prime}(t) \boldsymbol{u}^{\prime}[\varphi(t)]\)&lt;/span>&lt;/p>
&lt;h3 id="几何应用在空间解析几何中的应用空间曲线切向量曲面法向量">几何应用：在空间解析几何中的应用：空间曲线切向量、曲面法向量&lt;/h3>
&lt;h4 id="向量值函数的几何意义">向量值函数的几何意义&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200707170532542.png" alt="" />&lt;figcaption>image-20200707170532542&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;strong>导向量&lt;/strong> &lt;span class="math inline">\(f^{\prime}\left(t_{0}\right)=\lim _{\Delta t \rightarrow 0} \frac{\Delta r}{\Delta t}\)&lt;/span> 是向量值函数 &lt;span class="math inline">\(r=f(t)\)&lt;/span> 的&lt;strong>终端曲线 &lt;span class="math inline">\(\Gamma\)&lt;/span> 在点 &lt;span class="math inline">\(M\)&lt;/span> 处的一个切向量&lt;/strong>,其指向与 &lt;span class="math inline">\(t\)&lt;/span> 的增长方向一致.&lt;/p>
&lt;h4 id="空间曲线的切线与法平面">空间曲线的切线与法平面&lt;/h4>
&lt;p>&lt;strong>空间曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>的参数方程&lt;/strong>就是一个一元向量值函数， &lt;span class="math inline">\(\left\{\begin{array}{l}x=\varphi(t) \\ y=\psi(t), \quad t \in[\alpha, \beta] \\ z=\omega(t)\end{array}\right.\)&lt;/span> 也&lt;strong>可以写成向量形式&lt;/strong>： &lt;span class="math inline">\(\boldsymbol{r}=x \boldsymbol{i}+y \boldsymbol{j}+z \boldsymbol{k}, \quad \boldsymbol{f}(t)=\varphi(t) \boldsymbol{i}+\psi(t) \boldsymbol{j}+\omega(t) \boldsymbol{k}\)&lt;/span> 简记为向量方程： &lt;span class="math inline">\(\boldsymbol{r}=\boldsymbol{f}(t), t \in[\alpha, \boldsymbol{\beta}]\)&lt;/span>&lt;/p>
&lt;p>由前面&lt;strong>几何意义可知，导向量是向量值函数变化方向上的切向量&lt;/strong>。 则向量&lt;span class="math inline">\(\boldsymbol T=\boldsymbol f^{\prime}\left(t_{0}\right)=\left(\varphi^{\prime}\left(t_{0}\right), \psi^{\prime}\left(t_{0}\right), \omega^{\prime}\left(t_{0}\right)\right)\)&lt;/span>就是&lt;strong>曲线的一个切向量&lt;/strong>（要求三个导数不同时为0）（对参数求导组成得导向量） 曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>在点M处的&lt;strong>切线方程&lt;/strong>&lt;span class="math inline">\(\frac{x-x_{0}}{\varphi^{\prime}\left(t_{0}\right)}=\frac{y-y_{0}}{\psi^{\prime}\left(t_{0}\right)}=\frac{z-z_{0}}{\omega^{\prime}\left(t_{0}\right)}\)&lt;/span> 曲线&lt;span class="math inline">\(\Gamma\)&lt;/span>在点M处的&lt;strong>法平面方程&lt;/strong>&lt;span class="math inline">\(\varphi^{\prime}\left(t_{0}\right)\left(x-x_{0}\right)+\psi^{\prime}\left(t_{0}\right)\left(y-y_{0}\right)+\omega^{\prime}\left(t_{0}\right)\left(z-z_{0}\right)=0\)&lt;/span>&lt;/p>
&lt;p>对于非参数方程形式的空间曲线，如（显函数形式）： &lt;span class="math inline">\(\left\{\begin{array}{l}y=\varphi(x) \\ z=\psi(x)\end{array}\right.\)&lt;/span> 可以化为参数方程形式求解： &lt;span class="math inline">\(\left\{\begin{array}{l}x=x \\ y=\varphi(x) \\ z=\psi(x)\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>对于另一种非参数方程形式的空间曲线，如（隐函数方程组形式）： &lt;span class="math inline">\(\left\{\begin{array}{l}F(x, y, z)=0 \\ G(x, y, z)=0\end{array}\right.\)&lt;/span> 可以（对方程组求自由元的导数+解线性方程组）的方式来求解,得曲线的切向量&lt;span class="math inline">\((1,\frac{dy}{dx}, \frac{dz}{dx}) \rightarrow ...\)&lt;/span> 看过下一节：曲面的切平面与法线后，可以将&lt;span class="math inline">\(F(x,y,z)=0\)&lt;/span>和&lt;span class="math inline">\(G(x,y,z)=0\)&lt;/span>看作两个曲面，分别求曲面的法向量&lt;span class="math inline">\(\boldsymbol n_1, \boldsymbol n_2\)&lt;/span>，空间曲线是两曲面的交线，空间曲线的切向量&lt;span class="math inline">\(\boldsymbol n = \boldsymbol n_1 \times \boldsymbol n_2\)&lt;/span>&lt;/p>
&lt;h4 id="曲面的切平面与法线">曲面的切平面与法线&lt;/h4>
&lt;p>&lt;strong>曲面&lt;/strong>方程&lt;span class="math inline">\(F(x, y, z)=0\)&lt;/span> 在曲面&lt;span class="math inline">\(F(x, y, z)=0\)&lt;/span>上，且过曲面上一点&lt;span class="math inline">\(M(x_0,y_0,z_0)\)&lt;/span>的任意曲线，设&lt;strong>曲线&lt;/strong>的参数方程为： &lt;span class="math inline">\(\left\{\begin{array}{l}x=\varphi(t) \\ y=\psi(t), \quad t \in[\alpha, \beta] \\ z=\omega(t)\end{array}\right.\)&lt;/span> 由上一节知，这条空间曲线的切线方程为&lt;span class="math inline">\(\frac{x-x_{0}}{\varphi^{\prime}\left(t_{0}\right)}=\frac{y-y_{0}}{\psi^{\prime}\left(t_{0}\right)}=\frac{z-z_{0}}{\omega^{\prime}\left(t_{0}\right)}\)&lt;/span> &lt;span class="math inline">\(F[\varphi(t), \psi(t), \omega(t)] \equiv 0\)&lt;/span> F有连续偏导数的情况下，&lt;span class="math inline">\(\left.\frac{\mathrm{d}}{\mathrm{d} t} F[\varphi(t), \psi(t), \omega(t)]\right|_{t=t_{0}}=0\)&lt;/span> 即&lt;span class="math inline">\(F_{x}\left(x_{0}, y_{0}, z_{0}\right) \varphi^{\prime}\left(t_{0}\right)+F_{y}\left(x_{0}, y_{0}, z_{0}\right) \psi^{\prime}\left(t_{0}\right)+F_{z}\left(x_{0}, y_{0}, z_{0}\right) \omega^{\prime}\left(t_{0}\right)=0\)&lt;/span> 引入向量&lt;span class="math inline">\(\boldsymbol{n}=\left(\boldsymbol{F}_{x}\left(x_{0}, y_{0}, z_{0}\right), F,\left(x_{0}, y_{0}, z_{0}\right), F_{z}\left(x_{0}, y_{0}, z_{0}\right)\right)\)&lt;/span>，又有（见上一节）过曲面点&lt;span class="math inline">\(M(x_0,y_0,z_0)\)&lt;/span>的任任意曲线切向量&lt;span class="math inline">\(\boldsymbol{T}=\left(\boldsymbol{\varphi}^{\prime}\left(t_{0}\right), \boldsymbol{\psi}^{\prime}\left(t_{0}\right), \boldsymbol{\omega}^{\prime}\left(t_{0}\right)\right)\)&lt;/span> 即&lt;span class="math inline">\(\boldsymbol T \cdot \boldsymbol n = \boldsymbol 0\)&lt;/span> 这个与曲面上过点M的任意曲线切线都垂直的向量&lt;span class="math inline">\(\boldsymbol{n}=\left(\boldsymbol{F}_{x}\left(x_{0}, y_{0}, z_{0}\right), F,\left(x_{0}, y_{0}, z_{0}\right), F_{z}\left(x_{0}, y_{0}, z_{0}\right)\right)\)&lt;/span>，就是空间曲面在&lt;span class="math inline">\(M(x_0,y_0,z_0)\)&lt;/span>处的&lt;strong>切平面的法向量&lt;/strong>，（对隐函数左侧求偏导组成的向量） 对应的&lt;strong>切平面方程&lt;/strong>为&lt;span class="math inline">\(F_{x}\left(x_{0}, y_{0}, z_{0}\right)\left(x-x_{0}\right)+F_{y}\left(x_{0}, y_{0}, z_{0}\right)\left(y-y_{0}\right)+F_{z}\left(x_{0}, y_{0}, z_{0}\right)\left(z-z_{0}\right)=0\)&lt;/span> &lt;strong>法线方程&lt;/strong>为&lt;span class="math inline">\(\frac{x-x_{0}}{F_{x}\left(x_{0}, y_{0}, z_{0}\right)}=\frac{y-y_{0}}{F_{y}\left(x_{0}, y_{0}, z_{0}\right)}=\frac{z-z_{0}}{F_{z}\left(x_{0}, y_{0}, z_{0}\right)}\)&lt;/span>&lt;/p>
&lt;p>对于非隐函数形式的空间曲线，如（显函数形式）： &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 可以化为隐函数形式： &lt;span class="math inline">\(F(x, y, z)=f(x, y)-z\)&lt;/span> 对应的有： &lt;span class="math inline">\(F_{x}(x, y, z)=f_{x}(x, y), F_{y}(x, y, z)=f_{y}(x, y), F_{z}(x, y, z)=-1\)&lt;/span> 则平面切点M处的法向量： &lt;span class="math inline">\(\boldsymbol{n}=\left(f_{x}\left(x_{0}, y_{0}\right), f_{y}\left(x_{0}, y_{0}\right),-1\right)\)&lt;/span> 法向量单位化（化为方向余弦的形式：z轴向上）： 各分量分别为&lt;span class="math inline">\(\cos \alpha=\frac{-f_{x}}{\sqrt{1+f_{x}^{2}+f_{y}^{2}}}, \cos \beta=\frac{-f_{y}}{\sqrt{1+f_{x}^{2}+f_{,}^{2}}}, \cos \gamma=\frac{1}{\sqrt{1+f_{x}^{2}+f_{\gamma}^{2}}}\)&lt;/span>&lt;/p>
&lt;h3 id="物理应用速度与加速度">物理应用:速度与加速度&lt;/h3>
&lt;p>由前面几何意义可知，导向量是向量值函数变化方向上的切向量，进一步，可以赋予其物理意义。&lt;/p>
&lt;p>设向量值函数&lt;span class="math inline">\(\boldsymbol{r}=\boldsymbol{f}(t)\)&lt;/span>是沿空间光滑曲线运动的质点 &lt;span class="math inline">\(M\)&lt;/span> 的位置向量，t代表时间 &lt;span class="math inline">\(\boldsymbol{v}(t)=\frac{\mathrm{d} \boldsymbol{r}}{\mathrm{d} t}\)&lt;/span> 是质点 &lt;span class="math inline">\(M\)&lt;/span> 的速度向里,其方向与曲线相切 &lt;span class="math inline">\(\boldsymbol{a}(t)=\frac{\mathrm{d} v}{\mathrm{d} t}=\frac{\mathrm{d}^{2} \boldsymbol{r}}{\mathrm{d} t^{2}}\)&lt;/span> 是质点 &lt;span class="math inline">\(M\)&lt;/span> 的加速度向量.&lt;/p>
&lt;h2 id="多元向量值函数">多元向量值函数&lt;/h2>
&lt;h3 id="方向导数不是向量值函数">方向导数（不是向量值函数）&lt;/h3>
&lt;p>&lt;strong>方向导数不是多元向量值函数，但是它与梯度的定义有关，所以把它放到这里。&lt;/strong>&lt;/p>
&lt;p>偏导数反应的是函数沿坐标轴方向的变化率。很多物理现象需要求解物理量沿特定方向的变化率，只靠偏导数数是显然不够的。有必要讨论&lt;strong>函数沿特定方向的变化率&lt;/strong>。（给定方向，只求大小，是个标量）&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200707232929575.png" alt="" />&lt;figcaption>image-20200707232929575&lt;/figcaption>
&lt;/figure>
&lt;p>以二元函数为例，给定&lt;span class="math inline">\(P_0(x_0,y_0)\)&lt;/span>和附近的点&lt;span class="math inline">\(P(x,y)\)&lt;/span>,当两点距离&lt;span class="math inline">\(|PP_0|\)&lt;/span>足够小时， &lt;span class="math inline">\(P_0 P\)&lt;/span>可以看作是直线段&lt;span class="math inline">\(l\)&lt;/span>， &lt;span class="math inline">\(l\)&lt;/span>上两点间距离&lt;span class="math inline">\(|PP_0|=t\)&lt;/span>， &lt;span class="math inline">\(l\)&lt;/span>的方向向量&lt;span class="math inline">\(\boldsymbol e_{l}=(\cos \alpha, \cos \beta)\)&lt;/span> 参数方程：&lt;span class="math inline">\(\left\{\begin{array}{l}x=x_{0}+t \cos \alpha \\ y=y_{0}+t \cos \beta\end{array}(t \geqslant 0)\right.\)&lt;/span> 对于函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> 处&lt;strong>沿方向 &lt;span class="math inline">\(l\)&lt;/span> 的变化率&lt;/strong>. 即函数增量与距离的比值，&lt;strong>取极限&lt;/strong>，即&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)}=\lim _{t \rightarrow 0^{*}} \frac{f\left(x_{0}+t \cos \alpha, y_{0}+t \cos \beta\right)-f\left(x_{0}, y_{0}\right)}{t}\)&lt;/span>，这里&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)}\)&lt;/span>称作函数的&lt;strong>方向导数&lt;/strong>&lt;/p>
&lt;p>对于方向取&lt;span class="math inline">\(\boldsymbol e_l = \boldsymbol i = (1,0)\)&lt;/span>,方向导数就是对x的偏导数&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)} = f_x|_{(x_0,y_0)}\)&lt;/span> 对于方向取&lt;span class="math inline">\(\boldsymbol e_l = \boldsymbol j = (0,1)\)&lt;/span>,方向导数就是对y的偏导数&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)} = f_y|_{(x_0,y_0)}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>定理&lt;/strong> （方向导数存在的必要条件）如果函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> &lt;strong>可微&lt;/strong>分,那么函数在该点沿任一方向&lt;span class="math inline">\(l\)&lt;/span> 的&lt;strong>方向导数存在,且有&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)}=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta\)&lt;/span>，&lt;/strong>其中其中 &lt;span class="math inline">\(\cos \alpha\)&lt;/span> 和 &lt;span class="math inline">\(\cos \beta\)&lt;/span> 是方向 &lt;span class="math inline">\(l\)&lt;/span> 的方向余弦. &lt;strong>证明&lt;/strong>：由函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> 可微分,得： &lt;span class="math inline">\(\begin{aligned} &amp;amp; f\left(x_{0}+\Delta x, y_{0}+\Delta y\right)-f\left(x_{0}, y_{0}\right) \\=&amp;amp; f_{x}\left(x_{0}, y_{0}\right) \Delta x+f_{y}\left(x_{0}, y_{0}\right) \Delta y+o(\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}) \end{aligned}\)&lt;/span> 又&lt;span class="math inline">\(\Delta x=t \cos \alpha, \Delta y=t \cos \beta, \sqrt{(\Delta x)^{2}+(\Delta y)^{2}}=t\)&lt;/span> 得方向导数： &lt;span class="math inline">\(\begin{aligned} \left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)}&amp;amp;= \lim _{t \rightarrow 0^{+}} \frac{f\left(x_{0}+t \cos \alpha, y_{0}+t \cos \beta\right)-f\left(x_{0}, y_{0}\right)}{t} \\&amp;amp;= \lim _{t \rightarrow 0^{+}} \frac{f_{x}\left(x_{0}, y_{0}\right) \Delta x+f_{y}\left(x_{0}, y_{0}\right) \Delta y+o(\sqrt{(\Delta x)^{2}+(\Delta y)^{2}})-f\left(x_{0}, y_{0}\right)}{t} \\ &amp;amp;= f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>同理，对于三元函数 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 来说, 它在空间一点 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}, z_{0}\right)\)&lt;/span> 沿方向 &lt;span class="math inline">\(e_{l}=(cos \alpha, \cos \beta, \cos \gamma )\)&lt;/span>的方向导数为 &lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}, z_{0}\right)}=\lim _{t \rightarrow 0^{*}} \frac{f\left(x_{0}+t \cos \alpha, y_{0}+t \cos \beta, z_{0}+t \cos \gamma\right)-f\left(x_{0}, y_{0}, z_{0}\right)}{t}\)&lt;/span> 同样可证，三元函数 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 在空间一点 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}, z_{0}\right)\)&lt;/span> &lt;strong>可微&lt;/strong>，则该函数&lt;strong>沿方向 &lt;span class="math inline">\(\boldsymbol e_{i}=(\cos \alpha, \cos \beta, \cos \gamma)\)&lt;/span> 的方向导数为&lt;span class="math inline">\(\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}, z_{0}\right)}=f_{x}\left(x_{0}, y_{0}, z_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}, z_{0}\right) \cos \beta+f_{z}\left(x_{0}, y_{0}, z_{0}\right) \cos \gamma\)&lt;/span>&lt;/strong>&lt;/p>
&lt;h3 id="梯度">梯度&lt;/h3>
&lt;h4 id="二元函数梯度的定义">二元函数梯度的定义&lt;/h4>
&lt;p>以二元函数为例，函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> &lt;strong>可微&lt;/strong>分,那么函数在该点沿任一方向&lt;span class="math inline">\(l\)&lt;/span> 的&lt;strong>方向导数存在,且有$.|&lt;em>{(x&lt;/em>{0}, y_{0})}=f_{x}(x_{0}, y_{0}) +f_{y}(x_{0}, y_{0}) = (f_{x}(x_{0}, y_{0}) ,f_{,}(x_{0}, y_{0}) ) (, ) $，&lt;/strong>其中其中 &lt;span class="math inline">\(\cos \alpha\)&lt;/span> 和 &lt;span class="math inline">\(\cos \beta\)&lt;/span> 是方向 &lt;span class="math inline">\(l\)&lt;/span> 的方向余弦，则&lt;span class="math inline">\(\boldsymbol e_{l}=(\cos \alpha, \cos \beta)\)&lt;/span>是单位方向向量&lt;/p>
&lt;p>我们可以将&lt;strong>&lt;span class="math inline">\((f_{x}\left(x_{0}, y_{0}\right) ,f_{,}\left(x_{0}, y_{0}\right) )\)&lt;/span>向量（向量值函数），定义为梯度&lt;/strong>： &lt;span class="math inline">\(\boldsymbol {grad} f\left(x_{0}, y_{0}\right)=\nabla f\left(x_{0}, y_{0}\right)=f_{x}\left(x_{0}, y_{0}\right) \boldsymbol i+f_{,}\left(x_{0}, y_{0}\right) \boldsymbol j = (f_{x}\left(x_{0}, y_{0}\right) ,f_{,}\left(x_{0}, y_{0}\right) )\)&lt;/span> 它是定义在&lt;strong>多元函数上的向量值函数&lt;/strong>，&lt;span class="math inline">\(D \rightarrow \mathbf{R}^{n}\)&lt;/span> ，由标量函数&lt;span class="math inline">\(f(x,y)\)&lt;/span>经过&lt;span class="math inline">\(\nabla\)&lt;/span>算子的操作，映射到向量空间。&lt;/p>
&lt;p>那么，&lt;strong>方向导数&lt;/strong>可以看作是&lt;strong>梯度和单位方向向量的内积&lt;/strong>： &lt;span class="math inline">\(\begin{aligned}\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)} &amp;amp;=f_{x}\left(x_{0}, y_{0}\right) \cos \alpha+f_{y}\left(x_{0}, y_{0}\right) \cos \beta \\ &amp;amp;=\boldsymbol{grad} f\left(x_{0}, y_{0}\right) \cdot \boldsymbol e_{i}=\left|\boldsymbol{grad} f\left(x_{0}, y_{0}\right)\right| \cos \theta \end{aligned}\)&lt;/span> 其中&lt;span class="math inline">\(\theta\)&lt;/span>是两个向量的夹角。&lt;/p>
&lt;h4 id="梯度方向是方向导数取最大值的方向梯度的模就是方向导数的最大值">梯度方向是方向导数取最大值的方向，梯度的模就是方向导数的最大值。&lt;/h4>
&lt;p>&lt;span class="math inline">\(\begin{aligned}\left.\frac{\partial f}{\partial l}\right|_{\left(x_{0}, y_{0}\right)} &amp;amp;=\boldsymbol{grad} f\left(x_{0}, y_{0}\right) \cdot \boldsymbol e_{i}=\left|\boldsymbol{grad} f\left(x_{0}, y_{0}\right)\right| \cos \theta \end{aligned}\)&lt;/span>&lt;/p>
&lt;ul>
&lt;li>当&lt;strong>方向导数和梯度的方向相同时，即&lt;span class="math inline">\(\theta = 0\)&lt;/span>时，方向导数最大，函数增加最快。&lt;/strong> 梯度方向是方向导数取最大值的方向，&lt;strong>梯度的模就是方向导数的最大值。&lt;/strong>&lt;/li>
&lt;li>同理，当&lt;strong>方向导数和梯度的方向相反时，即&lt;span class="math inline">\(\theta = \pi\)&lt;/span>时，方向导数最小，函数减小最快。&lt;/strong> 梯度的反方向是方向导数取最小值的方向，&lt;strong>梯度模的相反数就是方向导数的最小值。&lt;/strong>&lt;/li>
&lt;li>同理，当&lt;strong>方向导数和梯度的方向正交时，即&lt;span class="math inline">\(\theta = \pi / 2\)&lt;/span>时，方向导数为0，函数变化率为0。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h4 id="二元函数等值线的法线方向是梯度方向">二元函数等值线的法线方向是梯度方向&lt;/h4>
&lt;p>二元函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在几何上表示一个曲面，它和平面&lt;span class="math inline">\(z=c\)&lt;/span>截得的曲线叫做等值线。 &lt;strong>二元函数的等值线&lt;/strong>&lt;span class="math inline">\(\left\{\begin{array}{l}z=f(x, y) \\ z=c\end{array}\right.\)&lt;/span>有3个变量2个约束1个自由元， 用代入消元或隐函数方程组的方法可求&lt;span class="math inline">\(\frac{dy}{dx}= -\frac{f_x}{f_y}\)&lt;/span>, 由前面&lt;strong>向量值函数&lt;span class="math inline">\(\boldsymbol r = x \boldsymbol i + y \boldsymbol j + z \boldsymbol k = (x,y,z)\)&lt;/span>的导函数的几何意义&lt;/strong>可知，向量&lt;span class="math inline">\((\frac{dx}{dx}, \frac{dy}{dx},\frac{dz}{dx}) = (1, \frac{dy}{dx},0)\)&lt;/span>代表&lt;strong>空间曲线的切向量&lt;/strong>，此切向量z分量为0，&lt;span class="math inline">\(z=c\)&lt;/span>平面上切向量分量&lt;span class="math inline">\((\frac{dx}{dx}, \frac{dy}{dx}) = (1, \frac{dy}{dx})\)&lt;/span>，则&lt;strong>&lt;span class="math inline">\(z=c\)&lt;/span>平面上法向量&lt;/strong>为$(1,-)= (1, ) $， 单位化法向量: &lt;span class="math inline">\(\begin{aligned} \boldsymbol n &amp;amp;=\frac{1}{\sqrt{f_{x}^{2}\left(x_{0}, y_{0}\right)+f_{y}^{2}\left(x_{0}, y_{0}\right)}}\left(f_{x}\left(x_{0}, y_{0}\right), f_{y}\left(x_{0}, y_{0}\right)\right) \\ &amp;amp;=\frac{\nabla f\left(x_{0}, y_{0}\right)}{\left|\nabla f\left(x_{0}, y_{0}\right)\right|} \end{aligned}\)&lt;/span> 即&lt;strong>二元函数等值线在&lt;span class="math inline">\(z=c\)&lt;/span>平面上的法线方向就是梯度方向&lt;/strong>&lt;/p>
&lt;h4 id="三元函数梯度的定义">三元函数梯度的定义&lt;/h4>
&lt;p>类似二元函数梯度（是个向量值函数）的定义，可以定义三元函数的梯度。&lt;/p>
&lt;p>只要函数&lt;span class="math inline">\(f(x,y,z)\)&lt;/span>在空间区域D有连续偏导数，在空间中任意点&lt;span class="math inline">\((x_0,y_0,z_0)\)&lt;/span>都可定义梯度&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} \operatorname{grad} f\left(x_{0}, y_{0}, z_{0}\right) &amp;amp;=\nabla f\left(x_{0}, y_{0}, z_{0}\right) \\ &amp;amp;=f_{x}\left(x_{0}, y_{0}, z_{0}\right) \boldsymbol{i}+f_{,}\left(x_{0}, y_{0}, z_{0}\right) \boldsymbol{j}+f_{i}\left(x_{0}, y_{0}, z_{0}\right) \boldsymbol{k} \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>其中&lt;span class="math inline">\(\nabla =\frac{\partial}{\partial x} i+\frac{\partial}{\partial y} j+\frac{\partial}{\partial z} k\)&lt;/span> 称为(三维的) 向量微分算子或 Nabla 算子 &lt;span class="math inline">\(, \nabla f=\frac{\partial f}{\partial x} i+\frac{\partial f}{\partial y} j+\frac{\partial f}{\partial z} k\)&lt;/span>&lt;/p>
&lt;h4 id="三元函数等值面的法线方向是梯度方向">三元函数等值面的法线方向是梯度方向&lt;/h4>
&lt;p>曲面&lt;span class="math inline">\(f(x, y, z)=c\)&lt;/span>是函数&lt;span class="math inline">\(f(x,y,z)\)&lt;/span>的等值面，写成标准形式是&lt;span class="math inline">\(F(x,y,z) = f(x,y,z) - c = 0\)&lt;/span>, 有3变量1约束2自由元，可求得&lt;span class="math inline">\((F_x,F_y,F_z) = (f_x, f_y, f_z)\)&lt;/span> 由前面的几何意义可知，对于空间曲面（等值面）上任意点&lt;span class="math inline">\(M(x_0,y_0,z_0)\)&lt;/span>，向量&lt;span class="math inline">\(\left(\boldsymbol{F}_{x}\left(x_{0}, y_{0}, z_{0}\right), F,\left(x_{0}, y_{0}, z_{0}\right), F_{z}\left(x_{0}, y_{0}, z_{0}\right)\right)\)&lt;/span>，就是空间曲面（等值面）&lt;span class="math inline">\(F(x, y, z)=0\)&lt;/span>在&lt;span class="math inline">\(M(x_0,y_0,z_0)\)&lt;/span>处的切平面的法向量， 单位化法向量： &lt;span class="math inline">\(\begin{aligned} \boldsymbol n &amp;amp;=\frac{1}{\sqrt{f_{x}^{2}\left(x_{0}, y_{0}, z_{0}\right)+f_{y}^{2}\left(x_{0}, y_{0}, z_{0}\right)+f_{y}^{2}\left(x_{0}, y_{0}, z_{0}\right)}}\left(f_{x}\left(x_{0}, y_{0}, z_{0}\right), f_{y}\left(x_{0}, y_{0}, z_{0}\right)\right) \\ &amp;amp;=\frac{\nabla f\left(x_{0}, y_{0}, z_{0}\right)}{\left|\nabla f\left(x_{0}, y_{0}, z_{0}\right)\right|} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h3 id="标量场f-mathbfrm-rightarrow-mathbfr">标量场&lt;span class="math inline">\(f: \mathbf{R}^{m} \rightarrow \mathbf{R}\)&lt;/span>&lt;/h3>
&lt;p>如果对于空间区域G内的任意一点M，都有一个确定的数量&lt;span class="math inline">\(f(M)\)&lt;/span>，那么称在这片区域G中确定了一个数量场（如温度场、密度场等）。 一个数量场可以用一个数量函数&lt;span class="math inline">\(f(M)\)&lt;/span>来确定。&lt;/p>
&lt;h3 id="矢量场f-mathbfrm-rightarrow-mathbfrn">矢量场&lt;span class="math inline">\(f: \mathbf{R}^{m} \rightarrow \mathbf{R}^{n}\)&lt;/span>&lt;/h3>
&lt;p>如果对于空间区域G内的任意一点M，如果与M对应的是一个向量&lt;span class="math inline">\(\boldsymbol F(M)\)&lt;/span>,那么称在这片区域中确定了 一个矢量场/向量场。（如力场、速度场等） 一个向量场可用一个向量值函数&lt;span class="math inline">\(\boldsymbol F(M)\)&lt;/span>来确定。&lt;/p>
&lt;p>如果向量场&lt;span class="math inline">\(\boldsymbol F(M)\)&lt;/span>恰好是某个数量函数&lt;span class="math inline">\(f(M)\)&lt;/span>的梯度，即&lt;span class="math inline">\(\boldsymbol F(M) = \nabla f(M)\)&lt;/span>，这样的向量场&lt;span class="math inline">\(\boldsymbol F(M)\)&lt;/span>称为&lt;strong>势场&lt;/strong>，对应数量函数&lt;span class="math inline">\(f(M)\)&lt;/span>称为&lt;strong>势函数&lt;/strong>&lt;/p>
&lt;p>例如： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200708115323459.png" alt="image-20200708115323459" style="zoom: 67%;" /> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200708115413718.png" alt="image-20200708115413718" style="zoom:67%;" />&lt;/p></description></item><item><title>高等数学-多元微分学-代数应用：多元函数的极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/</link><pubDate>Sun, 05 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微分学-代数应用多元函数的极值与最值">高等数学-多元微分学-代数应用：多元函数的极值与最值&lt;/h1>
&lt;h2 id="代数应用多元函数的极值">代数应用：多元函数的极值&lt;/h2>
&lt;p>极值/最值问题，其实就是&lt;strong>最优化问题&lt;/strong>。&lt;/p>
&lt;p>注意：极值问题，&lt;strong>可能取值的的位置&lt;/strong>，包括&lt;strong>驻点、不可导点、边界点&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>无条件极值&lt;/strong>的定义域为&lt;strong>开区域&lt;/strong>，&lt;strong>考虑的是&lt;/strong>定义域内的&lt;strong>驻点&lt;/strong>是否&lt;strong>取极值&lt;/strong>。 &lt;strong>条件极值&lt;/strong>多了约束，考虑的是&lt;strong>有约束&lt;/strong>的情况下是否&lt;strong>取极值&lt;/strong>。（如果约束正好是对应无条件极值的边界，则条件极值考虑的是边界点是否取极值）&lt;/p>
&lt;p>&lt;strong>例如&lt;/strong>求 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在区域 &lt;span class="math inline">\(D=\left\{(x, y) \mid x^{2}+4 y^{2} \leqslant 4\right\}\)&lt;/span> 上的极值/最值。 可以拆成两部分来求： 在区域 &lt;span class="math inline">\(D_1=\left\{(x, y) \mid x^{2}+4 y^{2} &amp;lt; 4\right\}\)&lt;/span> 上找到所有的驻点判断是否取极值（求非条件极值） 在区域 &lt;span class="math inline">\(D_2=\left\{(x, y) \mid x^{2}+4 y^{2} = 4\right\}\)&lt;/span> 上，即给定约束&lt;span class="math inline">\(x^{2}+4 y^{2} = 4\)&lt;/span>的条件下，求函数的极值（求条件极值）&lt;/p>
&lt;p>实际问题中，很多问题只在开区域内取最值，这个时候，可以不考虑在边界上取极值的情况（不用考虑条件极值）&lt;/p>
&lt;h3 id="多元函数极值的概念">多元函数极值的概念&lt;/h3>
&lt;table>
&lt;colgroup>
&lt;col style="width: 13%" />
&lt;col style="width: 43%" />
&lt;col style="width: 43%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>一元函数&lt;/th>
&lt;th>多元函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>极值的定义&lt;/td>
&lt;td>函数&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>的某邻域内有定义，对于&lt;strong>该邻域内的任意点x，恒有&lt;span class="math inline">\(f(x)&amp;gt;f(x_0)\)&lt;/span>,称&lt;span class="math inline">\(f(x_0)\)&lt;/span>为极小值&lt;/strong>。若邻域内任意点，恒有&lt;span class="math inline">\(f(x&amp;lt;f(x_0)\)&lt;/span>,称&lt;span class="math inline">\(f(x_0)\)&lt;/span>为极大值。&lt;/td>
&lt;td>设函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 点的某邻域内有定义,如果对于该邻城内异于 &lt;span class="math inline">\(P\left(x_{0},y_{0}\right)\)&lt;/span> 点的任一点 &lt;span class="math inline">\(Q(x, y),\)&lt;/span> 恒有&lt;span class="math inline">\(f(x, y)&amp;gt;f\left(x_{0}, y_{0}\right) \quad\left(\text { 或 } f(x, y)&amp;lt;f\left(x_{0}, y_{0}\right)\right)\)&lt;/span>，则称 &lt;span class="math inline">\(f\left(x_{0}, y_{0}\right)\)&lt;/span> 为 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 的&lt;strong>极小值&lt;/strong>(或极大值) ， 极大值与极小值统称极值. 使函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 取极值的自变量 &lt;span class="math inline">\(x, y\)&lt;/span> 的值,称为 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 的&lt;strong>极值点&lt;/strong>.&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>驻点&lt;/td>
&lt;td>一阶导数为0的点&lt;/td>
&lt;td>使各个偏导数都为0的点&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>极值的第一充分条件&lt;/td>
&lt;td>一元函数极值的第一充分条件：函数在某点&lt;strong>连续&lt;/strong>，该点&lt;strong>左侧导数大于0&lt;/strong>，&lt;strong>右侧导数小于0&lt;/strong>，则该点取得&lt;strong>极大值&lt;/strong>；&lt;br />函数在某点连续，该点左侧导数小于0，右侧导数大于0，则该点取得极小值&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>极值的第二充分条件&lt;/td>
&lt;td>一元函数极值的第二充分条件：函数在某点的&lt;strong>一阶导数等于0，二阶导数不等于0&lt;/strong>。若该点的二阶导数大于0，该点取得极小值；若该点的二阶导数小于0，则该点取得极大值&lt;/td>
&lt;td>（&lt;strong>多元函数取极值的充分条件&lt;/strong>）设 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的某邻域内有连续的二阶 偏导数，且&lt;span class="math display">\[\begin{array}{c}f_{x}^{\prime}\left(x_{0}, y_{0}\right)=0, f_{y}^{\prime}\left(x_{0}, y_{0}\right)=0 \\B^2 - AC = {\left[f_{x y}^{\prime \prime}\left(x_{0}, y_{0}\right)\right]^{2}-f_{xx}^{\prime \prime}\left(x_{0}, y_{0}\right) \cdot f_{yy}^{\prime \prime}\left(x_{0}, y_{0}\right)&amp;lt;0}\end{array}\]&lt;/span>&lt;br/>则 &lt;span class="math inline">\(\quad P\left(x_{0}, y_{0}\right)\)&lt;/span> 是 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 的一个初值点.&lt;br/>&lt;span class="math inline">\(1^{\circ} \quad\)&lt;/span> 若 &lt;span class="math inline">\(f_{xx}^{\prime \prime}\left(x_{0}, y_{0}\right)&amp;gt;0\)&lt;/span> (或 $ f_{yy}^{}(x_{0}, y_{0})&amp;lt;0$ )为极小值点. &lt;br/>&lt;span class="math inline">\(2^{\circ} \quad\)&lt;/span> 若 &lt;span class="math inline">\(f_{xx}^{\prime \prime}\left(x_{0}, y_{0}\right)&amp;lt;0\)&lt;/span> (或 $ f_{yy}^{}(x_{0}, y_{0})&amp;gt;0$ )为极小值点.&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>极值的必要条件&lt;/td>
&lt;td>&lt;span class="math inline">\(x=x_{0}\)&lt;/span>处取得极值，且可导 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 导数为零：&lt;span class="math inline">\(f^{\prime}\left(x_{0}\right)=0\)&lt;/span>&lt;/td>
&lt;td>（&lt;strong>取极值的必要条件&lt;/strong>） 设 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的一阶偏导数存在,且 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 是 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 的极值点，则&lt;br/>&lt;span class="math inline">\(\left\{\begin{array}{l}f^{\prime}_{x}\left(x_{0}, y_{0}\right)=0 \\f_{y}^{\prime}\left(x_{0}, y_{0}\right)=0\end{array}\right.\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>无条件极值，函数中的自变量只受定义域约束的极值问题&lt;/p>
&lt;p>条件极值，函数中的自变量除了受定义域约束，还有其他约束条件的极值问题。&lt;/p>
&lt;p>注意：极值问题，&lt;strong>可能取值的的位置&lt;/strong>，包括&lt;strong>驻点、不可导点、边界点&lt;/strong>。&lt;/p>
&lt;h3 id="无条件极值">无条件极值&lt;/h3>
&lt;p>注意，无条件极值的定义域为开区域。&lt;/p>
&lt;p>注意：极值问题，&lt;strong>可能取值的的位置&lt;/strong>，包括&lt;strong>驻点、不可导点、边界点&lt;/strong>。 无条件极值考虑的是开区域中的驻点是否取极值。实际问题中，一些实际情况可以只可能在开区域内取最值，则不考虑边界点。&lt;/p>
&lt;p>若二元函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 有连续二阶偏导数,则可按以下方法求它的极值： 第一步 : 令 &lt;span class="math inline">\(f_{x}^{\prime}(x, y)=0, f_{y}^{\prime}(x, y)=0\)&lt;/span> 求得所有驻点. 第二步 :对每个驻点求出二阶偏导数&lt;span class="math inline">\(A=f_{x x}^{\prime \prime}\left(x_{0}, y_{0}\right), B=f_{x y}^{\prime \prime}\left(x_{0}, y_{0}\right), C=f_{x y}^{\prime \prime}\left(x_{0}, y_{0}\right)\)&lt;/span> 第三步 :利用极值充分条件, 通过 &lt;span class="math inline">\(A C-B^{2}\)&lt;/span> 的正负对驻点 &lt;span class="math inline">\(\left(x_{0}, y_{0}\right)\)&lt;/span> 作判定.&lt;/p>
&lt;h3 id="条件极值">条件极值&lt;/h3>
&lt;p>参考：高数同济7版，李永乐复习全书，陈文灯考研复习指南 参考：https://zhuanlan.zhihu.com/p/67327634&lt;/p>
&lt;p>条件极值，其实就是有等式约束的&lt;strong>最优化问题&lt;/strong>。&lt;/p>
&lt;h4 id="条件极值求法1消元法">条件极值求法1：消元法&lt;/h4>
&lt;p>条件极值的求法1：函数中&lt;strong>利用约束条件消元&lt;/strong>，条件极值转化为非条件极值。&lt;/p>
&lt;h4 id="条件极值求法2拉格朗日乘数法">条件极值求法2：拉格朗日乘数法&lt;/h4>
&lt;p>条件极值的求法2：&lt;strong>拉格朗日乘数法&lt;/strong>：利用已知函数和约束条件，构造拉格朗日函数。&lt;/p>
&lt;p>&lt;strong>拉格朗日乘数法&lt;/strong>&lt;/p>
&lt;p>要找函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在附加条件 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 下的可能极 值点,可以先作拉格朗日函数 &lt;span class="math inline">\(L(x, y)=f(x, y)+\lambda \varphi(x, y)\)&lt;/span> 其中$ $为参数. 求其对 x 与 y 的一阶偏导数，并使之为零,然后与方程 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 联 立起来： &lt;span class="math inline">\(\left\{\begin{array}{l} f_{x}(x, y)+\lambda \varphi_{x}(x, y)=0 \\ f_{y}(x, y)+\lambda \varphi_{y}(x, y)=0 \\ \varphi(x, y)=0 \end{array}\right.\)&lt;/span> 由这方程组解出 &lt;span class="math inline">\(x, y\)&lt;/span> 及 &lt;span class="math inline">\(\lambda,\)&lt;/span> 这样得到的 &lt;span class="math inline">\((x, y)\)&lt;/span> 就是函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在附加条件 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 下的可能极值点.&lt;/p>
&lt;p>&lt;strong>拉格朗日乘数法的证明&lt;/strong>&lt;/p>
&lt;p>先讨论函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在附加条件 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 下取极值的必要条件。 设函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>取极值，则&lt;span class="math inline">\(\varphi(x_0, y_0)=0\)&lt;/span> 由 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 可以确定一个函数&lt;span class="math inline">\(y= \psi(x)\)&lt;/span>， 则&lt;span class="math inline">\(z=f(x, y)= f(x,\psi(x))\)&lt;/span> 则函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>取极值等价于一元函数&lt;span class="math inline">\(z= f(x,\psi(x))\)&lt;/span>在&lt;span class="math inline">\(x= x_0\)&lt;/span>取极值。 由一元可导函数取极值的必要条件得&lt;span class="math inline">\(\left.\frac{\mathrm{d} z}{\mathrm{d} x}\right|_{x=x_{0}}=f_{x}\left(x_{0}, y_{0}\right)+\left.f_{y}\left(x_{0}, y_{0}\right) \frac{\mathrm{d} y}{\mathrm{d} x}\right|_{x=x_{0}}=0\)&lt;/span> 又对 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 运用隐函数求导公式得&lt;span class="math inline">\(\left.\frac{\mathrm{d} y}{\mathrm{d} x}\right|_{x=x_{0}}=-\frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}\)&lt;/span>，将其代入上一式， 得&lt;span class="math inline">\(f_{x}\left(x_{0}, y_{0}\right)-f_{,}\left(x_{0}, y_{0}\right) \frac{\varphi_{x}\left(x_{0}, y_{0}\right)}{\varphi_{y}\left(x_{0}, y_{0}\right)}=0\)&lt;/span> 设 &lt;span class="math inline">\(\frac{f_{y}\left(x_{0}, y_{0}\right)}{\varphi,\left(x_{0}, y_{0}\right)}=-\lambda,\)&lt;/span> 上述必要条件就变为 &lt;span class="math inline">\(\left\{\begin{array}{l}f_{x}\left(x_{0}, y_{0}\right)+\lambda \varphi_{x}\left(x_{0}, y_{0}\right)=0 \\ f_{y}\left(x_{0}, y_{0}\right)+\lambda \varphi_{y}\left(x_{0}, y_{0}\right)=0 \\ \varphi\left(x_{0}, y_{0}\right)=0\end{array}\right.\)&lt;/span> 若引进辅助函数&lt;span class="math inline">\(L(x, y)=f(x, y)+\lambda \varphi(x, y)\)&lt;/span> 则函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在附加条件 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 下取极值的必要条件即为 &lt;span class="math inline">\(\left\{\begin{array}{l}f_{x}(x, y)+\lambda \varphi_{x}(x, y)=0 \\ f_{y}(x, y)+\lambda \varphi_{y}(x, y)=0 \\ \varphi(x, y)=0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>拉格朗日乘数法的推广&lt;/strong>&lt;/p>
&lt;p>这方法还可以推广到自变量多于两个而条件多于一个的情形. 例如,要求函数￥&lt;span class="math inline">\(u=f(x, y, z, t)\)&lt;/span> 在附加条件&lt;span class="math inline">\(\varphi(x, y, z, t)=0, \quad \psi(x, y, z, t)=0\)&lt;/span> 下的极值,可以先作拉格朗日函数&lt;span class="math inline">\(L(x, y, z, t)=f(x, y, z, t)+\lambda \varphi(x, y, z, t)+\mu \psi(x, y, z, t)\)&lt;/span> 其中 $, $均为参数,求其一阶偏导数,并使之为零,然后与两个附加条件联立起来求解 ,这样得出的 &lt;span class="math inline">\((x, y, z, t)\)&lt;/span> 就是函数 &lt;span class="math inline">\(f(x, y, z, t)\)&lt;/span> 在附加条件&lt;span class="math inline">\(\varphi(x, y, z, t)=0, \quad \psi(x, y, z, t)=0\)&lt;/span>的可能极值点。&lt;/p>
&lt;p>&lt;strong>拉格朗日乘数法的例子&lt;/strong>&lt;/p>
&lt;p>例1 求函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在条件 &lt;span class="math inline">\(\varphi(x, y)=0\)&lt;/span> 下的极值&lt;/p>
&lt;p>先构造拉格朗日函数 &lt;span class="math inline">\(F(x, y, \lambda)=f(x, y)+\lambda \varphi(x, y)\)&lt;/span>,然后解方程组 &lt;span class="math inline">\(\left\{\begin{array}{l} \frac{\partial F}{\partial x}=\frac{\partial f}{\partial x}+\lambda \frac{\partial \varphi}{\partial x}=0 \\ \frac{\partial F}{\partial y}=\frac{\partial f}{\partial y}+\lambda \frac{\partial \varphi}{\partial y}=0 \\ \frac{\partial F}{\partial \lambda}=\varphi(x, y)=0 \end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>方程组的解，就是可能的极值点&lt;/p>
&lt;p>例2 求函数 &lt;span class="math inline">\(f(x, y, z)\)&lt;/span> 在条件 &lt;span class="math inline">\(\varphi(x, y, z)=0, \psi(x, y, z)=0\)&lt;/span> 下的极值&lt;/p>
&lt;p>构造拉格朗日函数，&lt;span class="math inline">\(F(x, y, z, \lambda, \mu)=f(x, y, z)+\lambda \varphi(x, y, z)+\mu \psi(x, y, z)\)&lt;/span> 对函数求各个方向的偏导=0，联立方程组求解，方程组的解，就是可能的极值点。&lt;/p></description></item><item><title>高等数学-多元微分学</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</link><pubDate>Fri, 03 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微分学">高等数学-多元微分学&lt;/h1>
&lt;h2 id="极限连续性偏导数全微分定义及性质">极限、连续性、偏导数、全微分定义及性质&lt;/h2>
&lt;p>多元函数是有多个自由变量的函数，在其上可以定义距离的概念。可以考虑函数的极限、连续性、可导可微性。&lt;/p>
&lt;h3 id="多元函数的极限">多元函数的极限&lt;/h3>
&lt;p>以二元函数为例，&lt;span class="math inline">\(\lim _{x \rightarrow x_{0} \atop y \rightarrow y_{0}} f(x, y)=A \Leftrightarrow \forall \varepsilon&amp;gt;0, \exists \delta&amp;gt;0,\)&lt;/span> 当 &lt;span class="math inline">\(0&amp;lt;\sqrt{\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}}&amp;lt;\delta\)&lt;/span> 时，恒有 &lt;span class="math inline">\(\quad|f(x, y)-A|&amp;lt;\varepsilon\)&lt;/span>&lt;/p>
&lt;h3 id="极限性质">极限性质&lt;/h3>
&lt;table>
&lt;colgroup>
&lt;col style="width: 8%" />
&lt;col style="width: 43%" />
&lt;col style="width: 43%" />
&lt;col style="width: 4%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>一元函数&lt;/th>
&lt;th>多元函数&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>定理&lt;/td>
&lt;td>极限&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(f\left(x_{0}^{-}\right)=f\left(x_{0}^{+}\right)=A\)&lt;/span>&lt;/td>
&lt;td>极限&lt;span class="math inline">\(\lim _{x \rightarrow x_{0} \atop y \rightarrow y_{0}} f(x, y)=A\)&lt;/span>存在，&lt;span class="math inline">\(\Rightarrow\)&lt;/span> 从各路径趋于&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>的函数值&lt;span class="math inline">\(f(x,y)\)&lt;/span>都等于A；&lt;br />逆否命题也成立：若存在两条路径取得的极限值不同，则极限不存在&lt;/td>
&lt;td>不相同&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>极限运算法则&lt;/td>
&lt;td>有理运算、复合运算&lt;/td>
&lt;td>有理运算、复合运算&lt;/td>
&lt;td>相同&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>性质&lt;/td>
&lt;td>保号性、夹逼性、局部有界性、极限和无穷小的关系&lt;/td>
&lt;td>保号性、夹逼性、局部有界性、极限和无穷小的关系&lt;/td>
&lt;td>相同&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>多元函数证明极限存在，只能通过极限定义证明。多元函数证明极限不存在，可选两条路径证明趋于&lt;span class="math inline">\((x_0, y_0)\)&lt;/span>时函数值&lt;span class="math inline">\(f(x,y)\)&lt;/span>不相等。&lt;/p>
&lt;h3 id="多元函数的连续性">多元函数的连续性&lt;/h3>
&lt;p>简言之，函数值等于极限值，即连续。&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 21%" />
&lt;col style="width: 39%" />
&lt;col style="width: 39%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>一元函数&lt;/th>
&lt;th>多元函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>连续性的定义&lt;/td>
&lt;td>函数&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>的邻域内有定义(在定义域内)，且&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=f\left(x_{0}\right)\)&lt;/span>，则函数&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>连续&lt;/td>
&lt;td>函数&lt;span class="math inline">\(f(x,y)\)&lt;/span>在&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>的邻域内有定义(在定义域内)，且&lt;span class="math inline">\(\lim _{x \rightarrow x_{0} \atop y \rightarrow y_{0}} f(x, y)=A\)&lt;/span>，则函数&lt;span class="math inline">\(f(x,y)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>连续&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>连续函数定理（性质）&lt;/td>
&lt;td>有界性定理、最值定理、介值定理&lt;/td>
&lt;td>有界性定理、最值定理、介值定理&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>连续函数的和差积商与复合（性质）&lt;/td>
&lt;td>连续函数的和差积商均是连续函数，连续函数的复合函数仍为连续函数&lt;/td>
&lt;td>连续函数的和差积商均是连续函数，连续函数的复合函数仍为连续函数&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>初等函数的连续性&lt;/td>
&lt;td>一元初等函数在其定义域内处处连续&lt;/td>
&lt;td>多元初等函数在其定义域内处处连续&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="偏导数">偏导数&lt;/h3>
&lt;p>一元函数研究函数的变化率时，引入了导数概念。研究多元函数的变化率时，先从一个变量看起。即首先考虑多元&lt;strong>函数沿某一自变量的变化率&lt;/strong>。&lt;/p>
&lt;h4 id="偏导数的定义">偏导数的定义&lt;/h4>
&lt;p>以多元函数的某一变元做看作变量，而其他变元暂时看作常量，用一元微分学方式求导，得到的就是偏导数。&lt;/p>
&lt;p>以二元函数为例，设 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> 的某邻域内有定义，给&lt;strong>自变量 &lt;span class="math inline">\(x\)&lt;/span> 以增量 &lt;span class="math inline">\(\Delta x,\)&lt;/span> 而 &lt;span class="math inline">\(y\)&lt;/span> 保持不变&lt;/strong>(即 &lt;span class="math inline">\(\left.y=y_{0}\right),\)&lt;/span> 相应地得到函数关于 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>偏增量&lt;/strong>&lt;span class="math inline">\(\Delta_{x} z=f\left(x_{0}+\Delta x, y_{0}\right)-f\left(x_{0}, y_{0}\right)\)&lt;/span> 如果&lt;strong>极限&lt;/strong>&lt;span class="math inline">\(\lim _{\Delta x \rightarrow 0} \frac{\Delta_{x} z}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x, y_{0}\right)-f\left(x_{0}, y_{0}\right)}{\Delta x}\)&lt;/span>存在，则该被&lt;strong>极限值&lt;/strong>就称为 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P_{0}\left(x_{0}, y_{0}\right)\)&lt;/span> 改对变量 &lt;span class="math inline">\(x\)&lt;/span> 的&lt;strong>偏导数&lt;/strong>,记为&lt;span class="math inline">\(\frac{\partial z}{\partial x} \mid\left(x_{0}, y_{0}\right), \frac{\partial f\left(x_{0}, y_{0}\right)}{\partial x}\)&lt;/span> 或 &lt;span class="math inline">\(f_{x}^{\prime}\left(x_{0}, y_{0}\right)\)&lt;/span>&lt;/p>
&lt;p>即&lt;span class="math inline">\(f_{x}^{\prime}\left(x_{0}, y_{0}\right)=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x, y_{0}\right)-f\left(x_{0}, y_{0}\right)}{\Delta x}\)&lt;/span>&lt;/p>
&lt;p>同理&lt;span class="math inline">\(f^{\prime}_{y}\left(x_{0}, y_{0}\right)=\lim _{\Delta y \rightarrow 0} \frac{f\left(x_{0}, y_{0}+\Delta y\right)-f\left(x_{0}, y_{0}\right)}{\Delta y}\)&lt;/span>&lt;/p>
&lt;p>对于一元函数来说，&lt;span class="math inline">\(\frac{dy}{dx}\)&lt;/span>可以看作函数微分&lt;span class="math inline">\(dy\)&lt;/span>与自变量微分&lt;span class="math inline">\(dx\)&lt;/span>的商。而&lt;strong>偏微分的记号是一个整体记号&lt;/strong>，不能看作分子分母之商。（如高等数学-多元微分学习题.md#偏微分的计算#例5）&lt;/p>
&lt;h4 id="偏导数的几何意义">偏导数的几何意义&lt;/h4>
&lt;p>沿特定轴向的斜率&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200712011604756.png" alt="" />&lt;figcaption>image-20200712011604756&lt;/figcaption>
&lt;/figure>
&lt;h4 id="高阶偏导数">高阶偏导数&lt;/h4>
&lt;p>&lt;strong>二阶偏导数&lt;/strong>为例：&lt;/p>
&lt;p>&lt;span class="math inline">\(\frac{\partial}{\partial x}\left(\frac{\partial z}{\partial x}\right)=\frac{\partial^{2} z}{\partial x^{2}}=f_{x x}(x, y), \quad \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial x}\right)=\frac{\partial^{2} z}{\partial x \partial y}=f_{x y}(x, y)\)&lt;/span> &lt;span class="math inline">\(\frac{\partial}{\partial x}\left(\frac{\partial z}{\partial y}\right)=\frac{\partial^{2} z}{\partial y \partial x}=f_{y x}(x, y), \quad \frac{\partial}{\partial y}\left(\frac{\partial z}{\partial y}\right)=\frac{\partial^{2} z}{\partial y^{2}}=f_{y}(x, y)\)&lt;/span>&lt;/p>
&lt;p>定理 &lt;span class="math inline">\(\quad\)&lt;/span> 如果函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 的两个&lt;strong>二阶混合偏导数&lt;/strong> &lt;span class="math inline">\(\frac{\partial^{2} z}{\partial y \partial x}\)&lt;/span> 及 &lt;span class="math inline">\(\frac{\partial^{2} z}{\partial x \partial y}\)&lt;/span> 在区域 &lt;span class="math inline">\(D\)&lt;/span> 内 &lt;strong>连续&lt;/strong>, 那么在该区域内这两个二阶&lt;strong>混合偏导数&lt;/strong>必相等。&lt;/p>
&lt;h3 id="偏导数的计算">偏导数的计算&lt;/h3>
&lt;p>对于一元函数来说，&lt;span class="math inline">\(\frac{dy}{dx}\)&lt;/span>可以看作函数微分&lt;span class="math inline">\(dy\)&lt;/span>与自变量微分&lt;span class="math inline">\(dx\)&lt;/span>的商。而&lt;strong>偏微分的记号是一个整体记号&lt;/strong>，不能看作分子分母之商。（如高等数学-多元微分学习题.md#偏微分的计算#例5）&lt;/p>
&lt;h4 id="普通多元函数偏导数的计算">普通多元函数偏导数的计算&lt;/h4>
&lt;p>由于偏导数只有一个变量在动，其他变量看作常量，按一元函数求微分的方式计算即可。&lt;/p>
&lt;h4 id="多元复合函数偏导数的计算">多元复合函数偏导数的计算&lt;/h4>
&lt;p>概括起来就是：链式求导法则计算&lt;/p>
&lt;h5 id="复合函数zfuv连续可偏导-uvarphi-t-v-psit">复合函数&lt;span class="math inline">\(z=f(u,v)\)&lt;/span>连续可偏导, &lt;span class="math inline">\(u=\varphi (t), v = \psi(t)\)&lt;/span>&lt;/h5>
&lt;p>&lt;span class="math inline">\(\frac{\mathrm{d} z}{\mathrm{d} t}=\frac{\partial z}{\partial u} \frac{\mathrm{d} u}{\mathrm{d} t}+\frac{\partial z}{\partial v} \frac{\mathrm{d} v}{\mathrm{d} t}\)&lt;/span>&lt;/p>
&lt;h5 id="复合函数zfuv连续可偏导-uxy-v-xy">复合函数&lt;span class="math inline">\(z=f(u,v)\)&lt;/span>连续可偏导,$ u=(x,y), v = (x,y)$&lt;/h5>
&lt;p>&lt;span class="math inline">\(\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u} \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v} \frac{\partial v}{\partial x}\)&lt;/span> &lt;span class="math inline">\(\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u} \frac{\partial u}{\partial y}+\frac{\partial z}{\partial v} \frac{\partial v}{\partial y}\)&lt;/span>&lt;/p>
&lt;h5 id="复合函数zfuv连续可偏导-uxy-v-y">复合函数&lt;span class="math inline">\(z=f(u,v)\)&lt;/span>连续可偏导,$ u=(x,y), v = (y)$&lt;/h5>
&lt;p>&lt;span class="math inline">\(\frac{\partial z}{\partial x}=\frac{\partial z}{\partial u} \frac{\partial u}{\partial x}\)&lt;/span> &lt;span class="math inline">\(\frac{\partial z}{\partial y}=\frac{\partial z}{\partial u} \frac{\partial u}{\partial y}+\frac{\partial z}{\partial v} \frac{\mathrm{d} v}{\mathrm{d} y}\)&lt;/span>&lt;/p>
&lt;h5 id="在坐标变换中的应用">在坐标变换中的应用&lt;/h5>
&lt;h6 id="算子对函数的操作在不同坐标系中的转换">算子（对函数的操作）在不同坐标系中的转换&lt;/h6>
&lt;p>&lt;strong>拉普拉斯算子&lt;/strong>在直角坐标系与柱坐标系中的转换&lt;/p>
&lt;p>参考：&lt;a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90">拉普拉斯算子的百度百科&lt;/a>&lt;/p>
&lt;p>高数同济第七版P82的证明：&lt;/p>
&lt;p>&lt;img src="C:\Users\wangjm\AppData\Roaming\Typora\typora-user-images\image-20200704084022493.png" alt="image-20200704084022493" style="zoom: 67%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200704084151382.png" alt="image-20200704084151382" style="zoom:67%;" />&lt;/p>
&lt;p>还有csdn上博主的证明（与高数同济7的证明类似）：https://blog.csdn.net/u013102281/article/details/70800631&lt;/p>
&lt;h4 id="隐函数偏导数的计算">隐函数偏导数的计算&lt;/h4>
&lt;p>对于隐函数方程组，设有m=a+b个变量。 约束条件（函数）个数 = 受约束的变量的个数 =隐含的因变量个数，设为a； 不受约束的变量的个数 = 自变量个数 ，设为b； 则由隐函数方程组，可确定 a个b元函数。 从隐函数方程组中选定b个变量做自变量，剩余的a个变量做因变量，即a个函数。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212336213.png" alt="image-20200701212336213" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701212411343.png" alt="image-20200701212411343" style="zoom:50%;" />&lt;/p>
&lt;h5 id="方法1复合函数求导法求隐函数偏导">方法1：复合函数求导法求隐函数偏导&lt;/h5>
&lt;p>求对方程组求偏导时，记住哪些变量是自变量，哪些变量是函数，按复合函数求偏导方法求解即可。&lt;/p>
&lt;h5 id="方法2公式法求隐函数偏导">方法2：公式法求隐函数偏导&lt;/h5>
&lt;p>其实就是将复合函数求导法求隐函数的偏导数的过程，总结成了公式。&lt;/p>
&lt;p>&lt;strong>隐函数存在定理 1&lt;/strong>(两个变量的隐函数求偏导) 设函数 &lt;span class="math inline">\(F(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻域内具&lt;strong>有连续 偏导数&lt;/strong>,且隐函数&lt;span class="math inline">\(F\left(x_{0}, y_{0}\right)=0, F_{y}\left(x_{0}, y_{0}\right) \neq 0\)&lt;/span>， 则方程 &lt;span class="math inline">\(F(x, y)=0\)&lt;/span> 在点 &lt;span class="math inline">\(\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻域内恒能&lt;strong>唯一确定&lt;/strong>一个连续且具有连续导数的&lt;strong>函数 &lt;span class="math inline">\(y=f(x),\)&lt;/span>&lt;/strong> 它满足条件 &lt;span class="math inline">\(y_{0}=f\left(x_{0}\right)\)&lt;/span>， 并&lt;strong>有&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=-\frac{F_{x}}{F_y}\)&lt;/span>&lt;/strong> （可以用多元复合函数求导法简单推导）&lt;/p>
&lt;p>如果函数 &lt;span class="math inline">\(F(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻域内具&lt;strong>有连续 二阶偏导数&lt;/strong>,可利用复合函数求导法，再求一次导: &lt;span class="math inline">\(\begin{aligned} \frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}} &amp;amp;=\frac{\partial}{\partial x}\left(-\frac{F_{x}}{F_{y}}\right)+\frac{\partial}{\partial y}\left(-\frac{F_{x}}{F_{y}}\right) \frac{\mathrm{d} y}{\mathrm{d} x} \\ &amp;amp;=-\frac{F_{x x} F_{y}-F_{y x} F_{x}}{F^{2}}-\frac{F_{x y} F,-F_{yy} F_{x}}{F_{y}^{2}}\left(-\frac{F_{x}}{F}\right) \\ &amp;amp;=-\frac{F_{xx} F_{y}^{2}-2 F_{x y} F_{x} F_{y}+F_{yy} F_{x}^{2}}{F_{y}^{3}}\end{aligned}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>隐函数存在定理 2&lt;/strong> （三个变量的隐函数求偏导）设函数 &lt;span class="math inline">\(F(x, y, z)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}, z_{0}\right)\)&lt;/span> 的某一邻域具&lt;strong>有连续偏导数&lt;/strong>，且隐函数 &lt;span class="math inline">\(F\left(x_{0}, y_{0}, z_{0}\right)=0, F_{z}\left(x_{0}, y_{0}, z_{0}\right) \neq 0,\)&lt;/span> 则方程 &lt;span class="math inline">\(F(x, y, z)=0\)&lt;/span> 在 点&lt;span class="math inline">\(\left(x_{0}, y_{0}, z_{0}\right)\)&lt;/span> 的某一邻域 内恒能唯一确 定一个连 续且具有连 续偏导数的函数 &lt;span class="math inline">\(z=\)&lt;/span> &lt;span class="math inline">\(f(x, y),\)&lt;/span> 它满足条件 &lt;span class="math inline">\(z_{0}=f\left(x_{0}, y_{0}\right),\)&lt;/span> 并有 &lt;span class="math inline">\(\frac{\partial z}{\partial x}=-\frac{F_{x}}{F_{z}}, \frac{\partial z}{\partial y}=-\frac{F_{y}}{F_{z}}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>隐函数存在定理 3&lt;/strong> （4个变量2个约束的方程组求偏导）&lt;span class="math inline">\(\quad\)&lt;/span> 设 &lt;span class="math inline">\(F(x, y, u, v), G(x, y, u, v)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}, u_{0}, v_{0}\right)\)&lt;/span> 的某一邻域内具&lt;strong>有对各个变量的连续偏导数&lt;/strong>，又 &lt;span class="math inline">\(F\left(x_{0}, y_{0}, u_{0}, v_{0}\right)=0, G\left(x_{0}, y_{0}, u_{0}, v_{0}\right)=0\)&lt;/span>， 且偏导数所组成的函数行列式（或称雅可比 ( Jacobi) 式）&lt;span class="math inline">\(J=\frac{\partial(F, G)}{\partial(u, v)}=\left|\begin{array}{ll} \frac{\partial F}{\partial u} &amp;amp; \frac{\partial F}{\partial v} \\ \frac{\partial G}{\partial u} &amp;amp; \frac{\partial G}{\partial v} \end{array}\right|\)&lt;/span>在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}, u_{0}, v_{0}\right)\)&lt;/span> 不等于零, 则方程 组 &lt;span class="math inline">\(F(x, y, u, v)=0, G(x, y, u, v)=0\)&lt;/span> 在&lt;span class="math inline">\(\left(x_{0}, y_{0}, u_{0}, v_{0}\right)\)&lt;/span> 的某一邻域 内恒能唯一确定一组 连续且具有连 续偏导数的函数&lt;span class="math inline">\(u=u(x, y), v=v(x, y),\)&lt;/span> 它们满足条件 &lt;span class="math inline">\(u_{0}=u\left(x_{0}, y_{0}\right), v_{0}=v\left(x_{0}, y_{0}\right),\)&lt;/span> 并有： &lt;span class="math inline">\(\frac{\partial u}{\partial x}=-\frac{1}{J} \frac{\partial(F, G)}{\partial(x, v)}=-\frac{\left|\begin{array}{ll}F_{x} &amp;amp; F_{v} \\ G_{x} &amp;amp; G_{v}\end{array}\right|}{\left|\begin{array}{ll}F_{u} &amp;amp; F_{v} \\ G_{u} &amp;amp; G_{v}\end{array}\right|}\)&lt;/span> &lt;span class="math inline">\(\frac{\partial v}{\partial x}=-\frac{1}{J} \frac{\partial(F, G)}{\partial(u, x)}=-\frac{\left|\begin{array}{ll}F_{u} &amp;amp; F_{x} \\ G_{u} &amp;amp; G_{x}\end{array}\right|}{\left|\begin{array}{ll}F_{u} &amp;amp; F_{v} \\ G_{u} &amp;amp; G_{v}\end{array}\right|}\)&lt;/span> &lt;span class="math inline">\(\frac{\partial u}{\partial y}=-\frac{1}{J} \frac{\partial(F, G)}{\partial(y, v)}=-\frac{\left|\begin{array}{ll}F_{y} &amp;amp; F_{v} \\ G_{y} &amp;amp; G_{v}\end{array}\right|}{\left|\begin{array}{ll}F_{u} &amp;amp; F_{v} \\ G_{u} &amp;amp; G_{v}\end{array}\right|}\)&lt;/span> &lt;span class="math inline">\(\frac{\partial v}{\partial y}=-\frac{1}{J} \frac{\partial(F, G)}{\partial(u, y)}=-\frac{\left|\begin{array}{ll}F_{u} &amp;amp; F_{y} \\ G_{u} &amp;amp; G_{y}\end{array}\right|}{\left|\begin{array}{ll}F_{u} &amp;amp; F_{v} \\ G_{u} &amp;amp; G_{v}\end{array}\right|}\)&lt;/span> (以上是对方程组各自由变量求偏导，用线性代数的方法解方程组得来的。)&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 21%" />
&lt;col style="width: 39%" />
&lt;col style="width: 39%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;/th>
&lt;th>一阶偏导数&lt;/th>
&lt;th>二阶偏导数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>2个变量的隐函数（1个约束）求偏导&lt;/td>
&lt;td>&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=-\frac{F_{x}}{F_y}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\begin{aligned} \frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}} &amp;amp;=\frac{\partial}{\partial x}\left(-\frac{F_{x}}{F_{y}}\right)+\frac{\partial}{\partial y}\left(-\frac{F_{x}}{F_{y}}\right) \frac{\mathrm{d} y}{\mathrm{d} x} \\ &amp;amp;=-\frac{F_{xx} F_{y}^{2}-2 F_{x y} F_{x} F_{y}+F_{yy} F_{x}^{2}}{F_{y}^{3}}\end{aligned}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>3个变量的隐函数（1个约束）求偏导&lt;/td>
&lt;td>&lt;span class="math inline">\(\frac{\partial z}{\partial x}=-\frac{F_{x}}{F_{z}}, \frac{\partial z}{\partial y}=-\frac{F_{y}}{F_{z}}\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>4个变量2个约束的方程组求偏导&lt;/td>
&lt;td>方程组的行列式解&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="全微分">全微分&lt;/h3>
&lt;p>设函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的某邻域内有定义，给 &lt;span class="math inline">\(x, y\)&lt;/span> 在 &lt;span class="math inline">\(x_{0}, y_{0}\)&lt;/span> 处分别以增量 &lt;span class="math inline">\(\Delta x\)&lt;/span>，&lt;span class="math inline">\(\Delta y,\)&lt;/span> 相应地得到函数的&lt;strong>全增量&lt;/strong> &lt;span class="math inline">\(\Delta z,\)&lt;/span> 若全增量可表示为&lt;span class="math inline">\(\Delta z=A \Delta x+B \Delta y+o(\rho)\)&lt;/span>，其中 &lt;span class="math inline">\(A, B\)&lt;/span> 与 &lt;span class="math inline">\(\Delta x, \Delta y\)&lt;/span> 无关, &lt;span class="math inline">\(\rho=\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}, o(\rho)\)&lt;/span> 为 &lt;span class="math inline">\(\Delta x \rightarrow 0, \Delta y \rightarrow 0\)&lt;/span> 时 &lt;span class="math inline">\(\rho\)&lt;/span> 的高阶无穷小,则称函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> &lt;strong>可微&lt;/strong>， &lt;span class="math inline">\(A \Delta x+B \Delta y\)&lt;/span> 称为 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 处的&lt;strong>全微分&lt;/strong> 记为&lt;span class="math inline">\(\left.\mathrm{d} z\right|_{x_{0}, y_{0}}=\mathrm{d} f\left(x_{0}, y_{0}\right)=A \Delta x+B \Delta y\)&lt;/span>&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 7%" />
&lt;col style="width: 46%" />
&lt;col style="width: 46%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>可微的定义&lt;/th>
&lt;th>一元函数&lt;/th>
&lt;th>多元函数（二元函数为例）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>前提&lt;/td>
&lt;td>如果函数y=f（x）在点x处的某邻域内有定义，&lt;/td>
&lt;td>设函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 的某邻域内有定义，&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>全增量&lt;/td>
&lt;td>&lt;span class="math inline">\(\Delta y\)&lt;/span>是函数的增量： &lt;span class="math inline">\(\Delta y = f(x_0 + \Delta x) -f(x_0)\)&lt;/span>&lt;/td>
&lt;td>给 &lt;span class="math inline">\(x, y\)&lt;/span> 在 &lt;span class="math inline">\(x_{0}, y_{0}\)&lt;/span> 处分别以增量 &lt;span class="math inline">\(\Delta x\)&lt;/span>，&lt;span class="math inline">\(\Delta y,\)&lt;/span> 相应地得到函数的全增量 &lt;span class="math inline">\(\Delta z\)&lt;/span> ： &lt;span class="math inline">\(\Delta z = f(x_0 + \Delta x, y_0 + \Delta y) -f(x_0, y_0)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>可微&lt;/td>
&lt;td>若有&lt;span class="math inline">\(\Delta y=A \Delta x+o(\Delta x)\)&lt;/span>， 称y=f(x)在x处&lt;strong>可微&lt;/strong>， 称&lt;span class="math inline">\(d y=d f(x)=A \Delta x\)&lt;/span>为f(x)在x处的&lt;strong>微分&lt;/strong>。&lt;/td>
&lt;td>若全增量可表示为&lt;span class="math inline">\(\Delta z=A \Delta x+B \Delta y+o(\rho)\)&lt;/span>，&lt;br />其中 &lt;span class="math inline">\(A, B\)&lt;/span> 与 &lt;span class="math inline">\(\Delta x, \Delta y\)&lt;/span> 无关, &lt;br />&lt;span class="math inline">\(\rho=\sqrt{(\Delta x)^{2}+(\Delta y)^{2}}, o(\rho)\)&lt;/span> 为 &lt;span class="math inline">\(\Delta x \rightarrow 0, \Delta y \rightarrow 0\)&lt;/span> 时 &lt;span class="math inline">\(\rho\)&lt;/span> 的高阶无穷小,&lt;br />则称函数 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> &lt;strong>可微&lt;/strong>，&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>（全）微分&lt;/td>
&lt;td>又&lt;span class="math inline">\(f^{\prime}(x)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=A\)&lt;/span>，记&lt;span class="math inline">\(d x=\Delta x\)&lt;/span>，则&lt;strong>微分&lt;/strong>又可以写成&lt;strong>&lt;span class="math inline">\(\mathrm{d} y=f^{\prime}(x) \mathrm{d} x\)&lt;/span>&lt;/strong>&lt;/td>
&lt;td>&lt;span class="math inline">\(A \Delta x+B \Delta y\)&lt;/span> 称为 &lt;span class="math inline">\(f(x, y)\)&lt;/span> 在 &lt;span class="math inline">\(P\left(x_{0}, y_{0}\right)\)&lt;/span> 处的全微分，记为&lt;span class="math inline">\(\left.\mathrm{d} z\right|_{x_{0}, y_{0}}=\mathrm{d} f\left(x_{0}, y_{0}\right)=A \Delta x+B \Delta y\)&lt;/span>&lt;br />&lt;span class="math inline">\(= f_x^\prime(x_0,y_0)dx +f_y^\prime(x_0,y_0)dy\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>可微与连续、可导的关系&lt;/th>
&lt;th>一元函数&lt;/th>
&lt;th>多元函数&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>可微与连续性的关系&lt;/td>
&lt;td>可微&lt;span class="math inline">\(\Rightarrow\)&lt;/span>连续&lt;/td>
&lt;td>可微&lt;span class="math inline">\(\Rightarrow\)&lt;/span>连续&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>可微与可导的关系&lt;/td>
&lt;td>可微&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 可导&lt;/td>
&lt;td>可微&lt;span class="math inline">\(\Rightarrow\)&lt;/span> 可偏导&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>可微的充分条件&lt;/td>
&lt;td>与可导互为充要条件&lt;/td>
&lt;td>有连续偏导数（各偏导数都连续）&lt;span class="math inline">\(\Rightarrow\)&lt;/span>可微&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可用多元函数连续的定义证明&lt;strong>可微必连续&lt;/strong>（可微&lt;span class="math inline">\(\Rightarrow\)&lt;/span> 连续）&lt;/p>
&lt;p>&lt;strong>定理&lt;/strong> (可微的必要条件) 如果函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\((x, y)\)&lt;/span> &lt;strong>可微分&lt;/strong>,那么该函数在点&lt;span class="math inline">\((x, y)\)&lt;/span> 的&lt;strong>偏导数 &lt;span class="math inline">\(\frac{\partial z}{\partial x}\)&lt;/span> 与 &lt;span class="math inline">\(\frac{\partial z}{\partial y}\)&lt;/span> 必定存在&lt;/strong> &lt;span class="math inline">\(,\)&lt;/span> 且函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\((x, y)\)&lt;/span> 的全微分为&lt;span class="math inline">\(\mathrm{d} z=\frac{\partial z}{\partial x} \Delta x+\frac{\partial z}{\partial y} \Delta y\)&lt;/span> （可微&lt;span class="math inline">\(\Rightarrow\)&lt;/span> 可偏导）&lt;/p>
&lt;p>注意，（以二元函数为例）某函数的各个偏导数 &lt;span class="math inline">\(\frac{\partial z}{\partial x}\)&lt;/span> 与 &lt;span class="math inline">\(\frac{\partial z}{\partial y}\)&lt;/span> 都存在，函数的微分不一定能写成&lt;span class="math inline">\(\mathrm{d} z=\frac{\partial z}{\partial x} \Delta x+\frac{\partial z}{\partial y} \Delta y\)&lt;/span>。因为不保证剩余部分是广义距离&lt;span class="math inline">\(\rho\)&lt;/span>的高阶无穷小。（同济第七版P73有举例说明）&lt;/p>
&lt;p>&lt;strong>定理&lt;/strong> (可微的充分条件) 如果函数 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 的&lt;strong>偏导数&lt;/strong> &lt;span class="math inline">\(\frac{\partial z}{\partial x}, \frac{\partial z}{\partial y}\)&lt;/span> 在点 &lt;span class="math inline">\((x, y)\)&lt;/span> &lt;strong>连续&lt;/strong>，那么函数在该点&lt;strong>可微分&lt;/strong>。(连续可偏导&lt;span class="math inline">\(\Rightarrow\)&lt;/span> 可微)&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200701153739796.png" alt="" />&lt;figcaption>image-20200701153739796&lt;/figcaption>
&lt;/figure>
&lt;h3 id="全微分形式不变性">全微分形式不变性&lt;/h3>
&lt;p>设函数 &lt;span class="math inline">\(z=f(u, v)\)&lt;/span> 具有连续偏导数,则有全微分&lt;span class="math inline">\(\mathrm{d} z=\frac{\partial z}{\partial u} \mathrm{d} u+\frac{\partial z}{\partial v} \mathrm{d} v\)&lt;/span>， 又&lt;span class="math inline">\(u=\varphi(x, y), v=\psi(x, y)\)&lt;/span>也又连续的偏导数， 则复合函数&lt;span class="math inline">\(z=f[\varphi(x, y), \psi(x, y)]\)&lt;/span>的全微分为&lt;span class="math inline">\(\mathrm{d} z=\frac{\partial z}{\partial x} \mathrm{d} x+\frac{\partial z}{\partial y} \mathrm{d} y\)&lt;/span>， 即&lt;span class="math inline">\(\begin{aligned} \mathrm{d} z &amp;amp;=\left(\frac{\partial z}{\partial u} \frac{\partial u}{\partial x}+\frac{\partial z}{\partial v} \frac{\partial v}{\partial x}\right) \mathrm{d} x+\left(\frac{\partial z}{\partial u} \frac{\partial u}{\partial y}+\frac{\partial z}{\partial v} \frac{\partial v}{\partial y}\right) \mathrm{d} y \\ &amp;amp;=\frac{\partial z}{\partial u}\left(\frac{\partial u}{\partial x} \mathrm{d} x+\frac{\partial u}{\partial y} \mathrm{d} y\right)+\frac{\partial z}{\partial v}\left(\frac{\partial v}{\partial x} \mathrm{d} x+\frac{\partial v}{\partial y} \mathrm{d} y\right) \\ &amp;amp;=\frac{\partial z}{\partial u} \mathrm{d} u+\frac{\partial z}{\partial v} \mathrm{d} v \end{aligned}\)&lt;/span> 可见，无论是u和v作自变量还是x和y作自变量，函数f的全微分形式是一样的，这个性质叫做全微分形式不变性。&lt;/p>
&lt;h3 id="二元函数的泰勒公式">二元函数的泰勒公式&lt;/h3>
&lt;p>定理 &lt;span class="math inline">\(\quad\)&lt;/span> 设 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻域内连续且有 &lt;span class="math inline">\((n+1)\)&lt;/span> 阶连续偏导数， &lt;span class="math inline">\(\left(x_{0}+h, y_{0}+k\right)\)&lt;/span> 为此邻域内任一点 , 则有： &lt;span class="math inline">\(f\left(x_{0}+h, y_{0}+k\right)\)&lt;/span> &lt;span class="math inline">\(=f\left(x_{0}, y_{0}\right)+\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right) f\left(x_{0}, y_{0}\right)+\)&lt;/span> &lt;span class="math inline">\(\frac{1}{2 !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{2} f\left(x_{0}, y_{0}\right)+\cdots+\frac{1}{n !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{n} f\left(x_{0}, y_{0}\right)+\)&lt;/span> &lt;span class="math inline">\(\frac{1}{(n+1) !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{n+1} f\left(x_{0}+\theta h, y_{0}+\theta k\right) \quad(0&amp;lt;\theta&amp;lt;1)\)&lt;/span> ，称为&lt;strong>带皮亚诺余项的二元函数泰勒公式&lt;/strong>。其中记号 &lt;span class="math inline">\(\begin{array}{l} \left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right) f\left(x_{0}, y_{0}\right) \text { 表示 } h f_{x}\left(x_{0}, y_{0}\right)+k f_{y}\left(x_{0}, y_{0}\right) \\ \left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{2} f\left(x_{0}, y_{0}\right) \text { 表示} h^{2} f_{x x}\left(x_{0}, y_{0}\right)+2 h k f_{x y}\left(x_{0}, y_{0}\right)+k^{2} f_{y y}\left(x_{0}, y_{0}\right) \end{array}\)&lt;/span> 一般 地,记号&lt;span class="math inline">\(\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{m} f\left(x_{0}, y_{0}\right) \text { 表示 }\left. \sum_{p=0}^{m} C_{m}^{p} h^{p} k^{m-p} \frac{\partial^{m} f}{\partial x^{p} \partial y^{m-p}}\right|_{\left(x_{0} \cdot y_{0}\right)}\)&lt;/span>&lt;/p>
&lt;p>相同情况下，也可以写成&lt;strong>带拉格朗日余项的二元函数泰勒公式&lt;/strong>： 设 &lt;span class="math inline">\(z=f(x, y)\)&lt;/span> 在点 &lt;span class="math inline">\(\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻域内连续且有 &lt;span class="math inline">\((n+1)\)&lt;/span> 阶连续偏导数， &lt;span class="math inline">\(\left(x_{0}+h, y_{0}+k\right)\)&lt;/span> 为此邻域内任一点 , 则有： &lt;span class="math inline">\(f\left(x_{0}+h, y_{0}+k\right)\)&lt;/span> &lt;span class="math inline">\(=f\left(x_{0}, y_{0}\right)+\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right) f\left(x_{0}, y_{0}\right)+\frac{1}{2 !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{2} f\left(x_{0}, y_{0}\right)+\cdots+\frac{1}{n !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{n} f\left(x_{0}, y_{0}\right)+R_{n}\)&lt;/span> 其中&lt;span class="math inline">\(R_{n}=\frac{1}{(n+1) !}\left(h \frac{\partial}{\partial x}+k \frac{\partial}{\partial y}\right)^{n+1} f\left(x_{0}+\theta h, y_{0}+\theta k\right) \quad(0&amp;lt;\theta&amp;lt;1)\)&lt;/span>，是拉格朗日余项。&lt;/p>
&lt;p>由二元函数的泰勒公式可知 ,右端的 h 及 &lt;span class="math inline">\(k\)&lt;/span> 的 &lt;span class="math inline">\(n\)&lt;/span> 次多项式部分 近似表 达函数 $f(x_{0}+h, y_{0}+k) $ 时&lt;strong>,其误差为&lt;/strong> $ R_{n} $. 由假设, 函数的各 &lt;span class="math inline">\((n+1)\)&lt;/span> 阶偏导数都 连续,故它们的绝对值在点 &lt;span class="math inline">\(\left(x_{0}, y_{0}\right)\)&lt;/span> 的某一邻城内都不超过某一正常数 M. 于是，有下面的误差估计式： &lt;span class="math inline">\(\begin{aligned}\left|R_{n}\right| &amp;amp; \leqslant \frac{M}{(n+1) !}(|h|+|k|)^{n+1}=\frac{M}{(n+1) !} \rho^{n+1}\left(\frac{|h|}{\rho}+\frac{|k|}{\rho}\right)^{n+1} \\ &amp;amp; \leqslant \frac{M}{(n+1) !}(\sqrt{2})^{n+1} \rho^{n+1} \end{aligned}\)&lt;/span> 其中 &lt;span class="math inline">\(\rho=\sqrt{h^{2}+k^{2}}\)&lt;/span> 即，&lt;strong>误差 &lt;span class="math inline">\(|R_{n}|\)&lt;/span> 是当 &lt;span class="math inline">\(\rho \rightarrow 0\)&lt;/span> 时比 &lt;span class="math inline">\(\rho^{n}\)&lt;/span> 高阶的无穷小&lt;/strong>&lt;/p>
&lt;p>对于n=0，泰勒公式变成 &lt;span class="math inline">\(f\left(x_{0}+h, y_{0}+k\right)\)&lt;/span> &lt;span class="math inline">\(=f\left(x_{0}, y_{0}\right)+h f_{x}\left(x_{0}+\theta h, y_{0}+\theta k\right)+k f_{y}\left(x_{0}+\theta h, y_{0}+\theta k\right)\)&lt;/span> 称为&lt;strong>二元函数的拉格朗日中值定理&lt;/strong>。&lt;/p></description></item><item><title>高等数学-多元微积分概述</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/</link><pubDate>Fri, 03 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-多元微积分概述">高等数学-多元微积分概述&lt;/h1>
&lt;p>参考：&lt;a href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86">维基百科：多元微积分&lt;/a> 参考：&lt;a href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90">维基百科：向量分析&lt;/a>&lt;/p>
&lt;h2 id="多元函数">多元函数&lt;/h2>
&lt;p>多元函数是指&lt;a href="https://zh.wikipedia.org/wiki/定义域">定义域&lt;/a>为&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)&lt;/span>或其一部分，&lt;a href="https://zh.wikipedia.org/wiki/值域">值域&lt;/a>为&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R}\)&lt;/span>或&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)&lt;/span>}的&lt;a href="https://zh.wikipedia.org/wiki/函数">函数&lt;/a>。第二种情况可归结为第一种情况，因为它实际上可看成&lt;span class="math inline">\(\displaystyle m\)&lt;/span>个定义在&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)&lt;/span>上，值域是$ &lt;span class="math inline">\(的坐标函数。这样的函数让定义域中的每个元素（即[*n*元组](https://zh.wikipedia.org/wiki/多元组)\)&lt;/span>x=(x_{1},x_{2},,x_{n})&lt;span class="math inline">\(）对应唯一一个值域中的元素，记为\)&lt;/span>f(x)&lt;span class="math inline">\(或\)&lt;/span>f(x_{1},x_{2},,x_{n})$，如下所示：&lt;/p>
&lt;p>&lt;span class="math inline">\(\displaystyle f\colon {\begin{array}{rcl}E&amp;amp;\longrightarrow &amp;amp;F\\(x_{1},\ldots ,x_{n})&amp;amp;\longmapsto &amp;amp;f(x_{1},\ldots ,x_{n})\end{array}}\)&lt;/span>&lt;/p>
&lt;p>如果&lt;a href="https://zh.wikipedia.org/wiki/线性空间">线性空间&lt;/a>&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)&lt;/span>和&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)&lt;/span>上赋有&lt;a href="https://zh.wikipedia.org/wiki/范数">范数&lt;/a>，就可以研究这种多元函数的&lt;a href="https://zh.wikipedia.org/wiki/连续性">连续性&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/可微性">可微性&lt;/a>。如果固定除一个变量外的其他变量，多元函数的研究就可归结为值域是&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)&lt;/span>的函数。如果分别考虑坐标函数的话，甚至可归结为值域是$ $的函数。比如，这种函数的导数存在的话，就称为原来多元函数的偏导数。&lt;/p>
&lt;h2 id="多元函数的分析">多元函数的分析&lt;/h2>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/数学分析">数学分析&lt;/a>中的经典概念可以推广到多元函数，但也要引入&lt;a href="https://zh.wikipedia.org/wiki/线性代数">线性代数&lt;/a>中的概念。&lt;/p>
&lt;h3 id="极限与连续性">极限与连续性&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/函數極限">函数极限&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/連續函數">连续函数&lt;/a>&lt;/p>
&lt;p>设&lt;span class="math inline">\(\displaystyle E\)&lt;/span>是&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)&lt;/span>中的一个&lt;a href="https://zh.wikipedia.org/wiki/开集">开集&lt;/a>，&lt;span class="math inline">\(\displaystyle f\)&lt;/span>是定义在&lt;span class="math inline">\(\displaystyle E\)&lt;/span>上的函数。给&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)&lt;/span>赋予一个范数之后，就可以这样定义连续性：对&lt;span class="math inline">\(\displaystyle E\)&lt;/span>中的每个点&lt;span class="math inline">\(\displaystyle a\)&lt;/span>，&lt;span class="math inline">\(\displaystyle f\)&lt;/span>在&lt;span class="math inline">\(\displaystyle a\)&lt;/span>处连续当且仅当&lt;/p>
&lt;p>在多元微积分领域，对函数极限和连续性的研究可导致许多违反直觉的结果。例如，一些二元&lt;a href="https://zh.wikipedia.org/wiki/函数">标量函数&lt;/a>，当&lt;span class="math inline">\(\displaystyle x\)&lt;/span>，&lt;span class="math inline">\(\displaystyle y\)&lt;/span>沿不同路径（例如直线与抛物线）趋近于极限点时，函数的值不同。[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:19-22例如，函数&lt;/p>
&lt;p>沿任何直线 &lt;span class="math inline">\(\displaystyle y=kx\)&lt;/span> 趋近于原点 &lt;span class="math inline">\(\displaystyle (0,0)\)&lt;/span> 时，f趋近于0。然而，当变量x，y沿&lt;a href="https://zh.wikipedia.org/wiki/抛物线">抛物线&lt;/a> &lt;span class="math inline">\(\displaystyle y=x^{2}\)&lt;/span> 趋近于原点时，f趋近于0.5。由于沿不同路径取极限时函数值不同，故该函数在原点的极限不存在。&lt;/p>
&lt;p>每一个变量的连续不是多元函数连续的充分条件:[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:17-19 例如, 含有两个变量的实数函数 &lt;span class="math inline">\(\displaystyle f(x,y)\)&lt;/span>，对于每一个固定的 &lt;span class="math inline">\(\displaystyle y\)&lt;/span> ， &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 关于 &lt;span class="math inline">\(\displaystyle x\)&lt;/span> 的函数在其定义域内连续。同样的，对于每一个固定的 &lt;span class="math inline">\(\displaystyle x\)&lt;/span> ， &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 关于 &lt;span class="math inline">\(\displaystyle y\)&lt;/span> 的函数在其定义域也内连续，但这不能说明原函数连续。&lt;/p>
&lt;p>很容易验证，在实数域中，定义函数： &lt;span class="math inline">\(\displaystyle f_{y}(x):=f(x,y)\)&lt;/span>，则对于每一个固定的 &lt;span class="math inline">\(\displaystyle y\)&lt;/span> ，&lt;span class="math inline">\(\displaystyle f_{y}(x)\)&lt;/span> 在 $ $ 上连续。同理，函数&lt;span class="math inline">\(\displaystyle f_{x}\)&lt;/span> 也是关于 &lt;span class="math inline">\(\displaystyle y\)&lt;/span> 的连续函数。然而，函数 &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 在原点是不连续的。 考虑序列 &lt;span class="math inline">\(\displaystyle f\left({\frac {1}{n}},{\frac {1}{n}}\right)\)&lt;/span> ( &lt;span class="math inline">\(\displaystyle n\)&lt;/span> 为&lt;a href="https://zh.wikipedia.org/wiki/自然数">自然数&lt;/a>)，若在原点连续其结果应为 &lt;span class="math inline">\(\displaystyle f(0,0)=0\)&lt;/span> 。然而，通过计算知其在原点的极限为 &lt;span class="math inline">\(\displaystyle \lim _{n\to \infty }f\left({\frac {1}{n}},{\frac {1}{n}}\right)=1.\)&lt;/span>。 因此， &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 在原点不连续。&lt;/p>
&lt;h3 id="偏导数">偏导数&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/偏导数">偏导数&lt;/a>&lt;/p>
&lt;p>偏导数将导数的概念推广到更高维度。一个多变量函数的偏导数是一个相对于一个变量的导数，所有其他变量视作常数，保持不变。[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:26ff&lt;/p>
&lt;p>偏导数可以组合起来，创造出形式更复杂的导数。在&lt;a href="https://zh.wikipedia.org/wiki/向量分析">向量分析&lt;/a>中，&lt;a href="https://zh.wikipedia.org/wiki/Nabla算子">Nabla算子&lt;/a>($$)依据偏导数被用于定义这些概念：&lt;a href="https://zh.wikipedia.org/wiki/梯度">梯度&lt;/a>，&lt;a href="https://zh.wikipedia.org/wiki/散度">散度&lt;/a>，&lt;a href="https://zh.wikipedia.org/wiki/旋度">旋度&lt;/a>。在含有偏导数的矩阵中，&lt;a href="https://zh.wikipedia.org/wiki/雅可比矩阵">雅可比矩阵&lt;/a>可以用来表示任意维空间之间的函数的导数。因此，导数可理解为从函数定义域到函数值域的逐点变化的&lt;a href="https://zh.wikipedia.org/wiki/线性映射">线性映射&lt;/a>。&lt;/p>
&lt;p>含有偏导数的&lt;a href="https://zh.wikipedia.org/wiki/微分方程">微分方程&lt;/a>称为&lt;a href="https://zh.wikipedia.org/wiki/偏微分方程">偏微分方程&lt;/a>或“PDE”。这些方程较只含有一个变量的&lt;a href="https://zh.wikipedia.org/wiki/常微分方程">常微分方程&lt;/a>更难解出。[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:654ff&lt;/p>
&lt;h3 id="重积分">重积分&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/重积分">重积分&lt;/a>&lt;/p>
&lt;p>重积分将积分的概念拓展至任意数量的变量。二重积分和三重积分可用于计算平面和空间中区域的面积和体积。&lt;a href="https://zh.wikipedia.org/wiki/富比尼定理">富比尼定理&lt;/a>给出了使用逐次积分的方法计算&lt;a href="https://zh.wikipedia.org/wiki/二重积分">二重积分&lt;/a>的条件。[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:367ff&lt;/p>
&lt;p>可以用&lt;a href="https://zh.wikipedia.org/wiki/曲面积分">曲面积分&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/曲线积分">曲线积分&lt;/a>在&lt;a href="https://zh.wikipedia.org/wiki/曲面">曲面&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/曲线">曲线&lt;/a>等&lt;a href="https://zh.wikipedia.org/wiki/流形">流形&lt;/a>上进行积分。&lt;/p>
&lt;h3 id="多元微积分基本定理">多元微积分基本定理&lt;/h3>
&lt;p>在一元微积分中，微积分基本定理建立了导数与积分的联系。多元微积分中导数与积分之间的联系，体现为矢量微积分的积分定理：[&lt;a href="https://zh.wikipedia.org/wiki/多元微积分#cite_note-CourantJohn1999-1">1]&lt;/a>:543ff&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/梯度定理">梯度定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/斯托克斯定理">斯托克斯定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/高斯散度定理">高斯散度定理&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/格林公式">格林公式&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>在对多元微积分更深层次的研究中，可以认为以上四条定理是一个更一般的定理的具体表现，即&lt;a href="https://zh.wikipedia.org/wiki/斯托克斯定理#流形上的斯托克斯公式">广义斯托克斯定理&lt;/a>，后者适用于在&lt;a href="https://zh.wikipedia.org/wiki/流形">流形&lt;/a>上对&lt;a href="https://zh.wikipedia.org/wiki/微分形式">微分形式&lt;/a>进行积分。&lt;/p>
&lt;p>多元微积分基本定理将&lt;a href="https://zh.wikipedia.org/wiki/微积分基本定理">微积分基本定理&lt;/a>拓展到了更高维度：&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 32%" />
&lt;col style="width: 33%" />
&lt;col style="width: 33%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th style="text-align: center;">定理&lt;/th>
&lt;th style="text-align: center;">表示&lt;/th>
&lt;th style="text-align: center;">注解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/梯度定理">梯度定理&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \int _{L[\mathbf {p} \to \mathbf {q} ]\subset \mathbb {R} ^{n}}\nabla \varphi \cdot d\mathbf {r} =\varphi \left(\mathbf {q} \right)-\varphi \left(\mathbf {p} \right)\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">梯度（向量）场中的&lt;a href="https://zh.wikipedia.org/wiki/曲线积分">曲线积分&lt;/a>与它的标量场中两个端点的差。&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/格林定理">格林定理&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \int \!\!\!\!\int _{A\,\subset \mathbb {R} ^{2}}\left({\frac {\partial M}{\partial x}}-{\frac {\partial L}{\partial y}}\right)\,d\mathbf {A} =\oint _{\partial A}\left(L\,dx+M\,dy\right)\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">平面内向量场中区域的标量旋度，等于向量场沿逆时针方向的封闭曲线的线积分。&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/斯托克斯定理">斯托克斯定理&lt;/a>&lt;/td>
&lt;td style="text-align: center;">$!!!!&lt;em>{, ^{3}} d =&lt;/em>{} d $&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \mathbb {R} ^{3}\)&lt;/span> 内向量场的旋度的&lt;a href="https://zh.wikipedia.org/wiki/曲面">曲面&lt;/a>积分，等于向量场在曲面边界上的线积分。&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/高斯散度定理">高斯散度定理&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \int \!\!\!\!\int \!\!\!\!\int _{V\,\subset \mathbb {R} ^{3}}\left(\nabla \cdot \mathbf {F} \right)d\mathbf {V} =\)&lt;/span>$&lt;span class="math display">\[\displaystyle \scriptstyle \partial V\]&lt;/span> ; $&lt;/td>
&lt;td style="text-align: center;">向量场的散度对体积的积分，等于穿过包围体积的闭曲面&lt;a href="https://zh.wikipedia.org/wiki/通量">通量&lt;/a>的积分。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="向量分析">向量分析&lt;/h3>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/向量分析">向量分析&lt;/a>&lt;/p>
&lt;p>向量分析研究&lt;a href="https://zh.wikipedia.org/wiki/欧式空间">欧式空间&lt;/a>中足够光滑的&lt;a href="https://zh.wikipedia.org/wiki/标量场">标量&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/矢量场">矢量场&lt;/a>，即欧式空间&lt;span class="math inline">\(\displaystyle E\)&lt;/span>中的一个开集到 $ &lt;span class="math inline">\(和\)&lt;/span>E$的可微函数。因此向量分析是多元微积分的一个分支&lt;a href="https://zh.wikipedia.org/wiki/微分几何">微分几何&lt;/a>里的内容。&lt;/p>
&lt;p>不过，向量分析的重要性源自它在&lt;a href="https://zh.wikipedia.org/wiki/物理学">物理学&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/工程科學">工程科学&lt;/a>中的广泛应用，所以上面的&lt;span class="math inline">\(\displaystyle E\)&lt;/span>常限制为&lt;span class="math inline">\(\displaystyle \scriptstyle \mathbb {R} ^{3}\)&lt;/span>，即通常的三维空间。在这种语境下，矢量场给空间中的每个点赋予一个带有三个实数分量的矢量，而标量场给每个点赋予一个实数。以湖水为例，湖水各处的温度形成一标量场，而各处的速度则形成一矢量场。因此，矢量分析是&lt;a href="https://zh.wikipedia.org/wiki/流体力学">流体力学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/气象学">气象学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/静电学">静电学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/电动力学">电动力学&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/地球物理学">地球物理学&lt;/a>的基本工具。&lt;/p>
&lt;h4 id="向量运算">向量运算&lt;/h4>
&lt;h5 id="代数运算">代数运算&lt;/h5>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/向量">向量&lt;/a>&lt;/p>
&lt;p>向量分析中的基本代数（非微分）的运算称为&lt;strong>向量代数&lt;/strong>，定义在一向量空间，然后应用到整个向量场，包括：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/标量乘法">标量乘法&lt;/a>&lt;/p>
&lt;p>标量场和向量场相乘，产生向量场：$a $ ;&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/向量">向量加法&lt;/a>&lt;/p>
&lt;p>两个向量场相加，产生向量场：&lt;span class="math inline">\(\displaystyle \mathbf {v} _{1}+\mathbf {v} _{2}\)&lt;/span> ;&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/內積">内积&lt;/a>&lt;/p>
&lt;p>两个向量场相乘，产生标量场：&lt;span class="math inline">\(\displaystyle \mathbf {v} _{1}\cdot \mathbf {v} _{2}\)&lt;/span> ;&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/向量積">外积&lt;/a>&lt;/p>
&lt;p>两个向量场相乘，产生向量场：&lt;span class="math inline">\(\displaystyle \mathbf {v} _{1}\times \mathbf {v} _{2}\)&lt;/span> ;&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>还有两个&lt;a href="https://zh.wikipedia.org/wiki/三重积">三重积&lt;/a>：&lt;/p>
&lt;ul>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/三重积">标量三重积&lt;/a>&lt;/p>
&lt;p>向量和两个向量叉积的点积： &lt;span class="math inline">\(\displaystyle \mathbf {v} _{1}\cdot \left(\mathbf {v} _{2}\times \mathbf {v} _{3}\right)\)&lt;/span> ;&lt;/p>&lt;/li>
&lt;li>&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/三重积">向量三重积&lt;/a>&lt;/p>
&lt;p>向量和两个向量叉积的叉积： &lt;span class="math inline">\(\displaystyle \mathbf {v} _{1}\times \left(\mathbf {v} _{2}\times \mathbf {v} _{3}\right)\)&lt;/span> 或 &lt;span class="math inline">\(\displaystyle \left(\mathbf {v} _{3}\times \mathbf {v} _{2}\right)\times \mathbf {v} _{1}\)&lt;/span> ;&lt;/p>&lt;/li>
&lt;/ul>
&lt;p>尽管三重积不常作为基本运算，不过仍可以用内积及外积表示。&lt;/p>
&lt;h5 id="微分运算">微分运算&lt;/h5>
&lt;p>主条目：&lt;a href="https://zh.wikipedia.org/wiki/梯度">梯度&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/旋度">旋度&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/散度">散度&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/拉普拉斯算子">拉普拉斯算子&lt;/a>&lt;/p>
&lt;p>向量分析研究定义在标量场或向量场定义的不同&lt;a href="https://zh.wikipedia.org/wiki/微分算子">微分算子&lt;/a>，通常用的&lt;a href="https://zh.wikipedia.org/wiki/向量算子">向量算子&lt;/a>（∇）来表示，也被称为“Nabla算子”。向量分析的五个最重要的微分运算：&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 27%" />
&lt;col style="width: 27%" />
&lt;col style="width: 27%" />
&lt;col style="width: 16%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th style="text-align: center;">算子&lt;/th>
&lt;th style="text-align: center;">表示&lt;/th>
&lt;th style="text-align: center;">叙述&lt;/th>
&lt;th style="text-align: center;">界域&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/梯度">梯度&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \operatorname {grad} (f)=\nabla f\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">标量场 &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 于场中某点&lt;strong>增加率最大&lt;/strong>的速率与方向&lt;/td>
&lt;td style="text-align: center;">&lt;strong>标量场&lt;/strong>的梯度是&lt;strong>向量场&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/散度">散度&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \operatorname {div} ({\vec {F}})=\nabla \cdot {\vec {F}}\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">向量场 &lt;span class="math inline">\(\displaystyle {\vec {F}}\)&lt;/span> 于场中某点附近&lt;strong>发散&lt;/strong>或&lt;strong>汇聚&lt;/strong>的程度&lt;/td>
&lt;td style="text-align: center;">&lt;strong>向量场&lt;/strong>的散度是&lt;strong>标量场&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/旋度">旋度&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \operatorname {curl} ({\vec {F}})=\nabla \times {\vec {F}}\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">向量场 &lt;span class="math inline">\(\displaystyle {\vec {F}}\)&lt;/span> 于场中某点附近&lt;strong>旋转&lt;/strong>的程度&lt;/td>
&lt;td style="text-align: center;">&lt;strong>向量场&lt;/strong>的旋度是&lt;strong>向量场&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/w/index.php?title=向量拉普拉斯算子&amp;amp;action=edit&amp;amp;redlink=1">向量拉普拉斯算子&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \nabla ^{2}\mathbf {F} =\nabla (\nabla \cdot \mathbf {F} )-\nabla \times (\nabla \times \mathbf {F} )\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">均值在无穷小的球内向量场的值不同的程度&lt;/td>
&lt;td style="text-align: center;">&lt;strong>向量场&lt;/strong>的向量拉普拉斯是&lt;strong>向量场&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/拉普拉斯算子">拉普拉斯算子&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle \Delta f=\nabla ^{2}f=\nabla \cdot \nabla f\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">对标量场 &lt;span class="math inline">\(\displaystyle f\)&lt;/span> 作&lt;strong>梯度&lt;/strong>运算后，再作&lt;strong>散度&lt;/strong>运算&lt;/td>
&lt;td style="text-align: center;">&lt;strong>标量场&lt;/strong>的拉普拉斯是&lt;strong>标量场&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="多元微积分的应用">多元微积分的应用&lt;/h2>
&lt;p>这里根据定义域和值域的不同，进行划分&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 20%" />
&lt;col style="width: 26%" />
&lt;col style="width: 26%" />
&lt;col style="width: 26%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th style="text-align: center;">对象&lt;/th>
&lt;th style="text-align: center;">图示&lt;/th>
&lt;th style="text-align: center;">定义域和值域&lt;/th>
&lt;th style="text-align: center;">适用运算&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/曲线">曲线&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/File:Osculating_circle.svg">&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/84/Osculating_circle.svg/180px-Osculating_circle.svg.png" alt="Osculating circle.svg" />&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle f:\mathbb {R} \to \mathbb {R} ^{n}\)&lt;/span>for &lt;span class="math inline">\(\displaystyle n&amp;gt;1\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">曲线长度,&lt;a href="https://zh.wikipedia.org/wiki/曲线积分">曲线积分&lt;/a>,曲线&lt;a href="https://zh.wikipedia.org/wiki/曲率">曲率&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/曲面">曲面&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/File:Helicoid.svg">&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Helicoid.svg/180px-Helicoid.svg.png" alt="Helicoid.svg" />&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle f:\mathbb {R} ^{2}\to \mathbb {R} ^{n}\)&lt;/span>for &lt;span class="math inline">\(\displaystyle n&amp;gt;2\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/表面积">表面积&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/曲面积分">曲面积分&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/通量">通量&lt;/a>,曲面曲率.&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/标量场">标量场&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/File:Surface-plot.png">&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Surface-plot.png/180px-Surface-plot.png" alt="Surface-plot.png" />&lt;/a>&lt;/td>
&lt;td style="text-align: center;">$f: ^{n} $&lt;/td>
&lt;td style="text-align: center;">极大值和极小值,&lt;a href="https://zh.wikipedia.org/wiki/拉格朗日乘数">拉格朗日乘数&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/方向导数">方向导数&lt;/a>.&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/向量場">向量场&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;a href="https://zh.wikipedia.org/wiki/File:Vector_field.svg">&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c2/Vector_field.svg/180px-Vector_field.svg.png" alt="Vector field.svg" />&lt;/a>&lt;/td>
&lt;td style="text-align: center;">&lt;span class="math inline">\(\displaystyle f:\mathbb {R} ^{m}\to \mathbb {R} ^{n}\)&lt;/span>&lt;/td>
&lt;td style="text-align: center;">有关&lt;a href="https://zh.wikipedia.org/wiki/向量分析">向量分析&lt;/a>的运算,包括&lt;a href="https://zh.wikipedia.org/wiki/梯度">梯度&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/散度">散度&lt;/a>,&lt;a href="https://zh.wikipedia.org/wiki/旋度">旋度&lt;/a>.&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>高等数学-向量代数与空间解析几何</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</link><pubDate>Wed, 01 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-向量代数与空间解析几何">高等数学-向量代数与空间解析几何&lt;/h1>
&lt;p>这里先&lt;strong>引进向量的概念&lt;/strong>,根据&lt;strong>向量的线性运算建立空间坐标系&lt;/strong>,然后&lt;strong>利用坐标讨论向量的运算&lt;/strong>；并介绍空间解析几何的有关内容。&lt;/p>
&lt;p>在平面解析几何中,通过坐标法把平面上的点与一对有次序的数对应起来，把平面上的图形和方程对应起来,从而可以用代数方法来研究几何问题. &lt;strong>空间解析几何&lt;/strong>也是按照类似的方法建立起来的.通过坐标法把空间中的点与一对有次序的数对应起来，把空间里的图形和方程对应起来,从而可以用代数方法来研究几何问题.&lt;/p>
&lt;h2 id="向量及向量代数理论">向量及向量代数理论&lt;/h2>
&lt;h3 id="向量的基本概念与定义几何刻画">向量的基本概念与定义（几何刻画）&lt;/h3>
&lt;p>向量/矢量：有大小、有方向的量。分为自由向量与非自由向量。数学中研究自由向量。z 向量的表示：一般用带方向的线段表示。一般记为&lt;span class="math inline">\(\boldsymbol a, \vec{a}, \vec{AB}\)&lt;/span>&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200831203726046.png" alt="image-20200831203726046" /> 自由向量：与起点位置无关的向量。数学研究自由向量（而速度等物理量，和位置有关，不属于自由向量）&lt;/p>
&lt;p>向量相等：如果两个向量&lt;span class="math inline">\(\vec{a}\)&lt;/span>与&lt;span class="math inline">\(\vec{b}\)&lt;/span>大小相等、且方向相同，称这两个向量相等。&lt;/p>
&lt;p>向量的模：向量的大小叫做向量的模。向量&lt;span class="math inline">\(\vec{AB} , a\)&lt;/span> 和 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 的模依次记作 &lt;span class="math inline">\(|\overrightarrow{A B}|,|\boldsymbol a|\)&lt;/span> 和 &lt;span class="math inline">\(|\vec{a}|\)&lt;/span>&lt;/p>
&lt;p>单位向量：模为1的向量称为单位向量。&lt;/p>
&lt;p>向量的夹角：设有两个非零向置 &lt;span class="math inline">\(a, b,\)&lt;/span> 任取空间一点 &lt;span class="math inline">\(O,\)&lt;/span>作 &lt;span class="math inline">\(\overline{O A}=a, \overline{O B}=b,\)&lt;/span> 规定不超过 &lt;span class="math inline">\(\pi\)&lt;/span> 的 &lt;span class="math inline">\(\angle A O B\)&lt;/span> ( 设 &lt;span class="math inline">\(\varphi=\angle A O B, 0 \leqslant \varphi \leqslant \pi)\)&lt;/span> 称为向量 &lt;span class="math inline">\(a\)&lt;/span> 与 &lt;span class="math inline">\(b\)&lt;/span> 的夹角。记作 &lt;span class="math inline">\(\hat{(\boldsymbol{a}, \boldsymbol{b})}\)&lt;/span> 或 &lt;span class="math inline">\(\hat{(\boldsymbol{b}, \boldsymbol{a})},\)&lt;/span> 即 &lt;span class="math inline">\(\hat{(\boldsymbol{a}, \boldsymbol{b})}=\varphi\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200831202837187.png" alt="" />&lt;figcaption>image-20200831202837187&lt;/figcaption>
&lt;/figure>
&lt;p>向量共线/向量平行：若两个向量的起点放到一起时，当它们的终点和公共起点在一条直线上，称这两个向量共线。两平行向量一定共线，两向量共线也一定平行，两个概念等同。&lt;/p>
&lt;p>向量共面：设有&lt;span class="math inline">\(k(k\ge 3)\)&lt;/span>个向量，当它们的起点放在一起时，如果k个终点和它们的公共起点在同一平面上，就称这k个向量共面。&lt;/p>
&lt;p>而&lt;a href="#向量的坐标表示（代数刻画）">选取基矢，得到坐标系&lt;/a>后，利用&lt;a href="#向量的基本概念的坐标表示（代数刻画）">坐标表示这些概念&lt;/a>的方法，在后文介绍。&lt;/p>
&lt;h3 id="向量的线性运算与性质几何刻画">向量的线性运算与性质（几何刻画）&lt;/h3>
&lt;p>此节介绍向量线性运算的概念、定义以及性质； 而选取基矢，确定坐标系后，&lt;a href="#向量的线性运算（利用坐标运算）">利用坐标作向量的线性运算&lt;/a>的方法，在后面介绍。&lt;/p>
&lt;h4 id="向量的加法">向量的加法&lt;/h4>
&lt;p>向量相加的&lt;strong>三角形法则&lt;/strong>：设有两个向量 &lt;span class="math inline">\(\boldsymbol{a}\)&lt;/span> 与 &lt;span class="math inline">\(\boldsymbol{b},\)&lt;/span> 任取一点 &lt;span class="math inline">\(A,\)&lt;/span> 作 &lt;span class="math inline">\(\overrightarrow{A B}=a,\)&lt;/span> 月以 &lt;span class="math inline">\(B\)&lt;/span> 为起点, 作 &lt;span class="math inline">\(\overrightarrow{B C}=b\)&lt;/span>, 连接 &lt;span class="math inline">\(A C\)&lt;/span>, 那么向量 &lt;span class="math inline">\(\overrightarrow{A C}=c\)&lt;/span> 称为向母 &lt;span class="math inline">\(a\)&lt;/span> 与 &lt;span class="math inline">\(b\)&lt;/span> 的和，记作&lt;span class="math inline">\(\vec{c}=\vec{a}+\vec{b}\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200831215757966.png" alt="image-20200831215757966" />&lt;/p>
&lt;p>向量相加的&lt;strong>平行四边形法则&lt;/strong>：当向量 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 与 &lt;span class="math inline">\(\vec{b}\)&lt;/span> 不平行时,作 &lt;span class="math inline">\(\overrightarrow{A B}=\vec{a}\)&lt;/span>,&lt;span class="math inline">\(\overrightarrow{A D}=\boldsymbol{b},\)&lt;/span> 以 &lt;span class="math inline">\(A B, A D\)&lt;/span> 为边作一平行四边形 &lt;span class="math inline">\(A B C D,\)&lt;/span> 连接对角线 &lt;span class="math inline">\(A C\)&lt;/span>即等于向量 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 与 &lt;span class="math inline">\(\vec{b}\)&lt;/span> 的和 &lt;span class="math inline">\(\vec{a}+\vec{b} .\)&lt;/span> &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200831221339333.png" alt="image-20200831221339333" />&lt;/p>
&lt;h4 id="向量的减法">向量的减法&lt;/h4>
&lt;p>设&lt;span class="math inline">\(\vec{ a}\)&lt;/span> 为一向量,与 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 的模相同而方向相反的向量叫做 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 的负向量。记作 &lt;span class="math inline">\(-\vec{a}\)&lt;/span>&lt;/p>
&lt;p>规定向量&lt;span class="math inline">\(\vec{b}\)&lt;/span> 与 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 的差：&lt;span class="math inline">\(b-a=b+(-a)\)&lt;/span>.则我们可以借助向量的加法来计算减法。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200831222045275.png" alt="" />&lt;figcaption>image-20200831222045275&lt;/figcaption>
&lt;/figure>
&lt;h4 id="向量加减法性质">向量加减法性质&lt;/h4>
&lt;p>任给向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>及点O，有&lt;span class="math inline">\(\overrightarrow{A B}=\overrightarrow{A O}+\overrightarrow{O B}=\overrightarrow{O B}-\overrightarrow{O A},\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a}-\vec{a}=\vec{a}+(-\vec{a})=0\)&lt;/span>&lt;/p>
&lt;p>由三角形两边之和大于第三边，有&lt;span class="math inline">\(|a+b| \leqslant|a|+|b|\)&lt;/span>及&lt;span class="math inline">\(|a-b| \leqslant|a|+|b|\)&lt;/span>&lt;/p>
&lt;h4 id="向量与数的乘法数乘概念">向量与数的乘法（数乘）概念&lt;/h4>
&lt;p>向量&lt;span class="math inline">\(\vec{a}\)&lt;/span> 与实数 &lt;span class="math inline">\(\lambda\)&lt;/span> 的乘积记作 &lt;span class="math inline">\(\lambda \vec{a},\)&lt;/span> 规定 &lt;span class="math inline">\(\lambda \vec{a}\)&lt;/span> 是一个向量,它的模&lt;span class="math inline">\(|\lambda a|=|\lambda||a|\)&lt;/span>， 它的方向当 &lt;span class="math inline">\(\lambda&amp;gt;0\)&lt;/span> 时与 &lt;span class="math inline">\(a\)&lt;/span> 相同, 当 &lt;span class="math inline">\(\lambda&amp;lt;0\)&lt;/span> 时与 &lt;span class="math inline">\(a\)&lt;/span> 相反. 当 &lt;span class="math inline">\(\lambda=0\)&lt;/span> 时, &lt;span class="math inline">\(|\lambda \vec{a}|=0,\)&lt;/span> 即 &lt;span class="math inline">\(\lambda \vec{a}\)&lt;/span> 为零向量,这时它的方向可以是任意的.&lt;/p>
&lt;p>特别的，当 &lt;span class="math inline">\(\lambda=\pm 1\)&lt;/span> 时,有&lt;span class="math inline">\(1 \vec{a}=\vec{a},(-1) \vec{a}=-\vec{a}\)&lt;/span>&lt;/p>
&lt;h4 id="向量数乘的性质">向量数乘的性质&lt;/h4>
&lt;h5 id="结合律">结合律&lt;/h5>
&lt;p>&lt;span class="math inline">\(\lambda(\mu \vec{a})=\mu(\lambda \vec{a})=(\lambda \mu) \vec{a}\)&lt;/span>&lt;/p>
&lt;h5 id="分配律">分配律&lt;/h5>
&lt;p>&lt;span class="math inline">\((\lambda+\mu) \vec{a}=\lambda \vec{a}+\mu \vec{a}\)&lt;/span> &lt;span class="math inline">\(\lambda(\vec{a}+\vec{b})=\lambda \vec{a}+\lambda \vec{b}\)&lt;/span>&lt;/p>
&lt;h5 id="boldsymbolaboldsymbola-boldsymbole_n-quad-fracboldsymbolaboldsymbola-boldsymbole_n">&lt;span class="math inline">\(\boldsymbol{a}=|\boldsymbol{a}| \boldsymbol{{e}_{n}}, \quad \frac{\boldsymbol{a}}{|\boldsymbol{a}|}= \boldsymbol{{e}_{n}}\)&lt;/span>&lt;/h5>
&lt;h5 id="向量平行的充分必要条件">向量平行的充分必要条件&lt;/h5>
&lt;p>设向量 &lt;span class="math inline">\(\vec{a} \neq 0,\)&lt;/span> 则向量 &lt;span class="math inline">\(\vec{b}\)&lt;/span> 平行于 &lt;span class="math inline">\(\vec{a}\)&lt;/span> 的充分必要条件是 :存在唯一的实数&lt;span class="math inline">\(\lambda,\)&lt;/span> 使 &lt;span class="math inline">\(\vec{b}=\lambda \vec{a}\)&lt;/span>&lt;/p>
&lt;h3 id="向量的坐标表示代数刻画">向量的坐标表示（代数刻画）&lt;/h3>
&lt;h4 id="数轴上的点与向量坐标一一对应">数轴上的点与向量坐标一一对应&lt;/h4>
&lt;p>&lt;strong>给定一个点，一个方向及单位长度，就确定了一条数轴。&lt;/strong>&lt;/p>
&lt;p>设点 O 及单位向量 &lt;span class="math inline">\(\boldsymbol i\)&lt;/span> 确定了数轴 Ox。 对于轴上任一点 P, 对应一个向&lt;span class="math inline">\(\overrightarrow{OP}\)&lt;/span>，根据&lt;a href="#向量平行的充分必要条件">向量平行的充分必要条件&lt;/a>，必存在唯一的实数x，使得&lt;span class="math inline">\(\overrightarrow{O P}=x \boldsymbol i\)&lt;/span>，并知&lt;span class="math inline">\(\vec{OP}\)&lt;/span>和x一一对应。 即：点 &lt;span class="math inline">\(P \longleftrightarrow\)&lt;/span> 向量 &lt;span class="math inline">\(\overrightarrow{O P}=x \boldsymbol i \longleftrightarrow\)&lt;/span> 实数 &lt;span class="math inline">\(x\)&lt;/span> 即：轴上的点P与实数x有一一对应的关系，据此&lt;strong>定义x为轴上点P的坐标&lt;/strong>。 则，&lt;strong>轴上点P坐标为x&lt;span class="math inline">\(\quad\Leftrightarrow \quad\overrightarrow{O P}=x \boldsymbol i\)&lt;/span>&lt;/strong>&lt;/p>
&lt;p>需要注意的是x既是点P的坐标，又是向量&lt;span class="math inline">\(\vec{OP}\)&lt;/span>的坐标，点和向量是两个不同的概念，上下文中要注意区分。&lt;/p>
&lt;h4 id="数轴一维坐标系">数轴（一维坐标系）&lt;/h4>
&lt;p>在1维数轴上，可以选定一个方向为数轴正向的矢量（向量），作为基本矢量/基矢。 比如&lt;span class="math inline">\(\vec{AB} = (4-1)\vec{e} = 3\vec{e}\)&lt;/span>，其中3称为&lt;span class="math inline">\(\vec{AB}\)&lt;/span>的坐标。 一般情况下，有&lt;span class="math inline">\(\vec{AB} = (x_2-x_1)\vec{e}\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826003850356.png" alt="" />&lt;figcaption>image-20200826003850356&lt;/figcaption>
&lt;/figure>
&lt;h4 id="二维坐标系以及平面直角坐标系">二维坐标系以及平面直角坐标系&lt;/h4>
&lt;p>在二维平面上，可以选定某原点O，以及两个不同方向/不共线/不平行的单位矢量&lt;span class="math inline">\(\boldsymbol i, \boldsymbol j\)&lt;/span>（基本矢量/单位向量），分别确定两条数轴。&lt;/p>
&lt;p>根据向量的加法，平面内的任意向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>都可以平移到原点位置，并分解到基矢的两个数轴方向上$ = + &lt;span class="math inline">\(； 根据[向量平行的充分必要条件](#向量平行的充分必要条件)有\)&lt;/span> = _1 i, = _2 j &lt;span class="math inline">\(, 则\)&lt;/span> = _1 i + _2 j $ 即&lt;strong>二维平面中的任何向量都可以由两个基矢线性表示&lt;/strong>。 &lt;span class="math inline">\((\lambda_1, \lambda_2)\)&lt;/span>称为平面向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>在以单位向量&lt;span class="math inline">\(\boldsymbol i, \boldsymbol j\)&lt;/span>确定的坐标轴（数轴）上的&lt;strong>坐标&lt;/strong>。 二维平面中的所有向量对应的坐标，形成&lt;strong>平面坐标系&lt;/strong>&lt;/p>
&lt;p>特别的，可以以二维平面中的&lt;strong>两个互相垂直的单位向量&lt;span class="math inline">\(\boldsymbol i, \boldsymbol j\)&lt;/span>确定坐标轴&lt;/strong>，来表示平面中的任意向量。此时平面中的所有向量的坐标称为&lt;strong>平面直角坐标系&lt;/strong>。&lt;/p>
&lt;p>一般情况下，在以单位向量&lt;span class="math inline">\(\boldsymbol i, \boldsymbol j\)&lt;/span>分别确定的坐标轴形成的平面坐标系中，若平面中两点&lt;span class="math inline">\(A(x_1,y_1), B(x_2,y_2)\)&lt;/span>，则平面向量&lt;span class="math inline">\(\vec{AB} = \vec{A_1 B_1} + \vec{A_2 B_2} = (x_2 - x_1) \vec{i} + (y_2-y_1)\vec{j}\)&lt;/span>，即将&lt;span class="math inline">\(\vec{AB}\)&lt;/span>的平移&lt;span class="math inline">\((-x_1, -y_1)\)&lt;/span>到原点位置，得平面向量&lt;span class="math inline">\(AB\)&lt;/span>的坐标&lt;span class="math inline">\((x_2-x_1, y_2-y_1)\)&lt;/span>。&lt;/p>
&lt;p>需要注意的是平面中坐标为&lt;span class="math inline">\((x,y)\)&lt;/span>的点P，向量&lt;span class="math inline">\(\vec{OP}\)&lt;/span>的坐标也是&lt;span class="math inline">\((x,y)\)&lt;/span>，点和向量是两个不同的概念，上下文中要注意区分。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826004410073.png" alt="" />&lt;figcaption>image-20200826004410073&lt;/figcaption>
&lt;/figure>
&lt;h4 id="三维坐标系以及空间直角坐标系">三维坐标系以及空间直角坐标系&lt;/h4>
&lt;p>在三维空间中，可以选定三个不共面的矢量（向量）&lt;span class="math inline">\(\boldsymbol i , \boldsymbol j, \boldsymbol k\)&lt;/span>，作为基本矢量/基矢，以这三个基本矢量，可以分别确定一条数轴。类比二维的情况，根据向量的线性运算（加法与数乘），&lt;strong>空间中的任意向量都可用这三个基本矢量&lt;span class="math inline">\(\boldsymbol i , \boldsymbol j, \boldsymbol k\)&lt;/span>线性表示&lt;/strong>。 即&lt;span class="math inline">\(\vec{AB} = \lambda_1 \boldsymbol i + \lambda_2 \boldsymbol j + \lambda_3 \boldsymbol k\)&lt;/span>， 而&lt;span class="math inline">\((\lambda_1, \lambda_2, \lambda_3)\)&lt;/span>称为向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>在以单位向量&lt;span class="math inline">\(\boldsymbol i , \boldsymbol j, \boldsymbol k\)&lt;/span>确立的坐标轴（数轴）上的&lt;strong>坐标&lt;/strong>。 三维空间中的所有向量对应的坐标，形成&lt;strong>空间坐标系&lt;/strong>&lt;/p>
&lt;p>特别的，可以以三维空间中的&lt;strong>三个不共线的单位向量&lt;span class="math inline">\(\boldsymbol i, \boldsymbol j\)&lt;/span>确定坐标轴&lt;/strong>，来表示空间中的任意向量。此时空间中的所有向量的坐标，称为&lt;strong>空间直角坐标系&lt;/strong>。&lt;/p>
&lt;p>一般情况下，空间中的任意两点&lt;span class="math inline">\(A(x_1,y_1,z_1), B(x_2,y_2,z_2)\)&lt;/span>,都可形成向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>。通过将向量平移&lt;span class="math inline">\((-x_1,-y_1,-z_1)\)&lt;/span>到原点，有&lt;span class="math inline">\(\vec{AB} = \vec{A_1 B_1} + \vec{A_2 B_2} + \vec{A_3 B_3} = (x_2 - x_1) \vec{i} + (y_2-y_1)\vec{j} + (z_2-z_1)\vec{k}\)&lt;/span>，得到向量的坐标表示&lt;span class="math inline">\((x_2-x_1, y_2-y_1,z_2-z_1)\)&lt;/span>&lt;/p>
&lt;p>需要注意的是空间中坐标为&lt;span class="math inline">\((x,y，z)\)&lt;/span>的点P，向量&lt;span class="math inline">\(\vec{OP}\)&lt;/span>的坐标也是&lt;span class="math inline">\((x,y,z)\)&lt;/span>，点和向量是两个不同的概念，上下文中要注意区分。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826010443568.png" alt="" />&lt;figcaption>image-20200826010443568&lt;/figcaption>
&lt;/figure>
&lt;h3 id="向量的线性运算与性质代数刻画利用坐标">向量的线性运算与性质（代数刻画，利用坐标）&lt;/h3>
&lt;p>设两个向量&lt;span class="math inline">\(\boldsymbol{a}=\left(a_{x}, a_{y}, a_{z}\right), \boldsymbol{b}=\left(b_{x}, b_{y}, b_{z}\right)\)&lt;/span>,即&lt;span class="math inline">\(a=a_{x} \boldsymbol i+a_y \boldsymbol j+a_{z} \boldsymbol k, b=b_{x} \boldsymbol i+b_{y} \boldsymbol j+b_{z} \boldsymbol k\)&lt;/span>&lt;/p>
&lt;h5 id="向量的加法利用坐标运算">向量的加法（利用坐标运算）&lt;/h5>
&lt;p>&lt;span class="math inline">\(\boldsymbol{a}+\boldsymbol{b}=\left(a_{x}+b_{x}\right) \boldsymbol{i}+\left(\boldsymbol{a},+b_{y}\right) \boldsymbol{j}+\left(a_{z}+b_{z}\right) \boldsymbol{k}\)&lt;/span> 即&lt;span class="math inline">\(a+b=\left(a_{x}+b_{x}, a_{y}+b_{y}, a_{z}+b_{z}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="向量的减法利用坐标运算">向量的减法（利用坐标运算）&lt;/h5>
&lt;p>&lt;span class="math inline">\(\boldsymbol{a}-\boldsymbol{b}=\left(a_{x}-b_{x}\right) \boldsymbol{i}+\left(a_{y}-b_{y}\right) \boldsymbol{j}+\left(a_{z}-b_{z}\right) \boldsymbol{k}\)&lt;/span>&lt;/p>
&lt;p>即&lt;span class="math inline">\(\boldsymbol{a}-\boldsymbol{b}=\left(a_{x}-b_{x}, a_{y}-b_{y},, a_{z}-b_{z}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="向量的数乘利用坐标运算">向量的数乘（利用坐标运算）&lt;/h5>
&lt;p>&lt;span class="math inline">\(\lambda \boldsymbol{a}=\left(\lambda a_{x}\right) \boldsymbol{i}+\left(\lambda a_{y}\right) \boldsymbol{j}+\left(\lambda \boldsymbol{a}_{z}\right) \boldsymbol{k} \quad(\lambda\)&lt;/span> 为实数 &lt;span class="math inline">\()\)&lt;/span>&lt;/p>
&lt;p>即&lt;span class="math inline">\(\lambda \boldsymbol{a}=\left(\lambda a_{x}, \lambda a_{y}, \lambda a_{z}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="向量平行的充分必要条件坐标表示">向量平行的充分必要条件（坐标表示）&lt;/h5>
&lt;p>当向量 &lt;span class="math inline">\(\boldsymbol a \neq \boldsymbol 0\)&lt;/span> 时，向量 &lt;span class="math inline">\(\boldsymbol{b} / / \boldsymbol{a}\)&lt;/span> 相当于 &lt;span class="math inline">\(\boldsymbol{b}=\lambda \boldsymbol{a},\)&lt;/span> 坐标表示式为&lt;span class="math inline">\(\left(b_{x}, b_y, b_{z}\right)=\lambda\left(a_{x}, a_{y}, a_{z}\right)\)&lt;/span>，即坐标对应成比例：&lt;span class="math inline">\(\frac{b_{x}}{a_{x}}=\frac{b_{y}}{a_{y}}=\frac{b_{z}}{a_{z}}\)&lt;/span>&lt;/p>
&lt;h3 id="向量的基本概念的坐标表示代数刻画">向量的基本概念的坐标表示（代数刻画）&lt;/h3>
&lt;p>向量如下基本概念的定义在前面已有介绍：&lt;a href="#向量的基本概念与定义（几何刻画）">向量的基本概念与定义（几何刻画）&lt;/a>&lt;/p>
&lt;h4 id="向量的模">向量的模&lt;/h4>
&lt;p>向量的模：向量的大小称为向量的模。 则向量端点之间的距离就是向量的模。 设有点 &lt;span class="math inline">\(A\left(x_{1}, y_{1}, z_{1}\right)\)&lt;/span> 和点 &lt;span class="math inline">\(B\left(x_{2}, y_{2}, z_{2}\right),\)&lt;/span> 则点 &lt;span class="math inline">\(A\)&lt;/span> 与点 &lt;span class="math inline">\(B\)&lt;/span> 间的距离 &lt;span class="math inline">\(|A B|\)&lt;/span> 就是向量&lt;span class="math inline">\(\overrightarrow{A B}\)&lt;/span> 的模。 向量&lt;span class="math inline">\(\begin{aligned} \overrightarrow{A B} &amp;amp;=\overrightarrow{O B}-\overrightarrow{O A}=\left(x_{2}, y_{2}, z_{2}\right)-\left(x_{1}, y_{1}, z_{1}\right) \\ &amp;amp;=\left(x_{2}-x_{1}, y_{2}-y_{1}, z_{2}-z_{1}\right) \end{aligned}\)&lt;/span> A 、B 两点间的距离/向量&lt;span class="math inline">\(\vec{AB}\)&lt;/span>的模&lt;span class="math inline">\(|A B|=|\overrightarrow{A B}|=\sqrt{\left(x_{2}-x_{1}\right)^{2}+\left(y_{2}-y_{1}\right)^{2}+\left(z_{2}-z_{1}\right)^{2}}\)&lt;/span>&lt;/p>
&lt;h4 id="单位向量">单位向量&lt;/h4>
&lt;p>设直角坐标系中的向量&lt;span class="math inline">\(\vec{a}=(a_1,a_2,a_3)\)&lt;/span>&lt;/p>
&lt;p>则与&lt;span class="math inline">\(\vec{a}\)&lt;/span>同方向的单位向量为&lt;span class="math inline">\(\vec{a}^\circ = \frac{\vec{a}}{|\vec{a}|} = \left\{\frac{a_1}{\sqrt{a_1^2+b_1^2+c_1^2}},\frac{b_1}{\sqrt{a_1^2+b_1^2+c_1^2}}, \frac{c_1}{\sqrt{a_1^2+b_1^2+c_1^2}}\right\}\)&lt;/span>&lt;/p>
&lt;h4 id="方向角">方向角&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200901200128502.png" alt="" />&lt;figcaption>image-20200901200128502&lt;/figcaption>
&lt;/figure>
&lt;p>方向角：向量&lt;span class="math inline">\(\vec{r}= \vec{OM}=(a_1,b_1,c_1)\)&lt;/span>与x,y,z轴正向的夹角，一般记为&lt;span class="math inline">\(\alpha,\beta,\gamma\)&lt;/span>.&lt;/p>
&lt;h4 id="方向余弦">方向余弦&lt;/h4>
&lt;p>&lt;span class="math inline">\(\cos \alpha=\frac{a_1}{|O M|}=\frac{a_1}{|r|} = \frac{a_1}{\sqrt{a_1^2+b_1^2+c_1^2}}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos \beta=\frac{a_2}{|r|} = \frac{b_1}{\sqrt{a_1^2+b_1^2+c_1^2}}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos \gamma=\frac{a_3}{|r|} = \frac{c_1}{\sqrt{a_1^2+b_1^2+c_1^2}}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos^2 \alpha + \cos^2 \beta + \cos^2 \gamma = 1\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a}^\circ = \frac{\vec{a}}{|\vec{a}|} = \{\cos \alpha, \cos \beta, \cos \gamma\}\)&lt;/span>&lt;/p>
&lt;h4 id="向量的投影">向量的投影&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200901215017921.png" alt="" />&lt;figcaption>image-20200901215017921&lt;/figcaption>
&lt;/figure>
&lt;p>点M在数轴u上的投影：过点M作与u轴垂直的平面交u轴于点M‘，则点M’称作点M在u轴上的投影。&lt;/p>
&lt;p>向量&lt;span class="math inline">\(\vec{r}= \vec{OM}\)&lt;/span>在数轴u上的投影：过点M作与u轴垂直的平面交u轴于点M‘，则&lt;span class="math inline">\(\vec{OM^\prime}\)&lt;/span>称为向量&lt;span class="math inline">\(\vec{r}\)&lt;/span>在u轴上的分向量，设&lt;span class="math inline">\(\vec{OM^\prime} = \lambda boldsymbol e\)&lt;/span>，则&lt;span class="math inline">\(\lambda\)&lt;/span>称为向量&lt;span class="math inline">\(\vec{r}= \vec{OM}\)&lt;/span>在数轴u上的投影，记作&lt;span class="math inline">\(\operatorname{Prj}_{u} \boldsymbol r\)&lt;/span>或者&lt;span class="math inline">\((\boldsymbol r)_u\)&lt;/span>&lt;/p>
&lt;p>直角坐标系中，设向量&lt;span class="math inline">\(\vec{a} = (a_x,a_y,a_z)\)&lt;/span>，则&lt;span class="math inline">\(a_x,a_y,a_z\)&lt;/span>恰好就是&lt;span class="math inline">\(\vec{a}\)&lt;/span>在三条坐标上的投影。&lt;/p>
&lt;p>投影的性质： &lt;span class="math inline">\(\operatorname{Prj}_{u} \boldsymbol a=|\boldsymbol a| \cos \varphi\)&lt;/span> &lt;span class="math inline">\(\operatorname{Prj}_{u}(\boldsymbol{a}+\boldsymbol{b})=\operatorname{Prj}_{u} \boldsymbol{a}+\operatorname{Prj}_{u} \boldsymbol{b}\)&lt;/span> &lt;span class="math inline">\(\operatorname{Prj}_{u}(\lambda \boldsymbol{a})=\lambda \operatorname{Prj}_{u} \boldsymbol{a}\)&lt;/span>&lt;/p>
&lt;h3 id="向量的数量积向量积与混合积">向量的数量积、向量积与混合积&lt;/h3>
&lt;h5 id="数量积veca-cdot-vecb">数量积&lt;span class="math inline">\(\vec{a} \cdot \vec{b}\)&lt;/span>&lt;/h5>
&lt;p>数量积的结果是个标量。&lt;/p>
&lt;p>数量积定义（几何刻画）：&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \cdot \vec{b}=|\vec{a}| \cdot |\vec{b}| \cos \hat{(\vec{a},\vec{b})}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \cdot \vec{b}=|\vec{a}| \operatorname{Prj}_{\vec{a}} \vec{b}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \cdot \vec{b}=|\vec{b}| \operatorname{Prj}_{\vec{b}} \vec{a}\)&lt;/span>&lt;/p>
&lt;p>意义：是其中一个向量与另一个向量在此方向投影的乘积的大小。&lt;/p>
&lt;p>性质：&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \cdot \vec{b}=\vec{b} \cdot \vec{a}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((\vec{a}+\vec{b}) \cdot \vec{c}=\vec{a} \cdot \vec{c}+\vec{b} \cdot \vec{c}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((\lambda \vec{a}) \cdot \vec{b}=\lambda(\vec{a} \cdot \vec{b}), \lambda\)&lt;/span> 为数.&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \cdot \vec{a}=|\vec{a}|^2\)&lt;/span>&lt;/p>
&lt;p>若&lt;span class="math inline">\(\vec{a} \cdot \vec{a}=0 \Leftrightarrow \vec{a} = \vec{0}\)&lt;/span>&lt;/p>
&lt;p>若&lt;span class="math inline">\(\vec{a} \cdot \vec{b}=0 \Leftrightarrow \vec{a} \perp \vec{b}\)&lt;/span>&lt;/p>
&lt;p>坐标表示（直角坐标系中的代数刻画）：&lt;/p>
&lt;p>&lt;span class="math inline">\(\boldsymbol a \cdot \boldsymbol b=\left(a_{x} \boldsymbol i+a_y \boldsymbol j+a_{z} \boldsymbol k\right) \cdot\left(b_{x} \boldsymbol i+b_u \boldsymbol j+b_{z} \boldsymbol k\right)=a_{x} b_{x}+a_{y} b_{y}+a_{z} b_{z}\)&lt;/span>&lt;/p>
&lt;h5 id="向量积veca-times-vecb">向量积&lt;span class="math inline">\(\vec{a} \times \vec{b}\)&lt;/span>&lt;/h5>
&lt;p>向量积的结果是个向量。&lt;/p>
&lt;p>向量积定义（几何刻画）：&lt;/p>
&lt;p>向量积的方向：通过右手准则确定，并与&lt;span class="math inline">\(\vec{a}\)&lt;/span>和&lt;span class="math inline">\(\vec{b}\)&lt;/span>都垂直。 向量积的大小：&lt;span class="math inline">\(|\vec{a} \times \vec{b}|=|\vec{a}| \cdot |\vec{b}| \sin \hat{(\vec{a},\vec{b})}\)&lt;/span>&lt;/p>
&lt;p>意义：由两个向量决定另一个向量方向。&lt;/p>
&lt;p>性质：&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \times \vec{a}=\vec{0}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \times \vec{b}=-\vec{b} \times \vec{a}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \times \vec{b} \perp \vec{a}, \vec{a} \times \vec{b} \perp \vec{b}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((\vec{a}+\vec{b}) \times \vec{c}=\vec{a} \times \vec{c}+\vec{b} \times \vec{c}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((\lambda \vec{a}) \times \vec{b}=\vec{a} \times(\lambda \vec{b})=\lambda(\vec{a} \times \vec{b})\)&lt;/span>&lt;/p>
&lt;p>若对于两个非零向量，&lt;span class="math inline">\(\vec{a} \times \vec{b}=\vec{0} \Leftrightarrow \vec{a} // \vec{b}\)&lt;/span> 或&lt;span class="math inline">\(\frac{a_1}{a_2} = \frac{b_1}{b_2} = \frac{c_1}{c_2}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|\vec{a} \times \vec{b}| = |\vec{a}| \cdot |\vec{b}| \sin \hat{(\vec{a},\vec{b})} = 2 S_\triangle\)&lt;/span>&lt;/p>
&lt;p>坐标表示（直角坐标系中的代数刻画）：&lt;/p>
&lt;p>&lt;span class="math inline">\(\vec{a} \times \vec{b} =\left(a_{x} \boldsymbol i+a_{y} \boldsymbol j+a_{z} \boldsymbol k\right) \times\left(b_{x} \boldsymbol i+b_{y} \boldsymbol j+b_{z} \boldsymbol k\right)= \left|\begin{array} \vec{i} &amp;amp; \vec{j} &amp;amp; \vec{k} \\ a_x &amp;amp; a_y &amp;amp; a_z \\ b_x &amp;amp; b_y &amp;amp; b_z \end{array}\right|\)&lt;/span>&lt;/p>
&lt;h5 id="混合积veca-times-vecbcdot-vecc">混合积&lt;span class="math inline">\((\vec{a} \times \vec{b})\cdot \vec{c}\)&lt;/span>&lt;/h5>
&lt;p>三个向量的混合积是个标量。&lt;/p>
&lt;p>混合积定义（几何刻画）：&lt;/p>
&lt;p>&lt;span class="math inline">\([\vec{a} \vec{b} \vec{c}]=(\vec{a} \times \vec{b}) \cdot \vec{c}\)&lt;/span>&lt;/p>
&lt;p>意义：它的绝对值表示以&lt;span class="math inline">\(\vec{a} , \vec{b} , \vec{c}\)&lt;/span>为棱的平行六面体的体积。&lt;/p>
&lt;p>坐标表示（代数刻画）：&lt;/p>
&lt;p>&lt;span class="math inline">\([\vec{a} \vec{b} \vec{c}]=(\vec{a} \times \vec{b})\cdot \vec{c}=\left|\begin{array}{lll}a_{x} &amp;amp; a_{y} &amp;amp; a_{z} \\ b_{x} &amp;amp; b_{y} &amp;amp; b_{z} \\ c_{x} &amp;amp; c_{y} &amp;amp; c_{z}\end{array}\right|\)&lt;/span>&lt;/p>
&lt;p>性质：&lt;/p>
&lt;p>3个向量&lt;span class="math inline">\(\vec{a} , \vec{b} , \vec{c}\)&lt;/span>共面 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\([\vec{a} \vec{b} \vec{c}]=(\vec{a} \times \vec{b})\cdot \vec{c}=0\)&lt;/span>&lt;/p>
&lt;h2 id="向量的几何应用空间解析几何">向量的几何应用：空间解析几何&lt;/h2>
&lt;p>空间解析几何中，任何曲面或曲线都可以看作是点的几何轨迹。&lt;/p>
&lt;p>空间解析几何将图形看作是点的轨迹，&lt;strong>如何由几何轨迹建立方程&lt;/strong>、&lt;strong>如何根据方程研究几何图形&lt;/strong>，是研究的两个基本的问题。&lt;/p>
&lt;h3 id="空间曲面fxyz-0">空间曲面&lt;span class="math inline">\(F(x,y,z) = 0\)&lt;/span>&lt;/h3>
&lt;p>对于曲面S和方程&lt;span class="math inline">\(F(x,y,z) = 0\)&lt;/span>，若： 1）曲面上任何一点的坐标都满足方程 2）曲面外任何一点的坐标都不满足方程 称这个方程&lt;span class="math inline">\(F(x,y,z) = 0\)&lt;/span>是曲面S的方程，曲面S是方程&lt;span class="math inline">\(F(x,y,z) = 0\)&lt;/span>的图形。&lt;/p>
&lt;h4 id="特殊曲面">特殊曲面&lt;/h4>
&lt;h5 id="球面">球面&lt;/h5>
&lt;p>球心在点 &lt;span class="math inline">\(M_{0}\left(x_{0}, y_{0}, z_{0}\right),\)&lt;/span> 半径为 &lt;span class="math inline">\(R\)&lt;/span>，设 &lt;span class="math inline">\(M(x, y, z)\)&lt;/span> 是球面上的任一点，则有&lt;span class="math inline">\(\left|M_{0} M\right|=R\)&lt;/span> 即&lt;span class="math inline">\(\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}+\left(z-z_{0}\right)^{2}=R^{2}\)&lt;/span>&lt;/p>
&lt;p>一般的，三元二次方程&lt;span class="math inline">\(A x^{2}+A y^{2}+A z^{2}+D x+E y+F z+G=0\)&lt;/span>都可以通过配方法化为球的方程的标准形式。其特点是缺 xy, yz,zx 各项, 而且平方项系数相同。&lt;/p>
&lt;h5 id="柱面">柱面&lt;/h5>
&lt;p>&lt;span class="math inline">\(F(x,y)= 0\)&lt;/span>表示某平行于z轴的柱面。平面上任意一条平行于z轴的直线称为柱面的母线，xOy面上的&lt;span class="math inline">\(F(x,y)= 0\)&lt;/span>叫做柱面的准线。 &lt;span class="math inline">\(F(y,z)= 0\)&lt;/span>表示某平行于x轴的柱面。 &lt;span class="math inline">\(F(x,z)= 0\)&lt;/span>表示某平行于y轴的柱面。&lt;/p>
&lt;p>不论没出现的那个坐标取何值，点都在对应的曲面上。&lt;/p>
&lt;h5 id="旋转曲面">旋转曲面&lt;/h5>
&lt;p>对于曲线: &lt;span class="math inline">\(\left\{\begin{array}{} f(x,y) = 0 \\ z=0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>绕x轴旋转形成的曲面&lt;span class="math inline">\(\Sigma_x\)&lt;/span>为： &lt;span class="math inline">\(f(x,\pm \sqrt{y^2+z^2}) = 0\)&lt;/span>&lt;/p>
&lt;p>绕y轴旋转形成的曲面&lt;span class="math inline">\(\Sigma_y\)&lt;/span>为： &lt;span class="math inline">\(f(\pm \sqrt{x^2+z^2}, y)= 0\)&lt;/span>&lt;/p>
&lt;p>规律是：绕谁旋转，谁不变&lt;/p>
&lt;h4 id="二次曲面">二次曲面&lt;/h4>
&lt;p>与平面解析几何中规定的二次曲线相似，我们把&lt;strong>三元二次方程&lt;/strong>&lt;span class="math inline">\(F(x, y, z)=0\)&lt;/span>所表示的曲面称作&lt;strong>二次曲面&lt;/strong>，把平面称作一次曲面。&lt;/p>
&lt;p>我们可以通过截痕法、伸缩变形的方法得到二次曲面的形状。&lt;/p>
&lt;p>共有9种二次曲面。&lt;/p>
&lt;p>其中三种： 这3种二次曲面是以二次曲线为准线的&lt;a href="#柱面">柱面&lt;/a>：&lt;/p>
&lt;p>椭圆柱面：&lt;span class="math inline">\(\frac{x^{2}}{a^{2}}+\frac{y^{2}}{b^{2}}=1\)&lt;/span> 双曲柱面：&lt;span class="math inline">\(\frac{x^{2}}{a^{2}}-\frac{y^{2}}{b^{2}}=1\)&lt;/span> 抛物柱面：$ x^{2}=a y$&lt;/p>
&lt;p>剩余6种：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200903192916509.png" alt="" />&lt;figcaption>image-20200903192916509&lt;/figcaption>
&lt;/figure>
&lt;h3 id="空间平面">空间平面&lt;/h3>
&lt;p>空间平面可看作空间曲面的退化。&lt;/p>
&lt;h4 id="空间平面的点法式方程">空间平面的点法式方程&lt;/h4>
&lt;p>设&lt;span class="math inline">\(M_0(x_0,y_0,z_0) \in \pi\)&lt;/span>平面，&lt;span class="math inline">\(\vec{n} = {A,B,C} \perp \pi\)&lt;/span>平面。 $M(x,y,z) =0 $ 所以&lt;span class="math inline">\(\pi\)&lt;/span>平面方程为：&lt;span class="math inline">\(A(x-x_0)+B(y-y_0)+C(z-z_0)=0\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826181605884.png" alt="" />&lt;figcaption>image-20200826181605884&lt;/figcaption>
&lt;/figure>
&lt;h4 id="空间平面的截距式方程">空间平面的截距式方程&lt;/h4>
&lt;p>&lt;span class="math inline">\(\frac{x}{a} + \frac{y}{b} + \frac{z}{c} = 0\)&lt;/span>&lt;/p>
&lt;h4 id="空间平面的一般式方程">空间平面的一般式方程&lt;/h4>
&lt;p>&lt;span class="math inline">\(Ax+By+Cy+D=0\)&lt;/span>&lt;/p>
&lt;h4 id="两平面的夹角">两平面的夹角&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200903080426940.png" alt="" />&lt;figcaption>image-20200903080426940&lt;/figcaption>
&lt;/figure>
&lt;p>两平面的夹角等于两平面法向量的夹角，则：&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos \theta=\frac{\vec{| n_1 \cdot \vec{n_2}|}}{|\vec{n_1}| \cdot| \vec{n_2}|}=\frac{\left|A_{1} A_{2}+B_{1} B_{2}+C_{1} C_{2}\right|}{\sqrt{A_{1}^{2}+B_{1}^{2}+C_{1}^{2}} \sqrt{A_{2}^{2}+B_{2}^{2}+C_{2}^{2}}}\)&lt;/span>&lt;/p>
&lt;p>从两向量垂直、平行的充分必要条件可推得： 平面&lt;span class="math inline">\(\Pi_{1}, \Pi_{2}\)&lt;/span> 互相垂直相当于 &lt;span class="math inline">\(A_{1} A_{2}+B_{1} B_{2}+C_{1} C_{2}=0\)&lt;/span> 平面&lt;span class="math inline">\(\Pi_{1}, \Pi_{2}\)&lt;/span> 互相平行或重合相当于 &lt;span class="math inline">\(\frac{A_1}{A_{2}}=\frac{B_{1}}{B_{2}}=\frac{C_{1}}{C_{2}}\)&lt;/span>&lt;/p>
&lt;h4 id="平面束方程">平面束方程&lt;/h4>
&lt;p>设直线 L 由如下方程组确定： &lt;span class="math inline">\(\left\{\begin{array}{l}A_{1} x+B_{1} y+C_{1} z+D_{1}=0 \\ A_{2} x+B_{2} y+C_{2} z+D_{2}=0\end{array}\right.\)&lt;/span> 其中系数 &lt;span class="math inline">\(A_{1}, B_{1}, C_{1}\)&lt;/span> 与 &lt;span class="math inline">\(A_{2}, B_{2}, C_{2}\)&lt;/span> 不成比例.&lt;/p>
&lt;p>则三元一次方程组(其中 &lt;span class="math inline">\(\lambda\)&lt;/span> 为任意常数)： &lt;span class="math inline">\(A_{1} x+B_{1} y+C_{1} z+D_{1}+\lambda\left(A_{2} x+B_{2} y+C_{2} z+D_{2}\right)=0\)&lt;/span> 可表示过直线L的任意平面（除&lt;span class="math inline">\(A_{2} x+B_{2} y+C_{2} z+D_{2}=0\)&lt;/span>之外） 称为通过直线L的平面束方程。&lt;/p>
&lt;h3 id="空间曲面的切平面与法线">空间曲面的切平面与法线&lt;/h3>
&lt;p>&lt;span class="math inline">\(\Sigma: F(x,y,z)=0\)&lt;/span>是空间曲面， &lt;span class="math inline">\(M_0(x_0,y_0,z_0) \in \Sigma\)&lt;/span>曲面， &lt;span class="math inline">\(M_0\)&lt;/span>处切平面的一个法向量为&lt;span class="math inline">\(\vec{n} = \{F_x^\prime, F_y^\prime, F_z^\prime\}|_{M_0}\)&lt;/span>&lt;/p>
&lt;p>根据&lt;span class="math inline">\(M_0\)&lt;/span>和&lt;span class="math inline">\(\vec{n}\)&lt;/span>可写出曲面的切平面的&lt;a href="#空间平面的点法式方程">点法式方程&lt;/a>。 根据&lt;span class="math inline">\(M_0\)&lt;/span>和&lt;span class="math inline">\(\vec{n}\)&lt;/span>可写出曲面的法线的&lt;a href="#空间直线的点向式方程">点向式方程&lt;/a>。&lt;/p>
&lt;h3 id="空间曲线">空间曲线&lt;/h3>
&lt;h4 id="空间曲线的表达形式">空间曲线的表达形式&lt;/h4>
&lt;h5 id="空间曲线的一般式方程">空间曲线的一般式方程&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left\{\begin{array}{} F(x,y,z) = 0 \\ G(x,y,z) = 0 \end{array}\right.\)&lt;/span>&lt;/p>
&lt;h5 id="空间曲线的参数式方程">空间曲线的参数式方程&lt;/h5>
&lt;p>&lt;span class="math inline">\(\left\{\begin{array}{} x=x(t) \\ y=y(t) \\ z=z(t) \end{array}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="空间曲线在坐标面上的投影">空间曲线在坐标面上的投影&lt;/h4>
&lt;p>由&lt;a href="#空间曲线的一般式方程">空间曲线的一般式&lt;/a>消去其中一元后（如果可以消去的话，比如消去z），得：&lt;span class="math inline">\(H(x, y)=0\)&lt;/span> 由前面已知，这是一个柱面，称为曲线关于平面xOy的投影柱面，再令z=0， 即得到空间曲线在xOy面的投影（方程）： &lt;span class="math inline">\(\left\{\begin{array}{l}H(x, y)=0 \\ z=0\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>后面重积分章节，用投影法算三重积分可能会用到。&lt;/p>
&lt;h3 id="空间直线">空间直线&lt;/h3>
&lt;p>空间直线可看作是空间曲线的退化。&lt;/p>
&lt;h4 id="空间直线的点向式方程">空间直线的点向式方程&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826225538209.png" alt="" />&lt;figcaption>image-20200826225538209&lt;/figcaption>
&lt;/figure>
&lt;p>已知&lt;span class="math inline">\(M_0 \in L, \vec{s} = \{m,n,p\} // L\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\forall M(x,y,z) \in L \Leftrightarrow \vec{M_0 M} // \vec{s}\)&lt;/span>，则L：&lt;span class="math inline">\(\frac{x-x_0}{m} = \frac{y-y_0}{n} = \frac{z-z_0}{p}\)&lt;/span>&lt;/p>
&lt;p>当 m、n 和 p 中有一个为0,例如 m = 0, 而 n 与 p不等于0 时,这方程组应理解为 &lt;span class="math inline">\(\left\{\begin{array}{l}x-x_{0}=0 \\ \frac{y-y_{0}}{n}=\frac{z-z_{0}}{p}\end{array}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="空间直线的参数式方程">空间直线的参数式方程&lt;/h4>
&lt;p>令&lt;span class="math inline">\(\frac{x-x_0}{m} = \frac{y-y_0}{n} = \frac{z-z_0}{p} = t\)&lt;/span> 则L：&lt;span class="math inline">\(\left\{\begin{array}{} x=x_0 +mt \\ y=y_0 + nt \\ z=z_0 + pt \end{array}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="空间直线的一般式方程">空间直线的一般式方程&lt;/h4>
&lt;p>空间直线可看作是两个空间平面的交线。&lt;/p>
&lt;p>则L：&lt;span class="math inline">\(\left\{\begin{array}{} A_1 x + B_1 y + C_1 z + D_1 = 0 \\ A_2 x + B_2 y + C_2 z + D_2 = 0 \end{array}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="两空间直线的夹角">两空间直线的夹角&lt;/h4>
&lt;p>两直线的方向向量的夹角(通常指锐角或直角) 叫做两直线的夹角.&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos \varphi= \frac{| \vec{s_1} \cdot \vec{s_2} |}{| \vec{s_1}| \cdot |\vec{s_2} |}=\frac{\left|m_{1} m_{2}+n_{1} n_{2}+p_{1} p_{2}\right|}{\sqrt{m_{1}^{2}+n_{1}^{2}+p_{1}^{2}} \sqrt{m_{2}^{2}+n_{2}^{2}+p_{2}^{2}}}\)&lt;/span>&lt;/p>
&lt;h4 id="直线与平面的夹角">直线与平面的夹角&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200903134003112.png" alt="" />&lt;figcaption>image-20200903134003112&lt;/figcaption>
&lt;/figure>
&lt;p>当直线与平面不垂直时，直线与它在平面上的投影直线的夹角为&lt;span class="math inline">\(\varphi\left(0 \leqslant \varphi&amp;lt;\frac{\pi}{2}\right)\)&lt;/span>，称为直线与平面的夹角。 当直线与平面垂直时，规定直线与平面的夹角为&lt;span class="math inline">\(\frac{\pi}{2}\)&lt;/span>&lt;/p>
&lt;p>设直线的方向向量为 &lt;span class="math inline">\(\vec{s}=(m, n, p)\)&lt;/span>,平面的法线向量为 &lt;span class="math inline">\(\vec{n}=(A, B, C),\)&lt;/span> 直线与平面的夹角为 &lt;span class="math inline">\(\varphi=\left|\frac{\pi}{2}-\hat{(\boldsymbol s, \boldsymbol n)}\right|,\)&lt;/span> 因此（当&lt;span class="math inline">\(\varphi &amp;lt; \frac{\pi}{2}\)&lt;/span>时）： &lt;span class="math inline">\(\sin \varphi=|\cos \hat{(\boldsymbol s, \boldsymbol{n})}|=\frac{\left|A m+B n+C p\right|}{\sqrt{A^{2}+B^{2}+C^{2}} \sqrt{m^{2}+n^{2}+p^{2}}}\)&lt;/span> 当直线与平面平行时（即当&lt;span class="math inline">\(\varphi = 0\)&lt;/span>时），直线与平面的法向量垂直: &lt;span class="math inline">\(A m+B n+C p = 0\)&lt;/span> 当至直线与平面垂直时（即当&lt;span class="math inline">\(\varphi = \frac{\pi}{2}\)&lt;/span>时），直线与平面的法向量平行： &lt;span class="math inline">\(\frac{A}{m}=\frac{B}{n}=\frac{C}{p}\)&lt;/span>&lt;/p>
&lt;h3 id="空间曲线的切线与法平面">空间曲线的切线与法平面&lt;/h3>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200826232233762.png" alt="" />&lt;figcaption>image-20200826232233762&lt;/figcaption>
&lt;/figure>
&lt;p>根据&lt;a href="#空间曲线的参数式方程">空间曲线的参数式方程&lt;/a>： &lt;span class="math inline">\(\left\{\begin{array}{} x=x(t) \\ y=y(t) \\ z=z(t) \end{array}\right.\)&lt;/span> 取&lt;span class="math inline">\(t = t_0 \Rightarrow \text{切点}M_0(x_0, y_0, z_0)\)&lt;/span> 切点&lt;span class="math inline">\(M_0\)&lt;/span>处的切向量&lt;span class="math inline">\(\vec{T} = \{x^\prime(t_0), y^\prime(t_0), z^\prime(t_0)\}\)&lt;/span> 则可以写出空间曲线的切线的&lt;a href="#空间直线的点向式方程">点向式方程&lt;/a>， 也可以写出空间曲线的法平面的&lt;a href="#空间平面的点法式方程">点法式方程&lt;/a>。&lt;/p>
&lt;p>根据&lt;a href="#空间曲线的一般式方程">空间曲线的一般式方程&lt;/a>： &lt;span class="math inline">\(\left\{\begin{array}{} F(x,y,z) = 0 \\ G(x,y,z) = 0 \end{array}\right.\)&lt;/span> 取&lt;span class="math inline">\(M_0(x_0,y_0,z_0) \in \text{曲线} L\)&lt;/span> 设&lt;span class="math inline">\(\vec{n_1},\vec{n_2}\)&lt;/span>分别是&lt;span class="math inline">\(M_0\)&lt;/span>处两个曲面$ F(x,y,z) = 0 , G(x,y,z) = 0&lt;span class="math inline">\(的切平面的法向量，则\)&lt;/span> = = { F_x^, F_y^, F_z^} { G_x^, G_y^, G_z^} $ 则可以写出空间曲线的切线的&lt;a href="#空间直线的点向式方程">点向式方程&lt;/a>， 也可以写出空间曲线的法平面的&lt;a href="#空间平面的点法式方程">点法式方程&lt;/a>。&lt;/p>
&lt;h3 id="距离">距离&lt;/h3>
&lt;h4 id="两点间的距离">两点间的距离&lt;/h4>
&lt;p>设&lt;span class="math inline">\(A(x_1,y_1,z_1), B(x_2,y_2,z_2)\)&lt;/span> 则两点间的距离&lt;span class="math inline">\(d=\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}\)&lt;/span>&lt;/p>
&lt;h4 id="点到平面的距离">点到平面的距离&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200827090946874.png" alt="" />&lt;figcaption>image-20200827090946874&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\pi \text{平面:} Ax+By+Cz+D=0,M_0(x_0,y_0,z_0) \notin \pi\)&lt;/span> 则点&lt;span class="math inline">\(M_0\)&lt;/span>到&lt;span class="math inline">\(\pi\)&lt;/span>平面的距离&lt;span class="math inline">\(d=\frac{|A x_0 + B y_0 + C z_0 + D|}{\sqrt{A^2+B^2+C^2}}\)&lt;/span>&lt;/p>
&lt;h4 id="平行平面之间的距离">平行平面之间的距离&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200827095019148.png" alt="" />&lt;figcaption>image-20200827095019148&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\pi_1 \text{平面:} Ax+By+Cz+D_1=0\)&lt;/span> &lt;span class="math inline">\(\pi_2 \text{平面:} Ax+By+Cz+D_2=0\)&lt;/span>&lt;/p>
&lt;p>取&lt;span class="math inline">\(\forall M_0(x_0,y_0,z_0) \in \pi_2\)&lt;/span>，则&lt;span class="math inline">\(A x_0 + B y_0 + C z_0 + D_2 = 0\)&lt;/span> 则&lt;span class="math inline">\(M_0\)&lt;/span>到平面&lt;span class="math inline">\(\pi_1\)&lt;/span>的距离就是两平面间的距离。 &lt;span class="math inline">\(d=\frac{|A x_0 + B y_0 + C z_0 + D_1|}{\sqrt{A^2+B^2+C^2}}=\frac{|D_1 - D_2|}{\sqrt{A^2+B^2+C^2}}\)&lt;/span>&lt;/p>
&lt;h4 id="点到直线的距离">点到直线的距离&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200827100506033.png" alt="" />&lt;figcaption>image-20200827100506033&lt;/figcaption>
&lt;/figure>
&lt;p>设&lt;span class="math inline">\(M_0(x_0,y_0,z_0), M_1(x,y,z)\)&lt;/span> 则有&lt;span class="math inline">\(|\vec{M_1 M_0} \times \vec{s} | = 2 S_\triangle\)&lt;/span> 又有&lt;span class="math inline">\(|\vec{s}| \cdot d = 2 S_\triangle\)&lt;/span> 则&lt;span class="math inline">\(|\vec{s}| \cdot d =|\vec{M_1 M_0} \times \vec{s} |\)&lt;/span> 则点&lt;span class="math inline">\(M_0\)&lt;/span>到直线L的距离&lt;span class="math inline">\(d = \frac{|\vec{M_1 M_0} \times \vec{s} |}{|\vec{s}|}\)&lt;/span>&lt;/p>
&lt;h4 id="异面直线间的距离">异面直线间的距离&lt;/h4>
&lt;p>1）准备工作： 在直线&lt;span class="math inline">\(L_1\)&lt;/span>上找任意一点&lt;span class="math inline">\(M_1(x_1,y_1,z_1)\)&lt;/span>，找直线&lt;span class="math inline">\(L_1\)&lt;/span>的一个方向向量&lt;span class="math inline">\(\vec{s_1} = \{m_1,n_1,p_1\}\)&lt;/span>。 在直线&lt;span class="math inline">\(L_2\)&lt;/span>上找任意一点&lt;span class="math inline">\(M_2(x_2,y_2,z_2)\)&lt;/span>，找直线&lt;span class="math inline">\(L_2\)&lt;/span>的一个方向向量&lt;span class="math inline">\(\vec{s_2} = \{m_2,n_2,p_2\}\)&lt;/span>。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200827111601255.png" alt="" />&lt;figcaption>image-20200827111601255&lt;/figcaption>
&lt;/figure>
&lt;p>2）确认两直线异面 &lt;span class="math inline">\(L_1,L_2\)&lt;/span>共面&lt;span class="math inline">\(\Leftrightarrow \vec{s_1} \times \vec{s_2} \perp \vec{M_1 M_2} \Leftrightarrow (\vec{s_1} \times \vec{s_2}) \cdot \vec{M_1 M_2} = 0\)&lt;/span> &lt;span class="math inline">\(L_1,L_2\)&lt;/span>异面&lt;span class="math inline">\(\Leftrightarrow (\vec{s_1} \times \vec{s_2}) \cdot \vec{M_1 M_2} \neq 0\)&lt;/span>&lt;/p>
&lt;p>3）转化为求点到直线之间的距离 过点&lt;span class="math inline">\(M_1\)&lt;/span>作&lt;span class="math inline">\(L_2^\prime // L_2\)&lt;/span>，则&lt;span class="math inline">\(L_1,L_2^\prime\)&lt;/span>在一个平面&lt;span class="math inline">\(\pi\)&lt;/span>上 $M_1 &lt;span class="math inline">\(平面，\)&lt;/span> = &lt;span class="math inline">\(，则可以确定平面\)&lt;/span>$ 求异面直线间的距离转化为求&lt;a href="#点到平面的距离">点&lt;span class="math inline">\(M_2\)&lt;/span>到平面&lt;span class="math inline">\(\pi\)&lt;/span>的距离&lt;/a>。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200827113459143.png" alt="" />&lt;figcaption>image-20200827113459143&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-向量代数与空间解析几何习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 01 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-向量代数与空间解析几何习题">高等数学-向量代数与空间解析几何习题&lt;/h1>
&lt;h2 id="向量概念的考察">向量概念的考察&lt;/h2>
&lt;h4 id="向量">向量&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905184450689.png" alt="" />&lt;figcaption>image-20200905184450689&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905184511797.png" alt="" />&lt;figcaption>image-20200905184511797&lt;/figcaption>
&lt;/figure>
&lt;p>或者根据交点到两边的对称点的两个向量是两个大小相等、方向相反的向量来做。&lt;/p>
&lt;h4 id="夹角余弦">夹角余弦&lt;/h4>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905174929818.png" alt="" />&lt;figcaption>image-20200905174929818&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905174845185.png" alt="" />&lt;figcaption>image-20200905174845185&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906093626296.png" alt="" />&lt;figcaption>image-20200906093626296&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906093637707.png" alt="" />&lt;figcaption>image-20200906093637707&lt;/figcaption>
&lt;/figure>
&lt;h4 id="向量的数量积">向量的数量积&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905233247357.png" alt="" />&lt;figcaption>image-20200905233247357&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905233302354.png" alt="" />&lt;figcaption>image-20200905233302354&lt;/figcaption>
&lt;/figure>
&lt;h4 id="向量的向量积">向量的向量积&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906094519793.png" alt="" />&lt;figcaption>image-20200906094519793&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906094504383.png" alt="" />&lt;figcaption>image-20200906094504383&lt;/figcaption>
&lt;/figure>
&lt;h4 id="向量的混合积">向量的混合积&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906103157596.png" alt="" />&lt;figcaption>image-20200906103157596&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906103051483.png" alt="" />&lt;figcaption>image-20200906103051483&lt;/figcaption>
&lt;/figure>
&lt;p>两直线共面，混合积为0&lt;/p>
&lt;h2 id="空间平面">空间平面&lt;/h2>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905175405890.png" alt="" />&lt;figcaption>image-20200905175405890&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905175426305.png" alt="" />&lt;figcaption>image-20200905175426305&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905175444606.png" alt="" />&lt;figcaption>image-20200905175444606&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905183510586.png" alt="" />&lt;figcaption>image-20200905183510586&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905183529769.png" alt="" />&lt;figcaption>image-20200905183529769&lt;/figcaption>
&lt;/figure>
&lt;p>此题也可用过直线的平面束的方法来做。&lt;/p>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905234542278.png" alt="" />&lt;figcaption>image-20200905234542278&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905234557874.png" alt="" />&lt;figcaption>image-20200905234557874&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906080426002.png" alt="" />&lt;figcaption>image-20200906080426002&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906080440610.png" alt="" />&lt;figcaption>image-20200906080440610&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906080806612.png" alt="" />&lt;figcaption>image-20200906080806612&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906080826356.png" alt="" />&lt;figcaption>image-20200906080826356&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906081252618.png" alt="" />&lt;figcaption>image-20200906081252618&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906081306248.png" alt="" />&lt;figcaption>image-20200906081306248&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906084306386.png" alt="" />&lt;figcaption>image-20200906084306386&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906084321401.png" alt="" />&lt;figcaption>image-20200906084321401&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906094211792.png" alt="" />&lt;figcaption>image-20200906094211792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906094228013.png" alt="" />&lt;figcaption>image-20200906094228013&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906095723919.png" alt="" />&lt;figcaption>image-20200906095723919&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906095758025.png" alt="" />&lt;figcaption>image-20200906095758025&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100039278.png" alt="" />&lt;figcaption>image-20200906100039278&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100047664.png" alt="" />&lt;figcaption>image-20200906100047664&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100056168.png" alt="" />&lt;figcaption>image-20200906100056168&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100646084.png" alt="" />&lt;figcaption>image-20200906100646084&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100657279.png" alt="" />&lt;figcaption>image-20200906100657279&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100943223.png" alt="" />&lt;figcaption>image-20200906100943223&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906100953820.png" alt="" />&lt;figcaption>image-20200906100953820&lt;/figcaption>
&lt;/figure>
&lt;h2 id="空间曲面">空间曲面&lt;/h2>
&lt;h3 id="旋转曲面">旋转曲面&lt;/h3>
&lt;h4 id="旋转曲面的方程">旋转曲面的方程&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905175908197.png" alt="" />&lt;figcaption>image-20200905175908197&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905175854887.png" alt="" />&lt;figcaption>image-20200905175854887&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905180815701.png" alt="" />&lt;figcaption>image-20200905180815701&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905180835847.png" alt="" />&lt;figcaption>image-20200905180835847&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906110820088.png" alt="" />&lt;figcaption>image-20200906110820088&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906110831935.png" alt="" />&lt;figcaption>image-20200906110831935&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906110845051.png" alt="" />&lt;figcaption>image-20200906110845051&lt;/figcaption>
&lt;/figure>
&lt;h3 id="曲面某点处的法线">曲面某点处的法线&lt;/h3>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906084953030.png" alt="" />&lt;figcaption>image-20200906084953030&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906085005526.png" alt="" />&lt;figcaption>image-20200906085005526&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906090925529.png" alt="" />&lt;figcaption>image-20200906090925529&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906090933827.png" alt="" />&lt;figcaption>image-20200906090933827&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906090944633.png" alt="" />&lt;figcaption>image-20200906090944633&lt;/figcaption>
&lt;/figure>
&lt;h3 id="曲面某点处的切平面">曲面某点处的切平面&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906091426748.png" alt="" />&lt;figcaption>image-20200906091426748&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906091436624.png" alt="" />&lt;figcaption>image-20200906091436624&lt;/figcaption>
&lt;/figure>
&lt;h2 id="空间直线">空间直线&lt;/h2>
&lt;h3 id="求空间直线">求空间直线&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905181526670.png" alt="" />&lt;figcaption>image-20200905181526670&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905181539751.png" alt="" />&lt;figcaption>image-20200905181539751&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906101354857.png" alt="" />&lt;figcaption>image-20200906101354857&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906101406485.png" alt="" />&lt;figcaption>image-20200906101406485&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求直线在平面上的投影直线">求直线在平面上的投影直线&lt;/h3>
&lt;p>一般用过直线的平面束的方法做&lt;/p>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905182432012.png" alt="" />&lt;figcaption>image-20200905182432012&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905182444098.png" alt="" />&lt;figcaption>image-20200905182444098&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906101839101.png" alt="" />&lt;figcaption>image-20200906101839101&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906101851441.png" alt="" />&lt;figcaption>image-20200906101851441&lt;/figcaption>
&lt;/figure>
&lt;p>也可以先求出过直线L并垂直于平面&lt;span class="math inline">\(\pi\)&lt;/span>的平面&lt;span class="math inline">\(\pi_2\)&lt;/span>，则平面&lt;span class="math inline">\(\pi\)&lt;/span>与平面&lt;span class="math inline">\(\pi_2\)&lt;/span>的交线就是投影直线。&lt;/p>
&lt;h2 id="夹角">夹角&lt;/h2>
&lt;h3 id="直线与平面的位置关系">直线与平面的位置关系&lt;/h3>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092006813.png" alt="" />&lt;figcaption>image-20200906092006813&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092017071.png" alt="" />&lt;figcaption>image-20200906092017071&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092930226.png" alt="" />&lt;figcaption>image-20200906092930226&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092940261.png" alt="" />&lt;figcaption>image-20200906092940261&lt;/figcaption>
&lt;/figure>
&lt;h3 id="两直线的夹角">两直线的夹角&lt;/h3>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092431414.png" alt="" />&lt;figcaption>image-20200906092431414&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906092413025.png" alt="" />&lt;figcaption>image-20200906092413025&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906102311607.png" alt="" />&lt;figcaption>image-20200906102311607&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906102325137.png" alt="" />&lt;figcaption>image-20200906102325137&lt;/figcaption>
&lt;/figure>
&lt;h3 id="两直线共面">两直线共面&lt;/h3>
&lt;p>参见&lt;a href="#向量的混合积">向量的混合积&lt;/a>。&lt;/p>
&lt;p>两直线共面，混合积为0；两直线异面，混合积不为0.&lt;/p>
&lt;h2 id="距离">距离&lt;/h2>
&lt;h3 id="点到平面的距离">点到平面的距离&lt;/h3>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906085321799.png" alt="" />&lt;figcaption>image-20200906085321799&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906085331720.png" alt="" />&lt;figcaption>image-20200906085331720&lt;/figcaption>
&lt;/figure>
&lt;h3 id="平行平面之间的距离">平行平面之间的距离&lt;/h3>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906085528863.png" alt="" />&lt;figcaption>image-20200906085528863&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906085536873.png" alt="" />&lt;figcaption>image-20200906085536873&lt;/figcaption>
&lt;/figure>
&lt;h3 id="点到直线的距离">点到直线的距离&lt;/h3>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905180407489.png" alt="" />&lt;figcaption>image-20200905180407489&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905180345790.png" alt="" />&lt;figcaption>image-20200905180345790&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906090123300.png" alt="" />&lt;figcaption>image-20200906090123300&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200906090134326.png" alt="" />&lt;figcaption>image-20200906090134326&lt;/figcaption>
&lt;/figure>
&lt;h3 id="异面直线间的距离">异面直线间的距离&lt;/h3>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905185829684.png" alt="" />&lt;figcaption>image-20200905185829684&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905185845028.png" alt="" />&lt;figcaption>image-20200905185845028&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200905185856732.png" alt="" />&lt;figcaption>image-20200905185856732&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-微分方程</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</link><pubDate>Sat, 28 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-微分方程">高等数学-微分方程&lt;/h1>
&lt;p>许多问题中，往往不能直接给出所需要的函数关系，看是根据问题所提供的情况，有时可以列出含有要找的函数及其导数的关系式。这样的关系式就是&lt;strong>微分方程&lt;/strong>。&lt;/p>
&lt;p>微分方程建立后，对它进行研究，找出未知函数来，这就是&lt;strong>解微分方程&lt;/strong>。&lt;/p>
&lt;h2 id="微分方程的基本概念">微分方程的基本概念&lt;/h2>
&lt;h5 id="微分方程">微分方程&lt;/h5>
&lt;p>&lt;strong>微分方程&lt;/strong>：含有自变量、未知函数以及未知函数导数或微分的方程。&lt;/p>
&lt;p>&lt;strong>常微分方程&lt;/strong>：未知函数是一元函数的微分方程。&lt;/p>
&lt;p>常微分方程&lt;strong>一般形式&lt;/strong>：&lt;span class="math inline">\(F\left(x, y, y^{\prime}, \cdots * y^{(n)}\right)=0\)&lt;/span>&lt;/p>
&lt;p>常微分方程&lt;strong>标准形式&lt;/strong>（可解出最高阶导数）：&lt;span class="math inline">\(y^{(n)}=f\left(x, y, y^{\prime}, \cdots, y^{(n-1)}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>微分方程的阶&lt;/strong>：微分方程中所出现的未知函数的最高阶导数的阶数。&lt;/p>
&lt;p>&lt;strong>微分方程的解&lt;/strong>：建立微分方程后，找出满足微分方程的函数，这个函数代入微分方程能使该方程成为恒等式，这个函数就叫做微分方程的解。&lt;/p>
&lt;p>&lt;strong>微分方程的通解&lt;/strong>：如果微分方程的解中含有任意常数，且任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。&lt;/p>
&lt;p>&lt;strong>微分方程的初值条件&lt;/strong>（定解条件）：根据实际情况给定的条件，用来确定微分方程的通解中的任意常数。&lt;/p>
&lt;p>&lt;strong>微分方程的特解&lt;/strong>：确定了通解中的任意常数后，就得到了微分方程的特解。&lt;/p>
&lt;p>微分方程的积分曲线：微分方程的解&lt;span class="math inline">\(y=y(x)\)&lt;/span>所表示的曲线。&lt;/p>
&lt;h2 id="一阶微分方程yprimefx-y及解法">一阶微分方程&lt;span class="math inline">\(y^{\prime}=f(x, y)\)&lt;/span>及解法&lt;/h2>
&lt;p>一阶微分方程标准形式&lt;span class="math inline">\(\frac{dy}{dx} = P(x,y)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>利用变量代换&lt;/strong>（因变量的变量代换或者自变量的变量代换）把一个&lt;strong>微分方程化为变量可分离的方程&lt;/strong>，或者&lt;strong>化为已知求解步骤的方程&lt;/strong>，这是解微分方程最常用的方法。&lt;/p>
&lt;p>&lt;strong>一阶微分方程中，可解的方程&lt;/strong>有： 可分离变量的微分方程、 齐次微分方程、 线性微分方程、 非线性微分方程中的伯努利方程&lt;/p>
&lt;p>一阶的微分方程中，&lt;strong>一般的非线性微分方程不可解&lt;/strong>。&lt;/p>
&lt;h3 id="可分离变量的一阶微分方程">可分离变量的一阶微分方程&lt;/h3>
&lt;p>可分离变量的一阶微分方程：某些一阶微分方程可以化成即微分方程一端只含x和&lt;span class="math inline">\(dx\)&lt;/span>，另一端只含y和&lt;span class="math inline">\(dy\)&lt;/span>&lt;/p>
&lt;p>的形式。如&lt;span class="math inline">\(\frac{dy}{dx} = P(x)Q(y)\)&lt;/span>，或者&lt;span class="math inline">\(g(y) \mathrm{d} y=f(x) \mathrm{d} x\)&lt;/span>。&lt;/p>
&lt;p>对于可分离变量的一阶微分方程，分离变量后，两边取积分即可求得原方程得通解。&lt;/p>
&lt;p>分离变量法是求解微分方程的根本方法。&lt;/p>
&lt;h3 id="一阶x与y齐次微分方程">一阶[x与y齐次]微分方程&lt;/h3>
&lt;p>注：请注意微分方程中&lt;a href="#附：齐次的辨析">齐次的不同意义&lt;/a>&lt;/p>
&lt;h4 id="齐次方程">齐次方程&lt;/h4>
&lt;p>如果一阶微分方程可以写成&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=\varphi\left(\frac{y}{x}\right)\)&lt;/span>，是x与y齐次的一阶微分方程，简称&lt;strong>齐次方程&lt;/strong>。&lt;/p>
&lt;p>求&lt;strong>解x与y齐次的一阶微分方程，方法是作变量代换&lt;span class="math inline">\(u=\frac{y}{x}\)&lt;/span>，&lt;/strong>则&lt;span class="math inline">\(y=ux, \frac{dy}{dx}=x \frac{du}{dx} + u\)&lt;/span>。 代入原方程得&lt;span class="math inline">\(u+x \frac{\mathrm{d} u}{\mathrm{d} x}=\varphi(u)\)&lt;/span>。 这是一个可分离变量的一阶微分方程，分离变量得 &lt;span class="math inline">\(\frac{\mathrm{d} u}{\varphi(u)-u}=\frac{\mathrm{d} x}{x}\)&lt;/span>，两边取积分可求得原方程通解。&lt;/p>
&lt;h4 id="可化为齐次的方程">可化为齐次的方程&lt;/h4>
&lt;p>1）对于方程&lt;span class="math inline">\(\frac{\mathrm{d} Y}{\mathrm{d} X}=\frac{a X+b Y}{a_{1} X+b_{1} Y}\)&lt;/span>，自然可化为齐次方程。&lt;/p>
&lt;p>2）对于方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=\frac{a x+b y+c}{a_{1} x+b_{1} y+c_{1}}\)&lt;/span>，作变量代换&lt;span class="math inline">\(x=X+h, \quad y=Y+k\)&lt;/span>， 方程变为&lt;span class="math inline">\(\frac{\mathrm{d} Y}{\mathrm{d} X}=\frac{a X+b Y+a h+b k+c}{a_{1} X+b_{1} Y+a_{1} h+b_{1} k+c_{1}}\)&lt;/span>， 令&lt;span class="math inline">\(\left\{\begin{array}{l}a h+b k+c=0 \\ a_{1} h+b_{1} k+c_{1}=0\end{array}\right.\)&lt;/span>，可解出h和k，同时方程可化为齐次方程。&lt;/p>
&lt;p>3）对于方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=f\left(\frac{a x+b y+c}{a_{1} x+b_{1} y+c_{1}}\right)\)&lt;/span>，类似的，也可以化为齐次方程。&lt;/p>
&lt;h3 id="解一阶线性微分方程">解一阶线性微分方程&lt;/h3>
&lt;p>一阶线性微分方程：&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>。它对于未知函数y和其1阶导数导数都是1次。&lt;/p>
&lt;p>线性：（数乘+加法）性质&lt;/p>
&lt;p>&lt;a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">线性方程组：线性的说明：维基百科&lt;/a>&lt;/p>
&lt;p>注意：像&lt;span class="math inline">\(y^{\prime}+y \tan x=\cos x\)&lt;/span>这样的微分方程，也是一阶线性微分方程。&lt;/p>
&lt;h4 id="解一阶y和y齐次线性微分方程分离变数法">解一阶[y和y‘齐次]线性微分方程：分离变数法&lt;/h4>
&lt;p>一阶线性微分方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>，当&lt;span class="math inline">\(Q(x)=0\)&lt;/span>时，即&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=0\)&lt;/span>时，称为一阶（y和y的导数齐次）线性微分方程，简称&lt;strong>齐次线性方程&lt;/strong>&lt;/p>
&lt;p>&lt;strong>求解&lt;/strong>：齐次线性方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=0\)&lt;/span>可用&lt;strong>分离变数法&lt;/strong>求得&lt;strong>齐次线性方程的通解&lt;/strong>&lt;span class="math inline">\(y=C \mathrm{e}^{-\int P(x) \mathrm{d} x}\)&lt;/span>。&lt;/p>
&lt;h4 id="解一阶y和y非齐次线性微分方程常数变易法">解一阶[y和y’非齐次]线性微分方程：常数变易法&lt;/h4>
&lt;p>一阶线性微分方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>，当&lt;span class="math inline">\(Q(x) \neq 0\)&lt;/span>时，称为一阶（y和y‘非齐次）线性微分方程，简称一阶&lt;strong>非齐次线性方程&lt;/strong> (注：这里除了齐次的y和y’项，还有自由项&lt;span class="math inline">\(Q(x)\)&lt;/span>存在，所以非齐次)&lt;/p>
&lt;p>&lt;strong>求解&lt;/strong>：求解一阶非齐次线性微分方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>的方法是&lt;strong>常数变易法&lt;/strong>： 首先，其对应的一阶齐次线性微分方程的通解&lt;span class="math inline">\(y=C \mathrm{e}^{-\int P(x) \mathrm{d} x}\)&lt;/span>，将其中的常数C替换为x的函数&lt;span class="math inline">\(u(x)\)&lt;/span>，即&lt;span class="math inline">\(y=u(x) \mathrm{e}^{-\int P(x) \mathrm{d} x}\)&lt;/span>，作为非齐次线性微分方程的解。 将其代入非齐次线性方程，解得&lt;span class="math inline">\(u=\int Q(x) \mathrm{e}^{\int P(x) \mathrm{d} x} \mathrm{d} x+C\)&lt;/span>。 从而解得&lt;strong>非齐次线性方程的通解&lt;/strong>&lt;span class="math inline">\(y=\mathrm{e}^{-\int P(x) \mathrm{d} x}\left(\int Q(x) \mathrm{e}^{\int P(x) \mathrm{d} x} \mathrm{d} x+C\right)\)&lt;/span> 此通解也可以&lt;strong>看作齐次线性方程的通解和非齐次方程一个特解之和&lt;/strong>$y=C ^{-P(x) d x}+ ^{-P(x) x} $&lt;/p>
&lt;p>（关于常数变易法的更多讨论，参见：&lt;a href="#非齐次线性微分方程的求解（已知齐次通解）：常数变易法">解非齐次线性微分方程：常数变易法&lt;/a>&lt;/p>
&lt;h3 id="伯努利方程">伯努利方程&lt;/h3>
&lt;p>伯努利方程：&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x) y^{n} \quad(n \neq 0,1)\)&lt;/span>&lt;/p>
&lt;p>当&lt;span class="math inline">\(n=0\)&lt;/span>或&lt;span class="math inline">\(n=1\)&lt;/span>时，为线性微分方程。&lt;/p>
&lt;p>当&lt;span class="math inline">\(n \neq 0 , n \neq 1\)&lt;/span>时，为伯努利方程，这个是&lt;strong>非线性方程&lt;/strong>。&lt;/p>
&lt;p>通过变量代换，可以化为线性方程求解： 以&lt;span class="math inline">\(y^n\)&lt;/span>除方程两端，得：&lt;span class="math inline">\(y^{-n} \frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y^{1-n}=Q(x)\)&lt;/span> 得：&lt;span class="math inline">\(\frac{1}{1-n}\frac{\mathrm{d}}{\mathrm{d} x}\left(y^{1-n}\right)+P(x) y^{1-n}=Q(x)\)&lt;/span>&lt;br />
令&lt;span class="math inline">\(z=y^{1-n}\)&lt;/span>，得：&lt;span class="math inline">\(\frac{\mathrm{d} z}{\mathrm{d} x}+(1-n) P(x) z=(1-n) Q(x)\)&lt;/span> 上式是个一阶线性微分方程，根据前一节给出的方法可以求其通解。 以&lt;span class="math inline">\(y^{1-n}\)&lt;/span>代z即伯努利方程的通解。&lt;/p>
&lt;h2 id="可降至一阶的高阶微分方程及解法">可降至一阶的高阶微分方程及解法&lt;/h2>
&lt;p>&lt;strong>高阶微分方程&lt;/strong>：二阶及二阶以上的微分方程。&lt;/p>
&lt;p>对于&lt;strong>有些高阶微分方程，可以通过代换将它化成较低阶的方程来求解&lt;/strong>。&lt;/p>
&lt;h3 id="ynfx型微分方程">&lt;span class="math inline">\(y^{(n)}=f(x)\)&lt;/span>型微分方程&lt;/h3>
&lt;p>&lt;strong>变量代换&lt;/strong>：如果&lt;strong>把&lt;span class="math inline">\(y^{(n-1)}\)&lt;/span>看作未知函数&lt;/strong>，则微分方程就是该函数的一阶可分离变量微分方程。&lt;/p>
&lt;p>&lt;strong>求解方法&lt;/strong>：两边分别对&lt;span class="math inline">\(y\)&lt;/span>和&lt;span class="math inline">\(x\)&lt;/span>积分，重复多次即可。&lt;/p>
&lt;p>注意：每积分一次，产生一个不相关的常数。&lt;/p>
&lt;h3 id="yprime-primefleftx-yprimeright型微分方程">&lt;span class="math inline">\(y^{\prime \prime}=f\left(x, y^{\prime}\right)\)&lt;/span>型微分方程&lt;/h3>
&lt;p>&lt;span class="math inline">\(y^{\prime \prime}=f\left(x, y^{\prime}\right)\)&lt;/span>，方程右端不显含y。&lt;/p>
&lt;p>&lt;strong>变量代换与求解&lt;/strong>：将&lt;span class="math inline">\(y&amp;#39;\)&lt;/span>看作未知函数p，即&lt;span class="math inline">\(y^{\prime}=p\)&lt;/span>， 同时有&lt;span class="math inline">\(y^{\prime \prime}=\frac{\mathrm{d} p}{\mathrm{d} x}=p^{\prime}\)&lt;/span>， 则方程化为一阶微分方程&lt;span class="math inline">\(p^{\prime}=f(x, p)\)&lt;/span> 假如解出p的通解&lt;span class="math inline">\(p=\varphi\left(x, C_{1}\right)\)&lt;/span>，即&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=\varphi\left(x, C_{1}\right)\)&lt;/span>，这又是一个可分离变量的一阶微分方程，继续求解可得y的通解&lt;/p>
&lt;h3 id="yprime-primeflefty-yprimeright型微分方程">&lt;span class="math inline">\(y^{\prime \prime}=f\left(y, y^{\prime}\right)\)&lt;/span>型微分方程&lt;/h3>
&lt;p>&lt;span class="math inline">\(y^{\prime \prime}=f\left(y, y^{\prime}\right)\)&lt;/span>，方程右端不显含x。&lt;/p>
&lt;p>&lt;strong>变量代换与求解&lt;/strong>：将&lt;span class="math inline">\(y&amp;#39;\)&lt;/span>看作未知函数p，即&lt;span class="math inline">\(y^{\prime}=p\)&lt;/span>， 由复合函数求导法则有&lt;span class="math inline">\(y^{\prime \prime}=\frac{\mathrm{d} p}{\mathrm{d} x}=\frac{\mathrm{d} p}{\mathrm{d} y} \cdot \frac{\mathrm{d} y}{\mathrm{d} x}=p \frac{\mathrm{d} p}{\mathrm{d} y}\)&lt;/span>， 原方程变为&lt;span class="math inline">\(p \frac{\mathrm{d} p}{\mathrm{d} y}=f(y, p)\)&lt;/span>， 即&lt;span class="math inline">\(\frac{\mathrm{d} p}{\mathrm{d} y}=\frac {f(y, p)}{p}\)&lt;/span>，这是关于y，p为变量的一阶微分方程。 设此一阶方程可解，且其通解为&lt;span class="math inline">\(y^{\prime}=p=\varphi\left(y, C_{1}\right)\)&lt;/span>， 分离变量并积分，可得最初方程的通解。&lt;/p>
&lt;h2 id="线性微分方程">线性微分方程&lt;/h2>
&lt;p>高阶线性方程在实际应用较多。 如有空气阻尼弹簧振子自由振动的微分方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2 n \frac{\mathrm{d} x}{\mathrm{d} t}+k^{2} x=0\)&lt;/span>， 如弹簧振子受迫振动的微分方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2 n \frac{\mathrm{d} x}{\mathrm{d} t}+k^{2} x=h \sin p t\)&lt;/span> 带交流电源串联LC电路震荡方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} x}{\mathrm{d} t^{2}}+2 n \frac{\mathrm{d} x}{\mathrm{d} t}+k^{2} x=h \sin p t\)&lt;/span> 充电后撤电源串联LC电路震荡方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} u_{C}}{\mathrm{d} t^{2}}+2 \beta \frac{\mathrm{d} u_{C}}{\mathrm{d} t}+\omega_{0}^{2} u_{c}=0\)&lt;/span> (推导过程见：同济高数：第七版（上册）高阶线性微分方程章节)&lt;/p>
&lt;h3 id="线性微分方程的形式">线性微分方程的形式&lt;/h3>
&lt;h4 id="一阶线性微分方程">一阶线性微分方程&lt;/h4>
&lt;p>一阶线性微分方程：&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>。它对于未知函数y和其1阶导数导数都是1次。&lt;/p>
&lt;p>前面已经讨论过一阶线性微分方程，分离变数法可以求解对应的一阶齐次线性微分方程，常数变易法可以求解一阶非齐次线性微分方程。下面不多做赘述。&lt;/p>
&lt;h4 id="二阶线性微分方程">二阶线性微分方程&lt;/h4>
&lt;p>二阶线性微分方程：&lt;span class="math inline">\(\frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}}+P(x) \frac{\mathrm{d} y}{\mathrm{d} x}+Q(x) y=f(x)\)&lt;/span>。它对于y及y的各阶导都是一次的，具有线性特征（数乘、加法）&lt;/p>
&lt;h5 id="二阶yyy齐次线性微分方程">二阶[y、y’、y‘’齐次]线性微分方程&lt;/h5>
&lt;p>当二阶线性微分方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}}+P(x) \frac{\mathrm{d} y}{\mathrm{d} x}+Q(x) y=f(x)\)&lt;/span>取&lt;span class="math inline">\(f(x)=0\)&lt;/span>时， 即&lt;span class="math inline">\(\frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}}+P(x) \frac{\mathrm{d} y}{\mathrm{d} x}+Q(x) y=0\)&lt;/span>，称为二阶[y、y’、y‘’齐次]线性微分方程，简称&lt;strong>二阶齐次线性微分方程&lt;/strong>&lt;/p>
&lt;p>(关于“齐次”的讨论与辨析，请参考&lt;a href="#附：齐次的辨析">附：齐次的辨析&lt;/a>)&lt;/p>
&lt;h6 id="二阶常系数齐次线性微分方程">二阶常系数齐次线性微分方程&lt;/h6>
&lt;p>如果二阶齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>中，如果 &lt;span class="math inline">\(y^{\prime}, y\)&lt;/span> 的系数 &lt;span class="math inline">\(P(x), Q(x)\)&lt;/span> 均为常数, 即&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>，其中 &lt;span class="math inline">\(p, q\)&lt;/span> 是常数，称为二阶常系数齐次线性微分方程。&lt;/p>
&lt;p>二阶常系数齐次线性微分方程是可以解出来的，并可以总结为公式。详见&lt;a href="#常系数齐次线性微分方程的求解">后面的章节&lt;/a>&lt;/p>
&lt;h5 id="二阶yyy非齐次线性微分方程">二阶[y、y’、y‘’非齐次]线性微分方程&lt;/h5>
&lt;p>当二阶线性微分方程&lt;span class="math inline">\(\frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}}+P(x) \frac{\mathrm{d} y}{\mathrm{d} x}+Q(x) y=f(x)\)&lt;/span>取&lt;span class="math inline">\(f(x) \neq 0\)&lt;/span>时，称为二阶[y、y’、y‘’非齐次]线性微分方程，简称&lt;strong>二阶非齐次线性微分方程&lt;/strong>&lt;/p>
&lt;h6 id="二阶常系数非齐次线性微分方程">二阶常系数非齐次线性微分方程&lt;/h6>
&lt;p>类似的，如果二阶非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\)&lt;/span>中，如果 &lt;span class="math inline">\(y^{\prime}, y\)&lt;/span> 的系数 &lt;span class="math inline">\(P(x), Q(x)\)&lt;/span> 均为常数, 即&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=f(x)\)&lt;/span>，其中 &lt;span class="math inline">\(p, q\)&lt;/span> 是常数，称为二阶常系数非齐次线性微分方程。&lt;/p>
&lt;p>二阶常系数非齐次线性微分方程是可以解出来的，并可以总结为公式。详见&lt;a href="#常系数齐次线性微分方程的求解">后面的章节&lt;/a>&lt;/p>
&lt;h4 id="n阶线性微分方程">n阶线性微分方程&lt;/h4>
&lt;p>n阶线性微分方程：&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>&lt;/p>
&lt;p>二阶线性微分方程解的性质，可以推广导n阶线性微分方程&lt;/p>
&lt;h5 id="n阶常系数齐次线性微分方程">n阶常系数齐次线性微分方程&lt;/h5>
&lt;p>类似于二阶，有n阶常系数齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=0\)&lt;/span>，其中 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{n-1}, p_{n}\)&lt;/span> 都是常数.&lt;/p>
&lt;p>二阶常系数齐次线性微分方程也可以总结为公式。详见&lt;a href="#常系数齐次线性微分方程的求解">后面的章节&lt;/a>&lt;/p>
&lt;h5 id="n阶常系数非齐次线性微分方程">n阶常系数非齐次线性微分方程&lt;/h5>
&lt;p>以及有n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=f(x)\)&lt;/span>，其中 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{n-1}, p_{n}\)&lt;/span> 都是常数.&lt;/p>
&lt;p>n阶常系数非齐次线性微分方程也可以总结为公式。详见&lt;a href="#常系数齐次线性微分方程的求解">后面的章节&lt;/a>&lt;/p>
&lt;h3 id="线性微分方程解的性质与结构">线性微分方程解的性质与结构&lt;/h3>
&lt;h5 id="二阶与更高阶齐次线性微分方程解的叠加原理">二阶与更高阶齐次线性微分方程解的叠加原理&lt;/h5>
&lt;p>如果函数 &lt;span class="math inline">\(y_{1}(x)\)&lt;/span> 与 &lt;span class="math inline">\(y_{2}(x)\)&lt;/span> 是二阶齐次线性方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>的两个解, 那么&lt;span class="math inline">\(y=C_{1} y_{1}(x)+C_{2} y_{2}(x)\)&lt;/span>也是这个方程的解，其中&lt;span class="math inline">\(C_1,C_2\)&lt;/span>是任意常数&lt;/p>
&lt;p>（证明：将y代入即可）&lt;/p>
&lt;p>（同理可证，n阶齐次线性微分方程的解，都满足叠加原理）&lt;/p>
&lt;h5 id="二阶或更高阶齐次线性微分方程解的结构">二阶或更高阶齐次线性微分方程解的结构&lt;/h5>
&lt;p>如果函数 &lt;span class="math inline">\(y_{1}(x)\)&lt;/span> 与 &lt;span class="math inline">\(y_{2}(x)\)&lt;/span> 是二阶齐次线性方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>的&lt;strong>线性无关的两个特解&lt;/strong>, 那么&lt;span class="math inline">\(y=C_{1} y_{1}(x)+C_{2} y_{2}(x)\)&lt;/span>是这个方程的通解，其中&lt;span class="math inline">\(C_1,C_2\)&lt;/span>是任意常数&lt;/p>
&lt;p>（&lt;a href="#附2：线性相关与线性无关">函数的线性相关与线性无关&lt;/a>的说明）&lt;/p>
&lt;p>（证明：根据齐次方程解的叠加原理，y是这个齐次方程的解；y中常数个数等于方程阶数，所以是方程的通解）&lt;/p>
&lt;p>（同理可证，n阶齐次线性微分方程解的结构，也有类似二阶的结论）&lt;/p>
&lt;h5 id="二阶或更高阶非齐次线性微分方程解的叠加原理">二阶或更高阶非齐次线性微分方程解的叠加原理&lt;/h5>
&lt;p>设&lt;span class="math inline">\(y_{1}^{*}(x)\)&lt;/span> 与 &lt;span class="math inline">\(y_{2}^{*}(x)\)&lt;/span> 分别是方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f_{1}(x)\)&lt;/span>与&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f_{2}(x)\)&lt;/span>的特解， 则&lt;span class="math inline">\(y_{1}^{*}(x)+y_{2}^{*}(x)\)&lt;/span>是&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f_{1}(x)+f_{2}(x)\)&lt;/span>的特解。&lt;/p>
&lt;p>（证明：代入即可证明）&lt;/p>
&lt;p>（同理可证，n阶非齐次线性微分方程，也满足叠加原理）&lt;/p>
&lt;h5 id="二阶或更高阶非齐次线性微分方程解的结构">二阶或更高阶非齐次线性微分方程解的结构&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(y^{*}(x)\)&lt;/span> 是二阶非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\)&lt;/span>的一个特解， &lt;span class="math inline">\(Y(x)\)&lt;/span> 是与 之对应的齐次方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>通解, 则&lt;span class="math inline">\(y=Y(x)+y^{*}(x)\)&lt;/span>是非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\)&lt;/span>的通解。&lt;/p>
&lt;p>（证明：将y代入微分方程即可）&lt;/p>
&lt;p>（同理可证，n阶非齐次线性微分方程，解的结构也有类似二阶的结论）&lt;/p>
&lt;h3 id="非齐次线性微分方程的求解已知齐次通解常数变易法">非齐次线性微分方程的求解（已知齐次通解）：常数变易法&lt;/h3>
&lt;p>（常数变易法解非齐次线性微分方程的&lt;strong>前提是，已经求出对应齐次线性微分方程的通解&lt;/strong>。） （但是遗憾的是，除了常系数齐次线性微分方程，大部分的变系数齐次线性微分方程都求不出通解）&lt;/p>
&lt;p>根据齐次线性微分方程的通解，将&lt;strong>齐次解的常数&lt;span class="math inline">\(C_i\)&lt;/span>替换为x的函数&lt;span class="math inline">\(C_i(x)\)&lt;/span>作为非齐次的解&lt;/strong>，可以解出对应的非齐线性微分方程，这种方法叫&lt;strong>常数变易法&lt;/strong>，又称拉格朗日法。&lt;/p>
&lt;p>参考：高等数学同济第七版（上） 参考：知乎：https://www.zhihu.com/question/31329122 参考：知乎：https://www.zhihu.com/question/41042058&lt;/p>
&lt;h4 id="解一阶y与y非齐次线性微分方程常数变易法">解一阶[y与y’非齐次]线性微分方程：常数变易法&lt;/h4>
&lt;p>对于非齐次线性方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x)\)&lt;/span>的求解，可以用&lt;strong>常数变易法&lt;/strong>： 对应的一阶齐次线性方程&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=0\)&lt;/span>的通解（已知）为&lt;span class="math inline">\(y=C y_1 = C \mathrm{e}^{-\int P(x) \mathrm{d} x}\)&lt;/span>， 则设对应非齐次的解为&lt;span class="math inline">\(y=u y_1 = u \mathrm{e}^{-\int P(x) \mathrm{d} x}\)&lt;/span> ，（将齐次解的常数C替换为x的函数&lt;span class="math inline">\(u(x)\)&lt;/span>作为非齐次的解，为什么可以这样做？后面一节提供了&lt;a href="#常数变易法的思路">几种思路&lt;/a>）， 将非齐次的解y代入非齐次线性方程，可解得&lt;span class="math inline">\(u=\int Q(x) \mathrm{e}^{\int P(x) \mathrm{d} x} \mathrm{d} x+C\)&lt;/span>。 从而解得一阶非齐次线性方程的通解&lt;span class="math inline">\(y=\mathrm{e}^{-\int P(x) \mathrm{d} x}\left(\int Q(x) \mathrm{e}^{\int P(x) \mathrm{d} x} \mathrm{d} x+C\right)\)&lt;/span> 此通解也可以看作齐次线性方程的通解和非齐次方程一个特解之和$y=C ^{-P(x) d x}+ ^{-P(x) x} $&lt;/p>
&lt;h4 id="常数变易法的思路">常数变易法的思路&lt;/h4>
&lt;p>分离变量是解微分方程最基础也是最根本的方法。&lt;/p>
&lt;p>常数变易法可以看作是是分离变量的过程中产生的固定方法。&lt;/p>
&lt;h5 id="常数变易法的思路一">常数变易法的思路一&lt;/h5>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-f5daa318393e2d317136b1cf4426eb76_720w.jpg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h5 id="常数变易法思路二">常数变易法思路二&lt;/h5>
&lt;p>参考：东曦.知乎.链接：https://www.zhihu.com/question/31329122/answer/134977454&lt;/p>
&lt;p>一切的一切，都来源于这个小贱人：&lt;img src="https://www.zhihu.com/equation?tex=\frac%7Bdy%7D%7Bdx%7D%2BP(x)·y%3DQ(x)+" alt="[公式]" />,让你求y函数的表达式。&lt;/p>
&lt;p>直白的说，因为有P（x）和Q（x）在那里摆着，首先这个等式不一定齐次。即使齐次，只要Q（x）不等于0，就无法分离变量。&lt;/p>
&lt;p>而我们知道，&lt;strong>变量分离是最根本的解法&lt;/strong>，俗称“万变不离其宗”。那完，这个没法分离变量。&lt;/p>
&lt;p>于是大佬跟它斗争了十一年，最后发现设&lt;img src="https://www.zhihu.com/equation?tex=y%3DU(x)·V(x)" alt="[公式]" />是可以的.（下面简写为&lt;img src="https://www.zhihu.com/equation?tex=y%3Du·v" alt="[公式]" />）&lt;/p>
&lt;p>哦当然当时设的时候他并不知道这样是可以的。总之大佬抱着试一试的心理代入了原式，得到&lt;img src="https://www.zhihu.com/equation?tex=\frac%7Bdu%7D%7Bdx%7D·v%2Bu(\frac%7Bdv%7D%7Bdx%7D%2BP(x)v)%3DQ(x)++" alt="[公式]" />.&lt;/p>
&lt;p>大佬不忘初心，始终坚持着变量分离的思想。“我要分离u和x！”（好吧是我有点中二QAQ）&lt;/p>
&lt;p>在这里插一句，为什么不是分离v和x呢？其实在这里v和u是完全对等的状态，可以说只是符号表示的不同，不信把上式中的v提出来，你会发现形式完全相同。&lt;/p>
&lt;p>回到正题…大佬想要分离u和x。乍一眼看，要是令&lt;img src="https://www.zhihu.com/equation?tex=\frac%7Bdv%7D%7Bdx%7D%2BP(x)v+" alt="[公式]" /> 等于零，那么&lt;img src="https://www.zhihu.com/equation?tex=u(\frac%7Bdv%7D%7Bdx%7D%2BP(x)v)+" alt="[公式]" />一整项就不见了，能求出一个只跟随P（x）变化的函数v，再把v代进&lt;img src="https://www.zhihu.com/equation?tex=\frac%7Bdu%7D%7Bdx%7Dv%3DQ(x)+" alt="[公式]" />，积个分，u不就也出来了么。u和v都能用P（x）、Q（x）表示了，y也就出来了。&lt;/p>
&lt;p>按这个思路一路畅快地推导下来，得到&lt;img src="https://www.zhihu.com/equation?tex=v%3DC_%7B1%7D++e%5E%7B\int_%7B%7D-P(x)dx+%7D+" alt="[公式]" />,&lt;img src="https://www.zhihu.com/equation?tex=u%3D\frac%7B1%7D%7BC_%7B1%7D+%7D+\int_%7B%7D%5E%7B%7DQ(x)e%5E%7B\int_%7B%7D%5E%7B%7DP(x)dx+%7Ddx%2BC_%7B2%7D+" alt="[公式]" />。一路愉快地求出y。&lt;/p>
&lt;p>其实到这里这道题就结束了，结论也可以随便用了。但是！（敲黑板）因为v是跟随P（x）改变而改变的，对每一个确切的一阶线性方程都只存在唯一的一个v，再根据以上的推导过程可以知道对每一个确切的一阶线性方程也只存在唯一的一个u，所以大佬决定省略以上推导过程，就不设&lt;img src="https://www.zhihu.com/equation?tex=y%3Duv" alt="[公式]" />，而是直接设&lt;img src="https://www.zhihu.com/equation?tex=y%3Due%5E%7B\int_%7B%7D%5E%7B%7D-P(x)dx+%7D+" alt="[公式]" />，来求下面的过程。这就是常数变易法。&lt;/p>
&lt;p>问：我有个疑问：这个公式有个前提(dv/dx)+p(x)v＝0，等于0是一个特殊情况，如果不等于0呢？&lt;/p>
&lt;p>答：这个式子不是前提，&lt;strong>是其中一个解&lt;/strong>。0是最容易让人想到从这方面入手的特殊数字，所以拉格朗日试着让它等于0，然后发现确实能解出来。于是这个式子就诞生了。 也许不等于0的时候也有某个解存在呢？但是这还没人做出来。&lt;/p>
&lt;h5 id="常数变易法的思路三">常数变易法的思路三&lt;/h5>
&lt;p>参考：fjh1997.知乎.链接：https://www.zhihu.com/question/31329122/answer/663336777&lt;/p>
&lt;p>首先我们要求解如下式子：&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=y&amp;#39;%2Bp(x)y%3Dq(x)" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>那么可以看出，左边的式子和乘法求导公式有点像，我们可以把式子两边同乘以 &lt;img src="https://www.zhihu.com/equation?tex=u(x)" alt="[公式]" /> ,在这里，我们把 &lt;img src="https://www.zhihu.com/equation?tex=u" alt="[公式]" /> 叫做积分因子，可以得到：&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=y&amp;#39;u%2Bpuy%3Dqu" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>这个时候的思路就很简单，我们要是把左边的式子凑成关于x的某个函数的导数，然后两边积分，岂不是就很容易求解了？让我们试试吧。首先猜测是 &lt;img src="https://www.zhihu.com/equation?tex=(yu)&amp;#39;" alt="[公式]" /> ，那么：&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=(yu)&amp;#39;%3Dy&amp;#39;u%2Bu&amp;#39;y" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>这样，我们只要找到一个 &lt;img src="https://www.zhihu.com/equation?tex=u" alt="[公式]" /> ,使得 &lt;img src="https://www.zhihu.com/equation?tex=u&amp;#39;%3Dpu" alt="[公式]" /> ，那么不就解出来了？&lt;/p>
&lt;p>假如找到这样的u，满足 &lt;img src="https://www.zhihu.com/equation?tex=(yu)&amp;#39;%3Dqu" alt="[公式]" />&lt;/p>
&lt;p>那么可以得到 &lt;img src="https://www.zhihu.com/equation?tex=y%3D\frac+%7B\int+qu%2BC%7Du" alt="[公式]" /> ①&lt;/p>
&lt;p>就完成了求解&lt;/p>
&lt;p>那么，接下来&lt;/p>
&lt;p>让我们解 &lt;img src="https://www.zhihu.com/equation?tex=u&amp;#39;%3Dpu" alt="[公式]" /> 吧&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=\frac+%7Bdu%7D%7Bdx%7D%3Dp(x)u" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>整理得&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=\frac+%7Bdu%7D%7Bu%7D%3Dp(x)dx" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>两边积分得&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=lnu%3D\int+p(x)dx" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;p>故 &lt;img src="https://www.zhihu.com/equation?tex=u%3De%5E%7B\int+pdx%7D" alt="[公式]" />&lt;/p>
&lt;p>要注意的是，以上不定积分只要求出一个满足条件的 &lt;img src="https://www.zhihu.com/equation?tex=u" alt="[公式]" /> 即可，不用全部求出来(因为题目是让你求y,不是求u，u只是辅助而已)&lt;/p>
&lt;p>求得 &lt;img src="https://www.zhihu.com/equation?tex=u" alt="[公式]" /> 之后带入①式子就已经可以解出 &lt;img src="https://www.zhihu.com/equation?tex=y" alt="[公式]" /> 了,这样非常简单，我们把 &lt;img src="https://www.zhihu.com/equation?tex=u" alt="[公式]" /> 带入①来得到同济版的公式吧~&lt;/p>
&lt;figure>
&lt;img src="https://www.zhihu.com/equation?tex=y%3D\frac+%7B\int+qudx%2BC%7Du%3D\frac+%7B\int+qe%5E%7B\int+pdx%7Ddx%2BC%7D%7Be%5E%7B\int+pdx%7D%7D%3D+e%5E%7B-\int+pdx%7D\int+qe%5E%7B\int+pdx%7Ddx%2Be%5E%7B-%5E%7B\int+pdx%7D%7DC" alt="" />&lt;figcaption>[公式]&lt;/figcaption>
&lt;/figure>
&lt;h4 id="解二阶非齐次线性微分方程常数变易法">解二阶非齐次线性微分方程：常数变易法&lt;/h4>
&lt;h5 id="已知齐次通解求解二阶非齐次线性微分方程常数变易法">已知齐次通解，求解二阶非齐次线性微分方程：常数变易法&lt;/h5>
&lt;p>如果已知对应的二阶齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=0\)&lt;/span>的通解为&lt;span class="math inline">\(Y(x)=C_{1} y_{1}(x)+C_{2} y_{2}(x)\)&lt;/span>， 令&lt;span class="math inline">\(y=y_{1}(x) v_{1}+y_{2}(x) v_{2}\)&lt;/span>，要确定函数 &lt;span class="math inline">\(v_{1}(x)\)&lt;/span> 及 &lt;span class="math inline">\(v_{2}(x)\)&lt;/span> 使y满足对应的非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\)&lt;/span>。&lt;/p>
&lt;p>而为了将&lt;span class="math inline">\(y=y_{1}(x) v_{1}+y_{2}(x) v_{2}\)&lt;/span>代入非齐次线性微分方程，我们要求出y的各阶导。 &lt;span class="math inline">\(y^{\prime}=y_{1} v_{1}^{\prime}+y_{2} v_{2}^{\prime}+y_{1}^{\prime} v_{1}+y_{2}^{\prime} v_{2}\)&lt;/span> 当/令&lt;span class="math inline">\(y_{1} v_{1}^{\prime}+y_{2} v_{2}^{\prime}=0\)&lt;/span> 时（&lt;strong>我们添加的限制条件&lt;/strong>，简化计算为宜），&lt;span class="math inline">\(y^{\prime \prime}=y_{1}^{\prime} v_{1}^{\prime}+y_{2}^{\prime} v_{2}^{\prime}+y_{1}^{\prime \prime} v_{1}+y_{2}^{\prime \prime} v_{2}\)&lt;/span>， 然后可将&lt;span class="math inline">\(y,y&amp;#39;, y&amp;#39;&amp;#39;\)&lt;/span>代入非齐次线性微分方程，得&lt;span class="math inline">\(y_{1}^{\prime} v_{1}^{\prime}+y_{2}^{\prime} v_{2}^{\prime}=f(x)\)&lt;/span> &lt;strong>注意&lt;/strong>：添加限制条件&lt;span class="math inline">\(y_{1} v_{1}^{\prime}+y_{2} v_{2}^{\prime}=0\)&lt;/span> 时，如果非齐次线性微分方程&lt;strong>有解的话&lt;/strong>，所对应的y仍是该方程&lt;strong>解的一种情况&lt;/strong>（一个特解） 现在我们已知：&lt;span class="math inline">\(\left\{ \begin{array}{l} y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\\y=y_{1}(x) v_{1}+y_{2}(x) v_{2} \\ y_1 = y_1(x) \quad\text{(已知具体函数形式)}\\ y_2 = y_2(x) \quad\text{(已知具体函数形式)}\\ y_{1} v_{1}^{\prime}+y_{2} v_{2}^{\prime}=0 \quad \text{(我们添加的限制条件)} \end{array} \right.\)&lt;/span> 6个变量&lt;span class="math inline">\(y,y_1,y_2,v_1,v_2,x\)&lt;/span>，5个限制条件，则有1个自由元x，我们可以从中解出&lt;span class="math inline">\(v_1,v_2\)&lt;/span>以及y. 消元，即求解&lt;span class="math inline">\(\left\{ \begin{array}{l} y_{1}^{\prime} v_{1}^{\prime}+y_{2}^{\prime} v_{2}^{\prime}=f(x)\\ y_{1} v_{1}^{\prime}+y_{2} v_{2}^{\prime}=0 \quad \text{(我们添加的限制条件)} \end{array} \right.\)&lt;/span> 即求解以&lt;span class="math inline">\(v_1,v_2\)&lt;/span>为变量的函数矩阵： &lt;span class="math inline">\(\left[\begin{array}{ll}y_{1} &amp;amp; y_{2} \\ y_{1}^{\prime} &amp;amp; y_{2}^{\prime}\end{array}\right]\left[\begin{array}{l}v_{1}^{\prime} \\ v_{2}^{\prime}\end{array}\right]=\left[\begin{array}{l}0 \\ 1\end{array}\right] f(x)\)&lt;/span> 在系数行列式&lt;span class="math inline">\(W=\left|\begin{array}{ll}y_{1} &amp;amp; y_{2} \\ y_{1}^{\prime} &amp;amp; y_{2}^{\prime}\end{array}\right|=y_{1} y_{2}^{\prime}-y_{1}^{\prime} y_{2} \neq 0\)&lt;/span>时， 解得&lt;span class="math inline">\(v_{1}^{\prime}=-\frac{y_{2} f}{W}, v_{2}^{\prime}=\frac{y_{1} f}{W}\)&lt;/span>， 积分得&lt;span class="math inline">\(v_{1}=C_{1}+\int\left(-\frac{y_{2} f}{W}\right) \mathrm{d} x, v_{2}=C_{2}+\int \frac{y_{1} f}{W} \mathrm{d} x\)&lt;/span>， 于是得非齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+P(x) y^{\prime}+Q(x) y=f(x)\)&lt;/span>的通解&lt;span class="math inline">\(y=C_{1} y_{1}+C_{2} y_{2}-y_{1} \int \frac{y_{2} f}{W} \mathrm{d} x+y_{2} \int \frac{y_{1} f}{W} \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h5 id="已知齐次的一个特解求解二阶非齐次线性微分方程常数变易法">已知齐次的一个特解，求解二阶非齐次线性微分方程：常数变易法&lt;/h5>
&lt;p>对于已知二阶非齐次线性微分方程对应的齐次线性微分方程的一个特解&lt;span class="math inline">\(y_1\)&lt;/span>（不恒为0）的情况：&lt;/p>
&lt;p>如果已知二阶非齐次线性微分方程对应的齐次线性微分方程的一个特解&lt;span class="math inline">\(y_1\)&lt;/span>, &lt;strong>也可以使用常数变易法&lt;/strong>，设&lt;span class="math inline">\(y=u(x) \cdot y_1(x)\)&lt;/span>为二阶非齐次线性微分方程的解，代入非齐次方程，可化为一阶非齐次线性微分方程，进而求解。&lt;/p>
&lt;h4 id="解n阶非齐次线性微分方程常数变易法">解n阶非齐次线性微分方程：常数变易法&lt;/h4>
&lt;p>一阶、二阶线性微分方程的常数变易法（即利用对应齐次方程的通解，代换其中常数求非齐次线性方程通解的方法），可以推广到n线性微分方程。&lt;/p>
&lt;p>对于n阶非齐次线性微分方程：&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>&lt;/p>
&lt;p>假设我们求得的对应的n阶齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=0\)&lt;/span>的通解为&lt;span class="math inline">\(y=C_1 y_1 + C_2 y_2 + ... + C_n y_n\)&lt;/span> 常数变易法（把齐次解中的&lt;strong>常数换为未知函数&lt;/strong>作为非齐次的解）： &lt;strong>设&lt;/strong>对应的n阶&lt;strong>非齐次&lt;/strong>线性微分方程：&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>的&lt;strong>通解为&lt;/strong>&lt;span class="math inline">\(y=C_1(x) y_1 + C_2(x) y_2 + ... + C_n(x) y_n\)&lt;/span> (不用太在意为什么要这么设，如果带进去有解，那么就是正确的；非要细纠的话，参考一阶非齐次线性微分方程的常数变易法的几种思路) 为了将y代入非齐次线性微分方程，我们需要求出y的各阶导： &lt;span class="math inline">\(\begin{aligned} y^{\prime}=&amp;amp; C_{1}(x) y_{1}^{\prime}+C_{2}(x) y_{2}^{\prime}+\cdots+C_{n}(x) y_{n}^{\prime} \\ &amp;amp;+C_{1}^{\prime}(x) y_{1}+C_{2}^{\prime}(x) y_{2}+\cdots+C_{n}^{\prime}(x) y_{n} \end{aligned}\)&lt;/span> &lt;strong>设&lt;/strong>&lt;span class="math inline">\(C_{1}^{\prime}(x) y_{1}+C_{2}^{\prime}(x) y_{2}+\cdots+C_{n}^{\prime}(x) y_{n}=0\)&lt;/span>，则&lt;span class="math inline">\(y^{\prime}=C_{1}(x) y_{1}^{\prime}+C_{2}(x) y_{2}^{\prime}+\cdots+C_{n}(x) y_{n}^{\prime}\)&lt;/span>（不用介意这里新设了约束条件，只要最后有解，所用的y依旧是非齐次线性微分方程的一个解） &lt;strong>设&lt;/strong>&lt;span class="math inline">\(C_{1}^{\prime}(x) y_{1}^{\prime}+C_{2}^{\prime}(x) y_{2}^{\prime}+\cdots+C_{n}^{\prime}(x) y_{n}^{\prime}=0\)&lt;/span>，则&lt;span class="math inline">\(y^{\prime \prime}=C_{1}(x) y_{1}^{\prime \prime}+C_{2}(x) y_{2}^{\prime \prime}+\cdots+C_{n}(x) y_{n}^{\prime \prime}\)&lt;/span>（又增设了约束条件，只为了y的导数形式更简单） … &lt;strong>设&lt;/strong>&lt;span class="math inline">\(C_{1}^{\prime}(x) y_{1}^{(n-2)}+C_{2}^{\prime}(x) y_{1}^{(n-2)}+\cdots+C_{n}^{\prime}(x) y_{1}^{(n-2)}=0\)&lt;/span>，则&lt;span class="math inline">\(y^{(n-1)}=C_{1}(x) y_{1}^{(n-1)}+C_{2}(x) y_{1}^{(n-1)}+\cdots+C_{n}(x) y_{1}^{(n-1)}\)&lt;/span>（又增设了约束条件，只为了y的导数形式更简单） 直接再求一次导得 &lt;span class="math inline">\(\begin{aligned} y^{(n)}=&amp;amp; C_{1}(x) y_{1}^{(n)}+C_{2}(x) y_{2}^{(n)}+\cdots+C_{n}(x) y_{n}^{(n)} \\ &amp;amp;+C_{1}(x) y_{1}^{(n-1)}+C_{2}^{\prime}(x) y_{2}^{(n-1)}+\cdots+C_{n}^{\prime}(x) y_{n}^{(n-1)} \end{aligned}\)&lt;/span> 将各阶导代入非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>得&lt;span class="math inline">\(C_{1}^{\prime}(x) y_{1}^{(n-1)}+C_{2}^{\prime}(x) y_{1}^{(n-1)}+\cdots+C_{n}^{\prime}(x) y_{1}^{(n-1)}=f(x)\)&lt;/span> 综合&lt;strong>新设的约束条件&lt;/strong>和&lt;strong>各阶导代入非齐次线性微分方程的结果&lt;/strong>可得方程组： &lt;span class="math inline">\(\left[\begin{array}{cccc}y_{1}(x) &amp;amp; y_{2}(x) &amp;amp; \cdots &amp;amp; y_{n}(x) \\ y_{1}^{\prime}(x) &amp;amp; y_{2}^{\prime}(x) &amp;amp; \cdots &amp;amp; y_{n}^{\prime}(x) \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ y_{1}^{(n-1)}(x) &amp;amp; y_{2}^{(n-1)}(x) &amp;amp; \cdots &amp;amp; y_{n}^{(n-1)}(x)\end{array}\right]\left[\begin{array}{c}C_{1}^{\prime}(x) \\ C_{2}^{\prime}(x) \\ \vdots \\ C_{n}^{\prime}(x)\end{array}\right]=\left[\begin{array}{c}0 \\ \vdots \\ 0 \\ 1\end{array}\right] f(x)\)&lt;/span> 它是关于变量 &lt;span class="math inline">\(C_{i}^{\prime}(x)(i=1,2, \cdots, n)\)&lt;/span> 的线性代数方程组，它的系数行列式恰好是对应齐次方程组n个线性无关解的朗斯基行列式，它恒不为0，所以上述方程组关于变量 &lt;span class="math inline">\(C_{i}^{\prime}(x)(i=1,2, \cdots, n)\)&lt;/span> 有唯一解。 解出 &lt;span class="math inline">\(C_{i}^{\prime}(x)(i=1,2, \cdots, n)\)&lt;/span> 再积分，便可得到n阶非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>的通解（按以上求解步骤应该是特解，但是解中常数个数正好等于阶数n，所以是通解）&lt;/p>
&lt;h3 id="常系数线性微分方程的求解">常系数线性微分方程的求解&lt;/h3>
&lt;h4 id="常系数齐次线性微分方程的求解特征方程法">常系数齐次线性微分方程的求解：特征方程法&lt;/h4>
&lt;h5 id="二阶常系数齐次线性微分方程的求解特征方程法">二阶常系数齐次线性微分方程的求解：特征方程法&lt;/h5>
&lt;p>&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>，其中 &lt;span class="math inline">\(p, q\)&lt;/span> 是常数，称为二阶常系数齐次线性微分方程。&lt;/p>
&lt;p>由&lt;a href="#二阶或更高阶齐次线性微分方程解的结构">二阶齐次线性微分方程的解的结构&lt;/a>知，找到其两个线性无关的解&lt;span class="math inline">\(y_1,y_2\)&lt;/span>，则&lt;span class="math inline">\(y=C_{1} y_{1}+C_{2} y_{2}\)&lt;/span>就是方程的通解&lt;/p>
&lt;p>注意到&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>中y, y’, y’’是线性相关的（不严谨的说，可以用几个常数互相表示，也就是差了几个常数）。又注意到指数函数&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>与其各阶导数只差了一个常数（可以互相表示，线性相关）。于是我们考虑用&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>试解&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span> &lt;strong>将&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>代入二阶常系数齐次线性微分方程，如果存在r使方程成立，则&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>就是方程的一个解&lt;/strong>。&lt;/p>
&lt;p>&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>，&lt;span class="math inline">\(y^{\prime}=r \mathrm{e}^{r x}, \quad y^{\prime \prime}=r^{2} \mathrm{e}^{r x}\)&lt;/span>（r是负数也成立） 代入常系数齐次线性微分方程，方程化为&lt;span class="math inline">\(\left(r^{2}+p r+q\right) e^{r x}=0\)&lt;/span> 由于&lt;span class="math inline">\(\mathbf{e}^{r x} \neq 0\)&lt;/span>，方程化为&lt;strong>特征方程&lt;/strong>&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span>，&lt;strong>如果特征方程有解，&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>代入原方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>有解&lt;/strong>。&lt;/p>
&lt;p>关于r的特征方程&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span>是1元2次方程，它的两个根为&lt;span class="math inline">\(r_{1,2}=\frac{-p \pm \sqrt{p^{2}-4 q}}{2}\)&lt;/span>， &lt;strong>特征方程的根分为3种情况&lt;/strong>： 1）&lt;span class="math inline">\(p^{2}-4 q&amp;gt;0\)&lt;/span>时，特征方程有两个不相等的实根&lt;span class="math inline">\(r_{1}=\frac{-p+\sqrt{p^{2}-4 q}}{2}, \quad r_{2}=\frac{-p-\sqrt{p^{2}-4 q}}{2}\)&lt;/span> 2） &lt;span class="math inline">\(p^{2}-4 q=0\)&lt;/span> 时，特征方程有两个相等的的实根（二重实根）&lt;span class="math inline">\(r_{1}=r_{2}=-\frac{p}{2}\)&lt;/span> 3）&lt;span class="math inline">\(p^{2}-4 q&amp;lt;0\)&lt;/span> 时，特征方程有一对共轭复根（一对单重.复根）&lt;span class="math inline">\(r_{1}=\alpha+\beta i, \quad r_{2}=\alpha-\beta i\)&lt;/span>，其中&lt;span class="math inline">\(\alpha=-\frac{p}{2}, \quad \beta=\frac{\sqrt{4 q-p^{2}}}{2}\)&lt;/span>&lt;/p>
&lt;p>与&lt;strong>特征方程&lt;/strong>&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span>根可能有：两个不相等实根、二重实根、单重复根 三种情况&lt;strong>对应&lt;/strong>，&lt;strong>常系数齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的解也分3种情况讨论&lt;/strong>： 1）&lt;strong>特征方程有两个不相等实根&lt;span class="math inline">\(r_{1} \neq r_{2}\)&lt;/span>时&lt;/strong>，&lt;span class="math inline">\(y_{1}=\mathrm{e}^{r_{1} x}, y_{2}=\mathrm{e}^{r_{2} x}\)&lt;/span>是微分方程的两个解，又&lt;span class="math inline">\(y_1,y_2\)&lt;/span>线性无关（&lt;span class="math inline">\(\frac{y_1}{y_2}\)&lt;/span>不是常数），即&lt;span class="math inline">\(y_1,y_2\)&lt;/span>是常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>线性无关的两个特解，得通解为&lt;span class="math inline">\(y=C_{1} \mathrm{e}^{r_{1} x}+C_{2} \mathrm{e}^{r_{2} x}\)&lt;/span> 2）&lt;strong>特征方程有两个相等实根（二重实根）&lt;span class="math inline">\(r_{1}=r_{2}\)&lt;/span>时&lt;/strong>，得到微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的一个解&lt;span class="math inline">\(y_{1}=e^{r_{1} x}\)&lt;/span>。为了求此微分方程的通解，还需要求出另一个与&lt;span class="math inline">\(y_1\)&lt;/span>线性无关的解&lt;span class="math inline">\(y_2\)&lt;/span>。另一个解&lt;span class="math inline">\(y_2\)&lt;/span>可以用&lt;a href="#已知齐次的一个特解，求解二阶非齐次线性微分方程：常数变易法">常数变易法&lt;/a>求出：设&lt;span class="math inline">\(y_{2}=\mathrm{e}^{r_{1}^{x}} u(x)\)&lt;/span>，代入微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>有解，解出&lt;span class="math inline">\(u=C x\)&lt;/span>,不妨取&lt;span class="math inline">\(u=x\)&lt;/span>,则微分方程的另个一个解&lt;span class="math inline">\(y_{2}=x \mathrm{e}^{r_{1} x}\)&lt;/span>。 于是我们得到特征方程有两个相等实根（二重实根）时，常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解&lt;span class="math inline">\(y=C_{1} \mathrm{e}^{r_{1} x}+C_{2} x \mathrm{e}^{r_{1} x}\)&lt;/span> 3）&lt;strong>特征方程有一对共轭复根（单重复根）时&lt;/strong>，常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的两个解为&lt;span class="math inline">\(y_{1}=\mathrm{e}^{(\alpha+\beta i) x}=\mathrm{e}^{\alpha x} \cdot \mathrm{e}^{\beta x \mathrm{i}}=\mathrm{e}^{\alpha x}(\cos \beta x+\mathrm{i} \sin \beta x)\)&lt;/span> &lt;span class="math inline">\(y_{2}=\mathrm{e}^{(\alpha-\beta \mathrm{i}) x}=\mathrm{e}^{\alpha x} \cdot \mathrm{e}^{-\beta x \mathrm{i}}=\mathrm{e}^{\alpha x}(\cos \beta x-\mathrm{i} \sin \beta x)\)&lt;/span> 显然它们是线性无关的，直接用这两个根构造的通解也可以，但是可以构造更简洁的通解形式： 由齐次线性微分方程的叠加原理知，特解&lt;span class="math inline">\(y_1,y_2\)&lt;/span>的线性叠加也是方程的特解。 那么如下取共轭根的实部、虚部，也是方程的特解： &lt;span class="math inline">\(\bar{y}_{1}=\frac{1}{2}\left(y_{1}+y_{2}\right)=\mathrm{e}^{\alpha x} \cos \beta x\)&lt;/span> &lt;span class="math inline">\(\bar{y}_{2}=\frac{1}{2 \mathrm{i}}\left(y_{1}-y_{2}\right)=\mathrm{e}^{\alpha x} \sin \beta x\)&lt;/span> 它们是线性无关的（比值不是常数），所以，常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解为&lt;span class="math inline">\(y=e^{a x}\left(C_{1} \cos \beta x+C_{2} \sin \beta x\right)\)&lt;/span>。&lt;/p>
&lt;p>&lt;strong>综上，则&lt;span class="math inline">\(y=\mathrm{e}^{r x}\)&lt;/span>就是常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的解。通过对常系数齐次微分方程（关于r）的特征方程&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span>根的讨论，可以得到二阶常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解。&lt;/strong>&lt;/p>
&lt;p>在此（推导证明的）基础上，可以得到，&lt;strong>求解二阶常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解的（简化/固定）步骤&lt;/strong>： 1）写出&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的特征方程&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span> 2）求出特征方程的两个根&lt;span class="math inline">\(r_1,r_2\)&lt;/span> 3）根据特征方程根的不同情况（总结到了下面的表格中），写出&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 50%" />
&lt;col style="width: 50%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>特征方程&lt;span class="math inline">\(r^{2}+p r+q=0\)&lt;/span>的两个根&lt;span class="math inline">\(r_1,r_2\)&lt;/span>&lt;/th>
&lt;th>二阶常系数齐次微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=0\)&lt;/span>的通解&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>特征方程有两个不相等实根&lt;span class="math inline">\(r_{1} \neq r_{2}\)&lt;/span>时&lt;/td>
&lt;td>&lt;span class="math inline">\(y=C_{1} \mathrm{e}^{r_{1} x}+C_{2} \mathrm{e}^{r_{2} x}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>特征方程有两个相等实根（二重实根）&lt;span class="math inline">\(r_{1}=r_{2}\)&lt;/span>时&lt;/td>
&lt;td>&lt;span class="math inline">\(y=\left(C_{1}+C_{2} x\right) \mathrm{e}^{r_{1} x}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>特征方程有一对共轭复根（单重.复根）&lt;span class="math inline">\(r_{1,2}=\alpha \pm \beta i\)&lt;/span>时&lt;/td>
&lt;td>&lt;span class="math inline">\(y=e^{\alpha x}\left(C_{1} \cos \beta x+C_{2} \sin \beta x\right)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="n阶常系数齐次线性微分方程的求解特征方程法">n阶常系数齐次线性微分方程的求解：特征方程法&lt;/h5>
&lt;p>n阶常系数齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=0\)&lt;/span>，其中 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{n-1}, p_{n}\)&lt;/span> 都是常数.&lt;/p>
&lt;p>我们用记号D表示微分算子，即表示对 &lt;span class="math inline">\(x\)&lt;/span> 求导的运算&lt;span class="math inline">\(\frac{d}{d x}\)&lt;/span>，把 &lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}\)&lt;/span> 记作 &lt;span class="math inline">\(\mathrm{D} y\)&lt;/span>，把 &lt;span class="math inline">\(\frac{\mathrm{d}^{n} y}{\mathrm{d} x^{n}}\)&lt;/span> 记作 &lt;span class="math inline">\(\mathrm{D}^{n} y\)&lt;/span>，&lt;/p>
&lt;p>则&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=0\)&lt;/span>， 可以记作&lt;span class="math inline">\(\left(D^{n}+p_{1} D^{n-1}+\cdots+p_{n-1} D+p_{n}\right) y=0\)&lt;/span> 进一步，n阶常系数齐次线性微分方程可以记作&lt;span class="math inline">\(L(\mathrm{D}) y=0\)&lt;/span>&lt;/p>
&lt;p>这里取微分算子表达式&lt;span class="math inline">\(L(\mathrm{D})=\mathrm{D}^{n}+p_{1} \mathrm{D}^{n-1}+\cdots+p_{n-1} \mathrm{D}+p_{n}\)&lt;/span>，这是一个关于微分算子D的n次表达式。&lt;/p>
&lt;p>类比二阶时的求解，我们考虑&lt;span class="math inline">\(y=e^{rx}\)&lt;/span>作为&lt;span class="math inline">\(L(\mathrm{D}) y=0\)&lt;/span>的解。如果存在r使方程成立，则&lt;span class="math inline">\(y=e^{rx}\)&lt;/span>就是方程的解。&lt;/p>
&lt;p>将&lt;span class="math inline">\(y=e^{rx}\)&lt;/span>代入&lt;span class="math inline">\(L(\mathrm{D}) y=0\)&lt;/span>。 由于 $ ^{r x}=r ^{r x}, ,D^{n} e^{r x}=r^{n} e^{r x}&lt;span class="math inline">\(，所以\)&lt;/span>L() ^{r x}=L(r) ^{r x}$ 所以方程化为&lt;span class="math inline">\(L(r) \mathrm{e}^{r x}=0\)&lt;/span>， 进一步，方程化为r的特征方程&lt;span class="math inline">\(L(r)=0,\)&lt;/span> 即&lt;span class="math inline">\(r^{n}+p_{1} r^{n-1}+p_{2} r^{n-2}+\cdots+p_{n-1} r+p_{n}=0\)&lt;/span>。&lt;/p>
&lt;p>这样，如果r是特征方程&lt;span class="math inline">\(r^{n}+p_{1} r^{n-1}+p_{2} r^{n-2}+\cdots+p_{n-1} r+p_{n}=0\)&lt;/span>的一个根，则函数&lt;span class="math inline">\(y=e^{rx}\)&lt;/span>就是n阶常系数齐次线性微分方程&lt;span class="math inline">\(L(\mathrm{D}) y=0\)&lt;/span>的一个解。&lt;/p>
&lt;p>类比二阶时候的情况，根据特征方程的根的不同情况，可以得到&lt;span class="math inline">\(y=e^{rx}\)&lt;/span>和其他的根在微分方程通解中的项&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 44%" />
&lt;col style="width: 55%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>特征方程的根&lt;/th>
&lt;th>n阶常系数齐次微分方程通解中的对应项&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>特征方程存在单实根r&lt;/td>
&lt;td>微分方程通解中存在一项&lt;span class="math inline">\(C \mathrm{e}^{r x}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>特征方程存在k重实根r&lt;/td>
&lt;td>微分方程通解中存在k项：&lt;span class="math inline">\(\mathrm{e}^{r_{1}}\left(C_{1}+C_{2} x+\cdots+C_{k} x^{k-1}\right)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>特征方程中存在单复根&lt;span class="math inline">\(r_{1,2}=\alpha \pm \beta i\)&lt;/span>&lt;/td>
&lt;td>微分方程通解中存在一项&lt;span class="math inline">\(\mathrm{e}^{\alpha x}\left(C_{1} \cos \beta x+C_{2} \sin \beta x\right)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>特征方程中存在k重复根&lt;span class="math inline">\(r_{1,2}=\alpha \pm \beta i\)&lt;/span>&lt;/td>
&lt;td>微分方程通解中存在2k项&lt;span class="math inline">\(\mathrm{e}^{\alpha x}\left[\left(C_{1}+C_{2} x+\cdots+C_{k} x^{k-1}\right) \cos \beta x+\left(D_{1}+D_{2} x+\cdots+D_{k} x^{k-1}\right) \sin \beta x\right]\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>从代数学知道,n 次代数方程有 n 个根(重根按重数计算)， 而特征方程的每一个根都对应着通解中的一项,且每项各含一个任意常数,这样就得到 n 阶常系 数齐次线性微分方程的通解&lt;span class="math inline">\(y=C_{1} y_{1}+C_{2} y_{2}+\cdots+C_{n} y_{n}\)&lt;/span>&lt;/p>
&lt;h4 id="常系数非齐次线性微分方程的求解常数变易法待定系数法">常系数非齐次线性微分方程的求解：常数变易法、待定系数法&lt;/h4>
&lt;p>n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=f(x)\)&lt;/span>，其中 &lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{n-1}, p_{n}\)&lt;/span> 都是常数.&lt;/p>
&lt;p>这里以二阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=f(x)\)&lt;/span>讨论，对于n阶的，也适用&lt;/p>
&lt;p>根据非齐次线性微分方程解的结构，常系数非齐次线性微分方程的求解需要先求出对应齐次方程的通解，然后找一个特解即可。找特解有两种方法：常数变易法和待定系数法。&lt;/p>
&lt;h5 id="解常系数非齐次线性微分方程常数变易法">解常系数非齐次线性微分方程：常数变易法&lt;/h5>
&lt;p>&lt;strong>常数变易法&lt;/strong>（对于线性微分方程都可用），该方法利用对应的常系数齐次线性微分方程的解，将其中的常数换为几个未知函数，然后作为非齐次的解，代入非齐次方程求出这几个未知函数，从而求出非齐次方程的解。&lt;/p>
&lt;p>&lt;strong>常数变易法&lt;/strong>的问题是&lt;strong>需要积分，不一定能解得出来&lt;/strong>。&lt;/p>
&lt;p>（参见&lt;a href="#非齐次线性微分方程的求解（已知齐次通解）：常数变易法">常数变易法求解非齐次线性微分方程&lt;/a>，这里不多做赘述）&lt;/p>
&lt;h5 id="解常系数非齐次线性微分方程待定系数法">解常系数非齐次线性微分方程：待定系数法&lt;/h5>
&lt;p>&lt;strong>待定系数法&lt;/strong>只可以求解常系数非齐次线性微分方程的两类特例：方程右端自由项为&lt;span class="math inline">\(f(x)=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>型、&lt;span class="math inline">\(f(x)=\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>型。&lt;strong>待定系数法只能求解这两类特例&lt;/strong>，但不需要求积分。&lt;/p>
&lt;h6 id="解二阶常系数非齐次线性微分方程yprime-primep-yprimeq-ymathrmelambda-x-p_mx型">解二阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>型&lt;/h6>
&lt;p>&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>，其中&lt;span class="math inline">\(P_{m}(x)\)&lt;/span> 是 &lt;span class="math inline">\(x\)&lt;/span> 的一个 &lt;span class="math inline">\(m\)&lt;/span> 次多项式：&lt;span class="math inline">\(P_{m}(x)=a_{0} x^{m}+a_{1} x^{m-1}+\cdots+a_{m-1} x+a_{m}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>方程右端的自由项&lt;span class="math inline">\(\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>是指数函数和多项式函数的乘积， 而注意到指数函数和多项式函数的乘积的&lt;strong>导数&lt;/strong>，仍然是指数函数和多项式函数的乘积&lt;/p>
&lt;p>那么我们可以&lt;strong>推测&lt;/strong>方程的一个特解为&lt;span class="math inline">\(y^{*}=R(x) \mathrm{e}^{\lambda x}\)&lt;/span>，（其中&lt;span class="math inline">\(R(x)\)&lt;/span>是x的多项式），又 &lt;span class="math inline">\(y^{*}=R(x) \mathrm{e}^{\lambda x}\)&lt;/span> &lt;span class="math inline">\(y^{*\prime}=\mathrm{e}^{\lambda x}\left[\lambda R(x)+R^{\prime}(x)\right]\)&lt;/span> &lt;span class="math inline">\(y^{*\prime\prime}=\mathrm{e}^{\lambda x}\left[\lambda^{2} R(x)+2 \lambda R^{\prime}(x)+R^{\prime \prime}(x)\right]\)&lt;/span> 代入方程并消去&lt;span class="math inline">\(\mathrm{e}^{\lambda x}\)&lt;/span>，方程化为： &lt;span class="math inline">\(R^{\prime \prime}(x)+(2 \lambda+p) R^{\prime}(x)+\left(\lambda^{2}+p \lambda+q\right) R(x)=P_{m}(x)\)&lt;/span> 方程两端都是x的多项式，两边多项式的系数应该都相等，比较可以得到最初&lt;span class="math inline">\(R(x)\)&lt;/span>的各项系数，这就是&lt;strong>待定系数法&lt;/strong>。&lt;/p>
&lt;p>不过变换后的多项式方程&lt;span class="math inline">\(R(x)\)&lt;/span>和&lt;span class="math inline">\(R \prime (x)\)&lt;/span>项可能不存在，需要讨论一下： 1）若&lt;span class="math inline">\(\lambda^{2}+p \lambda+q \neq 0\)&lt;/span>（即参数&lt;span class="math inline">\(\lambda\)&lt;/span>不是特征方程&lt;span class="math inline">\(\lambda^{2}+p \lambda+q=0\)&lt;/span>的根），则&lt;span class="math inline">\(R(x)\)&lt;/span>应为m次多项式，可设&lt;span class="math inline">\(R(x) = R_{m}(x)=b_{0} x^{m}+b_{1} x^{m-1}+\cdots+b_{m-1} x+b_{m}\)&lt;/span>，代入原方程变换后的多项式方程即可确定各项系数。 2）若特征方程&lt;span class="math inline">\(\lambda^{2}+p \lambda+q=0\)&lt;/span>且&lt;span class="math inline">\(2 \lambda+p \neq 0\)&lt;/span>（即参数&lt;span class="math inline">\(\lambda\)&lt;/span>正好是特征方程的单根），原方程化为&lt;span class="math inline">\(R^{\prime \prime}(x)+(2 \lambda+p) R^{\prime}(x)=P_{m}(x)\)&lt;/span>，则&lt;span class="math inline">\(R(x)\)&lt;/span>应为(m+1)次多项式，可设&lt;span class="math inline">\(R(x)=x R_{m}(x)\)&lt;/span>，代入原方程变换后的多项式方程即可确定各项系数。 3）若特征方程&lt;span class="math inline">\(\lambda^{2}+p \lambda+q=0\)&lt;/span>且&lt;span class="math inline">\(2 \lambda+p = 0\)&lt;/span>（即参数&lt;span class="math inline">\(\lambda\)&lt;/span>正好是特征方程的二重根），则&lt;span class="math inline">\(R(x)\)&lt;/span>应为(m+2)次多项式，可设&lt;span class="math inline">\(R(x)=x^2 R_{m}(x)\)&lt;/span>，代入原方程变换后的多项式方程即可确定各项系数。&lt;/p>
&lt;p>&lt;strong>综上&lt;/strong>，对于二阶的&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>型常系数非齐次线性微分方程，其特解具有如下形式&lt;span class="math inline">\(y^{*}=x^{k} R_{m}(x) \mathrm{e}^{\lambda x}\)&lt;/span> （当参数&lt;span class="math inline">\(\lambda\)&lt;/span>分别 不是特征方程&lt;span class="math inline">\(\lambda^{2}+p \lambda+q=0\)&lt;/span>的根、是特征方程的的单根、是特征方程的二重根时， 分别有&lt;span class="math inline">\(k=0,1,2\)&lt;/span>） （&lt;span class="math inline">\(R_{m}(x)\)&lt;/span> 是与 &lt;span class="math inline">\(P_{m}(x)\)&lt;/span> 同次（ &lt;span class="math inline">\(m\)&lt;/span> 次 ) 的多项式）&lt;/p>
&lt;h6 id="解n阶常系数非齐次线性微分方程ynp_1-yn-1p_2-yn-2cdotsp_n-1-yprimep_n-ymathrmelambda-x-p_mx型">解n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>型&lt;/h6>
&lt;p>由二阶，很容易推广到n阶，结论如下：&lt;/p>
&lt;p>对于n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=\mathrm{e}^{\lambda x} P_{m}(x)\)&lt;/span>型，其特解具有如下形式&lt;span class="math inline">\(y^{*}=x^{k} R_{m}(x) \mathrm{e}^{\lambda x}\)&lt;/span> （当参数&lt;span class="math inline">\(\lambda\)&lt;/span>分别 不是特征方程&lt;span class="math inline">\(\lambda^{n}+p_1 \lambda^{n-1}+... +q=0\)&lt;/span>的根、是特征方程的s重根时， 分别有&lt;span class="math inline">\(k=0\)&lt;/span>和&lt;span class="math inline">\(k=s\)&lt;/span>） （&lt;span class="math inline">\(R_{m}(x)\)&lt;/span> 是与 &lt;span class="math inline">\(P_{m}(x)\)&lt;/span> 同次（ &lt;span class="math inline">\(m\)&lt;/span> 次 ) 的多项式）&lt;/p>
&lt;h6 id="解二阶常系数非齐次线性微分方程yprime-primep-yprimeq-ymathrmelambda-xleftp_lx-cos-omega-xq_nx-sin-omega-xright型">解二阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>型&lt;/h6>
&lt;p>应用&lt;a href="#附：欧拉公式">欧拉公式&lt;/a>有&lt;span class="math inline">\(\mathrm{e}^{i \theta}=\cos \theta +i \sin \theta)\)&lt;/span>，有&lt;span class="math inline">\(\cos \theta=\frac{1}{2}\left(\mathrm{e}^{i \theta}+\mathrm{e}^{-\mathrm{i} \theta}\right), \sin \theta=\frac{1}{2 \mathrm{i}}\left(\mathrm{e}^{i \theta}-\mathrm{e}^{-i \theta}\right)\)&lt;/span> 则非齐次方程右端自由项可以写成 &lt;span class="math inline">\(\begin{aligned} f(x) &amp;amp;=\mathrm{e}^{\lambda x}\left[P_{l} \cos \omega x+Q_{n} \sin \omega x\right] \\ &amp;amp;=\mathrm{e}^{\lambda x}\left[P_{l} \frac{\mathrm{e}^{\omega \mathrm{x}}+\mathrm{e}^{-\omega \mathrm{z} i}}{2}+Q_{n} \frac{\mathrm{e}^{\omega \mathrm{xi}}-\mathrm{e}^{-\omega \mathrm{xi}}}{2 \mathrm{i}}\right] \\ &amp;amp;=\left(\frac{P_{l}}{2}+\frac{Q_{n}}{2 \mathrm{i}}\right) \mathrm{e}^{(\lambda+\omega \mathrm{i}) x}+\left(\frac{P_{l}}{2}-\frac{Q_{n}}{2 \mathrm{i}}\right) \mathrm{e}^{(\lambda-\mathrm{oi}) x} \\ &amp;amp;=P(x) \mathrm{e}^{(\lambda+\omega \mathrm{i}) x}+\bar{P}(x) \mathrm{e}^{(\lambda-\omega i) x} \end{aligned}\)&lt;/span> 其中&lt;span class="math inline">\(P(x)=\frac{P_{t}}{2}+\frac{Q_{n}}{2 \mathrm{i}}=\frac{P_{t}}{2}-\frac{Q_{n}}{2} \mathrm{i}, \bar{P}(x)=\frac{P_{l}}{2}-\frac{Q_{n}}{2 \mathrm{i}}=\frac{P_{l}}{2}+\frac{Q_{n}}{2} \mathrm{i}\)&lt;/span>，互共轭。 由非齐次线性微分方程的叠加定理可知，原方程的特解可以看作是&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=P(x) \mathrm{e}^{(\lambda+\omega \mathrm{i}) x}\)&lt;/span>和$y^{}+p y^{}+q y={P}(x) ^{(-i) x} &lt;span class="math inline">\(特解的叠加。 而后面两个方程，都是可以用[上一目](#解二阶常系数非齐次线性微分方程\)&lt;/span>y^{}+p y^{}+q y=^{x} P_{m}(x)&lt;span class="math inline">\(型)待定系数法求解的， 从而可**设原方程的特解**为\)&lt;/span>y^{*}=x^{k} R_{m} ^{(+i) x}+x^{k} {R}_{m} ^{(-i) x}$ (这里&lt;span class="math inline">\(R_m(x)\)&lt;/span>是推广到复数域的多项式) (其中&lt;span class="math inline">\(m=\max \{l, n\}\)&lt;/span>，是原方程右端自由项&lt;span class="math inline">\(\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>中多项式得最高次) (&lt;span class="math inline">\(k\)&lt;/span> 按 &lt;span class="math inline">\(\lambda+\omega i\)&lt;/span> 不是特征方程的根或是特征方程的单根依次取 0 或 1) 特解&lt;span class="math inline">\(\begin{aligned} y^{*} &amp;amp;=x^{k} \mathrm{e}^{\lambda x}\left[R_{m} \mathrm{e}^{\omega x \mathrm{i}}+\bar{R}_{m} \mathrm{e}^{-\omega \mathrm{xi}}\right] \\ &amp;amp;=x^{k} \mathrm{e}^{\lambda x}\left[R_{m}(\cos \omega x+\mathrm{i} \sin \omega x)+\bar{R}_{m}(\cos \omega x-\mathrm{i} \sin \omega x)\right] \end{aligned}\)&lt;/span> 中括号内两项是共轭得，相加后无虚部，原方程特解可以写成实函数： &lt;span class="math inline">\(y^{*}=x^{k} \mathrm{e}^{\lambda x}\left[R_{m}^{(1)}(x) \cos \omega x+R_{m}^{(2)}(x) \sin \omega x\right]\)&lt;/span> (把&lt;span class="math inline">\(R_{m}^{(1)}(x)\)&lt;/span>和&lt;span class="math inline">\(R_{m}^{(2)}(x)\)&lt;/span>分别各看作一个m次多项式)&lt;/p>
&lt;p>综上，对于二阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{\prime \prime}+p y^{\prime}+q y=\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>型，其特解具有如下形式（可&lt;strong>设原方程的特解&lt;/strong>为） &lt;span class="math inline">\(y^{*}=x^{k} \mathrm{e}^{\lambda x}\left[R_{m}^{(1)}(x) \cos \omega x+R_{m}^{(2)}(x) \sin \omega x\right]\)&lt;/span> (其中&lt;span class="math inline">\(m=\max \{l, n\}\)&lt;/span>，是原方程右端自由项&lt;span class="math inline">\(\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>中多项式得最高次) (&lt;span class="math inline">\(k\)&lt;/span> 按 &lt;span class="math inline">\(\lambda+\omega i\)&lt;/span> 不是特征方程的根或是特征方程的单根依次取 0 或 1) (&lt;span class="math inline">\(R_{m}^{(1)}(x)\)&lt;/span>和&lt;span class="math inline">\(R_{m}^{(2)}(x)\)&lt;/span>分别是一个m次多项式)&lt;/p>
&lt;h6 id="解n阶常系数非齐次线性微分方程ynp_1-yn-1p_2-yn-2cdotsp_n-1-yprimep_n-ymathrmelambda-xleftp_lx-cos-omega-xq_nx-sin-omega-xright型">解n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>型&lt;/h6>
&lt;p>二阶很容易推广到n阶，对于n阶常系数非齐次线性微分方程&lt;span class="math inline">\(y^{(n)}+p_{1} y^{(n-1)}+p_{2} y^{(n-2)}+\cdots+p_{n-1} y^{\prime}+p_{n} y=\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>型，其特解具有如下形式 &lt;span class="math inline">\(y^{*}=x^{k} \mathrm{e}^{\lambda x}\left[R_{m}^{(1)}(x) \cos \omega x+R_{m}^{(2)}(x) \sin \omega x\right]\)&lt;/span> (其中&lt;span class="math inline">\(m=\max \{l, n\}\)&lt;/span>，是原方程右端自由项&lt;span class="math inline">\(\mathrm{e}^{\lambda x}\left[P_{l}(x) \cos \omega x+Q_{n}(x) \sin \omega x\right]\)&lt;/span>中多项式得最高次) (&lt;span class="math inline">\(k\)&lt;/span> 按 &lt;span class="math inline">\(\lambda+\omega i\)&lt;/span> 不是特征方程的根，或是特征方程的s重根依次取 0 或 s) (&lt;span class="math inline">\(R_{m}^{(1)}(x)\)&lt;/span>和&lt;span class="math inline">\(R_{m}^{(2)}(x)\)&lt;/span>分别是一个m次多项式)&lt;/p>
&lt;h3 id="常系数线性微分方程组的求解">常系数线性微分方程组的求解&lt;/h3>
&lt;p>参考：高等数学同济第七版（上）&lt;/p>
&lt;p>前面都是讨论一个微分方程确定一个（单自变量）未知函数的问题， 实际问题中，还会遇到几个微分方程组联立确定（一个自由元的）多个未知函数的问题，这些联立的微分方程称&lt;strong>微分方程组&lt;/strong>&lt;/p>
&lt;p>如果微分方程组中的每一个微分方程都是常系数线性微分方程，那么这个微分方程组就叫做&lt;strong>常系数线性微分方程组&lt;/strong>&lt;/p>
&lt;p>如果微分方程组是常系数线性微分方程组，且最终只有一个自由元，这种方程组是可解的。&lt;/p>
&lt;p>常系数线性微分方程组（一自由元）的&lt;strong>求解步骤&lt;/strong>： 1）从方程组中消去一些未知函数及其各阶导数,得到只含有一个未知函数的高阶常系数线性微分方程. （消元） 2）解此高阶微分方程,求出满足该方程的未知函数. 3）把已求得的函数代人原方程组，一般说来,不必经过积分就可求出其余的未知函数.&lt;/p>
&lt;p>注：用记号 D 表示 &lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}\)&lt;/span>（这里t是自由元），又常系数线性微分微分方程组是线性的， 可以使用线性代数解方程组的方法来求解&lt;/p>
&lt;h2 id="非线性微分方程">非线性微分方程&lt;/h2>
&lt;p>一般的非线性微分方程都是解不出来的，而有几种非线性方程却可以通过变量代换，变成可解的线性微分方程&lt;/p>
&lt;h3 id="解伯努利方程">解伯努利方程&lt;/h3>
&lt;p>伯努利方程：&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}+P(x) y=Q(x) y^{n} \quad(n \neq 0,1)\)&lt;/span>&lt;/p>
&lt;p>&lt;a href="#伯努利方程">伯努利方程的变量代换与求解&lt;/a>，前面已有介绍，这里不多做赘述。&lt;/p>
&lt;h3 id="解欧拉方程">解欧拉方程&lt;/h3>
&lt;p>&lt;strong>欧拉方程&lt;/strong>：&lt;span class="math inline">\(x^{n} y^{(n)}+p_{1} x^{n-1} y^{(n-1)}+\cdots+p_{n-1} x y^{\prime}+p_{n} y=f(x)\)&lt;/span>，其中&lt;span class="math inline">\(p_{1}, p_{2}, \cdots, p_{n}\)&lt;/span> 为常数。&lt;/p>
&lt;p>欧拉方程是一种特殊的&lt;a href="#n阶线性微分方程">变系数线性微分方程&lt;/a> （n阶线性微分方程：&lt;span class="math inline">\(y^{(n)}+a_{1}(x) y^{(n-1)}+\cdots+a_{n-1}(x) y^{\prime}+a_{n}(x) y=f(x)\)&lt;/span>）&lt;/p>
&lt;p>&lt;strong>变量代换&lt;/strong>：作变换 &lt;span class="math inline">\(x=\mathrm{e}^{t}\)&lt;/span> 或 &lt;span class="math inline">\(t=\ln x,\)&lt;/span> 将自变量 &lt;span class="math inline">\(x\)&lt;/span> 换成 &lt;span class="math inline">\(t\)&lt;/span>。&lt;/p>
&lt;p>则有： &lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=\frac{\mathrm{d} y}{\mathrm{d} t} \cdot \frac{\mathrm{d} t}{\mathrm{d} x}=\frac{1 \mathrm{d} y}{x \mathrm{d} t}\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}}=\frac{1}{x^{2}}\left(\frac{\mathrm{d}^{2} y}{\mathrm{d} t^{2}}-\frac{\mathrm{d} y}{\mathrm{d} t}\right)\)&lt;/span> &lt;span class="math inline">\(\frac{\mathrm{d}^{3} y}{\mathrm{d} x^{3}}=\frac{1}{x^{3}}\left(\frac{\mathrm{d}^{3} y}{\mathrm{d} t^{3}}-3 \frac{\mathrm{d}^{2} y}{\mathrm{d} t^{2}}+2 \frac{\mathrm{d} y}{\mathrm{d} t}\right)\)&lt;/span>&lt;/p>
&lt;p>取记号 D 表示对 &lt;span class="math inline">\(t\)&lt;/span> 求导的运算&lt;span class="math inline">\(\frac{\mathrm{d}}{\mathrm{d} t}\)&lt;/span>，并依据上述计算，有： &lt;span class="math inline">\(x y^{\prime}=D y\)&lt;/span> &lt;span class="math inline">\(x^{2} y^{\prime \prime}=\frac{\mathrm{d}^{2} y}{\mathrm{d} t^{2}}-\frac{\mathrm{d} y}{\mathrm{d} t}=\left(\frac{\mathrm{d}^{2}}{\mathrm{d} t^{2}}-\frac{\mathrm{d}}{\mathrm{d} t}\right) y=\left(\mathrm{D}^{2}-\mathrm{D}\right) y=\mathrm{D}(\mathrm{D}-1) y\)&lt;/span> &lt;span class="math inline">\(x^{3} y^{\prime \prime \prime}=\frac{\mathrm{d}^{3} y}{\mathrm{d} t^{3}}-3 \frac{\mathrm{d}^{2} y}{\mathrm{d} t^{2}}+2 \frac{\mathrm{d} y}{\mathrm{d} t}=\left(\mathrm{D}^{3}-3 \mathrm{D}^{2}+2 \mathrm{D}\right) y=\mathrm{D}(\mathrm{D}-1)(\mathrm{D}-2) y\)&lt;/span>&lt;/p>
&lt;p>一般的，有： &lt;span class="math inline">\(x^{k} y^{(k)}=D(D-1) \cdots(D-k+1) y\)&lt;/span>&lt;/p>
&lt;p>将上述各项&lt;span class="math inline">\(x^{k} y^{(k)}=D(D-1) \cdots(D-k+1) y\)&lt;/span> 代入欧拉方程，则原方程变为以 &lt;span class="math inline">\(t\)&lt;/span> 为自变量的常系数线性微分方程。 解出这个方程后，把 &lt;span class="math inline">\(t\)&lt;/span> 换成 In &lt;span class="math inline">\(x,\)&lt;/span> 即得原欧拉方程的解。&lt;/p>
&lt;h2 id="附欧拉公式">附：欧拉公式&lt;/h2>
&lt;p>欧拉公式&lt;span class="math inline">\(\mathrm{e}^{(a+b i) x}=\mathrm{e}^{a x}(\cos b x+i \sin b x)\)&lt;/span>&lt;/p>
&lt;p>或者有&lt;span class="math inline">\(\mathrm{e}^{i \theta}=\cos \theta +i \sin \theta\)&lt;/span>，&lt;/p>
&lt;p>有&lt;span class="math inline">\(\cos \theta=\frac{1}{2}\left(\mathrm{e}^{i \theta}+\mathrm{e}^{-\mathrm{i} \theta}\right), \sin \theta=\frac{1}{2 \mathrm{i}}\left(\mathrm{e}^{i \theta}-\mathrm{e}^{-i \theta}\right)\)&lt;/span>&lt;/p>
&lt;h2 id="附齐次的辨析">附：齐次的辨析&lt;/h2>
&lt;p>注：微分方程中有两个地方用到“齐次”的叫法：”齐次方程“，”齐次线性方程“，这里的齐次意义是不同的，注意辨析：&lt;a href="https://baike.baidu.com/item/齐次方程">百度百科：齐次方程&lt;/a>“齐次”从词面上解释是“次数相等”的意思。&lt;/p>
&lt;p>&lt;strong>微分方程中有两个地方用到“齐次”的叫法&lt;/strong>：&lt;/p>
&lt;p>1、形如&lt;/p>
&lt;figure>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/e20147f1a3eef408d3de4a7cd8ac956f.svg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>的方程称为“齐次方程”，这里是&lt;strong>指方程中每一项关于x、y的次数都是相等&lt;/strong>的，例如&lt;/p>
&lt;figure>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/1cfee93f41788e9f2335dc77735d3b29.svg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>都算是二次项，而&lt;/p>
&lt;figure>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/81156cce131efa267ddb3c7d8f015407.svg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>算0次项，方程&lt;/p>
&lt;figure>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/3f9a0692b78ce6aa0d18d51188bccac8.svg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>中每一项都是0次项，所以是“齐次方程”。&lt;/p>
&lt;p>2、形如y’‘+py’+qy=0的方程称为“齐次线性方程”，&lt;strong>这里“齐次”是指方程中每一项关于未知函数y及其导数y’，y’’，……的次数都是相等的（都是一次），方程中没有自由项（不包含y及其导数的项）&lt;/strong>，“线性”则表示导数之间是线性运算（简单地说就是各阶导数之间的只能加减），比如方程y’‘+py’+qy=x就不是“齐次”的,因为方程右边的项x不含y及y的导数，是关于y,y’,y’‘,……的0次项，因而就要称为“非齐次线性方程”，方程yy’=1也不是，因为它首先不是线性的。&lt;/p>
&lt;p>另外&lt;strong>在&lt;a href="https://baike.baidu.com/item/线性代数/800">线性代数&lt;/a>里也有“齐次”的叫法&lt;/strong>，例如&lt;/p>
&lt;figure>
&lt;img src="https://bkimg.cdn.bcebos.com/formula/41d244eb9c7fce7c5f48a0fc1057052d.svg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>称为二次齐式，即二次齐次式的意思，因为f中每一项都是关于x、y的二次项。&lt;/p>
&lt;h2 id="附2线性相关与线性无关">附2：线性相关与线性无关&lt;/h2>
&lt;p>设 &lt;span class="math inline">\(y_{1}(x), y_{2}(x), \cdots, y_{n}(x)\)&lt;/span> 为定义在区间 &lt;span class="math inline">\(I\)&lt;/span> 上的 &lt;span class="math inline">\(n\)&lt;/span> 个函数, 如果存在 &lt;span class="math inline">\(n\)&lt;/span> 个不 全为零的常数 &lt;span class="math inline">\(k_{1}, k_{2}, \cdots, k_{n},\)&lt;/span> 使得当 &lt;span class="math inline">\(x \in I\)&lt;/span> 时有恒等式&lt;span class="math inline">\(k_{1} y_{1}+k_{2} y_{2}+\cdots+k_{n} y_{n} \equiv 0\)&lt;/span>成立，称这n个函数在区间I上&lt;strong>线性相关&lt;/strong>，否则称&lt;strong>线性无关&lt;/strong>&lt;/p>
&lt;p>注：线性代数也由线性相关、线性无关的介绍。&lt;/p></description></item><item><title>高等数学-微分方程习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 28 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-微分方程习题">高等数学-微分方程习题&lt;/h1>
&lt;h2 id="解一阶微分方程">解一阶微分方程&lt;/h2>
&lt;h3 id="解可分离变量微分方程">解可分离变量微分方程&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729145702745.png" alt="" />&lt;figcaption>image-20200729145702745&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729145847968.png" alt="" />&lt;figcaption>image-20200729145847968&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729152157020.png" alt="" />&lt;figcaption>image-20200729152157020&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729152211540.png" alt="" />&lt;figcaption>image-20200729152211540&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730091430224.png" alt="" />&lt;figcaption>image-20200730091430224&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730091506205.png" alt="" />&lt;figcaption>image-20200730091506205&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730092154090.png" alt="" />&lt;figcaption>image-20200730092154090&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730092238167.png" alt="" />&lt;figcaption>image-20200730092238167&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730103034490.png" alt="" />&lt;figcaption>image-20200730103034490&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730103046475.png" alt="" />&lt;figcaption>image-20200730103046475&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173038743.png" alt="" />&lt;figcaption>image-20200730173038743&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173051788.png" alt="" />&lt;figcaption>image-20200730173051788&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730181328524.png" alt="" />&lt;figcaption>image-20200730181328524&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730181343137.png" alt="" />&lt;figcaption>image-20200730181343137&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731150442991.png" alt="" />&lt;figcaption>image-20200731150442991&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731150502652.png" alt="" />&lt;figcaption>image-20200731150502652&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731150513764.png" alt="" />&lt;figcaption>image-20200731150513764&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731172127318.png" alt="" />&lt;figcaption>image-20200731172127318&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731172139952.png" alt="" />&lt;figcaption>image-20200731172139952&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801184321854.png" alt="" />&lt;figcaption>image-20200801184321854&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801184336764.png" alt="" />&lt;figcaption>image-20200801184336764&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802071647351.png" alt="" />&lt;figcaption>image-20200802071647351&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802071702160.png" alt="" />&lt;figcaption>image-20200802071702160&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解齐次方程">解齐次方程&lt;/h3>
&lt;p>齐次方程，这里指一阶[y与x齐次]微分方程&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729183559285.png" alt="" />&lt;figcaption>image-20200729183559285&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729183633157.png" alt="" />&lt;figcaption>image-20200729183633157&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730095619350.png" alt="" />&lt;figcaption>image-20200730095619350&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730095635365.png" alt="" />&lt;figcaption>image-20200730095635365&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730160128314.png" alt="" />&lt;figcaption>image-20200730160128314&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730160144307.png" alt="" />&lt;figcaption>image-20200730160144307&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730225411512.png" alt="" />&lt;figcaption>image-20200730225411512&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730225425814.png" alt="" />&lt;figcaption>image-20200730225425814&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730225438818.png" alt="" />&lt;figcaption>image-20200730225438818&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731101559166.png" alt="" />&lt;figcaption>image-20200731101559166&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731101612930.png" alt="" />&lt;figcaption>image-20200731101612930&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731112332025.png" alt="" />&lt;figcaption>image-20200731112332025&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731112343175.png" alt="" />&lt;figcaption>image-20200731112343175&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731112353174.png" alt="" />&lt;figcaption>image-20200731112353174&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731120154961.png" alt="" />&lt;figcaption>image-20200731120154961&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731120213993.png" alt="" />&lt;figcaption>image-20200731120213993&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731121011587.png" alt="" />&lt;figcaption>image-20200731121011587&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731121027503.png" alt="" />&lt;figcaption>image-20200731121027503&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801220821586.png" alt="" />&lt;figcaption>image-20200801220821586&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801220854532.png" alt="" />&lt;figcaption>image-20200801220854532&lt;/figcaption>
&lt;/figure>
&lt;h2 id="解可降为一阶的微分方程">解可降为一阶的微分方程&lt;/h2>
&lt;h4 id="解可降阶的yprime-primeflefty-yprimeright型微分方程">解可降阶的&lt;span class="math inline">\(y^{\prime \prime}=f\left(y, y^{\prime}\right)\)&lt;/span>型微分方程&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729215704104.png" alt="" />&lt;figcaption>image-20200729215704104&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729215721517.png" alt="" />&lt;figcaption>image-20200729215721517&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729215735763.png" alt="" />&lt;figcaption>image-20200729215735763&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730104543571.png" alt="" />&lt;figcaption>image-20200730104543571&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730104613686.png" alt="" />&lt;figcaption>image-20200730104613686&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730112244792.png" alt="" />&lt;figcaption>image-20200730112244792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730112302665.png" alt="" />&lt;figcaption>image-20200730112302665&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731173835605.png" alt="" />&lt;figcaption>image-20200731173835605&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731173848627.png" alt="" />&lt;figcaption>image-20200731173848627&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-注意技巧">例5 注意技巧&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802070624057.png" alt="" />&lt;figcaption>image-20200802070624057&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802070642855.png" alt="" />&lt;figcaption>image-20200802070642855&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802070659655.png" alt="" />&lt;figcaption>image-20200802070659655&lt;/figcaption>
&lt;/figure>
&lt;h4 id="解可降阶的yprime-primefleftx-yprimeright型微分方程">解可降阶的&lt;span class="math inline">\(y^{\prime \prime}=f\left(x, y^{\prime}\right)\)&lt;/span>型微分方程&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730103729093.png" alt="" />&lt;figcaption>image-20200730103729093&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730103743479.png" alt="" />&lt;figcaption>image-20200730103743479&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730233439220.png" alt="" />&lt;figcaption>image-20200730233439220&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730233517293.png" alt="" />&lt;figcaption>image-20200730233517293&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731173048444.png" alt="" />&lt;figcaption>image-20200731173048444&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731173103657.png" alt="" />&lt;figcaption>image-20200731173103657&lt;/figcaption>
&lt;/figure>
&lt;h2 id="线性微分方程">线性微分方程&lt;/h2>
&lt;h3 id="线性微分方程解的结构与性质">线性微分方程解的结构与性质&lt;/h3>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729150021738.png" alt="" />&lt;figcaption>image-20200729150021738&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729150123225.png" alt="" />&lt;figcaption>image-20200729150123225&lt;/figcaption>
&lt;/figure>
&lt;p>我是将解代入左边做的&lt;/p>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730161148177.png" alt="" />&lt;figcaption>image-20200730161148177&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730161202971.png" alt="" />&lt;figcaption>image-20200730161202971&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730161213300.png" alt="" />&lt;figcaption>image-20200730161213300&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173800796.png" alt="" />&lt;figcaption>image-20200730173800796&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173851278.png" alt="" />&lt;figcaption>image-20200730173851278&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解一阶线性微分方程">解一阶线性微分方程&lt;/h3>
&lt;h4 id="解一阶齐次线性微分方程公式法分离变数法">解一阶齐次线性微分方程：公式法/分离变数法&lt;/h4>
&lt;p>可以看作可分离变量的一阶微分方程来求解&lt;/p>
&lt;p>也可以直接套一阶线性微分方程的公式&lt;/p>
&lt;p>习题详见&lt;a href="#解可分离变量微分方程">解可分离变量微分方程&lt;/a>&lt;/p>
&lt;h4 id="解一阶非齐次线性微分方程公式法分离变量法常数变易法">解一阶非齐次线性微分方程：公式法/（分离变量法+常数变易法）&lt;/h4>
&lt;p>先用分离变量法求对应的一阶齐次线性微分方程的通解，再用分离变量法求非齐次线性方程的解。&lt;/p>
&lt;p>或者直接套公式&lt;span class="math inline">\(y=\mathrm{e}^{-\int P(x) \mathrm{d} x}\left(\int Q(x) \mathrm{e}^{\int P(x) \mathrm{d} x} \mathrm{d} x+C\right)\)&lt;/span>&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729174301199.png" alt="" />&lt;figcaption>image-20200729174301199&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729174320782.png" alt="" />&lt;figcaption>image-20200729174320782&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729175709890.png" alt="" />&lt;figcaption>image-20200729175709890&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729175729080.png" alt="" />&lt;figcaption>image-20200729175729080&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730090502149.png" alt="" />&lt;figcaption>image-20200730090502149&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730090522244.png" alt="" />&lt;figcaption>image-20200730090522244&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731214134866.png" alt="" />&lt;figcaption>image-20200731214134866&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731214207512.png" alt="" />&lt;figcaption>image-20200731214207512&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731183713168.png" alt="" />&lt;figcaption>image-20200731183713168&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731183731530.png" alt="" />&lt;figcaption>image-20200731183731530&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-未完成没有积出来">例6 未完成：没有积出来&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731182647138.png" alt="" />&lt;figcaption>image-20200731182647138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731182705042.png" alt="" />&lt;figcaption>image-20200731182705042&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731145024886.png" alt="" />&lt;figcaption>image-20200731145024886&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731145036393.png" alt="" />&lt;figcaption>image-20200731145036393&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-变量代换的灵活使用">例8 变量代换的灵活使用&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731114805526.png" alt="" />&lt;figcaption>image-20200731114805526&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731114828144.png" alt="" />&lt;figcaption>image-20200731114828144&lt;/figcaption>
&lt;/figure>
&lt;p>这道题把&lt;span class="math inline">\(\cos y \frac{dy}{dx}\)&lt;/span>看作&lt;span class="math inline">\(\frac{d(\sin y)}{dx}\)&lt;/span>使用&lt;span class="math inline">\(u=siny\)&lt;/span>的 代换，后面又使用了&lt;span class="math inline">\(z=\frac{1}{u}\)&lt;/span>代换，最后才变成可分离变量的微分方程。&lt;/p>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731105016662.png" alt="" />&lt;figcaption>image-20200731105016662&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731105026503.png" alt="" />&lt;figcaption>image-20200731105026503&lt;/figcaption>
&lt;/figure>
&lt;p>这里是用一阶线性微分方程的公式法来解的。如果用常数变易法，就会发现x只能取&lt;span class="math inline">\(x&amp;gt;0\)&lt;/span>&lt;/p>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731100135441.png" alt="" />&lt;figcaption>image-20200731100135441&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731100207541.png" alt="" />&lt;figcaption>image-20200731100207541&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730094757805.png" alt="" />&lt;figcaption>image-20200730094757805&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730094819730.png" alt="" />&lt;figcaption>image-20200730094819730&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730094828153.png" alt="" />&lt;figcaption>image-20200730094828153&lt;/figcaption>
&lt;/figure>
&lt;p>这里将x看作自变量，y看作因变量，就可以解了&lt;/p>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802073447425.png" alt="" />&lt;figcaption>image-20200802073447425&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802073506715.png" alt="" />&lt;figcaption>image-20200802073506715&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解常系数线性微分方程">解常系数线性微分方程&lt;/h3>
&lt;h4 id="解常系数齐次线性微分方程特征方程法">解常系数齐次线性微分方程：特征方程法&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729164600137.png" alt="" />&lt;figcaption>image-20200729164600137&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729164618482.png" alt="" />&lt;figcaption>image-20200729164618482&lt;/figcaption>
&lt;/figure>
&lt;p>这里，给了常系数齐次线性微分方程的特解，对应通解的形式为&lt;span class="math inline">\(y= C_1 e^{r_1 x} + e^{\alpha x} (C_2 \cos \beta x + C_3 \sin \beta x)\)&lt;/span>，从而可以确定对应的特征方程的特征值，继而确定特征方程，最后确定常系数齐次线性微分方程的系数。&lt;/p>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173609736.png" alt="" />&lt;figcaption>image-20200730173609736&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730173627382.png" alt="" />&lt;figcaption>image-20200730173627382&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731170929884.png" alt="" />&lt;figcaption>image-20200731170929884&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731170947902.png" alt="" />&lt;figcaption>image-20200731170947902&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731220842327.png" alt="" />&lt;figcaption>image-20200731220842327&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731220858948.png" alt="" />&lt;figcaption>image-20200731220858948&lt;/figcaption>
&lt;/figure>
&lt;h4 id="解常系数非齐次线性微分方程特征方程法待定系数法">解常系数非齐次线性微分方程：特征方程法+待定系数法&lt;/h4>
&lt;p>解常系数非齐次线性微分方程，需要先用特征方程法求出对应的齐次方程通解，再用待定系数法求出非齐次方程特解，最终得到非齐次线性方程通解&lt;/p>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729223421932.png" alt="" />&lt;figcaption>image-20200729223421932&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200729223447890.png" alt="" />&lt;figcaption>image-20200729223447890&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730071916378.png" alt="" />&lt;figcaption>image-20200730071916378&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730071937868.png" alt="" />&lt;figcaption>image-20200730071937868&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730111422173.png" alt="" />&lt;figcaption>image-20200730111422173&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730111438281.png" alt="" />&lt;figcaption>image-20200730111438281&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730170059869.png" alt="" />&lt;figcaption>image-20200730170059869&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730170515147.png" alt="" />&lt;figcaption>image-20200730170515147&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730172527785.png" alt="" />&lt;figcaption>image-20200730172527785&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730172538972.png" alt="" />&lt;figcaption>image-20200730172538972&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730182036854.png" alt="" />&lt;figcaption>image-20200730182036854&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730182058538.png" alt="" />&lt;figcaption>image-20200730182058538&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730182419578.png" alt="" />&lt;figcaption>image-20200730182419578&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200730182432578.png" alt="" />&lt;figcaption>image-20200730182432578&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731230131265.png" alt="" />&lt;figcaption>image-20200731230131265&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731230557646.png" alt="" />&lt;figcaption>image-20200731230557646&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731230609940.png" alt="" />&lt;figcaption>image-20200731230609940&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801084224773.png" alt="" />&lt;figcaption>image-20200801084224773&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801084240991.png" alt="" />&lt;figcaption>image-20200801084240991&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801090330435.png" alt="" />&lt;figcaption>image-20200801090330435&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801090345301.png" alt="" />&lt;figcaption>image-20200801090345301&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801094740812.png" alt="" />&lt;figcaption>image-20200801094740812&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801094755262.png" alt="" />&lt;figcaption>image-20200801094755262&lt;/figcaption>
&lt;/figure>
&lt;h2 id="非线性方程">非线性方程&lt;/h2>
&lt;h3 id="解伯努利方程">解伯努利方程&lt;/h3>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801192200446.png" alt="" />&lt;figcaption>image-20200801192200446&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801192216771.png" alt="" />&lt;figcaption>image-20200801192216771&lt;/figcaption>
&lt;/figure>
&lt;h3 id="解欧拉方程">解欧拉方程&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801102500552.png" alt="" />&lt;figcaption>image-20200801102500552&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801102530760.png" alt="" />&lt;figcaption>image-20200801102530760&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801182559688.png" alt="" />&lt;figcaption>image-20200801182559688&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801182624635.png" alt="" />&lt;figcaption>image-20200801182624635&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200801182637672.png" alt="" />&lt;figcaption>image-20200801182637672&lt;/figcaption>
&lt;/figure>
&lt;h2 id="全微分方程">全微分方程&lt;/h2>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731121623628.png" alt="" />&lt;figcaption>image-20200731121623628&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200731121641346.png" alt="" />&lt;figcaption>image-20200731121641346&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元积分学-定积分的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Wed, 25 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-定积分的应用">高等数学-一元积分学-定积分的应用&lt;/h1>
&lt;h2 id="几何应用">几何应用&lt;/h2>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501180543268.png" alt="" />&lt;figcaption>image-20200501180543268&lt;/figcaption>
&lt;/figure>
&lt;h3 id="面积">面积&lt;/h3>
&lt;h4 id="直角坐标系中l-yfx-geqslant-0-quada-leq-x-leq-b">直角坐标系中&lt;span class="math inline">\(L : y=f(x) \geqslant 0 \quad(a \leq x \leq b)\)&lt;/span>&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501175849500.png" alt="" />&lt;figcaption>image-20200501175849500&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(A=\int_{a}^{b} f(x) d x\)&lt;/span>&lt;/p>
&lt;h4 id="极坐标系中l-rrtheta-quadalpha-leq-0-leq-beta">极坐标系中&lt;span class="math inline">\(L: r=r(\theta) \quad(\alpha \leq 0 \leq \beta)\)&lt;/span>&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501175959748.png" alt="" />&lt;figcaption>image-20200501175959748&lt;/figcaption>
&lt;/figure>
&lt;p>取&lt;span class="math inline">\([\theta,\theta+d \theta] \subset[\alpha, \beta]\)&lt;/span>, &lt;span class="math inline">\(d A=\frac{1}{2} r^{2}(\theta) d \theta\)&lt;/span> &lt;span class="math inline">\(A=\frac{1}{2} \int_{\alpha}^{\beta} r^{2}(\theta) d \theta\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501180100016.png" alt="" />&lt;figcaption>image-20200501180100016&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(A=\frac{1}{2} \int_{\alpha}^{\beta}\left[r_{2}^{2}(\theta)-r_{1}^{2}(\theta)\right] d \theta\)&lt;/span>&lt;/p>
&lt;h4 id="旋转体表面积">旋转体表面积&lt;/h4>
&lt;figure>
&lt;img src="upload\image-20200501180617690.png" alt="" />&lt;figcaption>image-20200501180617690&lt;/figcaption>
&lt;/figure>
&lt;p>取&lt;span class="math inline">\([x, x+d x]&amp;lt;[a, b]\)&lt;/span>, &lt;span class="math inline">\(d A=2 \pi | f(x) | \cdot d s\)&lt;/span> &lt;span class="math inline">\(2 \pi \cdot | f(x) | \cdot \sqrt{\left.1+f^{\prime} | x\right)} d x\)&lt;/span> &lt;span class="math inline">\(A=2 \pi \int_{a}^{b}|f(x)| \cdot \sqrt{1+f^{\prime}(x)} d x\)&lt;/span>&lt;/p>
&lt;h3 id="体积">体积&lt;/h3>
&lt;h4 id="图形绕x轴旋转体积">图形绕x轴旋转体积&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501182542973.png" alt="" />&lt;figcaption>image-20200501182542973&lt;/figcaption>
&lt;/figure>
&lt;p>取&lt;span class="math inline">\([x, x+d x]&amp;lt;[a, b]\)&lt;/span>, &lt;span class="math inline">\(d v=\pi f^{2} (x) \cdot d x\)&lt;/span> &lt;span class="math inline">\(V_{x}=\pi \int_{a}^{b} f^{2} (x) d x\)&lt;/span>&lt;/p>
&lt;h4 id="图形绕y轴旋转体积">图形绕y轴旋转体积&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501182848340.png" alt="" />&lt;figcaption>image-20200501182848340&lt;/figcaption>
&lt;/figure>
&lt;p>取&lt;span class="math inline">\([x, x+d x]&amp;lt;[a, b]\)&lt;/span>, &lt;span class="math inline">\(d v=2 \pi|x| \cdot|f(x)| \cdot d x\)&lt;/span> &lt;span class="math inline">\(V_{y}=2 \pi \int_{a}^{b}|x| \cdot|f(x)| \cdot d x\)&lt;/span>&lt;/p>
&lt;h4 id="已知截面面积求体积">已知截面面积求体积&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501183031361.png" alt="" />&lt;figcaption>image-20200501183031361&lt;/figcaption>
&lt;/figure>
&lt;p>取&lt;span class="math inline">\([x, x+d x]&amp;lt;[a, b]\)&lt;/span>, &lt;span class="math inline">\(d v=A(x) d x\)&lt;/span> &lt;span class="math inline">\(v=\int_{a}^{b} A(x) d x\)&lt;/span>&lt;/p>
&lt;h3 id="弧长">弧长&lt;/h3>
&lt;p>弧长部分可结合&lt;a href="#高等数学-一元微分学-应用-弧微分与曲率.md#弧微分">高等数学-一元微分学-应用-弧微分与曲率&lt;/a>部分来看&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501222813056.png" alt="" />&lt;figcaption>image-20200501222813056&lt;/figcaption>
&lt;/figure>
&lt;h4 id="直角坐标系l-yfxa-leq-x-leq-b">直角坐标系&lt;span class="math inline">\(L: y=f(x)(a \leq x \leq b)\)&lt;/span>&lt;/h4>
&lt;p>取&lt;span class="math inline">\([x, x+d x]&amp;lt;[a, b]\)&lt;/span>, &lt;span class="math inline">\(d s=\sqrt{1+f^{\prime}(x)} d x\)&lt;/span> &lt;span class="math inline">\(l=\int_{a}^{b} \sqrt{1+f^{\prime 2}(x)} d x\)&lt;/span>&lt;/p>
&lt;h4 id="参数方程beginarraylleftbeginarrayllxvarphit-ypsitendarrayright.-alpha-leqslant-t-leqslant-betaendarray">参数方程&lt;span class="math inline">\(\begin{array}{l}\left\{\begin{array}{ll}x=\varphi(t) \\ y=\psi(t)\end{array}\right. &amp;amp; (\alpha \leqslant t \leqslant \beta)\end{array}\)&lt;/span>&lt;/h4>
&lt;p>取&lt;span class="math inline">\([t, t+d t]&amp;lt;[\alpha , \beta]\)&lt;/span>, &lt;span class="math inline">\(\begin{aligned} d s &amp;amp;=\sqrt{(d x)^{2}+\left( d y\right)^{2}}=\sqrt{\left(\frac{d x}{d t}\right)^{2}+\left(\frac{d y}{d t}\right)^{2}} d t \\ &amp;amp;=\sqrt{\varphi^{\prime}(t)+\psi^{\prime}(t)} d t \end{aligned}\)&lt;/span> &lt;span class="math inline">\(l=\int_{\alpha}^{\beta} \sqrt{\varphi^{\prime 2}(t)+\psi^{\prime 2} ( t)} d t\)&lt;/span>&lt;/p>
&lt;h4 id="极坐标系l-rrtheta">极坐标系&lt;span class="math inline">\(L: r=r(\theta)\)&lt;/span>&lt;/h4>
&lt;p>极坐标曲线 &lt;span class="math inline">\(r=r(\theta), \alpha \leqslant \theta \leqslant \beta\)&lt;/span> 的弧长(其中 &lt;span class="math inline">\(r(\theta), r^{\prime}(\theta)\)&lt;/span> 连续,且不同时为零) &lt;span class="math display">\[
s=\int_{a}^{\beta} \sqrt{r^{2}(\theta)+r^{\prime 2}(\theta)} \mathrm{d} \theta
\]&lt;/span>&lt;/p>
&lt;h4 id="圆a0">圆&lt;span class="math inline">\((a&amp;gt;0)\)&lt;/span>&lt;/h4>
&lt;p>&lt;span class="math inline">\(x^{2}+y^{2}=a^{2} \Leftrightarrow r=a\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(x^{2}+y^{2}=2 a x \Leftrightarrow(x-a)^{2}+y^{2}=a^{2}\)&lt;/span>对应极坐标系&lt;span class="math inline">\(x=2 a \cos \theta\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(x^{2}+y^{2}=2 a y \Leftrightarrow x^{2}+(y-a)^{2}=a^{2}\)&lt;/span>对应极坐标系&lt;span class="math inline">\(r=2 a \sin \theta\)&lt;/span>&lt;/p>
&lt;h4 id="双扭线">双扭线&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501224352306.png" alt="" />&lt;figcaption>image-20200501224352306&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\left(x^{2}+y^{2}\right)^{2}=a^{2}\left(x^{2}-y^{2}\right)\)&lt;/span>对应极坐标系&lt;span class="math inline">\(r^{2}=a^{2} \cos 2 \theta\)&lt;/span>&lt;/p>
&lt;h4 id="摆线">摆线&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501224515514.png" alt="" />&lt;figcaption>image-20200501224515514&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(L : \left\{\begin{array}{l}x=a(t-\sin t) \\ y=a(1-\cos t)\end{array} \quad(0 \leq t \leq 2 \pi)\right.\)&lt;/span>&lt;/p>
&lt;h4 id="心形线">心形线&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501225025621.png" alt="" />&lt;figcaption>image-20200501225025621&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(L: r=a(1+\cos \theta)\)&lt;/span>&lt;/p>
&lt;h2 id="物理应用">物理应用&lt;/h2></description></item><item><title>高等数学-一元积分学-定积分的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-定积分的应用">高等数学-一元积分学-定积分的应用&lt;/h1>
&lt;h2 id="几何应用">几何应用&lt;/h2>
&lt;h3 id="求面积体积">求面积体积&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502000848670.png" alt="" />&lt;figcaption>image-20200502000848670&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(L : y=\sqrt{x-1}\)&lt;/span> 1) 求曲线上的切线,且该切线过原点 2) 求曲线、切线、x轴所夹图形的面积 3) 所夹图形绕x轴旋转一周形成的图形的体积&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502000955372.png" alt="" />&lt;figcaption>image-20200502000955372&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502001142899.png" alt="" />&lt;figcaption>image-20200502001142899&lt;/figcaption>
&lt;/figure>
&lt;ol start="3" type="1">
&lt;li>&lt;/li>
&lt;/ol>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502001349125.png" alt="" />&lt;figcaption>image-20200502001349125&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502001514639.png" alt="" />&lt;figcaption>image-20200502001514639&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;p>1)求摆线第一拱的面积 2)摆线第一拱绕x轴旋转一周形成图形的体积&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004215531.png" alt="" />&lt;figcaption>image-20200502004215531&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004300550.png" alt="" />&lt;figcaption>image-20200502004300550&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004519452.png" alt="" />&lt;figcaption>image-20200502004519452&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004640486.png" alt="" />&lt;figcaption>image-20200502004640486&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004746608.png" alt="" />&lt;figcaption>image-20200502004746608&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502004851139.png" alt="" />&lt;figcaption>image-20200502004851139&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503162329535.png" alt="" />&lt;figcaption>image-20200503162329535&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503162400622.png" alt="" />&lt;figcaption>image-20200503162400622&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503162436990.png" alt="" />&lt;figcaption>image-20200503162436990&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503195524460.png" alt="" />&lt;figcaption>image-20200503195524460&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503195656893.png" alt="" />&lt;figcaption>image-20200503195656893&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503202823319.png" alt="" />&lt;figcaption>image-20200503202823319&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503204103337.png" alt="" />&lt;figcaption>image-20200503204103337&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503204145282.png" alt="" />&lt;figcaption>image-20200503204145282&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503224911756.png" alt="" />&lt;figcaption>image-20200503224911756&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503225229388.png" alt="" />&lt;figcaption>image-20200503225229388&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503225926801.png" alt="" />&lt;figcaption>image-20200503225926801&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505175756028.png" alt="" />&lt;figcaption>image-20200505175756028&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505175743687.png" alt="" />&lt;figcaption>image-20200505175743687&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505220808540.png" alt="" />&lt;figcaption>image-20200505220808540&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505220740301.png" alt="" />&lt;figcaption>image-20200505220740301&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505222551355.png" alt="" />&lt;figcaption>image-20200505222551355&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505222532742.png" alt="" />&lt;figcaption>image-20200505222532742&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508223637226.png" alt="" />&lt;figcaption>image-20200508223637226&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508223731369.png" alt="" />&lt;figcaption>image-20200508223731369&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508223619295.png" alt="" />&lt;figcaption>image-20200508223619295&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508225342070.png" alt="" />&lt;figcaption>image-20200508225342070&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508225327824.png" alt="" />&lt;figcaption>image-20200508225327824&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508230030524.png" alt="" />&lt;figcaption>image-20200508230030524&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508230005684.png" alt="" />&lt;figcaption>image-20200508230005684&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508231241231.png" alt="" />&lt;figcaption>image-20200508231241231&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508231226651.png" alt="" />&lt;figcaption>image-20200508231226651&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511135002879.png" alt="" />&lt;figcaption>image-20200511135002879&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511134940465.png" alt="" />&lt;figcaption>image-20200511134940465&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18">例18&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511140558087.png" alt="" />&lt;figcaption>image-20200511140558087&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511140533596.png" alt="" />&lt;figcaption>image-20200511140533596&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例19">例19&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511150208005.png" alt="" />&lt;figcaption>image-20200511150208005&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511150230262.png" alt="" />&lt;figcaption>image-20200511150230262&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例20">例20&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511154214348.png" alt="" />&lt;figcaption>image-20200511154214348&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511154233324.png" alt="" />&lt;figcaption>image-20200511154233324&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例21">例21&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511165911131.png" alt="" />&lt;figcaption>image-20200511165911131&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511165855226.png" alt="" />&lt;figcaption>image-20200511165855226&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例22">例22&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511171329849.png" alt="" />&lt;figcaption>image-20200511171329849&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511171306058.png" alt="" />&lt;figcaption>image-20200511171306058&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例23">例23&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511172027585.png" alt="" />&lt;figcaption>image-20200511172027585&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511171955794.png" alt="" />&lt;figcaption>image-20200511171955794&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511172010771.png" alt="" />&lt;figcaption>image-20200511172010771&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例24">例24&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511180658728.png" alt="" />&lt;figcaption>image-20200511180658728&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511180730657.png" alt="" />&lt;figcaption>image-20200511180730657&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例25">例25&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511201758979.png" alt="" />&lt;figcaption>image-20200511201758979&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511201827919.png" alt="" />&lt;figcaption>image-20200511201827919&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例26">例26&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511212157990.png" alt="" />&lt;figcaption>image-20200511212157990&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511212214391.png" alt="" />&lt;figcaption>image-20200511212214391&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例27">例27&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511213746835.png" alt="" />&lt;figcaption>image-20200511213746835&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511213728683.png" alt="" />&lt;figcaption>image-20200511213728683&lt;/figcaption>
&lt;/figure>
&lt;h3 id="已知面积条件求函数或参数">已知面积条件求函数或参数&lt;/h3>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511152811348.png" alt="" />&lt;figcaption>image-20200511152811348&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511152822324.png" alt="" />&lt;figcaption>image-20200511152822324&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511152738831.png" alt="" />&lt;figcaption>image-20200511152738831&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511152751831.png" alt="" />&lt;figcaption>image-20200511152751831&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511160232884.png" alt="" />&lt;figcaption>image-20200511160232884&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511160158563.png" alt="" />&lt;figcaption>image-20200511160158563&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511205203321.png" alt="" />&lt;figcaption>image-20200511205203321&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511205144609.png" alt="" />&lt;figcaption>image-20200511205144609&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511211758884.png" alt="" />&lt;figcaption>image-20200511211758884&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511211738785.png" alt="" />&lt;figcaption>image-20200511211738785&lt;/figcaption>
&lt;/figure>
&lt;h2 id="物理应用">物理应用&lt;/h2>
&lt;h3 id="质心问题">质心问题&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504002911771.png" alt="" />&lt;figcaption>image-20200504002911771&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504002943464.png" alt="" />&lt;figcaption>image-20200504002943464&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504003010939.png" alt="" />&lt;figcaption>image-20200504003010939&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504003034119.png" alt="" />&lt;figcaption>image-20200504003034119&lt;/figcaption>
&lt;/figure>
&lt;h3 id="引力问题">引力问题&lt;/h3>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504003745942.png" alt="" />&lt;figcaption>image-20200504003745942&lt;/figcaption>
&lt;/figure>
&lt;h3 id="做功问题">做功问题&lt;/h3>
&lt;h4 id="反抗重力做功">反抗重力做功&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504082553773.png" alt="" />&lt;figcaption>image-20200504082553773&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504082612752.png" alt="" />&lt;figcaption>image-20200504082612752&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511215504230.png" alt="" />&lt;figcaption>image-20200511215504230&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511215447367.png" alt="" />&lt;figcaption>image-20200511215447367&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511215753755.png" alt="" />&lt;figcaption>image-20200511215753755&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511215735083.png" alt="" />&lt;figcaption>image-20200511215735083&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511215724062.png" alt="" />&lt;figcaption>image-20200511215724062&lt;/figcaption>
&lt;/figure>
&lt;h4 id="克服阻力做功">克服阻力做功&lt;/h4>
&lt;p>假设匀速做功&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504085219629.png" alt="" />&lt;figcaption>image-20200504085219629&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504085242815.png" alt="" />&lt;figcaption>image-20200504085242815&lt;/figcaption>
&lt;/figure>
&lt;h3 id="压力问题">压力问题&lt;/h3>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504084207767.png" alt="" />&lt;figcaption>image-20200504084207767&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508230329445.png" alt="" />&lt;figcaption>image-20200508230329445&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508230345062.png" alt="" />&lt;figcaption>image-20200508230345062&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元积分学-定积分与反常积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</link><pubDate>Sun, 22 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-定积分与反常积分">高等数学-一元积分学-定积分与反常积分&lt;/h1>
&lt;h2 id="定积分">定积分&lt;/h2>
&lt;h3 id="定积分概念">定积分概念&lt;/h3>
&lt;p>函数&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]有定义且&lt;strong>有界&lt;/strong>，&lt;strong>分割&lt;/strong>为&lt;span class="math inline">\(\Delta x_i\)&lt;/span>小段，每段上&lt;strong>取点&lt;/strong>&lt;span class="math inline">\(\xi_i\)&lt;/span>处函数值作乘积&lt;span class="math inline">\(f\left(\xi_{i}\right) \Delta x_{i}\)&lt;/span>，&lt;strong>求和取极限&lt;/strong>&lt;span class="math inline">\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}\)&lt;/span>，其中&lt;span class="math inline">\(\lambda=\max _{1 \leq i \leq n}\left|\Delta x_{i}\right|\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>如果&lt;/strong>上述极限&lt;strong>存在&lt;/strong>，则称&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上可积，并称上述极限为&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上的定积分，记为&lt;span class="math inline">\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}=\int_{a}^{b} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>（有界是可积的必要条件）&lt;/p>
&lt;h3 id="定积分和原函数存在的判定">定积分和原函数存在的判定&lt;/h3>
&lt;h5 id="定积分存在定理">定积分存在定理&lt;/h5>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上连续，则定积分&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x\)&lt;/span>存在&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上有界，且只有有限个间断点，则定积分&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x\)&lt;/span>存在（一般可以看作多个连续的定积分相加）&lt;/p>
&lt;h5 id="原函数存在定理">原函数存在定理&lt;/h5>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上连续，则原函数存在&lt;/p>
&lt;p>&lt;strong>注&lt;/strong>：如果&lt;span class="math inline">\(f(x)\)&lt;/span>不连续，则原函数存在与否与定积分&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x\)&lt;/span>存在与否不相关&lt;/p>
&lt;h5 id="牛顿-莱布尼兹定理">牛顿-莱布尼兹定理&lt;/h5>
&lt;p>由前面定理&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上连续，则原函数存在，定积分存在。&lt;/p>
&lt;p>若&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上连续，&lt;span class="math inline">\(F(x)\)&lt;/span>是&lt;span class="math inline">\(f(x)\)&lt;/span>的一个原函数，则&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x=\left.F(x)\right|_{a} ^{b}=F(b)-F(a)\)&lt;/span>，这个关系叫做牛顿-莱布尼兹公式&lt;/p>
&lt;p>证明:&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429234106470.png" alt="image-20200429234106470" style="zoom:50%;" />&lt;/p>
&lt;h3 id="定积分性质">定积分性质&lt;/h3>
&lt;p>以下均设&lt;span class="math inline">\(f(x)\)&lt;/span>与&lt;span class="math inline">\(g(x)\)&lt;/span>可积&lt;/p>
&lt;h5 id="四则与上下限">四则与上下限&lt;/h5>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x=-\int_{b}^{a} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{a} f(x) \mathrm{d} x=0\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b}[f(x) \pm g(x)] \mathrm{d} x=\int_{a}^{b} f(x) \mathrm{d} x \pm \int_{a}^{b} g(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} k f(x) \mathrm{d} x=k \int_{a}^{b} f(x) \mathrm{d} x, k\)&lt;/span> 为常数&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x=\int_{a}^{c} f(x) \mathrm{d} x+\int_{c}^{b} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>一些特殊上下限变换:&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{-a}^{0} \overset {x=-t}{=} \int_{0}^{a}\)&lt;/span> , 如:&lt;span class="math inline">\(\int_{-a}^{0} f(x) d x=\int_{0}^{a} f(-x) d x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} \overset{x+t=a+b}{=} \int_{a}^{b}\)&lt;/span> ,如: &lt;span class="math inline">\(\int_{a}^{b} f(x) d x=\int_{a}^{b} f(a+b-x) d x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{a+T} \overset{x-a=t}{=} \int_{0}^{T}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} \overset {x=a+(b-a) t}{=} \int_{0}^{1}\)&lt;/span>&lt;/p>
&lt;h5 id="缩放">缩放&lt;/h5>
&lt;p>&lt;span class="math inline">\(f(x) \leqslant g(x), a \leqslant b,\)&lt;/span> 则 &lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x \leqslant \int_{a}^{b} g(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>若 &lt;span class="math inline">\(f(x) \text { 与 } g(x) \text { 在区间[ } a, b]\)&lt;/span> 上连续, &lt;span class="math inline">\(f(x) \leqslant g(x)\)&lt;/span>,且至少存在点 &lt;span class="math inline">\(x_{1}, a \leqslant x_{1} \leqslant b\)&lt;/span>，使 &lt;span class="math inline">\(f\left(x_{1}\right)&amp;lt;g\left(x_{1}\right),\)&lt;/span> 则&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x&amp;lt;\int_{a}^{b} g(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left|\int_{a}^{b} f(x) d x\right| \leqslant \int_{a}^{b} | f(x) | d x \quad(a&amp;lt;b)\)&lt;/span>&lt;/p>
&lt;h5 id="积分中值定理">积分中值定理&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在[ } a, b]\)&lt;/span> 连续,则至少存在一点 &lt;span class="math inline">\(\xi \in [a, b]\)&lt;/span> 使&lt;span class="math inline">\(\int_{a}^{b} f(x) d x=f(\xi)(b-a)\)&lt;/span>&lt;/p>
&lt;p>证明:(用介值定理证明)&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429234524636.png" alt="image-20200429234524636" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429234559434.png" alt="image-20200429234559434" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429234739925.png" alt="image-20200429234739925" style="zoom:50%;" />&lt;/p>
&lt;h5 id="对称奇偶周期性">对称奇偶周期性&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在[ }-a, a](a&amp;gt;0)\)&lt;/span> 上是个连续函数,则&lt;span class="math inline">\(\int_{-a}^{a} f(x) d x=\int_{0}^{a}[f(x)+f(-x)] d x\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在[ }-a, a](a&amp;gt;0)\)&lt;/span> 上是个连续的偶函数，则&lt;span class="math inline">\(\int_{-a}^{a} f(x) \mathrm{d} x=2 \int_{0}^{a} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在[ }-a, a](a&amp;gt;0)\)&lt;/span> 上是个连续的奇函数,则 &lt;span class="math inline">\(\int_{-a}^{a} f(x) \mathrm{d} x=0\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在(一 } \infty,+\infty)\)&lt;/span> 内是以 &lt;span class="math inline">\(T\)&lt;/span> 为周期的连续函数,则对于任意的常数 &lt;span class="math inline">\(a,\)&lt;/span> 恒有&lt;span class="math inline">\(\int_{a}^{a+T} f(x) \mathrm{d} x=\int_{0}^{T} f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>设 &lt;span class="math inline">\(f(x) \text { 在(一 } \infty,+\infty)\)&lt;/span> 内是以 &lt;span class="math inline">\(T\)&lt;/span> 为周期的连续函数,则&lt;span class="math inline">\(\int_{0}^{n T} f(x) d x=n \int_{0}^{T} f\left(x\right) d x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{0}^{\frac{\pi}{2}} f(\sin x) d x=\int_{0}^{\frac{\pi}{2}} f(\cos x) d x\)&lt;/span>&lt;/p>
&lt;p>华里士公式：&lt;span class="math inline">\(I_n = \int_{0}^{\frac{\pi}{2}} \sin ^{n} x \mathrm{d} x=\int_{0}^{\frac{\pi}{2}} \cos ^{n} x \mathrm{d} x=\left\{\begin{array}{lr}\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdot \cdots \cdot \frac{1}{2} \cdot \frac{\pi}{2}, &amp;amp; \text { 当 } n \text { 为正偶数 } \\ \frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \cdots \frac{2}{3} \cdot 1, &amp;amp; \text { 当 } n \text { 为大于 } 1 \text { 的正奇数. }\end{array}\right.\)&lt;/span> 即&lt;span class="math inline">\(\left\{ \begin{aligned} &amp;amp; I_{n}=\frac{n-1}{n} I_{n-2} \\ &amp;amp; I_{0}=\frac{\pi}{2} \\ &amp;amp; I_{1}=1 \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{0}^{\pi} f\left(\sin x\right) d x=2 \int_{0}^{\frac{\pi}{2}} f\left(\sin x\right) d x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{0}^{\pi} f(|\cos x|) d x=2 \int_{0}^{\frac{\pi}{2}} f(\cos x) d x\)&lt;/span>&lt;/p>
&lt;p>一个比较常用的变换公式：&lt;/p>
&lt;p>&lt;span class="math inline">\(\int_{0}^{\pi} x f(\sin x) d x=\frac{\pi}{2} \int_{0}^{\pi} f(\sin x) d x=\pi \int_{0}^{\frac{x}{2}} f(\sin x) d x\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>证明： &lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-fafd0c808e279667a99b1fd229fb6b16_720w.jpg" alt="img" style="zoom: 67%;" />&lt;/p>
&lt;/blockquote>
&lt;h3 id="定积分积分法">定积分积分法&lt;/h3>
&lt;h4 id="定积分的换元积分法">定积分的换元积分法&lt;/h4>
&lt;p>定积分换元积分时，和不定积分的区别在于：换元时，积分上、下限应跟着换，而不必像不定积分那样求出原函数后代回成原变量x.&lt;/p>
&lt;h4 id="定积分的分部积分法">定积分的分部积分法&lt;/h4>
&lt;p>&lt;span class="math inline">\(\int_{a}^{b} u(x) v^{\prime}(x) \mathrm{d} x=\left.u(x) v(x)\right|_{a} ^{b}-\int_{a}^{b} v(x) u^{\prime}(x) \mathrm{d} x\)&lt;/span> 或&lt;span class="math inline">\(\int_{a}^{b} u(x) \mathrm{d} v(x)=\left.u(x) v(x)\right|_{a} ^{b} - \int_{a}^{b} v(x) \mathrm{d} u(x)\)&lt;/span> 相对不定积分，只是多了积分上下限。&lt;/p>
&lt;h2 id="变限积分函数">变限积分函数&lt;/h2>
&lt;h5 id="积分上限函数">积分上限函数&lt;/h5>
&lt;p>&lt;span class="math inline">\(\int_{a}^{x} f(t) d t \triangleq \Phi(x)\)&lt;/span>&lt;/p>
&lt;h5 id="积分下限函数">积分下限函数&lt;/h5>
&lt;p>类似积分上限函数定义&lt;/p>
&lt;h5 id="上限积分函数求导">上限积分函数求导&lt;/h5>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上连续，$ (x)＝&lt;em>{a}^{x} f(t) d t &lt;span class="math inline">\(，则\)&lt;/span>^{}(x)＝(&lt;/em>{a}^{x} f(t) t)&lt;em>x^{} =f(x), x &lt;span class="math inline">\(，即\)&lt;/span>&lt;/em>{a}^{x} f(t) t&lt;span class="math inline">\(是\)&lt;/span>f(x)$的一个原函数&lt;/p>
&lt;p>推论：&lt;span class="math inline">\(\frac{d}{d x} \int_{a}^{\varphi(x)} f(t) d t=f[\varphi(x)] \cdot \varphi^{\prime}(x)\)&lt;/span>&lt;/p>
&lt;p>推论：&lt;span class="math inline">\(\frac{d}{d x} \int_{\varphi_1(x)}^{\varphi_2(x)} f(t) d t=f\left[\varphi_{2}(x)\right] \varphi_{2}^{\prime}(x)-f\left[\varphi_1 (x)\right] \varphi_{1}^{\prime}(x)\)&lt;/span>&lt;/p>
&lt;h2 id="反常积分广义积分">反常积分(广义积分)&lt;/h2>
&lt;h3 id="正常积分">正常积分&lt;/h3>
&lt;p>积分区间有限 &lt;span class="math inline">\(f(x)\)&lt;/span>在区间[a,b]上连续,或存在有限个第一类间断点&lt;/p>
&lt;h3 id="定义域无限的反常积分">定义域无限的反常积分&lt;/h3>
&lt;h4 id="a-fx-d-x-型">$_{a}^{+} f(x) d x $型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\([a,+\infty)\)&lt;/span>连续,求$_{a}^{+} f(x) d x $&lt;/p>
&lt;p>正常积分有牛顿-莱布尼兹公式&lt;span class="math inline">\(\int_{a}^{b} f (x) d x=F(b)-F(a)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(F(b)-F(a)\)&lt;/span>与&lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span>不同,但是当&lt;span class="math inline">\(b \rightarrow +\infty\)&lt;/span>,则相同.&lt;/p>
&lt;h5 id="计算">计算&lt;/h5>
&lt;p>可以根据定义来计算&lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x =\lim _{b \rightarrow+\infty} \int_{a}^{b} f(x) \mathrm{d} x = \lim_{b \rightarrow +\infty}[F(b)-F(a)] = \left\{\begin{array}{l} =A \text { ,收敛 }\\ \text { 不存在,发散 } \end{array} \right.\)&lt;/span>&lt;/p>
&lt;p>也可以判敛之后，根据正常积分的步骤来计算。&lt;/p>
&lt;h5 id="判敛">判敛&lt;/h5>
&lt;p>比较审敛法&lt;/p>
&lt;p>极限审敛法:若&lt;span class="math inline">\(\lim_{n \rightarrow \infty} x^{\alpha} \cdot f(x)=c_{0}(\neq 0)\)&lt;/span>,则&lt;span class="math inline">\(\left\{\begin{aligned}\text{收敛},\alpha &amp;gt;1 \\ \text{发散}, \alpha \le 1\end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="a-fx-d-x-型-1">$_{-}^{a} f(x) d x $型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\([-\infty,a)\)&lt;/span>连续,求$_{-}^{a} f(x) d x $&lt;/p>
&lt;p>判敛和计算方式与趋于正无穷的反常积分类似.&lt;/p>
&lt;h4 id="fx-d-x-型">$_{-}^{+} f(x) d x $型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\([a,+\infty)\)&lt;/span>连续,求$_{-}^{+} f(x) d x $&lt;/p>
&lt;p>判敛:&lt;/p>
&lt;p>$&lt;em>{-}^{+} f(x) d x &lt;span class="math inline">\(收敛\)&lt;/span>$ $&lt;/em>{-}^{a} f(x) d x &lt;span class="math inline">\(与\)&lt;/span>_{a}^{+} f(x) d x $都收敛&lt;/p>
&lt;p>注意:要想对该类广义积分使用定积分对称区间上的性质,前提是该广义积分收敛.&lt;/p>
&lt;h3 id="函数值域无界的反常积分">函数值域无界的反常积分&lt;/h3>
&lt;h4 id="端点处fa-rightarrow-infty的-int_ab-f-x-d-x型">端点处&lt;span class="math inline">\(f(a+) \rightarrow \infty\)&lt;/span>的 &lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\((a,b]\)&lt;/span>连续,求&lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>&lt;/p>
&lt;p>根据牛顿-莱布尼兹公式有&lt;span class="math inline">\(\forall \varepsilon&amp;gt;0 , \int_{a+\varepsilon}^{b} f(x) d x=F(b)-F(a+\varepsilon)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(F(b)-F(a+\varepsilon)\)&lt;/span>与&lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>不等,但是&lt;span class="math inline">\(\varepsilon \rightarrow 0\)&lt;/span>则相同&lt;/p>
&lt;h5 id="计算-1">计算&lt;/h5>
&lt;p>可以根据定义计算&lt;span class="math inline">\(\int_{a}^{b} f (x) d x =\lim _{a \rightarrow a+} \int_{a}^{b} f(x) d x= \lim_{\varepsilon \rightarrow 0} \left[ F(b)-F(a+\varepsilon) \right] = \left\{\begin{array}{l} =A \text { ,收敛 }\\ \text { 不存在,发散 } \end{array} \right.\)&lt;/span>&lt;/p>
&lt;p>也可以判敛之后按正常积分来计算&lt;/p>
&lt;h5 id="判敛-1">判敛&lt;/h5>
&lt;p>比较审敛法&lt;/p>
&lt;p>极限审敛法:&lt;span class="math inline">\(\lim_{x \rightarrow a^{+}}(x-a)^{\alpha} \cdot f(x)=C\)&lt;/span>.则&lt;span class="math inline">\(\left\{\begin{aligned}\text{收敛},\alpha &amp;lt;1 \\ \text{发散}, \alpha \ge 1\end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;h4 id="端点处fb--rightarrow-infty的-int_ab-f-x-d-x型">端点处&lt;span class="math inline">\(f(b-) \rightarrow \infty\)&lt;/span>的 &lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\([a,b)\)&lt;/span>连续,求&lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>&lt;/p>
&lt;p>计算与判敛类似左端点函数值趋于无穷的情况&lt;/p>
&lt;h4 id="端点处fa-rightarrow-infty且fb--rightarrow-infty的-int_ab-f-x-d-x型">端点处&lt;span class="math inline">\(f(a+) \rightarrow \infty\)&lt;/span>且&lt;span class="math inline">\(f(b-) \rightarrow \infty\)&lt;/span>的 &lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\((a,b)\)&lt;/span>连续,求&lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>&lt;/p>
&lt;p>计算与判敛同上,判敛要对两个端点都进行一次&lt;/p>
&lt;h4 id="区间中有fc-rightarrow-infty的-int_ab-f-x-d-x型">区间中有&lt;span class="math inline">\(f(c) \rightarrow \infty\)&lt;/span>的 &lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>型&lt;/h4>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\([a, c) \cup(c, b]\)&lt;/span>连续,且&lt;span class="math inline">\(\lim_{x \rightarrow c} f(x) = \infty\)&lt;/span>,求&lt;span class="math inline">\(\int_{a}^{b} f (x) d x\)&lt;/span>&lt;/p>
&lt;p>$&lt;em>{a}^{b} f(x) d x &lt;span class="math inline">\(收敛\)&lt;/span>$ $&lt;/em>{a}^{c} f(x) d x &lt;span class="math inline">\(与\)&lt;/span>_{c}^{b} f(x) d x $都收敛&lt;/p>
&lt;h3 id="反常积分的审敛">反常积分的审敛&lt;/h3>
&lt;h5 id="反常积分的审敛-1">反常积分的审敛&lt;/h5>
&lt;p>不通过被积函数的原函数判定反常积分收敛性的判定方法&lt;/p>
&lt;h5 id="反常积分审敛依据的定理">反常积分审敛依据的定理&lt;/h5>
&lt;h6 id="定理-1单调有界必收敛">定理 1(单调有界必收敛)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a,+\infty)\)&lt;/span> 上连续且 &lt;span class="math inline">\(f(x) \geq 0 . \quad\)&lt;/span> 若函数 &lt;span class="math inline">\(F(x)=\int_{a}^{x} f(t) d t\)&lt;/span>在&lt;span class="math inline">\([a,+\infty)\)&lt;/span> 上有上界，则反常积分 &lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 收敛.&lt;/p>
&lt;h6 id="定理2比较审敛原理">定理2(比较审敛原理)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x), g(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a,+\infty)\)&lt;/span> 上连续、非负，如果 &lt;span class="math inline">\(f(x) \leq g(x),(a \leq x&amp;lt;+\infty),\)&lt;/span> 并且 &lt;span class="math inline">\(\int_{a}^{+\infty} g(x) d x\)&lt;/span> 收敛，则 &lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 也收敛 &lt;span class="math inline">\(; \quad\)&lt;/span> 如果 &lt;span class="math inline">\(f(x) \geq g(x),(a \leq x&amp;lt;+\infty)\)&lt;/span>并且 &lt;span class="math inline">\(\int_{a}^{+\infty} g(x) d x\)&lt;/span> 发散，则 &lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 也发散.(可依据定理1推导)&lt;/p>
&lt;p>区间 &lt;span class="math inline">\((-\infty,a]\)&lt;/span> 上连续, 或者 &lt;span class="math inline">\(f(x) \leq 0 \quad\)&lt;/span>情况类似.&lt;/p>
&lt;h5 id="无穷限反常积分的审敛法">无穷限反常积分的审敛法&lt;/h5>
&lt;p>特别地，取 &lt;span class="math inline">\(g(x)=\frac{1}{x^{p}}\)&lt;/span>,就可由定理2(比较审敛原理)推出下面的定理3(比较审敛法)&lt;/p>
&lt;h6 id="定理3比较审敛法-1">定理3(比较审敛法 1)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a,+\infty) \quad(a&amp;gt;0)\)&lt;/span> 上连续，且 &lt;span class="math inline">\(f(x) \geq 0\)&lt;/span> . 如果存在常数 M &amp;gt;0 及 p&amp;gt;1，使得 &lt;span class="math inline">\(\left.f(x) \leq \frac{M}{x^{p}},(a \leq x&amp;lt;+\infty), \text { 则 }\right] \int_{a}^{+\infty} f(x) d x\)&lt;/span> 收敛； 如果存在常数 N &amp;gt; 0，使得 &lt;span class="math inline">\(f(x) \geq \frac{N}{x}(a \leq x&amp;lt;+\infty),\)&lt;/span> 则 &lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 发散.&lt;/p>
&lt;h6 id="定理4极限审敛法-1">定理4(极限审敛法 1)&lt;/h6>
&lt;p>比较审敛法,移项取极限可得如下极限审敛法:&lt;/p>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a,+\infty)(a&amp;gt;0)\)&lt;/span> 上连续，且 &lt;span class="math inline">\(f(x) \geq 0\)&lt;/span> 。如果存在常数 &lt;span class="math inline">\(p&amp;gt;1,\)&lt;/span> 使得 &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x^{p} f(x)\)&lt;/span> 存在 则&lt;span class="math inline">\(\int_{a }^{+\infty} f(x) d x\)&lt;/span>收敛： 如果 &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x f(x)=d&amp;gt;0\left(\text { 或 } \lim _{x \rightarrow+\infty} x f(x)=+\infty\right),\)&lt;/span> 则&lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 发散.&lt;/p>
&lt;h6 id="定理5积分的绝对值小于绝对值的积分">定理5(积分的绝对值小于绝对值的积分)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\([a,+\infty)\)&lt;/span> 上连续， 如果 &lt;span class="math inline">\(\int_{a}^{+\infty}|f(x)| d x\)&lt;/span> 收敛,则 &lt;span class="math inline">\(\int_{a}^{+\infty} f(x) d x\)&lt;/span> 也收敛,称其绝对收敛.&lt;/p>
&lt;h5 id="无界函数反常积分的审敛法">无界函数反常积分的审敛法&lt;/h5>
&lt;h6 id="定理6比较审敛法2">定理6(比较审敛法2)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\((a, b]\)&lt;/span> 上连续，且 &lt;span class="math inline">\(f(x) \geq 0\)&lt;/span> ，&lt;span class="math inline">\(x=a\)&lt;/span> 是瑕点.如果存在常数 &lt;span class="math inline">\(M&amp;gt;0\)&lt;/span> 及 &lt;span class="math inline">\(q&amp;lt;1\)&lt;/span> 使得 &lt;span class="math inline">\(\quad f(x) \leq \frac{M}{(x-a)^{q}} \quad(a&amp;lt;x \leq b)\)&lt;/span> 则反常积分 &lt;span class="math inline">\(\int_{a}^{b} f(\boldsymbol{x}) d x\)&lt;/span> 收敛; 如果存在常数 &lt;span class="math inline">\(N&amp;gt;\mathbf{0}\)&lt;/span> 使得 &lt;span class="math inline">\(\quad f(x) \geq \frac{N}{x-a} \quad(a&amp;lt;x \leq b)\)&lt;/span> 则反常积分 &lt;span class="math inline">\(\int_a^{b} f(x) d x\)&lt;/span> 发散&lt;/p>
&lt;h6 id="定理-7极限审敛法2">定理 7(极限审敛法2)&lt;/h6>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\((a, b]\)&lt;/span> 上连续，且 &lt;span class="math inline">\(f(x) \geq 0\)&lt;/span> ，&lt;span class="math inline">\(x=a\)&lt;/span> 是瑕点.如果存在常数 &lt;span class="math inline">\(\mathbf{0}&amp;lt;q&amp;lt;1, \quad\)&lt;/span> 使得&lt;span class="math inline">\(\lim _{x \rightarrow a^{+}}(x-a)^{q} f(x)\)&lt;/span>存在,则反常积分 &lt;span class="math inline">\(\int_{a}^{b} f(x) d x\)&lt;/span> 收敛： 如果 &lt;span class="math inline">\(\lim _{x \rightarrow a^{+}}(x-a) f(x)=d&amp;gt;0\left(\text { 或 } \lim _{x \rightarrow a^{+}}(x-a) f(x)=+\infty\right)\)&lt;/span> 则反常积分 &lt;span class="math inline">\(\int_{a}^{b} f(x) d x\)&lt;/span> 发散.&lt;/p>
&lt;p>对于无界函数的反常积分，当被积函数在所讨论的区间上可取正值又可取负值时，也有与定理5相类似的结论。&lt;/p>
&lt;!--瑕积分的判敛定理如下:-->
&lt;!--![image-20200502215421879](https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502215421879.png)-->
&lt;!--![image-20200502215513012](https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502215513012.png)-->
&lt;h3 id="gamma函数">&lt;span class="math inline">\(\Gamma\)&lt;/span>函数&lt;/h3>
&lt;h5 id="gamma函数定义">&lt;span class="math inline">\(\Gamma\)&lt;/span>函数定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(\Gamma\)&lt;/span>函数属于区间无限的反常积分.&lt;/p>
&lt;p>$() _{0}^{+} x^{} e^{-x} d x $&lt;/p>
&lt;p>或者&lt;span class="math inline">\(\Gamma(s)=\int_{0}^{+\infty} e^{-x} x^{s-1} d x,(s&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200503104815499.png" alt="" />&lt;figcaption>image-20200503104815499&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\Gamma\)&lt;/span>函数的几个例子:&lt;/p>
&lt;p>eg: &lt;span class="math inline">\(\int_{0}^{+\infty} x^{4} e^{-x} d x=\Gamma(5)\)&lt;/span>&lt;/p>
&lt;p>eg: &lt;span class="math inline">\(\int_{0}^{+\infty} \sqrt{x} e^{-x} d x=\Gamma\left(\frac{3}{2}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="gamma函数特点">&lt;span class="math inline">\(\Gamma\)&lt;/span>函数特点&lt;/h5>
&lt;ol type="1">
&lt;li>积分区间为无穷区间;&lt;/li>
&lt;li>&lt;span class="math inline">\(0&amp;lt;s&amp;lt;1\)&lt;/span>时,被积函数在点 &lt;span class="math inline">\(x=0\)&lt;/span> 的右半邻域内无界. 点 &lt;span class="math inline">\(x=0\)&lt;/span> 是瑕点.&lt;/li>
&lt;li>&lt;span class="math inline">\(\Gamma(s)=\int_{0}^{+\infty} e^{-x} x^{s-1} d x\)&lt;/span> 对 &lt;span class="math inline">\(s&amp;gt;0\)&lt;/span> 均收敛.&lt;/li>
&lt;li>由&lt;span class="math inline">\(\Gamma(s)\)&lt;/span>的图形，可知&lt;span class="math inline">\(\Gamma(s)\)&lt;/span>在&lt;span class="math inline">\((0,+\infty)\)&lt;/span>上连续&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>证明&lt;span class="math inline">\(\Gamma\)&lt;/span>函数在&lt;span class="math inline">\(s&amp;gt;0\)&lt;/span>均收敛&lt;/p>
&lt;p>当 &lt;span class="math inline">\(s-1&amp;lt;0\)&lt;/span> 时,即&lt;span class="math inline">\(0&amp;lt;s&amp;lt;1\)&lt;/span>时,被积函数在点 &lt;span class="math inline">\(x=0\)&lt;/span> 的右半邻域内无界. 点 &lt;span class="math inline">\(x=0\)&lt;/span> 是瑕点. 设 &lt;span class="math inline">\(I_{1}=\int_{0}^{1} e^{-x} x^{s-1} d x, \quad I_{2}=\int_{1}^{+\infty} e^{-x} x^{s-1} d x\)&lt;/span> (1) 当 &lt;span class="math inline">\(s \geq 1\)&lt;/span> 时, &lt;span class="math inline">\(I_{1}\)&lt;/span> 是定积分 (2) &lt;span class="math inline">\(0&amp;lt;s&amp;lt;1\)&lt;/span> 时,&lt;span class="math inline">\(\because e^{-x} \cdot x^{s-1}=\frac{1}{x^{1-s}} \cdot \frac{1}{e^{x}}&amp;lt;\frac{1}{x^{1-s}}\)&lt;/span> 又&lt;span class="math inline">\(\because 1- s&amp;lt;1 \therefore I_{1}=\int_{0}^{1} e^{-x} x^{s-1} d x\)&lt;/span> 收敛.（比较审敛法2） &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x^{2} \cdot\left(e^{-x} x^{s-1}\right)=\lim _{x \rightarrow+\infty} \frac{x^{s+1}}{e^{x}}=0\)&lt;/span> &lt;span class="math inline">\(\therefore I_{2}=\int_{1}^{+\infty} e^{-x} x^{s-1} d x\)&lt;/span> 收敛. &lt;span class="math inline">\(\quad(\)&lt;/span> 极限审敛法)&lt;/p>
&lt;p>由 (1),(2) 知 &lt;span class="math inline">\(\Gamma(s)=\int_{0}^{+\infty} e^{-x} x^{s-1} d x\)&lt;/span> 对 &lt;span class="math inline">\(s&amp;gt;0\)&lt;/span> 均收敛.&lt;/p>
&lt;/blockquote>
&lt;h5 id="gamma函数性质">&lt;span class="math inline">\(\Gamma\)&lt;/span>函数性质&lt;/h5>
&lt;ol type="1">
&lt;li>递推公式 &lt;span class="math inline">\(\Gamma(\alpha+1)=\alpha \Gamma(\alpha)\)&lt;/span>,要求&lt;span class="math inline">\(\alpha &amp;gt;0\)&lt;/span> &lt;span class="math inline">\(\Gamma(n+1)=n !\)&lt;/span> &lt;span class="math inline">\(\Gamma\left(\frac{1}{2}\right)=\sqrt{\pi}\)&lt;/span>&lt;/li>
&lt;li>当 &lt;span class="math inline">\(s \rightarrow 0^{+}\)&lt;/span> 时 &lt;span class="math inline">\(, \Gamma(s) \rightarrow+\infty\)&lt;/span>&lt;/li>
&lt;li>余元公式 &lt;span class="math inline">\(\Gamma(s) \Gamma(1-s)=\frac{\pi}{\sin \pi s}(0&amp;lt;s&amp;lt;1)\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math inline">\(\int_{0}^{+\infty} e^{-u^{2}} u^{t} d u=\frac{1}{2} \Gamma\left(\frac{1+t}{2}\right),(t&amp;gt;-1)\)&lt;/span>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>递推公式 &lt;span class="math inline">\(\Gamma(s+1)=s \Gamma(s)(s&amp;gt;0)\)&lt;/span>的证明 &lt;span class="math inline">\(\Gamma(s+1)=\int_{0}^{+\infty} e^{-x} x^{(s+1)-1} d x\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-x} x^{s} d x=\int_{0}^{+\infty} x^{s} d\left(-e^{-x}\right)\)&lt;/span> &lt;span class="math inline">\(=\left[x^{s}\left(-e^{-x}\right)\right]_{0}^{+\infty}-\int_{0}^{+\infty}\left(-e^{-x}\right) d\left(x^{s}\right)\)&lt;/span> &lt;span class="math inline">\(=\lim _{x \rightarrow+\infty} x^{s}\left(-e^{-x}\right)-0-\int_{0}^{+\infty}\left(-e^{-x}\right) s x^{s-1} d x\)&lt;/span> &lt;span class="math inline">\(=\underline{0}-0+s \int_{0}^{+\infty} e^{-x} x^{s-1} d x \quad(\text { 洛必达法则 })\)&lt;/span> &lt;span class="math inline">\(=s \Gamma(s)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>当&lt;span class="math inline">\(s \rightarrow 0^{+}\)&lt;/span>时&lt;span class="math inline">\(\Gamma(s) \rightarrow+\infty\)&lt;/span>的证明 由（1）得: &lt;span class="math inline">\(\Gamma(s)=\frac{\Gamma(s+1)}{s},(s&amp;gt;0)\)&lt;/span> 令 &lt;span class="math inline">\(s \rightarrow 0^{+}\)&lt;/span> 取极限，得 &lt;span class="math inline">\(\Gamma(s+1) \rightarrow \Gamma(1)=1\)&lt;/span> &lt;span class="math inline">\([\because \Gamma(s) \text { 在s }=1 \text { 连续 }]\)&lt;/span> &lt;span class="math inline">\(\therefore \Gamma(s) \rightarrow+\infty \quad\left(\text { 当 } s \rightarrow 0^{+} \text {时 }\right)\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>&lt;span class="math inline">\(\Gamma(s) \Gamma(1-s)=\frac{\pi}{\sin \pi s},(0&amp;lt;s&amp;lt;1)\)&lt;/span>(余元公式)不证,但是可以比较轻松的得到&lt;span class="math inline">\(\Gamma\left(\frac{1}{2}\right)=\sqrt{\pi}\)&lt;/span> 取 &lt;span class="math inline">\(s=\frac{1}{2},\)&lt;/span> 代入得 &lt;span class="math inline">\(\Gamma\left(\frac{1}{2}\right) \Gamma\left(\frac{1}{2}\right)=\frac{\pi}{\sin \frac{\pi}{2}}=\pi\)&lt;/span> &lt;span class="math inline">\(\therefore \quad \Gamma\left(\frac{1}{2}\right)=\sqrt{\pi}\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;p>&lt;span class="math inline">\(\int_{0}^{+\infty} e^{-u^{2}} u^{t} d u=\frac{1}{2} \Gamma\left(\frac{1+t}{2}\right),(t&amp;gt;-1)\)&lt;/span>的证明 (&lt;span class="math inline">\(\Gamma\)&lt;/span>型向泊松型的变换) &lt;span class="math inline">\(\Gamma(s)=\int_{0}^{+\infty} e^{-x} x^{s-1} d x\)&lt;/span> &lt;span class="math inline">\(\overset{\text { 令 }{x}=u^{2} }{=} \int_{0}^{+\infty} e^{-u^{2}} u^{2(s-1)} 2 u d u\)&lt;/span> (换积分符号不影响函数的自变量) &lt;span class="math inline">\(=2 \int_{0}^{+\infty} e^{-u^{2}} u^{2 s-1} d u\)&lt;/span> (自变量换为t) &lt;span class="math inline">\(\overset{\text { 记 } t= 2 s-1 }{=} 2 \int_{0}^{+\infty} e^{-u^{2}} u^{t} d u\)&lt;/span> （泊松型表示为&lt;span class="math inline">\(\Gamma\)&lt;/span>函数） &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}} u^{t-1} 2 u d u\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}} u^{t-1} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}}\left(u^{2}\right)^{\frac{1}{2}(t-1)} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}}\left(u^{2}\right)^{\frac{1}{2}(t+1)-1} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(\overset{x=u^2}{=}\int_{0}^{+\infty} e^{-x} x^{\frac{1}{2}(t+1)-1} d x=\Gamma\left(\frac{1+t}{2}\right)\)&lt;/span> 综上&lt;span class="math inline">\(\therefore \int_{0}^{+\infty} e^{-u^{2}} u^{t} d u=\frac{1}{2} \Gamma\left(\frac{1+t}{2}\right),(t&amp;gt;-1)\)&lt;/span>&lt;/p>
&lt;h3 id="高斯积分与泊松积分">高斯积分与泊松积分&lt;/h3>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-0a7b4833ba97e83a3486aefe98d62b4e_720w.jpg" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(\int_{-\infty}^{+\infty} \mathrm{e}^{-x^{2}} \mathrm{d} x=2 \int_{0}^{+\infty} \mathrm{e}^{-x^{2}} \mathrm{d} x=\sqrt{\pi}\)&lt;/span>&lt;/p>
&lt;p>由于被积函数是一个偶函数（如下图所示），0到&lt;span class="math inline">\(+\infty\)&lt;/span>的积分显然就是&lt;span class="math inline">\(\frac {\sqrt{ \pi}}{2}\)&lt;/span>.&lt;/p>
&lt;p>(0到&lt;span class="math inline">\(+\infty\)&lt;/span>上的积分又叫泊松积分:Euler-Poisson积分)&lt;/p>
&lt;h4 id="高斯积分可由gamma函数可以算出">高斯积分可由&lt;span class="math inline">\(\Gamma\)&lt;/span>函数可以算出&lt;/h4>
&lt;p>&lt;span class="math inline">\(\Gamma\left(\frac{1}{2}\right)=\int_{0}^{\infty} \frac{1}{\sqrt{x} e^{x}} d x=\int_{-\infty}^{\infty} e^{-x^{2}} d x=\sqrt{\pi}\)&lt;/span>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/72367850">高斯积分的证明&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://wenku.baidu.com/view/dfe30822580216fc700afd7e.html">泊松积分的几种简便证明&lt;/a>&lt;/p>
&lt;h4 id="泊松型积分可表示为gamma函数">泊松型积分可表示为&lt;span class="math inline">\(\Gamma\)&lt;/span>函数&lt;/h4>
&lt;p>&lt;span class="math inline">\(2 \int_{0}^{+\infty} e^{-u^{2}} u^{t} d u\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}} u^{t-1} 2 u d u\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}} u^{t-1} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}}\left(u^{2}\right)^{\frac{1}{2}(t-1)} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(=\int_{0}^{+\infty} e^{-u^{2}}\left(u^{2}\right)^{\frac{1}{2}(t+1)-1} d\left(u^{2}\right)\)&lt;/span> &lt;span class="math inline">\(\overset{x=u^2}{=}\int_{0}^{+\infty} e^{-x} x^{\frac{1}{2}(t+1)-1} d x=\Gamma\left(\frac{1+t}{2}\right)\)&lt;/span>&lt;/p>
&lt;p>即&lt;span class="math inline">\(\int_{0}^{+\infty} e^{-u^{2}} u^{t} d u\)&lt;/span> &lt;span class="math inline">\(=\frac{1}{2}\Gamma\left(\frac{1+t}{2}\right)\)&lt;/span>&lt;/p>
&lt;p>即泊松积分都可以化为&lt;span class="math inline">\(\Gamma\)&lt;/span>函数求解。&lt;/p>
&lt;p>而泊松积分在概率论中会有应用（计算正态分布、瑞利分布等的分布函数、期望、方差等）&lt;/p>
&lt;h2 id="积分不等式的证明">积分不等式的证明&lt;/h2>
&lt;p>证明某积分不等式，是考研中经常见到的问题. 处理这类问题有三种方法. (1)将要证的某某 &amp;gt; 0(或 &lt;span class="math inline">\(\geqslant0\)&lt;/span>) 的一边变成变限函数,用微分学的办法证此不等式(例如 用单调性，最值,拉格朗日中值定理，拉格朗日余项泰勒公式等等)，这是考研中经常用到的方法. (2) 设要证的是 &lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x \geqslant \int_{a}^{b} g(x) \mathrm{d} x(a&amp;lt;b),\)&lt;/span>先去证当 &lt;span class="math inline">\(a \leqslant x \leqslant b\)&lt;/span> 时 &lt;span class="math inline">\(f(x) \geqslant g(x),\)&lt;/span> 那么再由积分不等式的性质便有 &lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x \geqslant \int_{a}^{b} g(x) \mathrm{d} x\)&lt;/span> 如果要证的是&lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x&amp;gt;\int_{a}^{b} g(x) \mathrm{d} x(a&amp;lt;b), \text {先去证当 } a \leqslant x \leqslant b \text { 时 } f(x) \text { 与 } g(x)\)&lt;/span>都连续,且 &lt;span class="math inline">\(f(x) \geqslant g(x),\)&lt;/span> 并且至少存在一点 &lt;span class="math inline">\(x_{1} \in[a, b]\)&lt;/span> 使 &lt;span class="math inline">\(f\left(x_{1}\right)&amp;gt;g\left(x_{1}\right),\)&lt;/span> 则由定理 便有 &lt;span class="math inline">\(\int_{a}^{b} f(x) \mathrm{d} x&amp;gt;\int_{a}^{b} g(x) \mathrm{d} x .\)&lt;/span> 考试中常见的是严格不等式情形. (3) 利用积分性质,例如积分中值定理、积分变量代换、分部积分等方法,经变形并计算。 如果一个式子有积分号，一个没有积分号,要比较它们的大小,可以将有积分号的那一个用积分中偵定理化成没有积分号的，或者将没有积分号的套上积分号，在积分号里面比较大小. 有时两个积分的积分区间不一样,那么是否能通过变量代换将它们变成一样，从而比较被积既数的大小等等&lt;/p></description></item><item><title>高等数学-一元积分学-定积分与反常积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 22 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-定积分与反常积分">高等数学-一元积分学-定积分与反常积分&lt;/h1>
&lt;h2 id="定积分与积分函数">定积分与积分函数&lt;/h2>
&lt;h3 id="求定积分">求定积分&lt;/h3>
&lt;h4 id="分部积分法求定积分">分部积分法求定积分&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505174539033.png" alt="" />&lt;figcaption>image-20200505174539033&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505174520659.png" alt="" />&lt;figcaption>image-20200505174520659&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505203737772.png" alt="" />&lt;figcaption>image-20200505203737772&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505203716425.png" alt="" />&lt;figcaption>image-20200505203716425&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505213436150.png" alt="" />&lt;figcaption>image-20200505213436150&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505213413514.png" alt="" />&lt;figcaption>image-20200505213413514&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509233644000.png" alt="" />&lt;figcaption>image-20200509233644000&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509233627415.png" alt="" />&lt;figcaption>image-20200509233627415&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509234405371.png" alt="" />&lt;figcaption>image-20200509234405371&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510013419787.png" alt="" />&lt;figcaption>image-20200510013419787&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510013359350.png" alt="" />&lt;figcaption>image-20200510013359350&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510133450231.png" alt="" />&lt;figcaption>image-20200510133450231&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510133334263.png" alt="" />&lt;figcaption>image-20200510133334263&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510134044574.png" alt="" />&lt;figcaption>image-20200510134044574&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510134017639.png" alt="" />&lt;figcaption>image-20200510134017639&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510134028330.png" alt="" />&lt;figcaption>image-20200510134028330&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510134425063.png" alt="" />&lt;figcaption>image-20200510134425063&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510134414384.png" alt="" />&lt;figcaption>image-20200510134414384&lt;/figcaption>
&lt;/figure>
&lt;h4 id="换元法求定积分">换元法求定积分&lt;/h4>
&lt;h5 id="常规换元法">常规换元法&lt;/h5>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501093018919.png" alt="" />&lt;figcaption>image-20200501093018919&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505120232614.png" alt="" />&lt;figcaption>image-20200505120232614&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505120213021.png" alt="" />&lt;figcaption>image-20200505120213021&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505173436928.png" alt="" />&lt;figcaption>image-20200505173436928&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505173420100.png" alt="" />&lt;figcaption>image-20200505173420100&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505174839095.png" alt="" />&lt;figcaption>image-20200505174839095&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505174820131.png" alt="" />&lt;figcaption>image-20200505174820131&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507205407235.png" alt="" />&lt;figcaption>image-20200507205407235&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507205342154.png" alt="" />&lt;figcaption>image-20200507205342154&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507205356908.png" alt="" />&lt;figcaption>image-20200507205356908&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509125408300.png" alt="" />&lt;figcaption>image-20200509125408300&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509125353858.png" alt="" />&lt;figcaption>image-20200509125353858&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509180150947.png" alt="" />&lt;figcaption>image-20200509180150947&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509180132634.png" alt="" />&lt;figcaption>image-20200509180132634&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509184235605.png" alt="" />&lt;figcaption>image-20200509184235605&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509184250679.png" alt="" />&lt;figcaption>image-20200509184250679&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509190730467.png" alt="" />&lt;figcaption>image-20200509190730467&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509190710787.png" alt="" />&lt;figcaption>image-20200509190710787&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509234556966.png" alt="" />&lt;figcaption>image-20200509234556966&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509234539465.png" alt="" />&lt;figcaption>image-20200509234539465&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510012658277.png" alt="" />&lt;figcaption>image-20200510012658277&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510012645336.png" alt="" />&lt;figcaption>image-20200510012645336&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510013936696.png" alt="" />&lt;figcaption>image-20200510013936696&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510013913701.png" alt="" />&lt;figcaption>image-20200510013913701&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510145312859.png" alt="" />&lt;figcaption>image-20200510145312859&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510145250432.png" alt="" />&lt;figcaption>image-20200510145250432&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510191658265.png" alt="" />&lt;figcaption>image-20200510191658265&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510191637402.png" alt="" />&lt;figcaption>image-20200510191637402&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200802220310984.png" alt="" />&lt;figcaption>image-20200802220310984&lt;/figcaption>
&lt;/figure>
&lt;p>解：换元法：&lt;span class="math inline">\(设t=e^{-2x}\)&lt;/span>，然后设&lt;span class="math inline">\(u=\sqrt{1-t}\)&lt;/span>求解&lt;/p>
&lt;h5 id="对调区间上下限的换元法">对调区间上下限的换元法&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507211013391.png" alt="" />&lt;figcaption>image-20200507211013391&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507210949950.png" alt="" />&lt;figcaption>image-20200507210949950&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430232945553.png" alt="" />&lt;figcaption>image-20200430232945553&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509185502121.png" alt="" />&lt;figcaption>image-20200509185502121&lt;/figcaption>
&lt;/figure>
&lt;p>方法一:递推法&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509185420222.png" alt="" />&lt;figcaption>image-20200509185420222&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509185442267.png" alt="" />&lt;figcaption>image-20200509185442267&lt;/figcaption>
&lt;/figure>
&lt;p>方法二:对调区间上下限的换元&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509185931338.png" alt="" />&lt;figcaption>image-20200509185931338&lt;/figcaption>
&lt;/figure>
&lt;h5 id="倒数的换元法">倒数的换元法&lt;/h5>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510012310077.png" alt="" />&lt;figcaption>image-20200510012310077&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510012335401.png" alt="" />&lt;figcaption>image-20200510012335401&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根据奇偶性和周期性求定积分">根据奇偶性和周期性求定积分&lt;/h4>
&lt;p>根据区间的对称性、函数的奇偶性求定积分；根据函数的周期性求定积分&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425195851248.png" alt="" />&lt;figcaption>image-20200425195851248&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425195907868.png" alt="" />&lt;figcaption>image-20200425195907868&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425200011429.png" alt="" />&lt;figcaption>image-20200425200011429&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425200042282.png" alt="" />&lt;figcaption>image-20200425200042282&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425200727286.png" alt="" />&lt;figcaption>image-20200425200727286&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425200912184.png" alt="" />&lt;figcaption>image-20200425200912184&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425201049310.png" alt="" />&lt;figcaption>image-20200425201049310&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501094621040.png" alt="" />&lt;figcaption>image-20200501094621040&lt;/figcaption>
&lt;/figure>
&lt;p>周期函数,平移上下限后可以使用华里士公式&lt;/p>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505132218887.png" alt="" />&lt;figcaption>image-20200505132218887&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505132237187.png" alt="" />&lt;figcaption>image-20200505132237187&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505172159808.png" alt="" />&lt;figcaption>image-20200505172159808&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505172141865.png" alt="" />&lt;figcaption>image-20200505172141865&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505172713456.png" alt="" />&lt;figcaption>image-20200505172713456&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505172730735.png" alt="" />&lt;figcaption>image-20200505172730735&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505233148850.png" alt="" />&lt;figcaption>image-20200505233148850&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505233134121.png" alt="" />&lt;figcaption>image-20200505233134121&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506223622291.png" alt="" />&lt;figcaption>image-20200506223622291&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506223607048.png" alt="" />&lt;figcaption>image-20200506223607048&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507212530289.png" alt="" />&lt;figcaption>image-20200507212530289&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507212514834.png" alt="" />&lt;figcaption>image-20200507212514834&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508235203625.png" alt="" />&lt;figcaption>image-20200508235203625&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200508235150535.png" alt="" />&lt;figcaption>image-20200508235150535&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-1">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509002557153.png" alt="" />&lt;figcaption>image-20200509002557153&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509002540513.png" alt="" />&lt;figcaption>image-20200509002540513&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-1">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509003149918.png" alt="" />&lt;figcaption>image-20200509003149918&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509003135070.png" alt="" />&lt;figcaption>image-20200509003135070&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-1">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509124036573.png" alt="" />&lt;figcaption>image-20200509124036573&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509124015453.png" alt="" />&lt;figcaption>image-20200509124015453&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15-1">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509172725341.png" alt="" />&lt;figcaption>image-20200509172725341&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509172800420.png" alt="" />&lt;figcaption>image-20200509172800420&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求分段函数的定积分">求分段函数的定积分&lt;/h4>
&lt;p>给f(x)为分段表达式，应按f(x)的分段，分段做定积分；由于积分的上限为x，所以应对x的范围作讨论才能选取分段&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424175709739.png" alt="" />&lt;figcaption>image-20200424175709739&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424175721802.png" alt="" />&lt;figcaption>image-20200424175721802&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424175735297.png" alt="" />&lt;figcaption>image-20200424175735297&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424175812220.png" alt="" />&lt;figcaption>image-20200424175812220&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424180355958.png" alt="" />&lt;figcaption>image-20200424180355958&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507204941040.png" alt="" />&lt;figcaption>image-20200507204941040&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507204923803.png" alt="" />&lt;figcaption>image-20200507204923803&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509004028743.png" alt="" />&lt;figcaption>image-20200509004028743&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509004044765.png" alt="" />&lt;figcaption>image-20200509004044765&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求三角函数的定积分">求三角函数的定积分&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430235449871.png" alt="" />&lt;figcaption>image-20200430235449871&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430235511346.png" alt="" />&lt;figcaption>image-20200430235511346&lt;/figcaption>
&lt;/figure>
&lt;p>此题是&lt;span class="math inline">\(\int_{0}^{\frac{\pi}{2}} f(\sin x) d x=\int_{0}^{\frac{\pi}{2}} f(\cos x) d x\)&lt;/span>的推广&lt;/p>
&lt;p>华里士公式：&lt;span class="math inline">\(I_n = \int_{0}^{\frac{\pi}{2}} \sin ^{n} x \mathrm{d} x=\int_{0}^{\frac{\pi}{2}} \cos ^{n} x \mathrm{d} x=\left\{\begin{array}{lr}\frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdot \cdots \cdot \frac{1}{2} \cdot \frac{\pi}{2}, &amp;amp; \text { 当 } n \text { 为正偶数 } \\ \frac{n-1}{n} \cdot \frac{n-3}{n-2} \cdots \cdots \frac{2}{3} \cdot 1, &amp;amp; \text { 当 } n \text { 为大于 } 1 \text { 的正奇数. }\end{array}\right.\)&lt;/span> 即&lt;span class="math inline">\(\left\{ \begin{aligned} &amp;amp; I_{n}=\frac{n-1}{n} I_{n-2} \\ &amp;amp; I_{0}=\frac{\pi}{2} \\ &amp;amp; I_{1}=1 \end{aligned}\right.\)&lt;/span>&lt;/p>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501092301923.png" alt="" />&lt;figcaption>image-20200501092301923&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501092336466.png" alt="" />&lt;figcaption>image-20200501092336466&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501092736324.png" alt="" />&lt;figcaption>image-20200501092736324&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501092808771.png" alt="" />&lt;figcaption>image-20200501092808771&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505115522887.png" alt="" />&lt;figcaption>image-20200505115522887&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505115456162.png" alt="" />&lt;figcaption>image-20200505115456162&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509175006406.png" alt="" />&lt;figcaption>image-20200509175006406&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509174953807.png" alt="" />&lt;figcaption>image-20200509174953807&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509175651332.png" alt="" />&lt;figcaption>image-20200509175651332&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509175631581.png" alt="" />&lt;figcaption>image-20200509175631581&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509183941294.png" alt="" />&lt;figcaption>image-20200509183941294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509183920776.png" alt="" />&lt;figcaption>image-20200509183920776&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求简单无理分式的定积分">求简单无理分式的定积分&lt;/h4>
&lt;p>定积分化简根式时要保留绝对值。（一般是三角替换的时候）&lt;/p>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425160649010.png" alt="" />&lt;figcaption>image-20200425160649010&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425160811054.png" alt="" />&lt;figcaption>image-20200425160811054&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求含导数或变限函数的积分">求含导数或变限函数的积分&lt;/h4>
&lt;p>带变限函数的积分有两种方法：可以化为2重积分，或者使用分部积分去掉一次积分&lt;/p>
&lt;p>含导数的积分一般使用分部积分求解&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425170539258.png" alt="" />&lt;figcaption>image-20200425170539258&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425170735444.png" alt="" />&lt;figcaption>image-20200425170735444&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425170903289.png" alt="image-20200425170903289" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425170931003.png" alt="image-20200425170931003" />&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425171008232.png" alt="" />&lt;figcaption>image-20200425171008232&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507204158707.png" alt="" />&lt;figcaption>image-20200507204158707&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507204145929.png" alt="" />&lt;figcaption>image-20200507204145929&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求带参带绝对值的定积分">求带参带绝对值的定积分&lt;/h4>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425204136708.png" alt="" />&lt;figcaption>image-20200425204136708&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425204327686.png" alt="" />&lt;figcaption>image-20200425204327686&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根据积分确定函数">根据积分确定函数&lt;/h4>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425214251294.png" alt="" />&lt;figcaption>image-20200425214251294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425214316718.png" alt="" />&lt;figcaption>image-20200425214316718&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425214345234.png" alt="" />&lt;figcaption>image-20200425214345234&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506224601222.png" alt="" />&lt;figcaption>image-20200506224601222&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509225659264.png" alt="" />&lt;figcaption>image-20200509225659264&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509225723752.png" alt="" />&lt;figcaption>image-20200509225723752&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509230510768.png" alt="" />&lt;figcaption>image-20200509230510768&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509230452964.png" alt="" />&lt;figcaption>image-20200509230452964&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求变限积分函数">求变限积分函数&lt;/h3>
&lt;h4 id="求变限积分">求变限积分&lt;/h4>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428205626186.png" alt="" />&lt;figcaption>image-20200428205626186&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428205641229.png" alt="" />&lt;figcaption>image-20200428205641229&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507213233711.png" alt="" />&lt;figcaption>image-20200507213233711&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507213249176.png" alt="" />&lt;figcaption>image-20200507213249176&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求含变限积分的极限">求含变限积分的极限&lt;/h4>
&lt;h3 id="求极限">求极限&lt;/h3>
&lt;h4 id="根据定积分定义求极限">根据定积分定义求极限&lt;/h4>
&lt;p>分子齐次，分母齐次，使用定积分的定义来求极限。&lt;/p>
&lt;p>分子或分母，有一个不齐，使用夹逼定理求极限&lt;/p>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429142647078.png" alt="" />&lt;figcaption>image-20200429142647078&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429142621656.png" alt="" />&lt;figcaption>image-20200429142621656&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505102931991.png" alt="" />&lt;figcaption>image-20200505102931991&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-8">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505110330164.png" alt="" />&lt;figcaption>image-20200505110330164&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505110921571.png" alt="" />&lt;figcaption>image-20200505110921571&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505111019103.png" alt="" />&lt;figcaption>image-20200505111019103&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505111036779.png" alt="" />&lt;figcaption>image-20200505111036779&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求含定积分的极限">求含定积分的极限&lt;/h4>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504125839308.png" alt="" />&lt;figcaption>image-20200504125839308&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504125902625.png" alt="" />&lt;figcaption>image-20200504125902625&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求含变限积分的极限-1">求含变限积分的极限&lt;/h4>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215012136.png" alt="" />&lt;figcaption>image-20200429215012136&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429220650314.png" alt="" />&lt;figcaption>image-20200429220650314&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215935760.png" alt="" />&lt;figcaption>image-20200429215935760&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429220414426.png" alt="" />&lt;figcaption>image-20200429220414426&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429220538054.png" alt="" />&lt;figcaption>image-20200429220538054&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-9">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426111557065.png" alt="" />&lt;figcaption>image-20200426111557065&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426111619610.png" alt="" />&lt;figcaption>image-20200426111619610&lt;/figcaption>
&lt;/figure>
&lt;h3 id="变限积分求参数">变限积分求参数&lt;/h3>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505230312876.png" alt="" />&lt;figcaption>image-20200505230312876&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505230254929.png" alt="" />&lt;figcaption>image-20200505230254929&lt;/figcaption>
&lt;/figure>
&lt;h3 id="变限积分函数求导数">变限积分函数求导数&lt;/h3>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215351533.png" alt="" />&lt;figcaption>image-20200429215351533&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215514607.png" alt="" />&lt;figcaption>image-20200429215514607&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215639710.png" alt="" />&lt;figcaption>image-20200429215639710&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215728699.png" alt="" />&lt;figcaption>image-20200429215728699&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200429215757984.png" alt="" />&lt;figcaption>image-20200429215757984&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-10">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505111703408.png" alt="" />&lt;figcaption>image-20200505111703408&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505111848595.png" alt="" />&lt;figcaption>image-20200505111848595&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-6">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505112312751.png" alt="" />&lt;figcaption>image-20200505112312751&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505112339949.png" alt="" />&lt;figcaption>image-20200505112339949&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505223848937.png" alt="" />&lt;figcaption>image-20200505223848937&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505223807075.png" alt="" />&lt;figcaption>image-20200505223807075&lt;/figcaption>
&lt;/figure>
&lt;h3 id="变限积分函数求最值">变限积分函数求最值&lt;/h3>
&lt;h6 id="例1-17">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510141142460.png" alt="" />&lt;figcaption>image-20200510141142460&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510141215381.png" alt="" />&lt;figcaption>image-20200510141215381&lt;/figcaption>
&lt;/figure>
&lt;h3 id="定积分与原函数的存在性判断">定积分与原函数的存在性判断&lt;/h3>
&lt;h6 id="例1-18">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424182040243.png" alt="" />&lt;figcaption>image-20200424182040243&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424182050910.png" alt="" />&lt;figcaption>image-20200424182050910&lt;/figcaption>
&lt;/figure>
&lt;p>函数存在原函数的前提条件是要连续。虽然不连续，但是只有有限个间断点，这样的函数是可积的（可以拆成几个连续的区间）。是否可导可根据定义或者左右导数存在且相等来看。&lt;/p>
&lt;h3 id="证明题">证明题&lt;/h3>
&lt;h4 id="求证存在xi使等式成立">求证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h4>
&lt;h5 id="零点定理求证存在xi使等式成立">零点定理求证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h5>
&lt;h6 id="例1-19">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510221201914.png" alt="" />&lt;figcaption>image-20200510221201914&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510221255498.png" alt="" />&lt;figcaption>image-20200510221255498&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510221309501.png" alt="" />&lt;figcaption>image-20200510221309501&lt;/figcaption>
&lt;/figure>
&lt;h5 id="罗尔定理求证存在xi使等式成立">罗尔定理求证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h5>
&lt;h6 id="例1-20">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511014833900.png" alt="" />&lt;figcaption>image-20200511014833900&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511014809787.png" alt="" />&lt;figcaption>image-20200511014809787&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-12">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511123840292.png" alt="" />&lt;figcaption>image-20200511123840292&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511123902861.png" alt="" />&lt;figcaption>image-20200511123902861&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511123917597.png" alt="" />&lt;figcaption>image-20200511123917597&lt;/figcaption>
&lt;/figure>
&lt;h5 id="泰勒公式证明存在xi使等式成立">泰勒公式证明存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h5>
&lt;h6 id="例1-21">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511111541173.png" alt="" />&lt;figcaption>image-20200511111541173&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511111554982.png" alt="" />&lt;figcaption>image-20200511111554982&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511111512554.png" alt="" />&lt;figcaption>image-20200511111512554&lt;/figcaption>
&lt;/figure>
&lt;h5 id="积分中值定理求证存在xi使等式成立">积分中值定理求证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h5>
&lt;h6 id="例1-22">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430141326453.png" alt="" />&lt;figcaption>image-20200430141326453&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430141427456.png" alt="" />&lt;figcaption>image-20200430141427456&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-13">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511013829484.png" alt="" />&lt;figcaption>image-20200511013829484&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511013919605.png" alt="" />&lt;figcaption>image-20200511013919605&lt;/figcaption>
&lt;/figure>
&lt;h5 id="变限积分函数证存在xi使等式成立">变限积分函数证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h5>
&lt;p>注意,如果要证明的是&lt;strong>开区间&lt;/strong>内存在点,使等式成立,则&lt;strong>不能使用积分中值定理&lt;/strong>.积分中值定理的结论是闭区间内存在点,满足条件&lt;/p>
&lt;p>要证明的是&lt;strong>开区间&lt;/strong>内存在点,使等式成立,应设变限积分函数来证.&lt;/p>
&lt;p>积分中值定理有开区间和闭区间两种题目，开区间的话用到的结论是积分中值定理的推广，要写过程，用拉格朗日证明，所以要写出变上限积分，在原函数之一的基础上进行拉格朗日证明，和拉格朗日一样最后取到开区间；闭区间的话就是积分中值定理本身，不用写出证明过程，但是本身证明用的是介值定理，所以积分中值定理本身是闭区间&lt;/p>
&lt;p>问的是开区间不是拉格朗日就是罗尔，就看已知几个相等&lt;/p>
&lt;h6 id="例1-23">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430174706147.png" alt="" />&lt;figcaption>image-20200430174706147&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430174749009.png" alt="" />&lt;figcaption>image-20200430174749009&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-14">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430174919420.png" alt="" />&lt;figcaption>image-20200430174919420&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430175356555.png" alt="" />&lt;figcaption>image-20200430175356555&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200430175426160.png" alt="" />&lt;figcaption>image-20200430175426160&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-11">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504163758884.png" alt="" />&lt;figcaption>image-20200504163758884&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-7">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504164731885.png" alt="" />&lt;figcaption>image-20200504164731885&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504164804525.png" alt="" />&lt;figcaption>image-20200504164804525&lt;/figcaption>
&lt;/figure>
&lt;h4 id="变限积分及其导数的奇偶性周期性">变限积分及其导数的奇偶性、周期性&lt;/h4>
&lt;p>由F（x）的奇偶性，周期性推断∫（x）的相应性质，用到微分学的性质； 反过来，由f（x）的奇偶性、周期性，推断F（x）的相应性质，可能会想到用不定积分，但是不定积分只能用来作为运算，不能用来讨论性质，应该用变上限函数来表示f（x）的某个原函数，用它来讨论原函数的性质&lt;/p>
&lt;p>结论：&lt;/p>
&lt;p>f-&amp;gt;F&lt;/p>
&lt;p>奇函数的（变上限）积分是偶函数；偶函数仅当从0开始的（变上限）积分是奇函数。&lt;/p>
&lt;p>F-&amp;gt;f&lt;/p>
&lt;p>原函数是奇函数，求导是偶函数；原函数是偶函数，求导是奇函数。&lt;/p>
&lt;h6 id="例1-24">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424215428629.png" alt="" />&lt;figcaption>image-20200424215428629&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424215618577.png" alt="" />&lt;figcaption>image-20200424215618577&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424215700314.png" alt="" />&lt;figcaption>image-20200424215700314&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-15">例2&lt;/h6>
&lt;figure>
&lt;img src="C:\Users\wangjm\OneDrive\桌面\image-20200424223926507.png" alt="" />&lt;figcaption>image-20200424223926507&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424223950028.png" alt="" />&lt;figcaption>image-20200424223950028&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-12">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424225752880.png" alt="" />&lt;figcaption>image-20200424225752880&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424225852799.png" alt="" />&lt;figcaption>image-20200424225852799&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424225911997.png" alt="" />&lt;figcaption>image-20200424225911997&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-8">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427101432005.png" alt="" />&lt;figcaption>image-20200427101432005&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427101450255.png" alt="" />&lt;figcaption>image-20200427101450255&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504104940202.png" alt="" />&lt;figcaption>image-20200504104940202&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-5">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509000710875.png" alt="" />&lt;figcaption>image-20200509000710875&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509000737551.png" alt="" />&lt;figcaption>image-20200509000737551&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200509000753598.png" alt="" />&lt;figcaption>image-20200509000753598&lt;/figcaption>
&lt;/figure>
&lt;h4 id="积分等式的证明">积分等式的证明&lt;/h4>
&lt;h6 id="例1-25">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510225004805.png" alt="" />&lt;figcaption>image-20200510225004805&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510224940666.png" alt="" />&lt;figcaption>image-20200510224940666&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-16">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510225603029.png" alt="" />&lt;figcaption>image-20200510225603029&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510225620713.png" alt="" />&lt;figcaption>image-20200510225620713&lt;/figcaption>
&lt;/figure>
&lt;h4 id="积分不等式的证明">积分不等式的证明&lt;/h4>
&lt;h5 id="积分的比较">积分的比较&lt;/h5>
&lt;h6 id="例1-26">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504143955475.png" alt="" />&lt;figcaption>image-20200504143955475&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504144013098.png" alt="" />&lt;figcaption>image-20200504144013098&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-17">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507223643082.png" alt="" />&lt;figcaption>image-20200507223643082&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507223628241.png" alt="" />&lt;figcaption>image-20200507223628241&lt;/figcaption>
&lt;/figure>
&lt;h5 id="变限积分函数单调性与单调区间的判断">变限积分函数单调性与单调区间的判断&lt;/h5>
&lt;p>一个带积分号的函数,和另一个不带积分号的函数的比较,有两种办法:&lt;/p>
&lt;ul>
&lt;li>用积分中值定理,将有积分号的化为无积分号的&lt;/li>
&lt;li>将没有积分号的套上积分号&lt;/li>
&lt;/ul>
&lt;h6 id="例1-27">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504110936361.png" alt="" />&lt;figcaption>image-20200504110936361&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504111046496.png" alt="" />&lt;figcaption>image-20200504111046496&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-18">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504124342111.png" alt="" />&lt;figcaption>image-20200504124342111&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504124357499.png" alt="" />&lt;figcaption>image-20200504124357499&lt;/figcaption>
&lt;/figure>
&lt;h5 id="积分不等式的证明-1">积分不等式的证明&lt;/h5>
&lt;h6 id="例1-28">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504145425744.png" alt="" />&lt;figcaption>image-20200504145425744&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504150244730.png" alt="" />&lt;figcaption>image-20200504150244730&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-19">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504154100792.png" alt="" />&lt;figcaption>image-20200504154100792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504154136239.png" alt="" />&lt;figcaption>image-20200504154136239&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-13">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504154759276.png" alt="" />&lt;figcaption>image-20200504154759276&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504154825522.png" alt="" />&lt;figcaption>image-20200504154825522&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-9">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504160007620.png" alt="" />&lt;figcaption>image-20200504160007620&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504160040511.png" alt="" />&lt;figcaption>image-20200504160040511&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-6">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504161121914.png" alt="" />&lt;figcaption>image-20200504161121914&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510232253632.png" alt="" />&lt;figcaption>image-20200510232253632&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510232231492.png" alt="" />&lt;figcaption>image-20200510232231492&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-4">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510234624546.png" alt="" />&lt;figcaption>image-20200510234624546&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510234640199.png" alt="" />&lt;figcaption>image-20200510234640199&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-3">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511100711240.png" alt="" />&lt;figcaption>image-20200511100711240&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511100733936.png" alt="" />&lt;figcaption>image-20200511100733936&lt;/figcaption>
&lt;/figure>
&lt;h4 id="零点问题">零点问题&lt;/h4>
&lt;p>零点问题,或者方程根的讨论&lt;/p>
&lt;p>与微分学中类似，定积分与变限积分中也有零点问题处理的办法&lt;/p>
&lt;ul>
&lt;li>一是化成变限积分看成变限的函数，用微分学中讲到的办法&lt;/li>
&lt;li>二是利用积分中值定理&lt;/li>
&lt;/ul>
&lt;h6 id="例1-29">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504162619158.png" alt="" />&lt;figcaption>image-20200504162619158&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200504162750994.png" alt="" />&lt;figcaption>image-20200504162750994&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-20">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511103949174.png" alt="" />&lt;figcaption>image-20200511103949174&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200511103919010.png" alt="" />&lt;figcaption>image-20200511103919010&lt;/figcaption>
&lt;/figure>
&lt;h2 id="反常积分">反常积分&lt;/h2>
&lt;h3 id="反常积分的识别">反常积分的识别&lt;/h3>
&lt;p>区间无限的反常积分:只要一看积分限有&lt;span class="math inline">\(\infty\)&lt;/span>,便知这是无穷区间上的反常积分&lt;/p>
&lt;p>无界函数的反常积分:般是看被积函数是否有使其分母为零的点。但这句话既不充分也不必要.&lt;/p>
&lt;h6 id="例1-30">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502145214971.png" alt="" />&lt;figcaption>image-20200502145214971&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-21">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502154159635.png" alt="" />&lt;figcaption>image-20200502154159635&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502154359833.png" alt="" />&lt;figcaption>image-20200502154359833&lt;/figcaption>
&lt;/figure>
&lt;h3 id="反常积分的判敛及求解">反常积分的判敛及求解&lt;/h3>
&lt;h4 id="通过计算来求解及判敛">通过计算来求解及判敛&lt;/h4>
&lt;h6 id="例1-31">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501120330982.png" alt="" />&lt;figcaption>image-20200501120330982&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-22">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501121826206.png" alt="" />&lt;figcaption>image-20200501121826206&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-14">例3&lt;/h6>
&lt;p>要想对无穷积分使用定积分在对称区间上的性质,首先要满足无穷积分收敛才行.&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501144412584.png" alt="" />&lt;figcaption>image-20200501144412584&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501144608412.png" alt="" />&lt;figcaption>image-20200501144608412&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-10">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501154831152.png" alt="" />&lt;figcaption>image-20200501154831152&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501155011607.png" alt="" />&lt;figcaption>image-20200501155011607&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-7">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501164436569.png" alt="" />&lt;figcaption>image-20200501164436569&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501164507820.png" alt="" />&lt;figcaption>image-20200501164507820&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-7">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501165744990.png" alt="" />&lt;figcaption>image-20200501165744990&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-5">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501170807882.png" alt="" />&lt;figcaption>image-20200501170807882&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501170846361.png" alt="" />&lt;figcaption>image-20200501170846361&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-4">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502150424446.png" alt="" />&lt;figcaption>image-20200502150424446&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502150445088.png" alt="" />&lt;figcaption>image-20200502150445088&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502152321698.png" alt="" />&lt;figcaption>image-20200502152321698&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502152337084.png" alt="" />&lt;figcaption>image-20200502152337084&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502152401169.png" alt="" />&lt;figcaption>image-20200502152401169&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502152856398.png" alt="" />&lt;figcaption>image-20200502152856398&lt;/figcaption>
&lt;/figure>
&lt;p>通过计算这两个积分可知都收敛,答案选A&lt;/p>
&lt;h6 id="例11-2">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502164823294.png" alt="" />&lt;figcaption>image-20200502164823294&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502164928490.png" alt="" />&lt;figcaption>image-20200502164928490&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-2">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502165257454.png" alt="" />&lt;figcaption>image-20200502165257454&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502165332642.png" alt="" />&lt;figcaption>image-20200502165332642&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502165500948.png" alt="" />&lt;figcaption>image-20200502165500948&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-2">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507211941551.png" alt="" />&lt;figcaption>image-20200507211941551&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507211930458.png" alt="" />&lt;figcaption>image-20200507211930458&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-2">例14&lt;/h6>
&lt;figure>
&lt;img src="upload\image-20200507212202476.png" alt="" />&lt;figcaption>image-20200507212202476&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507212127935.png" alt="" />&lt;figcaption>image-20200507212127935&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15-2">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510220037563.png" alt="" />&lt;figcaption>image-20200510220037563&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200510220022094.png" alt="" />&lt;figcaption>image-20200510220022094&lt;/figcaption>
&lt;/figure>
&lt;h4 id="反常积分的非计算判敛方式审敛">反常积分的非计算判敛方式(审敛)&lt;/h4>
&lt;h6 id="例1-32">例1&lt;/h6>
&lt;p>此题没弄懂.//TODO&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502215006231.png" alt="" />&lt;figcaption>image-20200502215006231&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502215107748.png" alt="" />&lt;figcaption>image-20200502215107748&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200502215343444.png" alt="" />&lt;figcaption>image-20200502215343444&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-23">例2&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{1}^{+\infty} \frac{d x}{\sqrt[3]{x^{4}+1}}\)&lt;/span> 的收敛性. 解 &lt;span class="math inline">\(\because\)&lt;/span>当 &lt;span class="math inline">\(x \in[1,+\infty)\)&lt;/span> 时 &lt;span class="math inline">\(0&amp;lt;\frac{1}{\sqrt[3]{x^{4}+1}}&amp;lt;\frac{1}{\sqrt[3]{x^{4}}}=\frac{1}{x^{4 / 3}}, p=\frac{4}{3}&amp;gt;1\)&lt;/span> &lt;span class="math inline">\(\therefore\)&lt;/span> 反常积分 &lt;span class="math inline">\(\int_{1}^{+\infty} \frac{d x}{\sqrt[3]{x^{4}+1}}\)&lt;/span> 收敛.&lt;/p>
&lt;h6 id="例3-15">例3&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{1}^{+\infty} \frac{d x}{x \sqrt{1+x^{2}}}\)&lt;/span> 的收敛性. 解 &lt;span class="math inline">\(\quad \because \lim _{x \rightarrow+\infty} x^{2} \cdot \frac{1}{x \sqrt{1+x^{2}}}=1, \quad p=2&amp;gt;1\)&lt;/span> &lt;span class="math inline">\(\therefore\)&lt;/span> 所给反常积分收敛.(极限审敛法1)&lt;/p>
&lt;h6 id="例4-11">例4&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{1}^{+\infty} \frac{x^{3 / 2}}{1+x^{2}} d x\)&lt;/span> 的收敛性 &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x \frac{x^{3 / 2}}{1+x^{2}}=\lim _{x \rightarrow+\infty} \frac{x^{2} \sqrt{x}}{1+x^{2}}=+\infty\)&lt;/span> 所给反常积分发散.（极限审敛法 1）&lt;/p>
&lt;h6 id="例5-8">例5&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{1}^{+\infty} \frac{\arctan x}{x} d x\)&lt;/span> 的收敛性. 解 &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x \frac{\arctan x}{x}=\lim _{x \rightarrow+\infty} \arctan x=\frac{\pi}{2}&amp;gt;0\)&lt;/span> &lt;span class="math inline">\(\therefore\)&lt;/span> 所给反常积分发散.(极限审敘法 1）&lt;/p>
&lt;h6 id="例6-8">例6&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{0}^{+\infty} e^{-a x} \sin b x d x(a, b\)&lt;/span> 都是常数 a &amp;gt; 0) 的收敛性. 解 &lt;span class="math inline">\(\quad \because | e^{-a x} \sin b x | \leq e^{-a x},\)&lt;/span> 而 &lt;span class="math inline">\(\int_{0}^{+\infty} e^{-a x} d x\)&lt;/span> 收敘. &lt;span class="math inline">\(\left[\because \int_{0}^{+\infty} e^{-a x} d x=\left[-\frac{1}{a} e^{-a x}\right]_{0}^{+\infty}=0-\left(-\frac{1}{a}\right)=\frac{1}{a} \right]\)&lt;/span> &lt;span class="math inline">\(\therefore \int_{0}^{+\infty} |e^{-a x} \sin b x| d x\)&lt;/span> 收敛. &lt;span class="math inline">\(\quad(\text { 比较审敛法 } 1)\)&lt;/span> &lt;span class="math inline">\(\therefore \int_{0}^{+\infty} e^{-a x} \sin b x d x\)&lt;/span> 收敛&lt;/p>
&lt;h6 id="例7-6">例7&lt;/h6>
&lt;p>&lt;span class="math inline">\(\quad\)&lt;/span>判别反常积分 &lt;span class="math inline">\(\int_{1}^{3} \frac{d x}{\ln x}\)&lt;/span> 的收敛性. 解 &lt;span class="math inline">\(\quad \because \lim _{x \rightarrow 1^{+}} \frac{1}{\ln x}=+\infty \quad \therefore x=1\)&lt;/span> 是瑕点 &lt;span class="math inline">\(\lim _{x \rightarrow 1^{+}}(x-1) \frac{1}{\ln x}=\lim _{x \rightarrow 1^{+}} \frac{x-1}{\ln x} \quad\left(\frac{0}{0}\right)=\)&lt;/span> &lt;span class="math inline">\(=\lim _{x \rightarrow 1^{+}} \frac{1}{\frac{1}{n}}(\text { 洛必达法则 })\)&lt;/span> &lt;span class="math inline">\(\begin{aligned} &amp;amp;=1&amp;gt;0 \end{aligned}\)&lt;/span> ：反常积分&lt;span class="math inline">\(\int_{1}^{3} \frac{d x}{\ln x}\)&lt;/span> 发散. (极限审敛法2)&lt;/p>
&lt;h6 id="例8-5">例8&lt;/h6>
&lt;p>&lt;span class="math inline">\(\begin{aligned} &amp;amp;\begin{array}{l} \text {判别椭圆积分 } \int_{0}^{1} \frac{1}{\sqrt{\left(1-x^{2}\right)\left(1-k^{2} x^{2}\right)}} d x \text { 的收敛性 } \\ \text { 这里 }|k|&amp;lt;1 \end{array}\\ &amp;amp;\because \lim _{x \rightarrow 1^{-}} \frac{1}{\sqrt{\left(1-x^{2}\right)\left(1-k^{2} x^{2}\right)}}=+\infty \quad \therefore x=1 \text { 是瑕点 }\\ &amp;amp;\because \lim _{x \rightarrow 1^{-}}(1-x)^{\frac{1}{2}} \frac{1}{\sqrt{\left(1-x^{2}\right)\left(1-k^{2} x^{2}\right)}}\\ &amp;amp;=\lim _{x \rightarrow 1^{-}} \frac{1}{\sqrt{(1+x)\left(1-k^{2} x^{2}\right)}}=\frac{1}{\sqrt{2\left(1-k^{2}\right)}}, q=\frac{1}{2}&amp;lt;1\\ &amp;amp;\therefore \int_{0}^{1} \frac{1}{\sqrt{\left(1-x^{2}\right)\left(1-k^{2} x^{2}\right)}} d x \text { 收敘. } \quad(\text { 极限审敛法2 }) \end{aligned}\)&lt;/span>&lt;/p>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;p>判别反常积分 &lt;span class="math inline">\(\int_{0}^{1} \frac{\sin \frac{1}{x}}{\sqrt{x}} d x\)&lt;/span> 的收敛性. 解 &lt;span class="math inline">\(\sin \frac{1}{x}\)&lt;/span> 在0的右半邻域内无界 &lt;span class="math inline">\(\therefore x=0\)&lt;/span> 是瑕点 &lt;span class="math inline">\(\because |\frac{\sin \frac{1}{x}}{\sqrt{x}} | \leq \frac{1}{\sqrt{x}},\)&lt;/span> 而 &lt;span class="math inline">\(\int_{0}^{1} \frac{d x}{\sqrt{x}}\)&lt;/span> 收敛, &lt;span class="math inline">\(\left[\because q=\frac{1}{2}&amp;lt;1\right]\)&lt;/span> &lt;span class="math inline">\(\therefore \int_{0}^{1} \frac{\sin \frac{1}{x}}{\sqrt{x}} d x\)&lt;/span> 收敛 &lt;span class="math inline">\((\text { 比较审敛法2 }) \therefore \int_{0}^{1}| \frac{\sin \frac{1}{x}}{\sqrt{x}}| d x\)&lt;/span> 也收敛&lt;/p>
&lt;h6 id="例10-3">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505212923220.png" alt="" />&lt;figcaption>image-20200505212923220&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200505212905286.png" alt="" />&lt;figcaption>image-20200505212905286&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-3">例11&lt;/h6>
&lt;p>首先是要审敛，要发现这是个反常积分。&lt;/p>
&lt;p>这里有四种方法，换元法，分部积分法，分子有理化，1的代换。都可以做出来，亮瞎眼。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506221426667.png" alt="" />&lt;figcaption>image-20200506221426667&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506221400129.png" alt="" />&lt;figcaption>image-20200506221400129&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200506221505554.png" alt="" />&lt;figcaption>image-20200506221505554&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-3">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507220002606.png" alt="" />&lt;figcaption>image-20200507220002606&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507220021255.png" alt="" />&lt;figcaption>image-20200507220021255&lt;/figcaption>
&lt;/figure>
&lt;h3 id="对泊松型积分和gamma函数的求解">对泊松型积分和&lt;span class="math inline">\(\Gamma\)&lt;/span>函数的求解&lt;/h3>
&lt;h6 id="例1-33">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501172046918.png" alt="" />&lt;figcaption>image-20200501172046918&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-24">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501172215649.png" alt="" />&lt;figcaption>image-20200501172215649&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-16">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501172300920.png" alt="" />&lt;figcaption>image-20200501172300920&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200501172328633.png" alt="" />&lt;figcaption>image-20200501172328633&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-12">例4&lt;/h6>
&lt;p>求 &lt;span class="math inline">\(\Gamma\left(\frac{7}{2}\right)\)&lt;/span> 解 由递推公式得： &lt;span class="math inline">\(\begin{aligned} \Gamma\left(\frac{7}{2}\right) &amp;amp;=\frac{5}{2} \cdot \Gamma\left(\frac{5}{2}\right) \\ &amp;amp;=\frac{5}{2} \cdot \frac{3}{2} \cdot \Gamma\left(\frac{3}{2}\right) \\ &amp;amp;=\frac{5}{2} \cdot \frac{3}{2} \cdot \frac{1}{2} \Gamma\left(\frac{1}{2}\right) \\ &amp;amp;=\frac{5}{2} \cdot \frac{3}{2} \cdot \frac{1}{2} \sqrt{\pi}=\frac{15}{8} \sqrt{\pi} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h6 id="例5-9">例5&lt;/h6>
&lt;p>用&lt;span class="math inline">\(\Gamma\)&lt;/span>函数表示积分 &lt;span class="math inline">\(\int_{0}^{+\infty} e^{-x^{4}} d x\)&lt;/span>&lt;/p>
&lt;p>解 &lt;span class="math inline">\(\quad \int_{0}^{+\infty} e^{-x^{4}} d x \overset{\text {令 } t=x^{4}}{=} \quad \int_{0}^{+\infty} e^{-t} \frac{1}{4} t^{-\frac{3}{4}} d t\)&lt;/span> &lt;span class="math inline">\(=\frac{1}{4} \int_{0}^{+\infty} e^{-t} t^{-\frac{3}{4}} d t\)&lt;/span> &lt;span class="math inline">\(=\frac{1}{4} \int_{0}^{+\infty} e^{-t} t^{\frac{1}{4}-1} d t\)&lt;/span> &lt;span class="math inline">\(=\frac{1}{4} \Gamma\left(\frac{1}{4}\right)\)&lt;/span>&lt;/p>
&lt;h6 id="例6-9">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507211455308.png" alt="" />&lt;figcaption>image-20200507211455308&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200507211544804.png" alt="" />&lt;figcaption>image-20200507211544804&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元积分学-不定积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</link><pubDate>Fri, 20 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-不定积分">高等数学-一元积分学-不定积分&lt;/h1>
&lt;h2 id="不定积分">不定积分&lt;/h2>
&lt;h3 id="概念与性质">概念与性质&lt;/h3>
&lt;h4 id="原函数">原函数&lt;/h4>
&lt;p>&lt;strong>原函数&lt;/strong>：如果&lt;span class="math inline">\(F^{\prime}(x)=f(x)\)&lt;/span>，则&lt;span class="math inline">\(F(x)\)&lt;/span>是&lt;span class="math inline">\(f(x)\)&lt;/span>的原函数。&lt;/p>
&lt;p>如果&lt;span class="math inline">\(f(x)\)&lt;/span>存在原函数，则存在无穷多个原函数，且任意两个原函数相差常数。&lt;/p>
&lt;p>&lt;strong>原函数存在定理&lt;/strong>：连续函数一定存在原函数&lt;/p>
&lt;h4 id="不定积分-1">不定积分&lt;/h4>
&lt;p>不定积分，即一个函数的原函数，包括它的所有原函数，即&lt;span class="math inline">\(\int f(x) d x=F(x)+c\)&lt;/span>&lt;/p>
&lt;h5 id="不定积分性质">不定积分性质&lt;/h5>
&lt;p>以下在&lt;span class="math inline">\(f(x)\)&lt;/span>连续的前提下&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(\int f(x) \mathrm{d} x\right)^{\prime}=f(x) ; \mathrm{d} \int f(x) \mathrm{d} x=f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int f^{\prime}(x) \mathrm{d} x=f(x)+C_{;} \int \mathrm{d} f(x)=f(x)+C\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int(f(x) \pm g(x)) \mathrm{d} x=\int f(x) \mathrm{d} x \pm \int g(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int k f(x) \mathrm{d} x=k \int f(x) \mathrm{d} x,\)&lt;/span> 常数 &lt;span class="math inline">\(k \neq 0\)&lt;/span>&lt;/p>
&lt;h3 id="不定积分工具">不定积分工具&lt;/h3>
&lt;h4 id="基本公式">基本公式&lt;/h4>
&lt;p>&lt;span class="math inline">\(\int k d x=k x+C\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int x^{a} d x=\left\{\begin{array}{ll} \frac{1}{a+1} \cdot x ^{a+1} &amp;amp; ,&amp;amp; a\neq -1\\ \ln |x|+c &amp;amp; , &amp;amp; a=-1\end{array}\right.\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int a^{x} d x=\frac{a^{x}}{\ln a}+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int e^{x} d x=e^{x}+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \sin x d x=-\cos x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \cos x d x=\sin x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \tan x d x=-\ln |\cos x|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \cot x d x=\ln |\sin x|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \sec x d x=\ln |\sec x+\tan x|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \csc x d x=\ln |\csc x-\cot x|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \sec ^{2} x d x=\tan x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \csc ^{2} x d x=-\cot x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \sec x \tan x d x=\sec x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \csc x \cot x d x=-\csc x+c\)&lt;/span>&lt;/p>
&lt;h4 id="平方和平方差公式">平方和平方差公式&lt;/h4>
&lt;p>&lt;span class="math inline">\(\int \frac{d x}{\sqrt{1-x^{2}}}=\arcsin x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{d x}{\sqrt{a^{2}-x^{2}}}=\arcsin \frac{x}{a}+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{1}{1+x^{2}} d x=\arctan x+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{1}{a^{2}+x^{2}} d x=\frac{1}{a} \arctan \frac{x}{a}+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{1}{\sqrt{x^{2}+a^{2}}} d x=\ln (x+\sqrt{x^{2}+a^{2}})+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{1}{\sqrt{x^{2}-a^{2}}} d x=\ln |x+\sqrt{x^{2}-a^{2}}|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \frac{1}{x^{2}-a^{2}} d x=\frac{1}{2 a} \ln \left|\frac{x-a}{x+a}\right|+c\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\int \sqrt{a^{2}-x^{2}} d x=\frac{a^{2}}{2} \arcsin \frac{x}{a}+\frac{1}{2} x \sqrt{a^{2}-x^{2}}+c\)&lt;/span>&lt;/p>
&lt;h4 id="换元积分法">换元积分法&lt;/h4>
&lt;h5 id="第一类换元积分法">第一类换元积分法&lt;/h5>
&lt;p>如下面所示的换元积分过程，即为第一类换元积分法&lt;/p>
&lt;p>&lt;span class="math inline">\(\int f[\varphi(x)] \varphi^{\prime}(x) d x=\int f[\varphi(x)] d \varphi(a)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\overset{\varphi(x)=t}{=} \quad \int f(t) d t=F(t)+c=F[\varphi(x)]+c\)&lt;/span>&lt;/p>
&lt;h5 id="第二类换元积分法">第二类换元积分法&lt;/h5>
&lt;h6 id="无理转有理不一定需要">无理转有理（不一定需要）&lt;/h6>
&lt;ul>
&lt;li>&lt;span class="math inline">\(\int R(x, \sqrt[n]{a x+b}, \sqrt[m]{a x+b}) \mathrm{d} x\)&lt;/span> 型 &lt;span class="math inline">\(, a \neq 0\)&lt;/span>。 命 &lt;span class="math inline">\(\sqrt[mn]{a x+b}=t, x=\frac{t^{m n}-b}{a}, \mathrm{d} x=\frac{m n}{a} t^{m n-1} \mathrm{d} t\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math inline">\(\int R(x, \sqrt{\frac{a x+b}{c x+d}}) \mathrm{d} x\)&lt;/span> 型 命 &lt;span class="math inline">\(\sqrt{\frac{a x+b}{c x+d}}=t, x=\frac{d t^{2}-b}{a-c t^{2}}, \mathrm{d} x=\frac{2(a d-b c) t}{\left(a-c t^{2}\right)^{2}} \mathrm{d} t .\)&lt;/span> 其中设 &lt;span class="math inline">\(a d-b c \neq 0\)&lt;/span>&lt;/li>
&lt;li>&lt;span class="math inline">\(\int R(\sin x, \cos x) \mathrm{d} x\)&lt;/span> 型 命 &lt;span class="math inline">\(\tan \frac{x}{2}=t,\)&lt;/span> 则 &lt;span class="math inline">\(\sin x=\frac{2 t}{1+t^{2}}, \cos x=\frac{1-t^{2}}{1+t^{2}}, \mathrm{d} x=\frac{2}{1+t^{2}} \mathrm{d} t .\)&lt;/span> 此称万能代换,非到不得己时不用.&lt;/li>
&lt;/ul>
&lt;h6 id="平方和差的三角替换">平方和差的三角替换&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103154569.png" alt="image-20200423103154569" style="zoom: 50%;" />&lt;/p>
&lt;h4 id="分部积分法">分部积分法&lt;/h4>
&lt;p>&lt;span class="math inline">\((u v)^{\prime}=u^{\prime} v+u v^{\prime}\)&lt;/span> &lt;span class="math inline">\(u v=\int v d u+\int u d v\)&lt;/span> &lt;span class="math inline">\(\int u d v=u v-\int v d u\)&lt;/span>&lt;/p>
&lt;h5 id="幂函数指数函数的积分int-xn-cdot-ex-d-x">幂函数*指数函数的积分&lt;span class="math inline">\(\int x^{n} \cdot e^{x} d x\)&lt;/span>&lt;/h5>
&lt;h5 id="幂函数对数函数的积分int-xn-cdot-ln-x-d-x">幂函数*对数函数的积分&lt;span class="math inline">\(\int x^{n} \cdot \ln x d x\)&lt;/span>&lt;/h5>
&lt;h5 id="幂函数三角函数的积分int-xn-cdot-三角函数-d-x">幂函数*三角函数的积分&lt;span class="math inline">\(\int x^{n} \cdot 三角函数 d x\)&lt;/span>&lt;/h5>
&lt;h5 id="幂函数反三角函数的积分int-xn-cdot-反三角函数-d-x">幂函数*反三角函数的积分&lt;span class="math inline">\(\int x^{n} \cdot 反三角函数 d x\)&lt;/span>&lt;/h5>
&lt;h5 id="指数函数正余弦函数的积分int-ea-x-timesleftbeginarraylcos-b-x-sin-b-xendarray-d-xright.">指数函数*正余弦函数的积分&lt;span class="math inline">\(\int e^{a x} \times\left\{\begin{array}{l}\cos b x \\ \sin b x\end{array} d x\right.\)&lt;/span>&lt;/h5>
&lt;h5 id="正余弦倒数的n次幂的积分奇次幂">正余弦倒数的n次幂的积分（奇次幂）&lt;/h5>
&lt;h4 id="特殊积分类型">特殊积分类型&lt;/h4>
&lt;h5 id="有理分式int-rx-d-x的积分">有理分式&lt;span class="math inline">\(\int R(x) d x\)&lt;/span>的积分&lt;/h5>
&lt;p>其中&lt;span class="math inline">\(R(x)=\frac{P(x)}{a(x)}\)&lt;/span>，而P(x)和Q(x)为多项式&lt;/p>
&lt;p>如果P的次数小于于Q的次数，称其为真分式； 如果P的次数大于等于Q的次数，称其为假分式&lt;/p>
&lt;h6 id="rx为假分式">&lt;span class="math inline">\(R(x)\)&lt;/span>为假分式&lt;/h6>
&lt;p>如果&lt;span class="math inline">\(R(x)\)&lt;/span>为假分式，要先转换成： 多项式+真分式&lt;/p>
&lt;p>例1&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424110734588.png" alt="image-20200424110734588" style="zoom: 50%;" />&lt;/p>
&lt;h6 id="rx为真分式">&lt;span class="math inline">\(R(x)\)&lt;/span>为真分式&lt;/h6>
&lt;p>如果&lt;span class="math inline">\(R(x)\)&lt;/span>为真分式，R(x)分子不变，分母因式分解；然后拆成部分和的形式。&lt;/p>
&lt;p>例1&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111143062.png" alt="image-20200424111143062" style="zoom:50%;" />&lt;/p>
&lt;p>例2&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111253059.png" alt="image-20200424111253059" style="zoom:50%;" />&lt;/p>
&lt;p>例3&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111345595.png" alt="image-20200424111345595" style="zoom:50%;" />&lt;/p>
&lt;p>例4&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424112731412.png" alt="image-20200424112731412" style="zoom:50%;" />&lt;/p>
&lt;h4 id="三角有理分式的积分">三角有理分式的积分&lt;/h4>
&lt;p>关于sinx,cosx的有理分式的积分，“万能代换”可解决这类间题。但随之而来的是一串复杂的计算，考研至今未见到过非要用它才能求这种不定积分的题对于这类题，&lt;/p>
&lt;p>一般采用下列办法处理：①化成同角；②尽量约分；③分母化成单项式； ④利用&lt;span class="math inline">\(1=\sin ^{2} x+\cos ^{2} x\)&lt;/span>或&lt;span class="math inline">\(1=\left(\sin ^{2} x+\cos ^{2} x\right)^{2}\)&lt;/span>等等。由于三角公式众多，化简时有些技巧，考研中这类题出得很少，但也曾考过&lt;/p>
&lt;h4 id="简单无理分式的积分">简单无理分式的积分&lt;/h4>
&lt;p>按照几种典型类型换元法中所讲的方法换元&lt;/p>
&lt;p>解路思路 含有&lt;span class="math inline">\(\sqrt[n]{ax+b}, \sqrt[n]{ax+b}\)&lt;/span>的简单分式的积分，一般命 &lt;span class="math inline">\(\sqrt[k]{a x+b}=t(\text { 其中 } k \text { 为 } n, m\)&lt;/span> 的最小公倍教）以去掉根式.&lt;/p>
&lt;p>可以使用平方和三角替换的，画三角替换。&lt;/p>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425154542534.png" alt="" />&lt;figcaption>image-20200425154542534&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425154625941.png" alt="" />&lt;figcaption>image-20200425154625941&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425154659172.png" alt="" />&lt;figcaption>image-20200425154659172&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425154742137.png" alt="" />&lt;figcaption>image-20200425154742137&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425154908530.png" alt="" />&lt;figcaption>image-20200425154908530&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元积分学-不定积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 20 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元积分学-不定积分">高等数学-一元积分学-不定积分&lt;/h1>
&lt;h2 id="求不定积分">求不定积分&lt;/h2>
&lt;h3 id="换元积分法">换元积分法&lt;/h3>
&lt;h4 id="第一类换元积分法">第一类换元积分法&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205016069.png" alt="" />&lt;figcaption>image-20200422205016069&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205108701.png" alt="" />&lt;figcaption>image-20200422205108701&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205130343.png" alt="" />&lt;figcaption>image-20200422205130343&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205154594.png" alt="" />&lt;figcaption>image-20200422205154594&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205216680.png" alt="" />&lt;figcaption>image-20200422205216680&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205243332.png" alt="" />&lt;figcaption>image-20200422205243332&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422205329766.png" alt="" />&lt;figcaption>image-20200422205329766&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210256137.png" alt="" />&lt;figcaption>image-20200422210256137&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210326399.png" alt="" />&lt;figcaption>image-20200422210326399&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210354812.png" alt="" />&lt;figcaption>image-20200422210354812&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210421022.png" alt="" />&lt;figcaption>image-20200422210421022&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210446108.png" alt="" />&lt;figcaption>image-20200422210446108&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422210531099.png" alt="" />&lt;figcaption>image-20200422210531099&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425130701361.png" alt="" />&lt;figcaption>image-20200425130701361&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425130801763.png" alt="" />&lt;figcaption>image-20200425130801763&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425131233607.png" alt="" />&lt;figcaption>image-20200425131233607&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425131254167.png" alt="" />&lt;figcaption>image-20200425131254167&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425131314711.png" alt="" />&lt;figcaption>image-20200425131314711&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425145018590.png" alt="" />&lt;figcaption>image-20200425145018590&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425144943007.png" alt="" />&lt;figcaption>image-20200425144943007&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426112941286.png" alt="" />&lt;figcaption>image-20200426112941286&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426113333046.png" alt="" />&lt;figcaption>image-20200426113333046&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426113954477.png" alt="" />&lt;figcaption>image-20200426113954477&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426121016605.png" alt="" />&lt;figcaption>image-20200426121016605&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例18">例18&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426152532636.png" alt="" />&lt;figcaption>image-20200426152532636&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例19">例19&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426154129241.png" alt="" />&lt;figcaption>image-20200426154129241&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例20">例20&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426154522051.png" alt="" />&lt;figcaption>image-20200426154522051&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例21">例21&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426175857969.png" alt="" />&lt;figcaption>image-20200426175857969&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例22">例22&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426180639081.png" alt="" />&lt;figcaption>image-20200426180639081&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例23">例23&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426215400625.png" alt="" />&lt;figcaption>image-20200426215400625&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;span class="math inline">\(=-2\tan \frac{\sqrt{x}}{2} + C\)&lt;/span>&lt;/p>
&lt;p>此题后面中间也可以使用1的代换，三角半角公式来做&lt;/p>
&lt;h6 id="例24">例24&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426215929000.png" alt="" />&lt;figcaption>image-20200426215929000&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426215943472.png" alt="" />&lt;figcaption>image-20200426215943472&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例25">例25&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426221819772.png" alt="" />&lt;figcaption>image-20200426221819772&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例26">例26&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426222544861.png" alt="" />&lt;figcaption>image-20200426222544861&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426222633675.png" alt="" />&lt;figcaption>image-20200426222633675&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例27">例27&lt;/h6>
&lt;p>此题需要功底&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426225326669.png" alt="" />&lt;figcaption>image-20200426225326669&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426225305599.png" alt="" />&lt;figcaption>image-20200426225305599&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例28">例28&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426231808485.png" alt="" />&lt;figcaption>image-20200426231808485&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例29">例29&lt;/h6>
&lt;p>此题需要功底&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426233241569.png" alt="" />&lt;figcaption>image-20200426233241569&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例30">例30&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427094002282.png" alt="" />&lt;figcaption>image-20200427094002282&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例31">例31&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427101700720.png" alt="" />&lt;figcaption>image-20200427101700720&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427101721015.png" alt="" />&lt;figcaption>image-20200427101721015&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例32">例32&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427103040941.png" alt="" />&lt;figcaption>image-20200427103040941&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例33">例33&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427103418076.png" alt="" />&lt;figcaption>image-20200427103418076&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427103418076.png" />&lt;/p>
&lt;h6 id="例34">例34&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427113729819.png" alt="" />&lt;figcaption>image-20200427113729819&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例35">例35&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427134314806.png" alt="" />&lt;figcaption>image-20200427134314806&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例36">例36&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427143724056.png" alt="" />&lt;figcaption>image-20200427143724056&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例37">例37&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427144856302.png" alt="" />&lt;figcaption>image-20200427144856302&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427144914187.png" alt="" />&lt;figcaption>image-20200427144914187&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例38">例38&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427150051741.png" alt="" />&lt;figcaption>image-20200427150051741&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例39">例39&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427151301085.png" alt="" />&lt;figcaption>image-20200427151301085&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例40">例40&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427182002433.png" alt="" />&lt;figcaption>image-20200427182002433&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427182034663.png" alt="" />&lt;figcaption>image-20200427182034663&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例41">例41&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427194005155.png" alt="" />&lt;figcaption>image-20200427194005155&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例42">例42&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427194241730.png" alt="" />&lt;figcaption>image-20200427194241730&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例43">例43&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427194513636.png" alt="" />&lt;figcaption>image-20200427194513636&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427194456603.png" alt="" />&lt;figcaption>image-20200427194456603&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例44">例44&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427195230243.png" alt="" />&lt;figcaption>image-20200427195230243&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427195318107.png" alt="" />&lt;figcaption>image-20200427195318107&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例45">例45&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427200900183.png" alt="" />&lt;figcaption>image-20200427200900183&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427200923247.png" alt="" />&lt;figcaption>image-20200427200923247&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例46">例46&lt;/h6>
&lt;p>第一换元积分，然后分部积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427204245466.png" alt="" />&lt;figcaption>image-20200427204245466&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例47">例47&lt;/h6>
&lt;p>指数的这种变换要能想得到&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427205433865.png" alt="" />&lt;figcaption>image-20200427205433865&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427205600729.png" alt="" />&lt;figcaption>image-20200427205600729&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例48">例48&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428154639184.png" alt="" />&lt;figcaption>image-20200428154639184&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428154620320.png" alt="" />&lt;figcaption>image-20200428154620320&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例49">例49&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428163059455.png" alt="" />&lt;figcaption>image-20200428163059455&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例50">例50&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428191259147.png" alt="" />&lt;figcaption>image-20200428191259147&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428191242216.png" alt="" />&lt;figcaption>image-20200428191242216&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例51">例51&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428204908077.png" alt="" />&lt;figcaption>image-20200428204908077&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428204851025.png" alt="" />&lt;figcaption>image-20200428204851025&lt;/figcaption>
&lt;/figure>
&lt;h4 id="第二类换元积分法">第二类换元积分法&lt;/h4>
&lt;h5 id="无理转有理不一定需要">无理转有理（不一定需要）&lt;/h5>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103451569.png" alt="" />&lt;figcaption>image-20200423103451569&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103537996.png" alt="" />&lt;figcaption>image-20200423103537996&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103552076.png" alt="" />&lt;figcaption>image-20200423103552076&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103703554.png" alt="" />&lt;figcaption>image-20200423103703554&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426120907962.png" alt="" />&lt;figcaption>image-20200426120907962&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426172615885.png" alt="" />&lt;figcaption>image-20200426172615885&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426172551800.png" alt="" />&lt;figcaption>image-20200426172551800&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427162111494.png" alt="" />&lt;figcaption>image-20200427162111494&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427162152965.png" alt="" />&lt;figcaption>image-20200427162152965&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427162230460.png" alt="" />&lt;figcaption>image-20200427162230460&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427181500688.png" alt="" />&lt;figcaption>image-20200427181500688&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;p>第二换元积分，然后有理分式积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427203505684.png" alt="" />&lt;figcaption>image-20200427203505684&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427203532759.png" alt="" />&lt;figcaption>image-20200427203532759&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428144339374.png" alt="" />&lt;figcaption>image-20200428144339374&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428144325581.png" alt="" />&lt;figcaption>image-20200428144325581&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428150900050.png" alt="" />&lt;figcaption>image-20200428150900050&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428150847346.png" alt="" />&lt;figcaption>image-20200428150847346&lt;/figcaption>
&lt;/figure>
&lt;h5 id="平方和差转三角">平方和差转三角&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103823600.png" alt="" />&lt;figcaption>image-20200423103823600&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423103911216.png" alt="" />&lt;figcaption>image-20200423103911216&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423104018258.png" alt="" />&lt;figcaption>image-20200423104018258&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423104051839.png" alt="" />&lt;figcaption>image-20200423104051839&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423104122464.png" alt="" />&lt;figcaption>image-20200423104122464&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423104156670.png" alt="" />&lt;figcaption>image-20200423104156670&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426212005054.png" alt="" />&lt;figcaption>image-20200426212005054&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426212329850.png" alt="" />&lt;figcaption>image-20200426212329850&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426212822931.png" alt="" />&lt;figcaption>image-20200426212822931&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426213429210.png" alt="" />&lt;figcaption>image-20200426213429210&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426213451207.png" alt="" />&lt;figcaption>image-20200426213451207&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426234604161.png" alt="" />&lt;figcaption>image-20200426234604161&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427143101393.png" alt="" />&lt;figcaption>image-20200427143101393&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427155436670.png" alt="" />&lt;figcaption>image-20200427155436670&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427202111805.png" alt="" />&lt;figcaption>image-20200427202111805&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427202128246.png" alt="" />&lt;figcaption>image-20200427202128246&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-1">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428203120686.png" alt="" />&lt;figcaption>image-20200428203120686&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428203150312.png" alt="" />&lt;figcaption>image-20200428203150312&lt;/figcaption>
&lt;/figure>
&lt;h3 id="分部积分法">分部积分法&lt;/h3>
&lt;h4 id="幂函数指数函数的积分int-xn-cdot-ex-d-x">幂函数*指数函数的积分&lt;span class="math inline">\(\int x^{n} \cdot e^{x} d x\)&lt;/span>&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423125054252.png" alt="" />&lt;figcaption>image-20200423125054252&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423125141452.png" alt="" />&lt;figcaption>image-20200423125141452&lt;/figcaption>
&lt;/figure>
&lt;h4 id="幂函数对数函数的积分int-xn-cdot-ln-x-d-x">幂函数*对数函数的积分&lt;span class="math inline">\(\int x^{n} \cdot \ln x d x\)&lt;/span>&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423125318620.png" alt="" />&lt;figcaption>image-20200423125318620&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423125353655.png" alt="" />&lt;figcaption>image-20200423125353655&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;p>第一类换元积分+幂函数对数函数的积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426160132650.png" alt="" />&lt;figcaption>image-20200426160132650&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427115306019.png" alt="" />&lt;figcaption>image-20200427115306019&lt;/figcaption>
&lt;/figure>
&lt;h4 id="幂函数三角函数的积分int-xn-cdot-三角函数-d-x">幂函数*三角函数的积分&lt;span class="math inline">\(\int x^{n} \cdot 三角函数 d x\)&lt;/span>&lt;/h4>
&lt;p>这里的三角函数，对于正弦余弦，要求变到1次幂；对于正切/余切/sec/csc，要求是2次方&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423133028057.png" alt="" />&lt;figcaption>image-20200423133028057&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423133107316.png" alt="" />&lt;figcaption>image-20200423133107316&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423133144411.png" alt="" />&lt;figcaption>image-20200423133144411&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423133208577.png" alt="" />&lt;figcaption>image-20200423133208577&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423133234297.png" alt="" />&lt;figcaption>image-20200423133234297&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423170756173.png" alt="" />&lt;figcaption>image-20200423170756173&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427175900925.png" alt="" />&lt;figcaption>image-20200427175900925&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427175927104.png" alt="" />&lt;figcaption>image-20200427175927104&lt;/figcaption>
&lt;/figure>
&lt;h4 id="幂函数反三角函数的积分int-xn-cdot-反三角函数-d-x">幂函数*反三角函数的积分&lt;span class="math inline">\(\int x^{n} \cdot 反三角函数 d x\)&lt;/span>&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423171543388.png" alt="" />&lt;figcaption>image-20200423171543388&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423180217655.png" alt="" />&lt;figcaption>image-20200423180217655&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423180256448.png" alt="" />&lt;figcaption>image-20200423180256448&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426164457497.png" alt="" />&lt;figcaption>image-20200426164457497&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426164532117.png" alt="" />&lt;figcaption>image-20200426164532117&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427174959800.png" alt="" />&lt;figcaption>image-20200427174959800&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428114813373.png" alt="" />&lt;figcaption>image-20200428114813373&lt;/figcaption>
&lt;/figure>
&lt;h4 id="指数函数正余弦函数的积分int-ea-x-timesleftbeginarraylcos-b-x-sin-b-xendarray-d-xright.">指数函数*正余弦函数的积分&lt;span class="math inline">\(\int e^{a x} \times\left\{\begin{array}{l}\cos b x \\ \sin b x\end{array} d x\right.\)&lt;/span>&lt;/h4>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426160802280.png" alt="" />&lt;figcaption>image-20200426160802280&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426162108438.png" alt="" />&lt;figcaption>image-20200426162108438&lt;/figcaption>
&lt;/figure>
&lt;h4 id="指数函数反三角函数的积分">指数函数*反三角函数的积分&lt;/h4>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;p>指数函数*反三角函数，并与简单无理式复合。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425162238638.png" alt="" />&lt;figcaption>image-20200425162238638&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425162342599.png" alt="" />&lt;figcaption>image-20200425162342599&lt;/figcaption>
&lt;/figure>
&lt;h4 id="sec或csc的n次幂的积分奇次幂">sec或csc的n次幂的积分（奇次幂）&lt;/h4>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;p>sec或csc非奇数次幂的例子，直接计算&lt;/p>
&lt;figure>
&lt;img src="H:\MyTree\考研\数学\数学总结\upload\image-20200423232938283.png" alt="" />&lt;figcaption>image-20200423232938283&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;p>非奇数次幂的例子，直接计算&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423233242199.png" alt="" />&lt;figcaption>image-20200423233242199&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423233501843.png" alt="" />&lt;figcaption>image-20200423233501843&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200423233608477.png" alt="" />&lt;figcaption>image-20200423233608477&lt;/figcaption>
&lt;/figure>
&lt;h4 id="对数复合三角的积分">对数复合三角的积分&lt;/h4>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428141639126.png" alt="" />&lt;figcaption>image-20200428141639126&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428141546583.png" alt="" />&lt;figcaption>image-20200428141546583&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428141605349.png" alt="" />&lt;figcaption>image-20200428141605349&lt;/figcaption>
&lt;/figure>
&lt;h3 id="有理分式积分">有理分式积分&lt;/h3>
&lt;h4 id="有理分式int-rx-d-x的积分">有理分式&lt;span class="math inline">\(\int R(x) d x\)&lt;/span>的积分&lt;/h4>
&lt;p>其中&lt;span class="math inline">\(R(x)=\frac{P(x)}{a(x)}\)&lt;/span>，而P(x)和Q(x)为多项式&lt;/p>
&lt;p>如果P的次数小于于Q的次数，称其为真分式； 如果P的次数大于等于Q的次数，称其为假分式&lt;/p>
&lt;h5 id="为真分式">为真分式&lt;/h5>
&lt;p>如果&lt;span class="math inline">\(R(x)\)&lt;/span>为真分式，R(x)分子不变，分母因式分解；然后拆成部分和的形式。&lt;/p>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111143062.png" alt="image-20200424111143062" />&lt;/p>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111253059.png" alt="image-20200424111253059" />&lt;/p>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424111345595.png" alt="image-20200424111345595" />&lt;/p>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424112731412.png" alt="image-20200424112731412" />&lt;/p>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424115646279.png" alt="" />&lt;figcaption>image-20200424115646279&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424115715811.png" alt="" />&lt;figcaption>image-20200424115715811&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424115852914.png" alt="" />&lt;figcaption>image-20200424115852914&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424115908681.png" alt="" />&lt;figcaption>image-20200424115908681&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-3">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424120031138.png" alt="" />&lt;figcaption>image-20200424120031138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424120057116.png" alt="" />&lt;figcaption>image-20200424120057116&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425210849272.png" alt="" />&lt;figcaption>image-20200425210849272&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425210919316.png" alt="" />&lt;figcaption>image-20200425210919316&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-3">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426173216693.png" alt="" />&lt;figcaption>image-20200426173216693&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426173152116.png" alt="" />&lt;figcaption>image-20200426173152116&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-2">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426174202448.png" alt="" />&lt;figcaption>image-20200426174202448&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-2">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426175744688.png" alt="" />&lt;figcaption>image-20200426175744688&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426175728081.png" alt="" />&lt;figcaption>image-20200426175728081&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13-1">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426231339243.png" alt="" />&lt;figcaption>image-20200426231339243&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426231327752.png" alt="" />&lt;figcaption>image-20200426231327752&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例14-1">例14&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427112938386.png" alt="" />&lt;figcaption>image-20200427112938386&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例15-1">例15&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427114430718.png" alt="" />&lt;figcaption>image-20200427114430718&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例16-1">例16&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427154700868.png" alt="" />&lt;figcaption>image-20200427154700868&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427154637520.png" alt="" />&lt;figcaption>image-20200427154637520&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例17-1">例17&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428171757828.png" alt="" />&lt;figcaption>image-20200428171757828&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428171943546.png" alt="" />&lt;figcaption>image-20200428171943546&lt;/figcaption>
&lt;/figure>
&lt;p>上面是换元法的答案，下面有理分式分解方法，没找到错在哪里&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428172245101.png" alt="" />&lt;figcaption>image-20200428172245101&lt;/figcaption>
&lt;/figure>
&lt;h5 id="rx为假分式">&lt;span class="math inline">\(R(x)\)&lt;/span>为假分式&lt;/h5>
&lt;p>如果&lt;span class="math inline">\(R(x)\)&lt;/span>为假分式，要先转换成： 多项式+真分式&lt;/p>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427210858636.png" alt="" />&lt;figcaption>image-20200427210858636&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427210842090.png" alt="" />&lt;figcaption>image-20200427210842090&lt;/figcaption>
&lt;/figure>
&lt;h4 id="三角有理分式的积分">三角有理分式的积分&lt;/h4>
&lt;p>关于sinx,cosx的有理分式的积分，“万能代换”可解决这类间题。但随之而来的是一串复杂的计算，考研至今未见到过非要用它才能求这种不定积分的题对于这类题，一般采用下列办法处理：①化成同角；②尽量约分；③分母化成单项式； ④利用&lt;span class="math inline">\(1=\sin ^{2} x+\cos ^{2} x\)&lt;/span>或&lt;span class="math inline">\(1=\left(\sin ^{2} x+\cos ^{2} x\right)^{2}\)&lt;/span>等等。由于三角公式众多，化简时有些技巧，考研中这类题出得很少，但也曾考过&lt;/p>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425150447980.png" alt="" />&lt;figcaption>image-20200425150447980&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425150502772.png" alt="" />&lt;figcaption>image-20200425150502772&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425150529966.png" alt="" />&lt;figcaption>image-20200425150529966&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427135923799.png" alt="" />&lt;figcaption>image-20200427135923799&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-8">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427181023135.png" alt="" />&lt;figcaption>image-20200427181023135&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-6">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427193735595.png" alt="" />&lt;figcaption>image-20200427193735595&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427230114126.png" alt="" />&lt;figcaption>image-20200427230114126&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427230100156.png" alt="" />&lt;figcaption>image-20200427230100156&lt;/figcaption>
&lt;/figure>
&lt;p>注：其中 &lt;span class="math inline">\(\quad \int \frac{1}{1+\sin x} d x\)&lt;/span> &lt;span class="math inline">\(=\int \frac{1-\sin x}{1-\sin ^{2} x} d x\)&lt;/span> &lt;span class="math inline">\(=\int \frac{1}{\cos ^{2} x} d x-\int \frac{\sin x}{\cos ^{2} x} d x\)&lt;/span> &lt;span class="math inline">\(=\tan x+\int \frac{d \cos x}{\cos ^{2} x}\)&lt;/span> &lt;span class="math inline">\(=\tan x-\frac{1}{\cos x}+C\)&lt;/span>&lt;/p>
&lt;p>而结合万能公式和tan加法，又可化为&lt;span class="math inline">\(\tan \left(\frac{x}{2}-\frac{\pi}{4}\right)+C\)&lt;/span>&lt;/p>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427232807272.png" alt="" />&lt;figcaption>image-20200427232807272&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427232828202.png" alt="" />&lt;figcaption>image-20200427232828202&lt;/figcaption>
&lt;/figure>
&lt;p>用万能公式解了一次，答案不一样，暂时找不到错误在哪里：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427234209903.png" alt="" />&lt;figcaption>image-20200427234209903&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-4">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427235913815.png" alt="" />&lt;figcaption>image-20200427235913815&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427235944240.png" alt="" />&lt;figcaption>image-20200427235944240&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-4">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428104653509.png" alt="" />&lt;figcaption>image-20200428104653509&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428104631770.png" alt="" />&lt;figcaption>image-20200428104631770&lt;/figcaption>
&lt;/figure>
&lt;p>下面使用万能公式算了一遍，答案不一样，暂时找不到错在哪里：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428171324435.png" alt="" />&lt;figcaption>image-20200428171324435&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-4">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428143408045.png" alt="" />&lt;figcaption>image-20200428143408045&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428143421195.png" alt="" />&lt;figcaption>image-20200428143421195&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-4">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428193724034.png" alt="" />&lt;figcaption>image-20200428193724034&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-3">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428200300390.png" alt="" />&lt;figcaption>image-20200428200300390&lt;/figcaption>
&lt;/figure>
&lt;p>和上一题比较，注意体会这类题型的灵活性&lt;/p>
&lt;h3 id="换元分部积分有理分式">换元+分部积分+有理分式&lt;/h3>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;p>第二换元积分，分部积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428120429968.png" alt="" />&lt;figcaption>image-20200428120429968&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428120446348.png" alt="" />&lt;figcaption>image-20200428120446348&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;p>第一换元积分，分部积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428120815802.png" alt="" />&lt;figcaption>image-20200428120815802&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-9">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428121807819.png" alt="" />&lt;figcaption>image-20200428121807819&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428121829361.png" alt="" />&lt;figcaption>image-20200428121829361&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-7">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428204008861.png" alt="" />&lt;figcaption>image-20200428204008861&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428203957815.png" alt="" />&lt;figcaption>image-20200428203957815&lt;/figcaption>
&lt;/figure>
&lt;h3 id="指数有理分式三角有理分式简单无理式的混合或复合后的积分">指数，有理分式，三角有理分式，简单无理式的混合或复合后的积分&lt;/h3>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;p>指数函数*反三角函数，并与简单无理式复合。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425162238638.png" alt="" />&lt;figcaption>image-20200425162238638&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425162342599.png" alt="" />&lt;figcaption>image-20200425162342599&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425164527994.png" alt="" />&lt;figcaption>image-20200425164527994&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425164540995.png" alt="" />&lt;figcaption>image-20200425164540995&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425164556562.png" alt="" />&lt;figcaption>image-20200425164556562&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-10">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425164832169.png" alt="" />&lt;figcaption>image-20200425164832169&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200425164844465.png" alt="" />&lt;figcaption>image-20200425164844465&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-8">例4&lt;/h6>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426160132650.png" />&lt;/p>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;p>第一换元法+分部积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426183534552.png" alt="" />&lt;figcaption>image-20200426183534552&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426183559031.png" alt="" />&lt;figcaption>image-20200426183559031&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-5">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427095304645.png" alt="" />&lt;figcaption>image-20200427095304645&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-5">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427142302335.png" alt="" />&lt;figcaption>image-20200427142302335&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427142326820.png" alt="" />&lt;figcaption>image-20200427142326820&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-5">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427192509791.png" alt="" />&lt;figcaption>image-20200427192509791&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427192532106.png" alt="" />&lt;figcaption>image-20200427192532106&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200427192557501.png" alt="" />&lt;figcaption>image-20200427192557501&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-5">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428110330723.png" alt="" />&lt;figcaption>image-20200428110330723&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428110242105.png" alt="" />&lt;figcaption>image-20200428110242105&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428110257490.png" alt="" />&lt;figcaption>image-20200428110257490&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-5">例10&lt;/h6>
&lt;p>三角有理分式和幂函数混合&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428111550983.png" alt="" />&lt;figcaption>image-20200428111550983&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428111524833.png" alt="" />&lt;figcaption>image-20200428111524833&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-4">例11&lt;/h6>
&lt;p>无理式积分&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428142539531.png" alt="" />&lt;figcaption>image-20200428142539531&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428142519874.png" alt="" />&lt;figcaption>image-20200428142519874&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求分段函数的不定积分">求分段函数的不定积分&lt;/h2>
&lt;p>解题思路本题的被积函数为绝对值所表示，&lt;/p>
&lt;p>第一步，应将它写成分段表达式，可知它是连续的； 第二步，将此分段函数按分段求其原函数，并使在分界点处接成连续，&lt;/p>
&lt;p>再加C便可得不定积分&lt;/p>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424170943738.png" alt="" />&lt;figcaption>image-20200424170943738&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424171015081.png" alt="" />&lt;figcaption>image-20200424171015081&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428191829102.png" alt="" />&lt;figcaption>image-20200428191829102&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428191812340.png" alt="" />&lt;figcaption>image-20200428191812340&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求带导数或带积分的不定积分">求带导数或带积分的不定积分&lt;/h2>
&lt;h6 id="例1-17">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200426165344131.png" alt="" />&lt;figcaption>image-20200426165344131&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200428191955630.png" alt="" />&lt;figcaption>image-20200428191955630&lt;/figcaption>
&lt;/figure>
&lt;h2 id="比较不定积分的大小">比较不定积分的大小&lt;/h2>
&lt;h6 id="例1-18">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424181358154.png" alt="" />&lt;figcaption>image-20200424181358154&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200424181431350.png" alt="" />&lt;figcaption>image-20200424181431350&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元微分学-一元微分学的应用-弧微分与曲率</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 15 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-一元微分学的应用-弧微分与曲率">高等数学-一元微分学-一元微分学的应用-弧微分与曲率&lt;/h1>
&lt;h2 id="弧微分与曲率">弧微分与曲率&lt;/h2>
&lt;h3 id="考察弧微分的定义">考察弧微分的定义&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419201751511.png" alt="" />&lt;figcaption>image-20200419201751511&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419201738165.png" alt="" />&lt;figcaption>image-20200419201738165&lt;/figcaption>
&lt;/figure>
&lt;h3 id="考察曲率的定义">考察曲率的定义&lt;/h3>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419221426971.png" alt="" />&lt;figcaption>image-20200419221426971&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419221445751.png" alt="" />&lt;figcaption>image-20200419221445751&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419221500943.png" alt="" />&lt;figcaption>image-20200419221500943&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元微分学-导数的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/</link><pubDate>Sun, 15 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-导数的应用">高等数学-一元微分学-导数的应用&lt;/h1>
&lt;h2 id="弧微分与曲率">弧微分与曲率&lt;/h2>
&lt;h5 id="弧微分">弧微分&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419145612636.png" alt="image-20200419145612636" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419145657286.png" alt="image-20200419145657286" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419145822055.png" alt="image-20200419145822055" style="zoom:50%;" />&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419145751576.png" alt="image-20200419145751576" style="zoom:50%;" />&lt;/p>
&lt;p>直角座标系中，&lt;span class="math inline">\(\mathrm{d} s=\sqrt{1+y^{\prime 2}} \mathrm{d} x,(\mathrm{d} x&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;p>参数方程中，&lt;span class="math inline">\(\mathrm{d} s=\sqrt{x^{\prime 2}(t)+y^{\prime 2}(t)} \mathrm{d} t,(\mathrm{d} t&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;p>极坐标系中，&lt;span class="math inline">\(\mathrm{d} s=\sqrt{p^{2}(\theta)+p^{\prime}(\theta)^{2}} \mathrm{d} \theta,(\mathrm{d} \theta&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;blockquote>
&lt;p>极坐标系中的证明： &lt;span class="math inline">\(r=r(\theta)\)&lt;/span> &lt;span class="math inline">\(x=r \cos \theta, y=r \sin \theta\)&lt;/span> &lt;span class="math inline">\(\frac{d x}{d \theta}=\frac{\partial x}{\partial r} \frac{d r}{d \theta}+\frac{\partial x}{\partial \theta}=\cos \theta r^{\prime}-r \sin \theta\)&lt;/span> &lt;span class="math inline">\(\frac{d y}{d \theta}=\frac{\partial y}{\partial r} \frac{d r}{d \theta}+\frac{\partial y}{\partial \theta}=\sin \theta r^{\prime}+r \cos \theta\)&lt;/span> &lt;span class="math inline">\(d s=\sqrt{\left(\frac{d x}{d \theta}\right)^{2}+\left(\frac{d y}{d \theta}\right)^{2}} d \theta=\sqrt{r^{2}+r^{\prime}(\theta)^{2}} d \theta\)&lt;/span>&lt;/p>
&lt;/blockquote>
&lt;h5 id="曲率">曲率&lt;/h5>
&lt;h6 id="曲率的引入">曲率的引入&lt;/h6>
&lt;p>在数学上，曲线的曲率表明曲线在某一点的弯曲程度的数值。&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20200306185121.png" />&lt;/p>
&lt;p>曲率越大，表示曲线的弯曲程度越大。&lt;/p>
&lt;h6 id="曲率定义">曲率定义&lt;/h6>
&lt;p>比值&lt;span class="math inline">\(\left|\frac{\Delta \alpha}{\Delta s}\right|\)&lt;/span>表示单位弧段上的切线转角，刻划了弧MM’的平均弯曲程度。称它为弧段MM’的&lt;strong>平均曲率&lt;/strong>。记作&lt;span class="math inline">\(\bar{k}=\left|\frac{\Delta \alpha}{\Delta s}\right|\)&lt;/span>&lt;/p>
&lt;p>当&lt;img src="https://sxyd.sdut.edu.cn/_upload/tpl/02/32/562/template562/onlineLearning/gaodengshuxueshang/lesson/3.9%20qulv.files/image145.gif" alt="img" />时(即：&lt;span class="math inline">\(M^{\prime} \rightarrow M\)&lt;/span>)，上述平均曲率的极限就称着曲线在点M处的&lt;strong>曲率&lt;/strong>，记作&lt;span class="math inline">\(k=\lim _{\Delta s \rightarrow 0}\left|\frac{\Delta \alpha}{\Delta s}\right|\)&lt;/span> 。&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref">&lt;sup>1&lt;/sup>&lt;/a>&lt;/p>
&lt;p>当&lt;span class="math inline">\(\lim _{\Delta s \rightarrow 0} \frac{\Delta \alpha}{\Delta s}=\frac{d \alpha}{d s}\)&lt;/span>存在时，有 &lt;span class="math inline">\(k=\left|\frac{d \alpha}{d s}\right|\)&lt;/span>&lt;/p>
&lt;p>由上述定义知，&lt;strong>曲率是一个局部概念，&lt;/strong>谈曲线的弯曲应该具体地指出是曲线在哪一点处的弯曲，这样才准确。&lt;/p>
&lt;h6 id="曲率圆和曲率半径">曲率圆和曲率半径&lt;/h6>
&lt;p>&lt;img src="https://bkimg.cdn.bcebos.com/pic/b3b7d0a20cf431adc3be11524836acaf2edd9868" alt="img" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200318100923495.png" alt="image-20200318100923495" />&lt;/p>
&lt;p>光滑曲线上某点的极小邻域，都可以看作是一个圆上的一部分，这个圆叫做曲率圆，这个圆的半径R叫做曲率半径。&lt;/p>
&lt;p>如上图，在圆上&lt;span class="math inline">\(\frac{d s}{R}=\tan d \alpha \approx d \alpha\)&lt;/span> &lt;span class="math inline">\(\Rightarrow R=\left|\frac{d s}{d \alpha}\right|\)&lt;/span> 即&lt;span class="math inline">\(k=\frac{1}{R}=\left|\frac{d \alpha}{d s}\right|\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>曲率的倒数&lt;/strong>就是&lt;a href="https://baike.baidu.com/item/曲率半径/2036643">曲率半径&lt;/a>。&lt;/p>
&lt;p>又$==y^{} $&lt;/p>
&lt;p>$ ==y^{} $&lt;/p>
&lt;p>$ =y^{} $&lt;/p>
&lt;p>$d =y^{} ^{2} d x =y^{} d x $&lt;/p>
&lt;p>又&lt;span class="math inline">\(\mathrm{d} s=\sqrt{1+y^{\prime 2}} \mathrm{d} x,(\mathrm{d} x&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;p>则可以得到&lt;strong>曲率计算公式&lt;/strong>&lt;span class="math inline">\(k=\frac{1}{R}=\left|\frac{d \alpha}{d s}\right| = \frac{\left|y^{\prime \prime}\right|}{\left[1+\left(y^{\prime}\right)^{2}\right]^{3 / 2}}\)&lt;/span>&lt;/p>
&lt;p>假设曲线方程是参数方程 &lt;span class="math inline">\(\left\{\begin{array}{l}x=\varphi(t) \\ y=\phi(t)\end{array}\right.\)&lt;/span> 给出&lt;/p>
&lt;p>则(2)式可相应地改成形式：&lt;/p>
&lt;p>&lt;span class="math inline">\(y^{\prime}=\frac{\phi^{\prime}(t)}{\varphi^{\prime}(t)}\)&lt;/span>，，&lt;span class="math inline">\(y^{\prime \prime}=\frac{\phi^{\prime \prime}(t) \psi^{\prime}(t)-\varphi^{\prime \prime}(t) \phi^{\prime}(t)}{\left[\varphi^{\prime}(t)\right]^{3}}\)&lt;/span>&lt;/p>
&lt;p>可得&lt;strong>参数方程曲率计算公式&lt;/strong>&lt;span class="math inline">\(k=\frac{\left|\phi^{\prime \prime}(t) \varphi^{\prime}(t)-\varphi^{\prime \prime}(t) \phi^{\prime}(t)\right|}{\left[\left(\varphi^{\prime}(t)\right)^{2}+\left(\phi^{\prime}(t)\right)^{2}\right]^{3 / 2}}\)&lt;/span>&lt;/p>
&lt;p>例1&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328085424830.png" alt="" />&lt;figcaption>image-20200328085424830&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200328085457798.png" alt="" />&lt;figcaption>image-20200328085457798&lt;/figcaption>
&lt;/figure>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr />
&lt;ol>
&lt;li id="fn1" role="doc-endnote">&lt;p>&lt;a href="https://sxyd.sdut.edu.cn/_upload/tpl/02/32/562/template562/onlineLearning/gaodengshuxueshang/lesson/3.9%20qulv.htm">山东理工大学电子教材&lt;/a>&lt;a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎&lt;/a>&lt;/p>&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>高等数学-一元函数微分学-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元函数微分学-单调性与极值">高等数学-一元函数微分学-单调性与极值&lt;/h1>
&lt;h3 id="概念">概念&lt;/h3>
&lt;p>极值、最值（略）&lt;/p>
&lt;h5 id="曲线的凹凸性">曲线的凹凸性&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419131142567.png" alt="image-20200419131142567" style="zoom: 33%;" />&lt;/p>
&lt;p>同理可有曲线是凸的的定义&lt;/p>
&lt;h5 id="曲线的拐点">曲线的拐点&lt;/h5>
&lt;p>连续曲线y=f(x)上的凹、凸弧的分界点称为该曲线的拐点&lt;/p>
&lt;h5 id="曲线的驻点">曲线的驻点&lt;/h5>
&lt;p>连续曲线y=f(x)上若f’(x)=0的解为a则称其为f(x)的驻点或称稳定点、临界点&lt;/p>
&lt;h3 id="极值与单调性的的判定">极值与单调性的的判定&lt;/h3>
&lt;h4 id="单调性的判定">单调性的判定&lt;/h4>
&lt;p>在区间I上恒有&lt;span class="math inline">\(f^{\prime}(x) \geqslant 0\)&lt;/span>，称f(x)在区间I上单调增加；同理判断单调减少。&lt;/p>
&lt;h4 id="极值的判定">极值的判定&lt;/h4>
&lt;ul>
&lt;li>确定函数&lt;strong>定义域&lt;/strong>&lt;/li>
&lt;li>找所有的&lt;strong>不可导点&lt;/strong>和&lt;strong>导数为0点&lt;/strong>&lt;/li>
&lt;li>根据&lt;strong>极值的判定条件&lt;/strong>来判定&lt;/li>
&lt;/ul>
&lt;h5 id="极值的判定条件充分条件">极值的判定条件（充分条件）&lt;/h5>
&lt;h6 id="极值第一充分条件">极值第一充分条件&lt;/h6>
&lt;p>函数在某点&lt;strong>连续&lt;/strong>，该点&lt;strong>左侧导数大于0&lt;/strong>，&lt;strong>右侧导数小于0&lt;/strong>，则该点取得&lt;strong>极大值&lt;/strong>&lt;/p>
&lt;p>函数在某点连续，该点左侧导数小于0，右侧导数大于0，则该点取得极小值&lt;/p>
&lt;h6 id="极值第二充分条件">极值第二充分条件&lt;/h6>
&lt;p>函数在某点的&lt;strong>一阶导数等于0，二阶导数不等于0&lt;/strong>。若该点的二阶导数大于0，该点取得极小值；若该点的二阶导数小于0，则该点取得极大值&lt;/p>
&lt;h4 id="函数取极值的性质">函数取极值的性质&lt;/h4>
&lt;h5 id="极值的必要条件">极值的必要条件&lt;/h5>
&lt;p>&lt;span class="math inline">\(x=x_{0}\)&lt;/span>处取得极值，且可导 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 导数为零：&lt;span class="math inline">\(f^{\prime}\left(x_{0}\right)=0\)&lt;/span>&lt;/p>
&lt;h3 id="凹凸性与拐点的判定">凹凸性与拐点的判定&lt;/h3>
&lt;h5 id="凹凸性的判定">凹凸性的判定&lt;/h5>
&lt;p>函数在区间I上恒有&lt;span class="math inline">\(f^{\prime \prime}(x) \geqslant 0\)&lt;/span>（且不在任意子区间上取等号），则曲线在区间I上是凹的。 &lt;span class="math inline">\(f^{\prime \prime}(x) \leqslant 0\)&lt;/span>，凸的。&lt;/p>
&lt;h5 id="拐点的必要条件">拐点的必要条件&lt;/h5>
&lt;p>函数在某点取得拐点，且二阶导数存在，则二阶导数等于0&lt;/p>
&lt;h5 id="拐点的充分条件">拐点的充分条件&lt;/h5>
&lt;p>函数在某点连续，某去心邻域二阶可导，左右邻域二阶导数反号，则函数在该点取拐点&lt;/p>
&lt;h3 id="最值的求法">最值的求法&lt;/h3>
&lt;h5 id="闭区间上最值求法">闭区间上最值求法&lt;/h5>
&lt;p>（1）求出f（x）在该区间内部的一切驻点及不可导的点，并计算相应的函数值； （2）求出f（x）在闭区间两端点处的函数值 （3）比较上述（1）（2）中求出的函数值，最大者为最大值，最小者为最小值 （4）如果（2）区间内部只有个可疑极值点，并且是极大（极小值点，则它必是f（x）的最大（最小值点此时的区间”可以是闭的，也可以是开的、半开半闭或无穷区间实际上遇到的多数是（4）&lt;/p>
&lt;h5 id="应用题求最值">应用题求最值&lt;/h5>
&lt;p>（1）建模：建立目标函数的表达式y=f（x），及相应的定义区间1； （2）如果f（x）在I内可导，则求出f（x）在I内的一切驻点； （3）如果I内只有一个驻点，并且经检验，是极大（极小）值点，则在此唯一的驻点处函数必为最大（最小）值&lt;/p>
&lt;h3 id="不等式的证明">不等式的证明&lt;/h3>
&lt;h4 id="构造函数求极值来证明">构造函数求极值来证明&lt;/h4>
&lt;p>移项构造函数求最值，恒大于（或恒大于等于或。。。）某个值，得证。&lt;/p>
&lt;h3 id="函数的渐近线">函数的渐近线&lt;/h3>
&lt;h5 id="水平渐近线">水平渐近线&lt;/h5>
&lt;p>若&lt;span class="math inline">\(\lim_{x \rightarrow+\infty} f(x)=b_{1}\)&lt;/span>，则&lt;span class="math inline">\(y=b_{1}\)&lt;/span>是一条水平渐近线； 若&lt;span class="math inline">\(\lim_{x \rightarrow-\infty} f(x)=b_{2}\)&lt;/span>，则&lt;span class="math inline">\(y=b_{2}\)&lt;/span>是一条水平渐近线（若&lt;span class="math inline">\(b_1 = b_2\)&lt;/span>,只算作一条）&lt;/p>
&lt;h5 id="铅直渐近线">铅直渐近线&lt;/h5>
&lt;p>若存在&lt;span class="math inline">\(x_0\)&lt;/span>，使&lt;span class="math inline">\(\lim_{x \rightarrow x_{0}^{-}} f(x)=\infty\)&lt;/span>（或者&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}^{+}} f(x)=\infty\)&lt;/span>），则&lt;span class="math inline">\(x=x_0\)&lt;/span>是一条铅直渐近线。&lt;/p>
&lt;p>这里的&lt;span class="math inline">\(x_0\)&lt;/span>先由观察法获得，一般考虑分母为0处，对数的真数为0处等。&lt;/p>
&lt;h5 id="斜渐近线">斜渐近线&lt;/h5>
&lt;p>&lt;span class="math inline">\(y=a x+b\)&lt;/span>是函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>的一条斜渐近线 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=a\)&lt;/span>,&lt;span class="math inline">\(\lim _{x \rightarrow+\infty}(f(x)-a x)=b\)&lt;/span>.&lt;/p>
&lt;p>对于&lt;span class="math inline">\(x \rightarrow-\infty\)&lt;/span>也类似。&lt;/p>
&lt;p>若&lt;span class="math inline">\(a=0\)&lt;/span>，即为水平渐近线。&lt;/p>
&lt;p>&lt;strong>水平渐近线和斜渐近线是互克的&lt;/strong>&lt;/p></description></item><item><title>高等数学-一元函数微分学-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元函数微分学-单调性与极值">高等数学-一元函数微分学-单调性与极值&lt;/h1>
&lt;h3 id="概念">概念&lt;/h3>
&lt;p>极值、最值（略）&lt;/p>
&lt;h5 id="曲线的凹凸性">曲线的凹凸性&lt;/h5>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419131142567.png" alt="image-20200419131142567" style="zoom: 33%;" />&lt;/p>
&lt;p>同理可有曲线是凸的的定义&lt;/p>
&lt;h5 id="曲线的拐点">曲线的拐点&lt;/h5>
&lt;p>连续曲线y=f(x)上的凹、凸弧的分界点称为该曲线的拐点&lt;/p>
&lt;h5 id="曲线的驻点">曲线的驻点&lt;/h5>
&lt;p>连续曲线y=f(x)上若f’(x)=0的解为a则称其为f(x)的驻点或称稳定点、临界点&lt;/p>
&lt;h3 id="极值与单调性的的判定">极值与单调性的的判定&lt;/h3>
&lt;h4 id="单调性的判定">单调性的判定&lt;/h4>
&lt;p>在区间I上恒有&lt;span class="math inline">\(f^{\prime}(x) \geqslant 0\)&lt;/span>，称f(x)在区间I上单调增加；同理判断单调减少。&lt;/p>
&lt;h4 id="极值的判定">极值的判定&lt;/h4>
&lt;ul>
&lt;li>确定函数&lt;strong>定义域&lt;/strong>&lt;/li>
&lt;li>找所有的&lt;strong>不可导点&lt;/strong>和&lt;strong>导数为0点&lt;/strong>&lt;/li>
&lt;li>根据&lt;strong>极值的判定条件&lt;/strong>来判定&lt;/li>
&lt;/ul>
&lt;h5 id="极值的判定条件充分条件">极值的判定条件（充分条件）&lt;/h5>
&lt;h6 id="极值第一充分条件">极值第一充分条件&lt;/h6>
&lt;p>函数在某点&lt;strong>连续&lt;/strong>，该点&lt;strong>左侧导数大于0&lt;/strong>，&lt;strong>右侧导数小于0&lt;/strong>，则该点取得&lt;strong>极大值&lt;/strong>&lt;/p>
&lt;p>函数在某点连续，该点左侧导数小于0，右侧导数大于0，则该点取得极小值&lt;/p>
&lt;h6 id="极值第二充分条件">极值第二充分条件&lt;/h6>
&lt;p>函数在某点的&lt;strong>一阶导数等于0，二阶导数不等于0&lt;/strong>。若该点的二阶导数大于0，该点取得极小值；若该点的二阶导数小于0，则该点取得极大值&lt;/p>
&lt;h4 id="函数取极值的性质">函数取极值的性质&lt;/h4>
&lt;h5 id="极值的必要条件">极值的必要条件&lt;/h5>
&lt;p>&lt;span class="math inline">\(x=x_{0}\)&lt;/span>处取得极值，且可导 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 导数为零：&lt;span class="math inline">\(f^{\prime}\left(x_{0}\right)=0\)&lt;/span>&lt;/p>
&lt;h3 id="凹凸性与拐点的判定">凹凸性与拐点的判定&lt;/h3>
&lt;h5 id="凹凸性的判定">凹凸性的判定&lt;/h5>
&lt;p>函数在区间I上恒有&lt;span class="math inline">\(f^{\prime \prime}(x) \geqslant 0\)&lt;/span>（且不在任意子区间上取等号），则曲线在区间I上是凹的。 &lt;span class="math inline">\(f^{\prime \prime}(x) \leqslant 0\)&lt;/span>，凸的。&lt;/p>
&lt;h5 id="拐点的必要条件">拐点的必要条件&lt;/h5>
&lt;p>函数在某点取得拐点，且二阶导数存在，则二阶导数等于0&lt;/p>
&lt;h5 id="拐点的充分条件">拐点的充分条件&lt;/h5>
&lt;p>函数在某点连续，某去心邻域二阶可导，左右邻域二阶导数反号，则函数在该点取拐点&lt;/p>
&lt;h3 id="最值的求法">最值的求法&lt;/h3>
&lt;h5 id="闭区间上最值求法">闭区间上最值求法&lt;/h5>
&lt;p>（1）求出f（x）在该区间内部的一切驻点及不可导的点，并计算相应的函数值； （2）求出f（x）在闭区间两端点处的函数值 （3）比较上述（1）（2）中求出的函数值，最大者为最大值，最小者为最小值 （4）如果（2）区间内部只有个可疑极值点，并且是极大（极小值点，则它必是f（x）的最大（最小值点此时的区间”可以是闭的，也可以是开的、半开半闭或无穷区间实际上遇到的多数是（4）&lt;/p>
&lt;h5 id="应用题求最值">应用题求最值&lt;/h5>
&lt;p>（1）建模：建立目标函数的表达式y=f（x），及相应的定义区间1； （2）如果f（x）在I内可导，则求出f（x）在I内的一切驻点； （3）如果I内只有一个驻点，并且经检验，是极大（极小）值点，则在此唯一的驻点处函数必为最大（最小）值&lt;/p>
&lt;h3 id="不等式的证明">不等式的证明&lt;/h3>
&lt;h4 id="构造函数求极值来证明">构造函数求极值来证明&lt;/h4>
&lt;p>移项构造函数求最值，恒大于（或恒大于等于或。。。）某个值，得证。&lt;/p>
&lt;h3 id="函数的渐近线">函数的渐近线&lt;/h3>
&lt;h5 id="水平渐近线">水平渐近线&lt;/h5>
&lt;p>若&lt;span class="math inline">\(\lim_{x \rightarrow+\infty} f(x)=b_{1}\)&lt;/span>，则&lt;span class="math inline">\(y=b_{1}\)&lt;/span>是一条水平渐近线； 若&lt;span class="math inline">\(\lim_{x \rightarrow-\infty} f(x)=b_{2}\)&lt;/span>，则&lt;span class="math inline">\(y=b_{2}\)&lt;/span>是一条水平渐近线（若&lt;span class="math inline">\(b_1 = b_2\)&lt;/span>,只算作一条）&lt;/p>
&lt;h5 id="铅直渐近线">铅直渐近线&lt;/h5>
&lt;p>若存在&lt;span class="math inline">\(x_0\)&lt;/span>，使&lt;span class="math inline">\(\lim_{x \rightarrow x_{0}^{-}} f(x)=\infty\)&lt;/span>（或者&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}^{+}} f(x)=\infty\)&lt;/span>），则&lt;span class="math inline">\(x=x_0\)&lt;/span>是一条铅直渐近线。&lt;/p>
&lt;p>这里的&lt;span class="math inline">\(x_0\)&lt;/span>先由观察法获得，一般考虑分母为0处，对数的真数为0处等。&lt;/p>
&lt;h5 id="斜渐近线">斜渐近线&lt;/h5>
&lt;p>&lt;span class="math inline">\(y=a x+b\)&lt;/span>是函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>的一条斜渐近线 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\lim _{x \rightarrow+\infty} \frac{f(x)}{x}=a\)&lt;/span>,&lt;span class="math inline">\(\lim _{x \rightarrow+\infty}(f(x)-a x)=b\)&lt;/span>.&lt;/p>
&lt;p>对于&lt;span class="math inline">\(x \rightarrow-\infty\)&lt;/span>也类似。&lt;/p>
&lt;p>若&lt;span class="math inline">\(a=0\)&lt;/span>，即为水平渐近线。&lt;/p>
&lt;p>&lt;strong>水平渐近线和斜渐近线是互克的&lt;/strong>&lt;/p></description></item><item><title>高等数学-一元微分学-可导函数的中值定理</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-可导函数的中值定理">高等数学-一元微分学-可导函数的中值定理&lt;/h1>
&lt;h3 id="函数的导数分类">函数的导数分类&lt;/h3>
&lt;p>函数的导数分为4种情况，导数大于0，等于0，小于0，不可导&lt;/p>
&lt;h4 id="可导的局部特性">可导的局部特性&lt;/h4>
&lt;p>以导数大于0为例，根据函数极限的局部保号性：&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} if \quad &amp;amp; f^{\prime}(a)&amp;gt;0 ,f^{\prime}(a) =\lim_{x \rightarrow a} \frac{f(x)-f(a)}{x-a}&amp;gt;0 \\ \Rightarrow \quad&amp;amp; \exists \delta&amp;gt;0, x&amp;lt;|x-a|&amp;lt;\delta , \frac{f(x)-f(a)}{x-a}&amp;gt;0 \end{aligned}\)&lt;/span>&lt;/p>
&lt;p>即导数大于0，表示在极小邻域内，函数值递增 同理，导数小于0，表示在极小邻域内，函数值递减 同理，导数等于0，表示在极小邻域内，函数取极值&lt;/p>
&lt;h4 id="费马定理">费马定理&lt;/h4>
&lt;p>函数在某点及邻域有定义，在该点取极值，在该点导数存在 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 该点导数为0（该点是驻点）。&lt;/p>
&lt;p>即有：&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=a\)&lt;/span>取极值， &lt;span class="math inline">\(\Rightarrow \nLeftarrow\)&lt;/span> &lt;span class="math inline">\(f&amp;#39;(a)=0\)&lt;/span> 或 不存在&lt;span class="math inline">\(f&amp;#39;(a)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x)\)&lt;/span>可导且在&lt;span class="math inline">\(x=a\)&lt;/span>取极值， &lt;span class="math inline">\(\Rightarrow \nLeftarrow\)&lt;/span> &lt;span class="math inline">\(f&amp;#39;(a)=0\)&lt;/span>&lt;/p>
&lt;h3 id="可导函数的中值定理">可导函数的中值定理&lt;/h3>
&lt;p>几个中值定理的共同条件：一个函数在闭区间连续，开区间可导，中间存在一个点怎么怎么样&lt;/p>
&lt;p>高阶中值定理（拉格朗日余项泰勒定理）的条件：一个函数在闭区间n阶连续，开区间n+1阶可导，中间存在一个点怎么怎么样&lt;/p>
&lt;h4 id="罗尔定理">罗尔定理&lt;/h4>
&lt;p>若&lt;span class="math inline">\(f(x)\)&lt;/span>在闭区间&lt;span class="math inline">\([a, b]\)&lt;/span>内连续，在开区间&lt;span class="math inline">\((a, b)\)&lt;/span>内可导，且&lt;span class="math inline">\(f(a)=f(b)\)&lt;/span>，则至少存在一点&lt;span class="math inline">\(\xi \in(a, b)\)&lt;/span>，&lt;span class="math inline">\(f^{\prime}(\xi)=0\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417102902630.png" alt="" />&lt;figcaption>image-20200417102902630&lt;/figcaption>
&lt;/figure>
&lt;h4 id="拉格朗日中值定理">拉格朗日中值定理&lt;/h4>
&lt;p>若&lt;span class="math inline">\(f(x)\)&lt;/span>在闭区间&lt;span class="math inline">\([a, b]\)&lt;/span>内连续，在开区间&lt;span class="math inline">\((a, b)\)&lt;/span>内可导，且&lt;span class="math inline">\(f(a)=f(b)\)&lt;/span>，则至少存在一点&lt;span class="math inline">\(\xi \in(a, b)\)&lt;/span>，&lt;span class="math inline">\(f(b)-f(a)=f^{\prime}(\xi)(b-a)\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417110059482.png" alt="" />&lt;figcaption>image-20200417110059482&lt;/figcaption>
&lt;/figure>
&lt;p>作辅助函数+罗尔定理可证此定理； 所作的辅助函数：直线AB-曲线AB，则在端点处都为0，满足罗尔定理条件。&lt;/p>
&lt;h4 id="柯西中值定理">柯西中值定理&lt;/h4>
&lt;p>若&lt;span class="math inline">\(f(x), g(x)\)&lt;/span>在闭区间&lt;span class="math inline">\([a, b]\)&lt;/span>连续，在开区间&lt;span class="math inline">\((a, b)\)&lt;/span>可导，且&lt;span class="math inline">\(g^{\prime}(x) \neq 0, x \in(a, b)\)&lt;/span>则至少存在一点&lt;span class="math inline">\(\xi \in(a, b)\)&lt;/span>，使得&lt;span class="math inline">\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f^{\prime}(\xi)}{g^{\prime}(\xi)}\)&lt;/span>。&lt;/p>
&lt;p>作辅助函数+罗尔定理证明&lt;/p>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417112739202.png" alt="image-20200417112739202" style="zoom:50%;" />&lt;/p>
&lt;h4 id="泰勒定理">泰勒定理&lt;/h4>
&lt;p>泰勒定理一般有两种形式。&lt;/p>
&lt;p>具有拉格朗日余项的n阶泰勒公式，可看作是高阶中值定理。退化到零阶，即拉格朗日中值定理。&lt;/p>
&lt;p>佩亚诺余项泰勒公式，余项是无穷小，一般用于无穷小的比较（比如求极限）&lt;/p>
&lt;h5 id="具有拉格朗日余项的n阶泰勒公式">具有拉格朗日余项的n阶泰勒公式&lt;/h5>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>在闭区间&lt;span class="math inline">\([a,b]\)&lt;/span>上有n阶连续导数，在开区间&lt;span class="math inline">\((a,b)\)&lt;/span>内有n+1阶导数，&lt;span class="math inline">\(x_{0} \in[a, b], x \in[a, b]\)&lt;/span>是任意两点，则至少存在一点&lt;span class="math inline">\(\xi\)&lt;/span>介于x和&lt;span class="math inline">\(x_0\)&lt;/span>之间，使得&lt;span class="math inline">\(f(x)=f\left(x_{0}\right)+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\frac{f^{\prime \prime}\left(x_{0}\right)}{2 !}\left(x-x_{0}\right)^{2}+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+R_{x}(x)\)&lt;/span>，其中&lt;span class="math inline">\(R_{n}(x)=\frac{f^{(n+1)}(\xi)}{(n+1) !}\left(x-x_{0}\right)^{n+1}\)&lt;/span>称为拉格朗日余项，整个公式称为具有&lt;strong>拉格朗日余项的n阶泰勒公式&lt;/strong>。&lt;/p>
&lt;p>若&lt;span class="math inline">\(x_0 = 0\)&lt;/span>,则该公式称为麦克劳林公式。&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 50%" />
&lt;col style="width: 50%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>函数&lt;/th>
&lt;th>对应的麦克劳林级数展开&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\frac{1}{\sqrt{1-x^{2}}}=\left(1-x^{2}\right)^{-\frac{1}{2}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(1+\sum_{n=1}^{\infty} \frac{1 \times 3 \times 5 \times \cdots \times(2 n-1)}{2^{n} \cdot n !} x^{2 n}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\frac{1}{1+x^{2}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(1-x^{2}+x^{4}-x^{6}+\cdots+(-1)^{n} x^{2 n}+\cdots\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\frac{1}{x-1}=-\frac{1}{1-x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\sum_{n=0}^{\infty} x^{n}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\frac{1}{2 x-1}=-\frac{1}{1-2 x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(-\sum_{n=0}^{\infty} 2^{n} x^{n}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\arctan x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\begin{array}{ll}=x-\frac{1}{3} x^{3}+\frac{1}{5} x^{5}-\cdots+(-1)^{n} \frac{x^{2 n+1}}{2 n+1}+\cdots &amp;amp; (-1 \leqslant x \leqslant 1) \\ =\sum_{n=0}^{\infty}(-1)^{n} \frac{x^{2 n+1}}{2 n+1} &amp;amp; (-1 \leqslant x \leqslant 1)\end{array}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="佩亚诺余项泰勒公式">佩亚诺余项泰勒公式&lt;/h5>
&lt;p>将定理的条件减弱为： 设&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>具有n阶导数，设x为&lt;span class="math inline">\(x_0\)&lt;/span>充分小邻域内的任意一点，则有&lt;span class="math inline">\(f(x)=f\left(x_{0}\right)+\frac{f^{\prime}\left(x_{0}\right)}{1 !}\left(x-x_{0}\right)+\cdots+\frac{f^{(n)}\left(x_{0}\right)}{n !}\left(x-x_{0}\right)^{n}+R_{n}(x)\)&lt;/span>，其中&lt;span class="math inline">\(R_{n}(x)=o\left(\left(x-x_{0}\right)^{n}\right)\)&lt;/span>，整个公式称为&lt;strong>佩亚诺余项泰勒公式&lt;/strong>。&lt;/p>
&lt;p>常见的&lt;a href="#泰勒公式（佩亚诺余项式）">泰勒公式（佩亚诺余项式）&lt;/a>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200329183215654.png" alt="" />&lt;figcaption>image-20200329183215654&lt;/figcaption>
&lt;/figure>
&lt;h3 id="已知函数可导证明不等式">已知函数可导证明不等式&lt;/h3>
&lt;p>前提条件：设&lt;span class="math inline">\(f(x)\)&lt;/span>与&lt;span class="math inline">\(g(x)\)&lt;/span>在区间&lt;span class="math inline">\((a,b)\)&lt;/span>可导 用微分学证明不等式：在此区间内&lt;span class="math inline">\(f(x) \geqslant g(x)\)&lt;/span>或者&lt;span class="math inline">\(f(x)&amp;gt;g(x)\)&lt;/span>&lt;/p>
&lt;p>先命&lt;span class="math inline">\(\varphi(x)=f(x)-g(x)\)&lt;/span>，然后用下列方法之一或者联合运用来证明&lt;/p>
&lt;h5 id="用单调性证明">用单调性证明&lt;/h5>
&lt;p>若&lt;span class="math inline">\(\varphi(x)=f(x)-g(x)\)&lt;/span>单调增加，且左端点处值大于等于0，则&lt;span class="math inline">\(\varphi(x)=f(x)-g(x) \ge 0\)&lt;/span>恒成立。 同理可证其他情况。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200330112250913.png" alt="" />&lt;figcaption>image-20200330112250913&lt;/figcaption>
&lt;/figure>
&lt;h5 id="用最值证明">用最值证明&lt;/h5>
&lt;p>若在&lt;span class="math inline">\((a,b)\)&lt;/span>内，&lt;span class="math inline">\(\varphi (x)\)&lt;/span>有最小值大于0，则在&lt;span class="math inline">\((a,b)\)&lt;/span>内恒有&lt;span class="math inline">\(\varphi (x) \gt 0\)&lt;/span>. 若&lt;span class="math inline">\(\varphi (x)\)&lt;/span>有最小值等于0则在&lt;span class="math inline">\((a,b)\)&lt;/span>内恒有&lt;span class="math inline">\(\varphi (x) \ge 0\)&lt;/span>。&lt;/p>
&lt;p>类似可用最大值可证小于，小于等于的情况。&lt;/p>
&lt;h5 id="用拉格朗日中值公式证明">用拉格朗日中值公式证明&lt;/h5>
&lt;p>如果题目求证&lt;span class="math inline">\(f(b)-f(a)&amp;gt;A(b-a)\)&lt;/span>，常想到拉格朗日中值定理：&lt;span class="math inline">\(f(b)-f(a)=f^{\prime}(\xi)(b-a)\)&lt;/span>。 只要去证&lt;span class="math inline">\(f^{\prime}(\xi)&amp;gt;A\)&lt;/span>，则原式得证。&lt;/p>
&lt;p>同理可证&lt;span class="math inline">\(f(b)-f(a)&amp;lt;A(b-a)\)&lt;/span>&lt;/p>
&lt;h5 id="用拉格朗日余项泰勒公式证明">用拉格朗日余项泰勒公式证明&lt;/h5>
&lt;p>如果&lt;span class="math inline">\(f^{\prime \prime}(x)\)&lt;/span>存在且（大于0或者小于0），想到1阶拉格朗日余项泰勒公式：&lt;span class="math inline">\(f(x)=f\left(x_{0}\right)+\frac{1}{1!} f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{1}{2 !} f^{\prime \prime}(\xi)\left(x-x_{0}\right)^{2}\)&lt;/span>。 证明的关键是展开位置&lt;span class="math inline">\(x_0\)&lt;/span>的确定。&lt;/p>
&lt;p>如果&lt;span class="math inline">\(f^{\prime \prime}(x)\)&lt;/span>存在且（大于0或者小于0），也可能使用两次拉格朗日中值定理（0阶拉格朗日余项泰勒公式）：&lt;span class="math inline">\(f(x)=f\left(x_{0}\right)+\frac{1}{1!} f^{\prime}\left(\xi\right)\left(x-x_{0}\right)\)&lt;/span>&lt;/p>
&lt;p>如果为更高阶导数存在（且大于0或小于0），那么想到将&lt;span class="math inline">\(f(x)\)&lt;/span>展开至更高阶。&lt;/p>
&lt;h3 id="存在零点及零点个数的证明">存在零点及零点个数的证明&lt;/h3>
&lt;h4 id="零点是否存在的证明">零点是否存在的证明&lt;/h4>
&lt;h5 id="由连续函数介值定理或零点定理证明">由&lt;a href="#闭区间上连续函数的性质">连续函数介值定理或零点定理&lt;/a>证明&lt;/h5>
&lt;h5 id="由罗尔定理证明">由&lt;a href="#罗尔定理">罗尔定理&lt;/a>证明&lt;/h5>
&lt;p>&lt;a href="#罗尔定理">罗尔定理&lt;/a>&lt;/p>
&lt;p>罗尔定理关于零点的推论：设以下所提到的导数存在，则有结论：如果&lt;span class="math inline">\(f(x)\)&lt;/span>有&lt;span class="math inline">\(k(k\ge 2)\)&lt;/span>个零点，则&lt;span class="math inline">\(f^\prime (x)\)&lt;/span>至少有(k-1)个零点，…,&lt;span class="math inline">\(f^{(k-1)}(x)\)&lt;/span>至少有1个零点。&lt;/p>
&lt;h4 id="至多有几个零点的证明">至多有几个零点的证明&lt;/h4>
&lt;p>设以下所提到的导数存在，则有结论： 如果&lt;span class="math inline">\(f^{\prime}(x)\)&lt;/span>没有零点，则&lt;span class="math inline">\(f(x)\)&lt;/span>至多有1个零点； 如果&lt;span class="math inline">\(f^{\prime}(x)\)&lt;/span>最多1个零点，则&lt;span class="math inline">\(f(x)\)&lt;/span>至多有2个零点； 如果&lt;span class="math inline">\(f^{\prime}(x)\)&lt;/span>最多k个零点，则&lt;span class="math inline">\(f(x)\)&lt;/span>至多有k+1个零点； 如果&lt;span class="math inline">\(f^{\prime \prime}(x)\)&lt;/span>没有零点，则&lt;span class="math inline">\(f^{\prime}(x)\)&lt;/span>最多1个零点，&lt;span class="math inline">\(f(x)\)&lt;/span>最多2个零点。。。。&lt;/p></description></item><item><title>高等数学-一元微分学-可导函数的中值定理习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-可导函数的中值定理习题">高等数学-一元微分学-可导函数的中值定理习题&lt;/h1>
&lt;h2 id="考察中值定理的定义">考察中值定理的定义&lt;/h2>
&lt;h3 id="考察罗尔定理的定义">考察罗尔定理的定义&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419191223856.png" alt="" />&lt;figcaption>image-20200419191223856&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419191114818.png" alt="" />&lt;figcaption>image-20200419191114818&lt;/figcaption>
&lt;/figure>
&lt;h3 id="考察拉格朗日中值定理定义">考察拉格朗日中值定理定义&lt;/h3>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419194020246.png" alt="" />&lt;figcaption>image-20200419194020246&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419194350114.png" alt="" />&lt;figcaption>image-20200419194350114&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419195057298.png" alt="" />&lt;figcaption>image-20200419195057298&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419195136725.png" alt="" />&lt;figcaption>image-20200419195136725&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419195152638.png" alt="" />&lt;figcaption>image-20200419195152638&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420195449158.png" alt="" />&lt;figcaption>image-20200420195449158&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420195433746.png" alt="" />&lt;figcaption>image-20200420195433746&lt;/figcaption>
&lt;/figure>
&lt;p>其实这道题就是求极限，没考察中值定理&lt;/p>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224321957.png" alt="" />&lt;figcaption>image-20200420224321957&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224306297.png" alt="" />&lt;figcaption>image-20200420224306297&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421151721709.png" alt="" />&lt;figcaption>image-20200421151721709&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421151648390.png" alt="" />&lt;figcaption>image-20200421151648390&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421151707394.png" alt="" />&lt;figcaption>image-20200421151707394&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421194140003.png" alt="" />&lt;figcaption>image-20200421194140003&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421194123394.png" alt="" />&lt;figcaption>image-20200421194123394&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421210050736.png" alt="" />&lt;figcaption>image-20200421210050736&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421210034865.png" alt="" />&lt;figcaption>image-20200421210034865&lt;/figcaption>
&lt;/figure>
&lt;h3 id="考察泰勒定理">考察泰勒定理&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419200751777.png" alt="" />&lt;figcaption>image-20200419200751777&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419200728386.png" alt="" />&lt;figcaption>image-20200419200728386&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420110500021.png" alt="" />&lt;figcaption>image-20200420110500021&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420110442108.png" alt="" />&lt;figcaption>image-20200420110442108&lt;/figcaption>
&lt;/figure>
&lt;p>分母也可使用泰勒展开替换&lt;/p>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420111856720.png" alt="" />&lt;figcaption>image-20200420111856720&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420111915216.png" alt="" />&lt;figcaption>image-20200420111915216&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420111931538.png" alt="" />&lt;figcaption>image-20200420111931538&lt;/figcaption>
&lt;/figure>
&lt;p>其实此题不用泰勒展开，多次使用洛必达法则，也可求出a和b，而且更简单&lt;/p>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420115526420.png" alt="" />&lt;figcaption>image-20200420115526420&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420115505603.png" alt="" />&lt;figcaption>image-20200420115505603&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421210709905.png" alt="" />&lt;figcaption>image-20200421210709905&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421210619877.png" alt="" />&lt;figcaption>image-20200421210619877&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421210647408.png" alt="" />&lt;figcaption>image-20200421210647408&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求证存在xi使等式成立">求证存在&lt;span class="math inline">\(\xi\)&lt;/span>使等式成立&lt;/h2>
&lt;h3 id="求证fnxi0">求证&lt;span class="math inline">\(f^{(n)}(\xi)=0\)&lt;/span>&lt;/h3>
&lt;p>一般会用到罗尔定理&lt;/p>
&lt;h4 id="找多个相同值点多次使用罗尔定理">找多个相同值点，多次使用罗尔定理&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417134624096.png" alt="" />&lt;figcaption>image-20200417134624096&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417134756621.png" alt="" />&lt;figcaption>image-20200417134756621&lt;/figcaption>
&lt;/figure>
&lt;p>本题使用2次零点定理+罗尔定理证明&lt;/p>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417135300981.png" alt="" />&lt;figcaption>image-20200417135300981&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417140421456.png" alt="" />&lt;figcaption>image-20200417140421456&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417140650913.png" alt="" />&lt;figcaption>image-20200417140650913&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417141636783.png" alt="" />&lt;figcaption>image-20200417141636783&lt;/figcaption>
&lt;/figure>
&lt;p>介值定理+罗尔定理得两个等值点，再用一次罗尔定理证明 函数值相加要想到用介值定理&lt;/p>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417150456153.png" alt="" />&lt;figcaption>image-20200417150456153&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417150429213.png" alt="" />&lt;figcaption>image-20200417150429213&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419225623647.png" alt="" />&lt;figcaption>image-20200419225623647&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419225701750.png" alt="" />&lt;figcaption>image-20200419225701750&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420095404906.png" alt="" />&lt;figcaption>image-20200420095404906&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420095349655.png" alt="" />&lt;figcaption>image-20200420095349655&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求证仅含xi的等式">求证仅含&lt;span class="math inline">\(\xi\)&lt;/span>的等式&lt;/h3>
&lt;p>即求证仅包含&lt;span class="math inline">\(\xi\)&lt;/span>不包含其他字母的等式&lt;/p>
&lt;p>一般方法包括&lt;strong>积分还原法&lt;/strong>和&lt;strong>微分方程法&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/33271753">微分中值定理证明题中构造辅助函数的方法&lt;/a>&lt;/p>
&lt;h4 id="积分还原法求证仅xi的等式">积分还原法求证仅&lt;span class="math inline">\(\xi\)&lt;/span>的等式&lt;/h4>
&lt;h5 id="左侧可化为fracfprimexfxln-fxprime的式子">左侧可化为&lt;span class="math inline">\(\frac{f^{\prime}(x)}{f(x)}=[\ln f(x)]^{\prime}\)&lt;/span>的式子&lt;/h5>
&lt;p>一般要求要证的式子包含一个函数及其导数（&lt;strong>差一阶&lt;/strong>），有些可以变换到求证&lt;span class="math inline">\(\frac{f^{\prime}(x)}{f(x)}=\cdot \cdot \cdot\)&lt;/span>的形式，我们可以将左右都看作是函数的导数。&lt;/p>
&lt;p>而&lt;span class="math inline">\(\frac{f^{\prime}(x)}{f(x)}=[\ln f(x)]^{\prime}\)&lt;/span>，即证&lt;span class="math inline">\([\ln f(x)]^{\prime}-[balabala]^{\prime}=0\)&lt;/span>, 即证&lt;span class="math inline">\(\{\ln [f(x) \cdot balabala] \}^{\prime}=0\)&lt;/span>。&lt;/p>
&lt;p>则我们一般可以取辅助函数&lt;span class="math inline">\(\phi (x) = \ln [f(x) \cdot balabala\)&lt;/span>来求证。&lt;/p>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417173651484.png" alt="" />&lt;figcaption>image-20200417173651484&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417173758475.png" alt="" />&lt;figcaption>image-20200417173758475&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417173938459.png" alt="" />&lt;figcaption>image-20200417173938459&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417195732919.png" alt="" />&lt;figcaption>image-20200417195732919&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417195827982.png" alt="" />&lt;figcaption>image-20200417195827982&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417200632830.png" alt="" />&lt;figcaption>image-20200417200632830&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417200930439.png" alt="" />&lt;figcaption>image-20200417200930439&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417201031243.png" alt="" />&lt;figcaption>image-20200417201031243&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417201129388.png" alt="" />&lt;figcaption>image-20200417201129388&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420091719475.png" alt="" />&lt;figcaption>image-20200420091719475&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420091737995.png" alt="" />&lt;figcaption>image-20200420091737995&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420100144941.png" alt="" />&lt;figcaption>image-20200420100144941&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420100203236.png" alt="" />&lt;figcaption>image-20200420100203236&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420100219163.png" alt="" />&lt;figcaption>image-20200420100219163&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421120216621.png" alt="" />&lt;figcaption>image-20200421120216621&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421120237517.png" alt="" />&lt;figcaption>image-20200421120237517&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421162121240.png" alt="" />&lt;figcaption>image-20200421162121240&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421162134466.png" alt="" />&lt;figcaption>image-20200421162134466&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421162101282.png" alt="" />&lt;figcaption>image-20200421162101282&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421163921890.png" alt="" />&lt;figcaption>image-20200421163921890&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421163905819.png" alt="" />&lt;figcaption>image-20200421163905819&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422112237034.png" alt="" />&lt;figcaption>image-20200422112237034&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422112202616.png" alt="" />&lt;figcaption>image-20200422112202616&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422113633153.png" alt="" />&lt;figcaption>image-20200422113633153&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422113714619.png" alt="" />&lt;figcaption>image-20200422113714619&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422113734732.png" alt="" />&lt;figcaption>image-20200422113734732&lt;/figcaption>
&lt;/figure>
&lt;h5 id="找其他原函数">找其他原函数&lt;/h5>
&lt;p>变为&lt;code>式子=0&lt;/code>的形式，式子左侧作为函数，试着积分，可解的的话，就可作为辅助函数。&lt;/p>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421155838520.png" alt="" />&lt;figcaption>image-20200421155838520&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421155825050.png" alt="" />&lt;figcaption>image-20200421155825050&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421171654698.png" alt="" />&lt;figcaption>image-20200421171654698&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421171619179.png" alt="" />&lt;figcaption>image-20200421171619179&lt;/figcaption>
&lt;/figure>
&lt;h4 id="微分方程法">微分方程法&lt;/h4>
&lt;p>将要证的方程看作微分方程，解出函数的形式，作为辅助函数。&lt;/p>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420102643447.png" alt="" />&lt;figcaption>image-20200420102643447&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420102659501.png" alt="" />&lt;figcaption>image-20200420102659501&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421154812481.png" alt="" />&lt;figcaption>image-20200421154812481&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421154745450.png" alt="" />&lt;figcaption>image-20200421154745450&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求证含xi和a与b的等式">求证含&lt;span class="math inline">\(\xi\)&lt;/span>和a与b的等式&lt;/h3>
&lt;p>这里&lt;strong>a,b指区间端点&lt;/strong>，一般是在[a,b]上连续，在(a,b)上可导&lt;/p>
&lt;h4 id="ab与xi可分离">a，b与&lt;span class="math inline">\(\xi\)&lt;/span>可分离&lt;/h4>
&lt;p>若a，b侧有如下形式，则使用对应的方法求解&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-04-17%20201716.png" alt="" />&lt;figcaption>批注 2020-04-17 201716&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417202303061.png" alt="" />&lt;figcaption>image-20200417202303061&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417202354879.png" alt="" />&lt;figcaption>image-20200417202354879&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417202625491.png" alt="" />&lt;figcaption>image-20200417202625491&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417204213695.png" alt="" />&lt;figcaption>image-20200417204213695&lt;/figcaption>
&lt;/figure>
&lt;h4 id="ab与xi不可分离">a，b与&lt;span class="math inline">\(\xi\)&lt;/span>不可分离&lt;/h4>
&lt;p>&lt;span class="math inline">\(\xi\)&lt;/span>变为x，去分母，移项，变为&lt;code>式子=0&lt;/code>, 将其看作&lt;code>(?)'=0&lt;/code>，以？部分作辅助函数来证明&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417204924273.png" alt="" />&lt;figcaption>image-20200417204924273&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417205042765.png" alt="" />&lt;figcaption>image-20200417205042765&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200417205218979.png" alt="" />&lt;figcaption>image-20200417205218979&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421163135029.png" alt="" />&lt;figcaption>image-20200421163135029&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421163036916.png" alt="" />&lt;figcaption>image-20200421163036916&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421163100435.png" alt="" />&lt;figcaption>image-20200421163100435&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求证存在xi和eta使等式成立">求证存在&lt;span class="math inline">\(\xi\)&lt;/span>和&lt;span class="math inline">\(\eta\)&lt;/span>使等式成立&lt;/h2>
&lt;h3 id="仅有fprimexi-fprimeeta">仅有&lt;span class="math inline">\(f^{\prime}(\xi), f^{\prime}(\eta)\)&lt;/span>&lt;/h3>
&lt;p>方法是找3个点，使用2次拉格朗日中值定理&lt;/p>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418142509820.png" alt="" />&lt;figcaption>image-20200418142509820&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418143040335.png" alt="" />&lt;figcaption>image-20200418143040335&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418143150291.png" alt="" />&lt;figcaption>image-20200418143150291&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418143719247.png" alt="" />&lt;figcaption>image-20200418143719247&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418143808660.png" alt="" />&lt;figcaption>image-20200418143808660&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418143844591.png" alt="" />&lt;figcaption>image-20200418143844591&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421191400095.png" alt="" />&lt;figcaption>image-20200421191400095&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421191417002.png" alt="" />&lt;figcaption>image-20200421191417002&lt;/figcaption>
&lt;/figure>
&lt;h3 id="xieta复杂度不同">&lt;span class="math inline">\(\xi,\eta\)&lt;/span>复杂度不同&lt;/h3>
&lt;p>方法：留下偏复杂一部分，凑成某式的导数，用拉格朗日中值定理；或者凑成连个两个导数的比值，用柯西中值定理。&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418144323608.png" alt="" />&lt;figcaption>image-20200418144323608&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418144520471.png" alt="" />&lt;figcaption>image-20200418144520471&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418144729966.png" alt="" />&lt;figcaption>image-20200418144729966&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418144833788.png" alt="" />&lt;figcaption>image-20200418144833788&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418144932552.png" alt="" />&lt;figcaption>image-20200418144932552&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418145022666.png" alt="" />&lt;figcaption>image-20200418145022666&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418145124271.png" alt="" />&lt;figcaption>image-20200418145124271&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418145212288.png" alt="" />&lt;figcaption>image-20200418145212288&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420105317475.png" alt="" />&lt;figcaption>image-20200420105317475&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420104915669.png" alt="" />&lt;figcaption>image-20200420104915669&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421193128025.png" alt="" />&lt;figcaption>image-20200421193128025&lt;/figcaption>
&lt;/figure>
&lt;p>&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421193027903.png" alt="image-20200421193027903" />&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421193049924.png" alt="image-20200421193049924" />&lt;/p>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;p>这题第二问要想到使用第一问的结论&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422115052225.png" alt="" />&lt;figcaption>image-20200422115052225&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422115033884.png" alt="" />&lt;figcaption>image-20200422115033884&lt;/figcaption>
&lt;/figure>
&lt;h2 id="求证存在epsilonxieta使等式成立">求证存在&lt;span class="math inline">\(\epsilon,\xi,\eta\)&lt;/span>使等式成立&lt;/h2>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421143911960.png" alt="" />&lt;figcaption>image-20200421143911960&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421143943207.png" alt="" />&lt;figcaption>image-20200421143943207&lt;/figcaption>
&lt;/figure>
&lt;h2 id="拉格朗日中值定理使用">拉格朗日中值定理使用&lt;/h2>
&lt;h3 id="出现fb-fa想到使用拉格朗日中值定理">出现&lt;span class="math inline">\(f(b)-f(a)\)&lt;/span>想到使用拉格朗日中值定理&lt;/h3>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418152102250.png" alt="" />&lt;figcaption>image-20200418152102250&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418152203402.png" alt="" />&lt;figcaption>image-20200418152203402&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418152329175.png" alt="" />&lt;figcaption>image-20200418152329175&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418152406592.png" alt="" />&lt;figcaption>image-20200418152406592&lt;/figcaption>
&lt;/figure>
&lt;h3 id="出现fa-fc-fb-想到使用2次拉格朗日中值定理">出现&lt;span class="math inline">\(f(a), f(c), f(b)\)&lt;/span> 想到使用2次拉格朗日中值定理&lt;/h3>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418152916469.png" alt="" />&lt;figcaption>image-20200418152916469&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418155808392.png" alt="" />&lt;figcaption>image-20200418155808392&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418160135906.png" alt="" />&lt;figcaption>image-20200418160135906&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418160302541.png" alt="" />&lt;figcaption>image-20200418160302541&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200418160344460.png" alt="" />&lt;figcaption>image-20200418160344460&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419185922277.png" alt="" />&lt;figcaption>image-20200419185922277&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419185949907.png" alt="" />&lt;figcaption>image-20200419185949907&lt;/figcaption>
&lt;/figure>
&lt;h2 id="不等式的证明">不等式的证明&lt;/h2>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421204048417.png" alt="" />&lt;figcaption>image-20200421204048417&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421204128250.png" alt="" />&lt;figcaption>image-20200421204128250&lt;/figcaption>
&lt;/figure>
&lt;p>其实设&lt;span class="math inline">\(f(x)=x,g(x)=ln(x)\)&lt;/span>用柯西中值定理来做也简单。&lt;/p></description></item><item><title>高等数学-一元微分学-导数的应用-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-导数的应用-单调性与极值">高等数学-一元微分学-导数的应用-单调性与极值&lt;/h1>
&lt;h2 id="单调性与极值">单调性与极值&lt;/h2>
&lt;h3 id="取得极值求参数">取得极值求参数&lt;/h3>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421003426239.png" alt="" />&lt;figcaption>image-20200421003426239&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421003408417.png" alt="" />&lt;figcaption>image-20200421003408417&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求函数极值最值拐点">求函数极值最值拐点&lt;/h3>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419195708739.png" alt="" />&lt;figcaption>image-20200419195708739&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419195723861.png" alt="" />&lt;figcaption>image-20200419195723861&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419200119412.png" alt="" />&lt;figcaption>image-20200419200119412&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419200408718.png" alt="" />&lt;figcaption>image-20200419200408718&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421215552152.png" alt="" />&lt;figcaption>image-20200421215552152&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421215539424.png" alt="" />&lt;figcaption>image-20200421215539424&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421223721753.png" alt="" />&lt;figcaption>image-20200421223721753&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421223647790.png" alt="" />&lt;figcaption>image-20200421223647790&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421223707139.png" alt="" />&lt;figcaption>image-20200421223707139&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421234610269.png" alt="" />&lt;figcaption>image-20200421234610269&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421234549317.png" alt="" />&lt;figcaption>image-20200421234549317&lt;/figcaption>
&lt;/figure>
&lt;h3 id="不等式的证明">不等式的证明&lt;/h3>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419105526487.png" alt="" />&lt;figcaption>image-20200419105526487&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419105612557.png" alt="" />&lt;figcaption>image-20200419105612557&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419105817774.png" alt="" />&lt;figcaption>image-20200419105817774&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419110336084.png" alt="" />&lt;figcaption>image-20200419110336084&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419110432991.png" alt="" />&lt;figcaption>image-20200419110432991&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111217580.png" alt="" />&lt;figcaption>image-20200419111217580&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111349386.png" alt="" />&lt;figcaption>image-20200419111349386&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111417677.png" alt="" />&lt;figcaption>image-20200419111417677&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111515417.png" alt="" />&lt;figcaption>image-20200419111515417&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111621331.png" alt="" />&lt;figcaption>image-20200419111621331&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111738948.png" alt="" />&lt;figcaption>image-20200419111738948&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111823189.png" alt="" />&lt;figcaption>image-20200419111823189&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419111854517.png" alt="" />&lt;figcaption>image-20200419111854517&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420133940016.png" alt="" />&lt;figcaption>image-20200420133940016&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420134002071.png" alt="" />&lt;figcaption>image-20200420134002071&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421211229118.png" alt="" />&lt;figcaption>image-20200421211229118&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421211213122.png" alt="" />&lt;figcaption>image-20200421211213122&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421212306546.png" alt="" />&lt;figcaption>image-20200421212306546&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421212244606.png" alt="" />&lt;figcaption>image-20200421212244606&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421212720592.png" alt="" />&lt;figcaption>image-20200421212720592&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421212704141.png" alt="" />&lt;figcaption>image-20200421212704141&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421230538382.png" alt="" />&lt;figcaption>image-20200421230538382&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421230518064.png" alt="" />&lt;figcaption>image-20200421230518064&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421232406926.png" alt="" />&lt;figcaption>image-20200421232406926&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421232344310.png" alt="" />&lt;figcaption>image-20200421232344310&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421233509457.png" alt="" />&lt;figcaption>image-20200421233509457&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421233445561.png" alt="" />&lt;figcaption>image-20200421233445561&lt;/figcaption>
&lt;/figure>
&lt;h3 id="方程根的讨论">方程根的讨论&lt;/h3>
&lt;h4 id="零点定理证明方程有根">零点定理证明方程有根&lt;/h4>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419112411767.png" alt="" />&lt;figcaption>image-20200419112411767&lt;/figcaption>
&lt;/figure>
&lt;h4 id="罗尔定理加原函数证明方程有根">罗尔定理加原函数证明方程有根&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419112651426.png" alt="" />&lt;figcaption>image-20200419112651426&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419112806674.png" alt="" />&lt;figcaption>image-20200419112806674&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419112837164.png" alt="" />&lt;figcaption>image-20200419112837164&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419112910603.png" alt="" />&lt;figcaption>image-20200419112910603&lt;/figcaption>
&lt;/figure>
&lt;h4 id="单调法求方程根的数目">单调法求方程根的数目&lt;/h4>
&lt;ul>
&lt;li>设立函数，关注定义域&lt;/li>
&lt;li>找出驻点和不可导点，考察这些点处的值&lt;/li>
&lt;li>关注区间两侧，做草图&lt;/li>
&lt;/ul>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114101538.png" alt="" />&lt;figcaption>image-20200419114101538&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114230396.png" alt="" />&lt;figcaption>image-20200419114230396&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114257690.png" alt="" />&lt;figcaption>image-20200419114257690&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114323890.png" alt="" />&lt;figcaption>image-20200419114323890&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114404601.png" alt="" />&lt;figcaption>image-20200419114404601&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419114626282.png" alt="" />&lt;figcaption>image-20200419114626282&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422004431575.png" alt="" />&lt;figcaption>image-20200422004431575&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422004417498.png" alt="" />&lt;figcaption>image-20200422004417498&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422004808801.png" alt="" />&lt;figcaption>image-20200422004808801&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422004739575.png" alt="" />&lt;figcaption>image-20200422004739575&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422004756135.png" alt="" />&lt;figcaption>image-20200422004756135&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422105544816.png" alt="" />&lt;figcaption>image-20200422105544816&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422105531412.png" alt="" />&lt;figcaption>image-20200422105531412&lt;/figcaption>
&lt;/figure>
&lt;h4 id="已知方程根数目求参数的范围">已知方程根数目求参数的范围&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420121227949.png" alt="" />&lt;figcaption>image-20200420121227949&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420121202318.png" alt="" />&lt;figcaption>image-20200420121202318&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420223346656.png" alt="" />&lt;figcaption>image-20200420223346656&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420223327541.png" alt="" />&lt;figcaption>image-20200420223327541&lt;/figcaption>
&lt;/figure>
&lt;h3 id="函数极值点的判定">函数极值点的判定&lt;/h3>
&lt;ul>
&lt;li>设立函数，关注定义域&lt;/li>
&lt;li>找出驻点和不可导点&lt;/li>
&lt;li>极值点的判别法
&lt;ul>
&lt;li>第一判别法：一阶导数左边大于0右边小于0，极大值&lt;/li>
&lt;li>第二判别法：二阶导数小于0，极大值&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120525676.png" alt="" />&lt;figcaption>image-20200419120525676&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120600695.png" alt="" />&lt;figcaption>image-20200419120600695&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120619583.png" alt="" />&lt;figcaption>image-20200419120619583&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120740848.png" alt="" />&lt;figcaption>image-20200419120740848&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120833477.png" alt="" />&lt;figcaption>image-20200419120833477&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419120906304.png" alt="" />&lt;figcaption>image-20200419120906304&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419121043544.png" alt="" />&lt;figcaption>image-20200419121043544&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419121155925.png" alt="" />&lt;figcaption>image-20200419121155925&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419121249527.png" alt="" />&lt;figcaption>image-20200419121249527&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419121336818.png" alt="" />&lt;figcaption>image-20200419121336818&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420210515185.png" alt="" />&lt;figcaption>image-20200420210515185&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420210441704.png" alt="" />&lt;figcaption>image-20200420210441704&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420222151454.png" alt="" />&lt;figcaption>image-20200420222151454&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420222110963.png" alt="" />&lt;figcaption>image-20200420222110963&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420222133567.png" alt="" />&lt;figcaption>image-20200420222133567&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224050066.png" alt="" />&lt;figcaption>image-20200420224050066&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224032845.png" alt="" />&lt;figcaption>image-20200420224032845&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224820402.png" alt="" />&lt;figcaption>image-20200420224820402&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420224803435.png" alt="" />&lt;figcaption>image-20200420224803435&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421000705445.png" alt="" />&lt;figcaption>image-20200421000705445&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421000637031.png" alt="" />&lt;figcaption>image-20200421000637031&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421002732769.png" alt="" />&lt;figcaption>image-20200421002732769&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421002713453.png" alt="" />&lt;figcaption>image-20200421002713453&lt;/figcaption>
&lt;/figure>
&lt;h3 id="凹凸性或拐点的判定">凹凸性或拐点的判定&lt;/h3>
&lt;p>二阶导数与0的比较判断凹凸性&lt;/p>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132232287.png" alt="" />&lt;figcaption>image-20200419132232287&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132359015.png" alt="" />&lt;figcaption>image-20200419132359015&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132543609.png" alt="" />&lt;figcaption>image-20200419132543609&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132619855.png" alt="" />&lt;figcaption>image-20200419132619855&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132646963.png" alt="" />&lt;figcaption>image-20200419132646963&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419132736921.png" alt="" />&lt;figcaption>image-20200419132736921&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419133037795.png" alt="" />&lt;figcaption>image-20200419133037795&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419134810917.png" alt="" />&lt;figcaption>image-20200419134810917&lt;/figcaption>
&lt;/figure>
&lt;p>同理，x1，x2也是拐点&lt;/p>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420211117238.png" alt="" />&lt;figcaption>image-20200420211117238&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420211103328.png" alt="" />&lt;figcaption>image-20200420211103328&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421003114473.png" alt="" />&lt;figcaption>image-20200421003114473&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421003056157.png" alt="" />&lt;figcaption>image-20200421003056157&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422120254671.png" alt="" />&lt;figcaption>image-20200422120254671&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422120242960.png" alt="" />&lt;figcaption>image-20200422120242960&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求函数渐近线">求函数渐近线&lt;/h3>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419142633183.png" alt="" />&lt;figcaption>image-20200419142633183&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419144107200.png" alt="" />&lt;figcaption>image-20200419144107200&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419144232633.png" alt="" />&lt;figcaption>image-20200419144232633&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419222130464.png" alt="" />&lt;figcaption>image-20200419222130464&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200419222110214.png" alt="" />&lt;figcaption>image-20200419222110214&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420122142599.png" alt="" />&lt;figcaption>image-20200420122142599&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420122128178.png" alt="" />&lt;figcaption>image-20200420122128178&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420222837617.png" alt="" />&lt;figcaption>image-20200420222837617&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200420222805112.png" alt="" />&lt;figcaption>image-20200420222805112&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421115714521.png" alt="" />&lt;figcaption>image-20200421115714521&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421115659052.png" alt="" />&lt;figcaption>image-20200421115659052&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421224917390.png" alt="" />&lt;figcaption>image-20200421224917390&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200421225234846.png" alt="" />&lt;figcaption>image-20200421225234846&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422104544611.png" alt="" />&lt;figcaption>image-20200422104544611&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200422104605915.png" alt="" />&lt;figcaption>image-20200422104605915&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元微分学-导数和微分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/</link><pubDate>Wed, 11 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微分学-导数和微分">高等数学-一元微分学-导数和微分&lt;/h1>
&lt;h3 id="概念定理和公式">概念定理和公式&lt;/h3>
&lt;h4 id="导数与微分定义">导数与微分定义&lt;/h4>
&lt;h5 id="导数与可导定义">导数与可导定义&lt;/h5>
&lt;p>设函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>的邻域内有定义，&lt;span class="math inline">\(f^{\prime}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)&lt;/span>，称函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>在点&lt;span class="math inline">\(x_0\)&lt;/span>处&lt;strong>可导&lt;/strong>，极限值称为&lt;strong>函数的导数&lt;/strong>&lt;/p>
&lt;p>还可以写成&lt;span class="math inline">\(x \rightarrow x_0\)&lt;/span>的等价定义（略）&lt;/p>
&lt;p>由于导数是根据极限定义的。则 &lt;span class="math inline">\(y=f(x)\)&lt;/span>在&lt;span class="math inline">\(x_0\)&lt;/span>处可导&lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(f_{-}^{\prime}\left(x_{0}\right)\)&lt;/span>和&lt;span class="math inline">\(f_{+}^{\prime}\left(x_{0}\right)\)&lt;/span>存在且相等&lt;/p>
&lt;p>&lt;strong>左导数&lt;/strong>：&lt;span class="math inline">\(f^{\prime}_{-}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0^{-}} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>右导数&lt;/strong>：&lt;span class="math inline">\(f^{\prime}_{+}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0^{+}} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)&lt;/span>&lt;/p>
&lt;h5 id="导数几何意义">导数几何意义&lt;/h5>
&lt;blockquote>
&lt;p>根据定义，导数是一个分式的极限，其中分子是函数在两点处的差值，分母是两点处的差值&lt;/p>
&lt;/blockquote>
&lt;p>函数在某点的导数，对应直角坐标系中曲线在该点处的斜率，即&lt;span class="math inline">\(\tan \alpha=f^{\prime}\left(x_{0}\right)\)&lt;/span>。&lt;/p>
&lt;h5 id="区间内可导与闭区间上可导">区间内可导与闭区间上可导&lt;/h5>
&lt;p>如果函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>在&lt;span class="math inline">\((a, b)\)&lt;/span>内每一点均可导，称函数在&lt;span class="math inline">\((a, b)\)&lt;/span>内可导； 如果函数在&lt;span class="math inline">\((a, b)\)&lt;/span>内可导，且在x=a和x=b分别具有右导数&lt;span class="math inline">\(f^{\prime}+(a)\)&lt;/span>和左导数&lt;span class="math inline">\(f^{\prime}-(b)\)&lt;/span>，则函数在&lt;span class="math inline">\([a, b]\)&lt;/span>上可导。&lt;/p>
&lt;h5 id="微分与可微定义">微分与可微定义&lt;/h5>
&lt;p>如果函数y=f（x）在点x处的某邻域内有定义， &lt;span class="math inline">\(\Delta y=A \Delta x+o(\Delta x)\)&lt;/span>， 称y=f(x)在x处&lt;strong>可微&lt;/strong>， 称&lt;span class="math inline">\(d y=d f(x)=A \Delta x\)&lt;/span>为f(x)在x处的&lt;strong>微分&lt;/strong>。&lt;/p>
&lt;p>又&lt;span class="math inline">\(f^{\prime}(x)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=A\)&lt;/span>，记&lt;span class="math inline">\(d x=\Delta x\)&lt;/span>，则&lt;strong>微分&lt;/strong>又可以写成&lt;span class="math inline">\(\mathrm{d} y=f^{\prime}(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;h4 id="导数与微分的重要定理与性质">导数与微分的重要定理与性质&lt;/h4>
&lt;p>（在某点处）导数存在 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 左导数与右导数都存在且相等&lt;/p>
&lt;p>（在某点处）可导 &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 连续&lt;/p>
&lt;p>（在某点处）可微 &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> 可导&lt;/p>
&lt;p>（在某点及其邻域）可导（且导数不为0） &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 反函数可导,即&lt;span class="math inline">\(\frac{d x}{d y}=\frac{1}{\frac{d y}{d x}}\)&lt;/span>,即&lt;span class="math inline">\(x^{\prime} (y) = \frac {1}{y^{\prime}(x)}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(d y=d f(x)=f^{\prime}(x) d x\)&lt;/span>&lt;/p>
&lt;p>可导的偶函数的导数是奇函数；可导的奇函数的导数是偶函数。&lt;/p>
&lt;h4 id="导数与微分运算法则">导数与微分运算法则&lt;/h4>
&lt;p>设&lt;span class="math inline">\(u=u(x), v=v(x)\)&lt;/span>均可导，则：&lt;/p>
&lt;p>&lt;span class="math inline">\((1)(u \pm v)^{\prime}=u^{\prime} \pm v^{\prime}, \quad d(u \pm v)=\mathrm{d} u \pm \mathrm{d} v\)&lt;/span> &lt;span class="math inline">\((2)(w v)^{\prime}=u v^{\prime}+u u^{\prime}, \quad d(u v)=u \mathrm{d} v+v \mathrm{d} u\)&lt;/span> &lt;span class="math inline">\((u v w)^{\prime}=u^{\prime} v w+u v^{\prime} w+u v w^\prime\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\((3)\left(\frac{u}{v}\right)^{\prime}=\frac{u u^{\prime}-u v^{\prime}}{v^{2}}(v \neq 0), \mathrm{d}\left(\frac{u}{v}\right)=\frac{v \mathrm{d} u-u \mathrm{d} v}{v^{2}} \quad(v \neq 0)\)&lt;/span>&lt;/p>
&lt;h4 id="导数公式与微分公式">导数公式与微分公式&lt;/h4>
&lt;table>
&lt;colgroup>
&lt;col style="width: 20%" />
&lt;col style="width: 37%" />
&lt;col style="width: 41%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;span class="math inline">\(y=c\)&lt;/span>&lt;/th>
&lt;th>&lt;span class="math inline">\(y^{\prime}=0\)&lt;/span>&lt;/th>
&lt;th>&lt;span class="math inline">\(d y=0\)&lt;/span>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=x^{\alpha}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=a x^{\alpha-1}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d} y=\alpha x^{\alpha-1} \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=a^{x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=a^{x} \ln a\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d} y=a^{x} \ln a d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\mathrm{e}^{x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\left(\mathrm{e}^{z}\right)^{\prime}=\mathrm{e}^{x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d}\left(\mathrm{e}^{x}\right)=\left\langle\mathrm{e}^{x}\right\rangle \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\log _{a} x, a&amp;gt;0, a \neq 1\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\frac{1}{x \ln a}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d y=\frac{1}{x \ln a} d x \quad(x&amp;gt;0)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\ln x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\((\ln x)^{\prime}=\frac{1}{x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\ln x)=\frac{1}{x} d x \quad(x&amp;gt;0)\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\sin x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\cos x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\sin x)=\cos x d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\cos x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=-\sin x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d}(\cos x)=-\sin x \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\tan x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\frac{1}{\cos ^{2} x}=\sec ^{2} x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d}(\tan x)=\sec ^{2} x \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\cot x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=-\frac{1}{\sin ^{2} x}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\cot x)=-\csc ^{2} x d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\sec x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\sec x \tan x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d}(\sec x)=\sec x \tan x \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\csc x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=-\csc x \cot x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\csc x)=-\csc x \cot x d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\arcsin x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\frac{1}{\sqrt{1-x^{2}}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\arcsin x)=\frac{1}{\sqrt{1-x^{2}}} d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\arccos x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=-\frac{1}{\sqrt{1-x^{2}}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\arccos x)=-\frac{1}{\sqrt{1-x^{2}}} d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(y=\arctan x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=\frac{1}{1+x^{2}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(d(\arctan x)=\frac{1}{1+x^{2}} d x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(y=\operatorname{arccot} x\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(y^{\prime}=-\frac{1}{1+x^{2}}\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\mathrm{d}(\operatorname{arccot} x)=-\frac{1}{1+x^{2}} \mathrm{d} x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="高阶导数定义与基本公式">高阶导数定义与基本公式&lt;/h4>
&lt;p>若y=f(x)的一阶导函数&lt;span class="math inline">\(f^{\prime}(x)\)&lt;/span>在x点可导，称y=f(x)在x点存在&lt;strong>二阶导函数&lt;/strong>&lt;span class="math inline">\(f^{\prime \prime}(x)=\lim _{\Delta x \rightarrow 0} \frac{f^{\prime}(x+\Delta x)-f^{\prime}(x)}{\Delta x}\)&lt;/span>。&lt;/p>
&lt;p>以此类推可得y=f(x)的&lt;strong>n阶导函数&lt;/strong>&lt;span class="math inline">\(f^{(n)}(x)=\lim _{\Delta x \rightarrow 0} \frac{f^{(n-1)}(x+\Delta x)-f^{(n-1)}(x)}{\Delta x}\)&lt;/span>&lt;/p>
&lt;h5 id="高阶导数公式">高阶导数公式&lt;/h5>
&lt;table>
&lt;colgroup>
&lt;col style="width: 65%" />
&lt;col style="width: 34%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;span class="math inline">\(\left( x^{m}\right)^{(n)}=m(m-1) \cdot \cdots \cdot(m-n+1) x^{m-n}\)&lt;/span>&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\left(a^{x}\right)^{(n)}=a^{x} \ln ^{n} a\)&lt;/span>&lt;/td>
&lt;td>&lt;span class="math inline">\(\left(e^{x}\right)^{(n)}=e^{z}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\((\ln x)^{(n)}=(-1)^{n-1} \frac{(n-1) !}{x^{n}}\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\((\sin k x)^{(n)}=k^{n} \sin \left(k x+n \cdot \frac{\pi}{2}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\((\cos k x)^{(n)}=k^{n} \cos \left(k x+n \cdot \frac{\pi}{2}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\((u v)^{(n)}=\sum_{i=0}^{n} C_{n}^{i} u^{(i)} v^{(n-i)}\)&lt;/span>&lt;/td>
&lt;td>即莱布尼兹高阶导数公式&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\left(\frac{1}{a x+b}\right)^{(n)} =\frac{(-1)^{n} m ! \cdot a^{n}}{(a x+b)^{n+1}}\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="求各种函数的导数方法">求各种函数的导数方法&lt;/h3>
&lt;h4 id="求复合导数的微分">求复合导数的微分&lt;/h4>
&lt;p>&lt;span class="math inline">\(\frac{d y}{d x}=\frac{d y}{d u} \cdot \frac{d u}{d x}\)&lt;/span>&lt;/p>
&lt;h4 id="求参数方程的导数和微分">求参数方程的导数和微分&lt;/h4>
&lt;p>&lt;span class="math inline">\(\frac{d y}{d x}=\frac{y^{\prime}(t)}{x^{\prime}(t)}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\begin{aligned} \frac{\mathrm{d}^{2} y}{\mathrm{d} x^{2}} &amp;amp;=\frac{\mathrm{d}}{\mathrm{d} x}\left(y^{\prime}\right)=\frac{\mathrm{d}}{\mathrm{d} x}\left(\frac{y^{\prime}(t)}{x^{\prime}(t)}\right)=\frac{\mathrm{d}}{\mathrm{d} t}\left(\frac{y^{\prime}(t)}{x^{\prime}(t)}\right) \cdot \frac{\mathrm{d} t}{\mathrm{d} x} \\ &amp;amp;=\frac{x^{\prime}(t) y^{\prime \prime}(t)-y^{\prime}(t) x^{\prime \prime}(t)}{\left[x^{\prime}(t)\right]^{2}} \cdot \frac{1}{x^{\prime}(t)}=\frac{x^{\prime}(t) y^{\prime \prime}(t)-y^{\prime}(t) x^{\prime \prime}(t)}{\left[x^{\prime}(t)\right]^{3}} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h4 id="求隐函数的导数和微分">求隐函数的导数和微分&lt;/h4>
&lt;p>三种方法：&lt;/p>
&lt;ul>
&lt;li>方程两边对x求导，注意y也是x的函数，方程两边分别作为复合函数求导&lt;/li>
&lt;li>公式法：对于&lt;span class="math inline">\(F(x, y)=0\)&lt;/span>，&lt;span class="math inline">\(\frac{\mathrm{d} y}{\mathrm{d} x}=-\frac{F_{x}^{\prime}(x, y)}{F_{y}^{\prime}(x, y)}\)&lt;/span>&lt;/li>
&lt;li>方程两边取微分（微分形式不变性），然后解出&lt;span class="math inline">\(\frac{d y}{d x}\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;h6 id="例2">例2&lt;/h6>
&lt;p>由隐函数组成的参数方程求导&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200411181622344.png" alt="" />&lt;figcaption>image-20200411181622344&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200411181723539.png" alt="" />&lt;figcaption>image-20200411181723539&lt;/figcaption>
&lt;/figure>
&lt;h4 id="求幂指函数的导数和微分">求幂指函数的导数和微分&lt;/h4>
&lt;p>&lt;span class="math inline">\(y=u(x)^{v(x)} \quad(u(x)&amp;gt;0, u(x) \neq 1) \quad \Rightarrow y=e^{v(x) \ln u(x)}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(y^{\prime}=\mathrm{e}^{\mathrm{v}(x) \ln x(x)}\left[v^{\prime}(x) \ln u(x)+v(x) \cdot \frac{u^{\prime}(x)}{u(x)}\right]\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(=u(x)^{v(x)}\left[v^{\prime}(x) \ln u(x)+v(x) \cdot \frac{u^{\prime}(x)}{u(x)}\right]\)&lt;/span>&lt;/p>
&lt;h4 id="表达式为若干因子连乘乘方开方或商形式函数的导数或微分">表达式为若干因子连乘、乘方、开方或商形式函数的导数或微分&lt;/h4>
&lt;p>一般用对数微分法（先对式子两边取对数，然后在等式的两边对x求导）&lt;/p>
&lt;p>例： &lt;span class="math inline">\(y=(x-2)^{2} \sqrt[3]{\frac{(x+3)^{2}\left(3-2 x^{2}\right)^{4}}{\left(1+x^{2}\right)\left(5-3 x^{3}\right)}}\)&lt;/span>，求y‘&lt;/p>
&lt;p>先化为分式指数幂形式：&lt;span class="math inline">\(y=(x-2)^{2}(x+3)^{\frac{2}{3}}\left(3-2 x^{2}\right)^{\frac{4}{3}}\left(1+x^{2}\right)^{-\frac{1}{3}} \cdot\left(5-3 x^{3}\right)^{-\frac{1}{3}}\)&lt;/span>&lt;/p>
&lt;p>式子两边取对数：&lt;span class="math inline">\(\ln y=2 \ln (x-2)+\frac{2}{3} \ln (x+3)+\frac{4}{3} \ln \left(3-2 x^{2}\right)-\frac{1}{3} \ln \left(1+x^{2}\right)-\frac{1}{3} \ln \left(5-3 x^{3}\right)\)&lt;/span>&lt;/p>
&lt;p>两边对x求导：&lt;span class="math inline">\(\frac{y^{\prime}}{y}=\frac{2}{x-2}+\frac{2}{3(x+3)}-\frac{16 x}{3\left(3-2 x^{2}\right)}-\frac{2 x}{3\left(1+x^{2}\right)}+\frac{3 x^{2}}{5-3 x^{3}}\)&lt;/span>&lt;/p>
&lt;p>代入y移项即可得最终结果&lt;/p>
&lt;h4 id="求分段函数的导数和微分">求分段函数的导数和微分&lt;/h4>
&lt;ul>
&lt;li>分段内与一般导数求法无异&lt;/li>
&lt;li>分界点处的导数用导数的定义求&lt;/li>
&lt;/ul>
&lt;h4 id="求绝对值函数的导数和微分">求绝对值函数的导数和微分&lt;/h4>
&lt;ul>
&lt;li>写成分段函数&lt;/li>
&lt;li>求分段函数的导数和微分&lt;/li>
&lt;/ul>
&lt;h4 id="求极限式表示的函数的导数和微分">求极限式表示的函数的导数和微分&lt;/h4>
&lt;ul>
&lt;li>先求极限，得到函数的分段表达式&lt;/li>
&lt;li>求分段函数的导数和微分&lt;/li>
&lt;/ul>
&lt;h4 id="求变限积分函数的导数和微分">求变限积分函数的导数和微分&lt;/h4>
&lt;p>如果函数&lt;span class="math inline">\(f(x)\)&lt;/span>在区间&lt;span class="math inline">\([a,b]\)&lt;/span>连续，对于变上限积分函数&lt;span class="math inline">\(\Phi(x)=\int_{a}^{x} f(t) d t\)&lt;/span>，它的导数&lt;span class="math inline">\(\Phi^{\prime}(x)=\frac{d}{d x} \int_{a}^{x} f(t) d t=f(x)\)&lt;/span>，或者&lt;span class="math inline">\(\mathrm{d} \Phi(x)=\mathrm{d} \int_{a}^{x} f(t) \mathrm{d} t=f(x) \mathrm{d} x\)&lt;/span>&lt;/p>
&lt;p>如果函数&lt;span class="math inline">\(f(x)\)&lt;/span>在区间&lt;span class="math inline">\([a,b]\)&lt;/span>连续，对于变下限积分函数&lt;span class="math inline">\(\Psi(x)=\int_{x}^{b} f(t) \mathrm{d} t\)&lt;/span>，它的导数&lt;span class="math inline">\(\Psi^{\prime}(x)=\frac{d}{d x} \int_{x}^{b} f(t) d t=-f(x)\)&lt;/span>，或者&lt;span class="math inline">\(\Phi^{\prime}(x)=\frac{d}{d x} \int_{x}^{b} f(t) d t=-f(x)\)&lt;/span>&lt;/p>
&lt;p>如果函数&lt;span class="math inline">\(f(x)\)&lt;/span>在区间&lt;span class="math inline">\([a,b]\)&lt;/span>连续，对于上下限都变的积分函数，它&lt;span class="math inline">\(\Phi(x)=\int_{g(x)}^{h(x)} f(t) d t\)&lt;/span>的导数是&lt;span class="math inline">\(\Phi^{\prime}(x)=f[h(x)] \cdot h^{\prime}(x)-f[g(x)] \cdot g^{\prime}(x)\)&lt;/span>&lt;/p>
&lt;p>&lt;a href="https://wenku.baidu.com/view/494e991fa76e58fafab003b2.html">变限积分函数求导方法研究&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://www.saikr.com/u/5447502">高航&lt;/a> 变限积分上求导：https://www.saikr.com/a/2774&lt;/p>
&lt;h3 id="讨论分界点处的导数和微分">讨论分界点处的导数和微分&lt;/h3>
&lt;h5 id="求分段函数分界点的导数和微分">求分段函数分界点的导数和微分&lt;/h5>
&lt;p>用导数的定义来看&lt;/p>
&lt;h5 id="带绝对值函数分界点的导数和微分">带绝对值函数分界点的导数和微分&lt;/h5>
&lt;p>根据导数的定义来看（左右导数存在且相等）&lt;/p>
&lt;h6 id="例1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326163051752.png" alt="" />&lt;figcaption>image-20200326163051752&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326163349444.png" alt="" />&lt;figcaption>image-20200326163349444&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326163715044.png" alt="" />&lt;figcaption>image-20200326163715044&lt;/figcaption>
&lt;/figure>
&lt;h5 id="极限式表示的函数的可导性">极限式表示的函数的可导性&lt;/h5>
&lt;ul>
&lt;li>先求极限，得到函数的的分段表达式&lt;/li>
&lt;li>再讨论函数的可导性&lt;/li>
&lt;/ul>
&lt;p>例1&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326174839184.png" alt="" />&lt;figcaption>image-20200326174839184&lt;/figcaption>
&lt;/figure>
&lt;h3 id="求高阶导数">求高阶导数&lt;/h3>
&lt;ul>
&lt;li>直接法（归纳法）：一阶，二阶，三阶，，，递推找规律&lt;/li>
&lt;li>间接法（公式法）：利用已知的&lt;a href="#高阶导数公式">高阶导数公式&lt;/a>，通过四则运算，变量代换，泰勒级数等方法，达到将给定的函数求出n阶导数的方法，称之为间接法(//TODO 求高阶导数）
&lt;ul>
&lt;li>&lt;a href="#分式有理函数的高阶导数">分式有理函数的高阶导数&lt;/a>&lt;/li>
&lt;li>&lt;span class="math inline">\(\cos ^{n} \alpha x, \sin ^{m} \beta x\)&lt;/span>的和、差、积所构成的函数的高阶导数&lt;/li>
&lt;li>利用函数的泰勤级数展开式，求函数在一点处的高阶导数&lt;/li>
&lt;li>利用递推公式求n阶导数&lt;/li>
&lt;li>利用&lt;a href="#高阶导数公式">莱布尼茨高阶导数公式&lt;/a>求高阶导数&lt;/li>
&lt;/ul>&lt;/li>
&lt;/ul>
&lt;h5 id="分式有理函数的高阶导数">分式有理函数的高阶导数&lt;/h5>
&lt;ul>
&lt;li>先将有理假分式通过&lt;a href="#长除法">多项式除法&lt;/a>化为整式与有理真分式之和，&lt;/li>
&lt;li>再将有理真分式写成部分分式之和，&lt;/li>
&lt;li>最后仿&lt;a href="#高阶导数公式">&lt;span class="math inline">\(\left(x^{m}\right)^{(n)}\)&lt;/span>的表达式&lt;/a>写出所给定的有理函数的n阶导数&lt;/li>
&lt;/ul>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;p>&lt;span class="math inline">\(y=\frac{a x+b}{c x+d}\)&lt;/span> 由多项式除法得：&lt;span class="math inline">\(y=\frac{a}{c}+\frac{b c-a d}{c^{2}} \frac{1}{x+\frac{d}{c}}\)&lt;/span> 将其有理真分式写成部分分式之和：&lt;span class="math inline">\(y = \frac{a}{c}+\frac{b c-a d}{c^{2}}\left(x+\frac{d}{c}\right)^{-1} \quad\left(x \neq-\frac{d}{c}\right)\)&lt;/span> 仿&lt;span class="math inline">\(\left(x^{m}\right)^{(n)}\)&lt;/span>求n阶导数： &lt;span class="math inline">\(\begin{aligned} y^{(n)} &amp;amp;=\frac{b c-a d}{c^{2}}(-1)(-2) \cdots(-1-n+1)\left(x+\frac{d}{c}\right)^{-1-n} \\ &amp;amp;=\frac{b c-a d}{c^{2}} \frac{(-1)^{n} n !}{\left(x+\frac{d}{c}\right)^{n+1}}=\frac{(-1)^{n} n ! c^{n-1}(b c-a d)}{(c x+d)^{n+1}} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h5 id="cos-n-alpha-x-sin-m-beta-x的和差积所构成的函数的高阶导数">&lt;span class="math inline">\(\cos ^{n} \alpha x, \sin ^{m} \beta x\)&lt;/span>的和、差、积所构成的函数的高阶导数&lt;/h5>
&lt;p>利用三角函数中积化和差与倍角公式把函数的次数逐次降低，最后变为&lt;span class="math inline">\(\cos k x, \sin k x\)&lt;/span>的和、差形式，再用公式&lt;span class="math inline">\(\sin ^{(n)} k x=k^{n} \sin \left(k x+n \cdot \frac{\pi}{2}\right), \cos ^{(n)} k x=k^{n} \cos \left(k x+n \cdot \frac{\pi}{2}\right)\)&lt;/span>将给定函数的n阶导数写出来。&lt;/p>
&lt;h5 id="利用函数的泰勤级数展开式求高阶导数">利用函数的泰勤级数展开式求高阶导数&lt;/h5>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326220555812.png" alt="" />&lt;figcaption>image-20200326220555812&lt;/figcaption>
&lt;/figure>
&lt;h5 id="利用递推公式求高阶导数">利用递推公式求高阶导数&lt;/h5>
&lt;p>//TODO&lt;/p>
&lt;h5 id="利用莱布尼茨公式求高阶导数">利用莱布尼茨公式求高阶导数&lt;/h5>
&lt;p>//TODO&lt;/p>
&lt;h3 id="已知导数求极限或参数或者已知极限求导数">已知导数求极限或参数，或者已知极限求导数&lt;/h3>
&lt;p>例1&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326143911077.png" alt="" />&lt;figcaption>image-20200326143911077&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326144022856.png" alt="" />&lt;figcaption>image-20200326144022856&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326144056545.png" alt="" />&lt;figcaption>image-20200326144056545&lt;/figcaption>
&lt;/figure>
&lt;p>例2&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326153624418.png" alt="" />&lt;figcaption>image-20200326153624418&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326154233060.png" alt="" />&lt;figcaption>image-20200326154233060&lt;/figcaption>
&lt;/figure>
&lt;h3 id="导数与微分增量的关系">导数与微分、增量的关系&lt;/h3>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326181131837.png" alt="" />&lt;figcaption>image-20200326181131837&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200326181215318.png" alt="" />&lt;figcaption>image-20200326181215318&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-基础概念-函数与极限</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</link><pubDate>Fri, 06 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-基础概念-函数与极限">高等数学-基础概念-函数与极限&lt;/h1>
&lt;p>数学分析/高等数学（数学系教材是数学分析，理工科教材是高等数学）是由微积分演进而来，在微积分发展至现代阶段中，从应用中的方法总结升华为一类综合性分析方法。&lt;/p>
&lt;p>&lt;strong>数学分析&lt;/strong>（英语：&lt;strong>mathematical analysis&lt;/strong>）区别于其他非数学类学生的&lt;a href="https://zh.wikipedia.org/wiki/高等数学">高等数学&lt;/a>内容，是分析学中最古老、最基本的分支，一般指以&lt;a href="https://zh.wikipedia.org/wiki/微积分学">微积分学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/无穷级数">无穷级数&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/解析函數">解析函数&lt;/a>等的一般理论为主要内容。&lt;/p>
&lt;p>微积分学的研究对象是函数，微积分学的理论基础是极限理论，极限理论的理论基础是实数理论。&lt;/p>
&lt;p>级数是研究函数的一种方法和工具，理论基础也是极限理论。通过函数展开成级数，研究函数在无穷多项和表示下的性质，以及进行数值计算。&lt;/p>
&lt;p>综上，数学分析的&lt;strong>研究对象是函数&lt;/strong>，数学分析的&lt;strong>基本方法是&lt;a href="https://baike.baidu.com/item/极限">极限&lt;/a>的方法&lt;/strong>，或者说是无穷小分析。它的发展由微积分开始，并扩展到函数的&lt;a href="https://baike.baidu.com/item/连续性/8676216">连续性&lt;/a>、可&lt;a href="https://baike.baidu.com/item/微分/317988">微分&lt;/a>及可&lt;a href="https://baike.baidu.com/item/积分/5749068">积分&lt;/a>等各种特性。&lt;/p>
&lt;p>此章节介绍函数与极限的相关概念与性质&lt;/p>
&lt;h3 id="映射">映射&lt;/h3>
&lt;h4 id="映射定义">映射定义&lt;/h4>
&lt;p>设 &lt;span class="math inline">\(X_{ }, Y\)&lt;/span> 是两个非空集合,如果存在一个法则 &lt;span class="math inline">\(f,\)&lt;/span> 使得对 &lt;span class="math inline">\(X\)&lt;/span> 中每个元素x, 按法则 &lt;span class="math inline">\(f,\)&lt;/span> 在 Y 中有唯一确定的元素 y 与之对应,那么称 &lt;span class="math inline">\(f\)&lt;/span> 为从 X 到 Y 的映射， 记作&lt;span class="math inline">\(f: X \rightarrow Y\)&lt;/span> 其中 &lt;span class="math inline">\(y\)&lt;/span> 称为元素 &lt;span class="math inline">\(x\)&lt;/span> (在映射 &lt;span class="math inline">\(f\)&lt;/span> 下)的&lt;strong>像&lt;/strong>,并记作 &lt;span class="math inline">\(f(x)\)&lt;/span>, 即 而元素 x 称为元素 &lt;span class="math inline">\(y\)&lt;/span> ( 在映射 &lt;span class="math inline">\(f\)&lt;/span> 下 ) 的一个&lt;strong>原像&lt;/strong> ; 集合 &lt;span class="math inline">\(X\)&lt;/span> 称为映射 &lt;span class="math inline">\(f\)&lt;/span> 的&lt;strong>定义域&lt;/strong>, 记 作 &lt;span class="math inline">\(D_{f},\)&lt;/span> 即 $D_{f}=X ; $ &lt;span class="math inline">\(X\)&lt;/span> 中所有元素的像所组成的集合称为映射 &lt;span class="math inline">\(f\)&lt;/span> 的&lt;strong>值域&lt;/strong>, 记作 &lt;span class="math inline">\(R_{f}\)&lt;/span> 或&lt;span class="math inline">\(f(X),\)&lt;/span> 即&lt;span class="math inline">\(R_{f}=f(X)=\{f(x) \mid x \in X\}\)&lt;/span>&lt;/p>
&lt;h4 id="映射三要素">映射三要素&lt;/h4>
&lt;p>定义域、映射法则、值域。&lt;/p>
&lt;h4 id="映射的分类">映射的分类&lt;/h4>
&lt;h5 id="按映射关系分类">按映射关系分类&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(f\)&lt;/span> 是从集合 &lt;span class="math inline">\(X\)&lt;/span> 到集合 Y 的映射, 若 &lt;span class="math inline">\(R_{f}=Y,\)&lt;/span> 即 &lt;span class="math inline">\(Y\)&lt;/span> 中任一元素 &lt;span class="math inline">\(y\)&lt;/span> 都是 &lt;span class="math inline">\(X\)&lt;/span> 中某 元素的像,则称 &lt;span class="math inline">\(f\)&lt;/span> 为X 到 Y 上的映射或&lt;strong>满射&lt;/strong>; 若对 X 中任意两个不同元素 &lt;span class="math inline">\(x_{1} \neq\)&lt;/span> &lt;span class="math inline">\(x_{2},\)&lt;/span> 它们的像 &lt;span class="math inline">\(f\left(x_{1}\right) \neq f\left(x_{2}\right),\)&lt;/span> 则称 &lt;span class="math inline">\(f\)&lt;/span> 为 &lt;span class="math inline">\(X\)&lt;/span> 到 &lt;span class="math inline">\(Y\)&lt;/span> 的&lt;strong>单射&lt;/strong> ; 若映射 &lt;span class="math inline">\(f\)&lt;/span> 既是单射,又是满射,则称 &lt;span class="math inline">\(f\)&lt;/span> 为&lt;strong>一一映射&lt;/strong>(或双射)。&lt;/p>
&lt;h5 id="按定义域与值域分类">按定义域与值域分类&lt;/h5>
&lt;p>映射又称为算子。根据集合 X、Y 的不同情形,在不同的数学分支中,映射有不同的惯用名称。 从非空集 X 到数集 Y 的映射又称为 X 上的&lt;strong>泛函&lt;/strong>, 从非 空集 X 到它自身的映射又称为 X 上的&lt;strong>变换&lt;/strong>, 从实数集( 或其子集) X 到实数集 Y 的映射通常称为定义在 X 上的&lt;strong>函数&lt;/strong>.&lt;/p>
&lt;h5 id="逆映射">逆映射&lt;/h5>
&lt;p>设 &lt;span class="math inline">\(f\)&lt;/span> 是&lt;span class="math inline">\(X\)&lt;/span> 到 &lt;span class="math inline">\(Y\)&lt;/span> 的单射,则由定义, 对每个 &lt;span class="math inline">\(y \in R_{f},\)&lt;/span> 有 唯一的 &lt;span class="math inline">\(x \in X,\)&lt;/span> 适合&lt;span class="math inline">\(f(x)=y .\)&lt;/span> 于是,我们可定义一个从 &lt;span class="math inline">\(R_{f}\)&lt;/span> 到 &lt;span class="math inline">\(X\)&lt;/span> 的新映射 &lt;span class="math inline">\(g,\)&lt;/span> 即&lt;span class="math inline">\(g: R_{f} \rightarrow X\)&lt;/span> 对每个 &lt;span class="math inline">\(y \in R_{f},\)&lt;/span> 规定 &lt;span class="math inline">\(g(y)=x,\)&lt;/span> 这 &lt;span class="math inline">\(x\)&lt;/span> 满足 &lt;span class="math inline">\(f(x)=y .\)&lt;/span> 这个映射 &lt;span class="math inline">\(g\)&lt;/span> 称为 &lt;span class="math inline">\(f\)&lt;/span> 的逆映射, 记作 &lt;span class="math inline">\(f^{-1}\)&lt;/span> 其定义域 &lt;span class="math inline">\(D_{f^{-1}}=R_{f},\)&lt;/span> 值域 &lt;span class="math inline">\(R_{f^{-1}}=X\)&lt;/span>&lt;/p>
&lt;p>单射才可能有逆映射&lt;/p>
&lt;h5 id="复合映射">复合映射&lt;/h5>
&lt;p>设有两个映射&lt;span class="math inline">\(g: X \rightarrow Y_{1}, \quad f: Y_{2} \rightarrow Z\)&lt;/span> 其中 &lt;span class="math inline">\(Y_{1} \subset Y_{2},\)&lt;/span> 则 由 映射 &lt;span class="math inline">\(g\)&lt;/span> 和 &lt;span class="math inline">\(f\)&lt;/span> 可 以定出一个从 &lt;span class="math inline">\(X\)&lt;/span> 到 &lt;span class="math inline">\(Z\)&lt;/span> 的对应法则, 它将每个&lt;span class="math inline">\(x \in X\)&lt;/span> 映成 &lt;span class="math inline">\(f[g(x)] \in Z .\)&lt;/span> 显然,这个对应法则确定了一个从 X 到 Z 的映射, 这个映射称为映射 g 和 f 构成的复合映射,记作 &lt;span class="math inline">\(f \circ g,\)&lt;/span> 即&lt;span class="math inline">\(f \circ g: X \rightarrow Z,(f \circ g)(x)=f[g(x)], x \in X\)&lt;/span>&lt;/p>
&lt;p>映射 g 和 &lt;span class="math inline">\(f\)&lt;/span> &lt;strong>构成复合映射的条件&lt;/strong>是: g 的值域 &lt;span class="math inline">\(R_{B}\)&lt;/span> 必 须包含在 &lt;span class="math inline">\(f\)&lt;/span> 的定义域内,即 &lt;span class="math inline">\(R_{g} \subset D_{f} .\)&lt;/span> 否则,不能构成复合映射. 由此可以知道,映 射 g 和 &lt;span class="math inline">\(f\)&lt;/span> 的 &lt;strong>复 合 是有顺 序&lt;/strong> 的, &lt;span class="math inline">\(f \circ g\)&lt;/span> 有 意 义 并不 表 示 &lt;span class="math inline">\(g \circ f\)&lt;/span> 也 有 意 义. 即 使&lt;/p>
&lt;h3 id="函数的基本概念">函数的基本概念&lt;/h3>
&lt;p>函数是客观事物的内部联系在数量方面的反映，利用函数关系又可以对事物的规律性进行研究。&lt;/p>
&lt;h4 id="函数定义">函数定义&lt;/h4>
&lt;p>设数集 &lt;span class="math inline">\(D\subset R\)&lt;/span>,则称映射 &lt;span class="math inline">\(f: D \rightarrow \mathbf{R}\)&lt;/span> 为定义在 &lt;span class="math inline">\(D\)&lt;/span> 上的函数,通常简记为&lt;span class="math inline">\(y=f(x), x \in D\)&lt;/span> 其中 &lt;span class="math inline">\(x\)&lt;/span> 称为自变量, &lt;span class="math inline">\(y\)&lt;/span> 称为因变量, &lt;span class="math inline">\(D\)&lt;/span> 称为定义域, 记作 &lt;span class="math inline">\(D_{f},\)&lt;/span> 即 &lt;span class="math inline">\(D_{f}=D .\)&lt;/span>&lt;/p>
&lt;p>函数是从实数集到实数集的映射,其值域总在 R 内,因此构成函数的要素 是 :定义域 D 及对应法则 f.  如果两个函数的定义域相同,对应法则也相同,那么 这两个函数就是相同的,否则就是不同的.&lt;/p>
&lt;h4 id="某些函数的特性">某些函数的特性&lt;/h4>
&lt;p>单调性，奇偶性，周期性，有界性&lt;/p>
&lt;h5 id="奇偶性">奇偶性&lt;/h5>
&lt;p>奇函数x奇函数-&amp;gt;偶函数；奇函数x偶函数-&amp;gt;奇函数；偶函数x偶函数-&amp;gt;偶函数&lt;/p>
&lt;h4 id="函数的分类">函数的分类&lt;/h4>
&lt;h5 id="一些有特点的函数">一些有特点的函数&lt;/h5>
&lt;p>分段函数，绝对值函数，取整函数，符号函数，狄里克雷函数，隐函数，参数式表示的函数，反函数，复合函数，初等函数&lt;/p>
&lt;h5 id="反函数">反函数&lt;/h5>
&lt;p>反函数属于逆映射。&lt;/p>
&lt;p>设函数 &lt;span class="math inline">\(f: D \rightarrow f(D)\)&lt;/span> 是单射,则它存在逆映射 &lt;span class="math inline">\(f^{-1}: f(D) \rightarrow D,\)&lt;/span> 称此映射 &lt;span class="math inline">\(f^{-1}\)&lt;/span> 为函数&lt;span class="math inline">\(f\)&lt;/span>的反函数。&lt;/p>
&lt;p>按此定义,对每个 &lt;span class="math inline">\(y \in f(D),\)&lt;/span> 有唯一的 &lt;span class="math inline">\(x \in D,\)&lt;/span> 使得 &lt;span class="math inline">\(f(x)=y,\)&lt;/span> 于是有&lt;span class="math inline">\(f^{-1}(y)=x\)&lt;/span>。 即反函数 &lt;span class="math inline">\(f^{-1}\)&lt;/span> 的对应法则是完全由函数 &lt;span class="math inline">\(f\)&lt;/span> 的对应法则所确定的.&lt;/p>
&lt;p>直接函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>与其反函数&lt;span class="math inline">\(y=f^{-1}(x)\)&lt;/span>的图像，是关于直线&lt;span class="math inline">\(y=x\)&lt;/span>对称的。&lt;/p>
&lt;h5 id="复合函数">复合函数&lt;/h5>
&lt;p>复合函数属于复合映射的一种特例。&lt;/p>
&lt;p>设函数 &lt;span class="math inline">\(y=f(u)\)&lt;/span> 的定义域为 &lt;span class="math inline">\(D_{f},\)&lt;/span> 函数 &lt;span class="math inline">\(u=g(x)\)&lt;/span> 的定义域为 &lt;span class="math inline">\(D_g\)&lt;/span>,且其值域 &lt;span class="math inline">\(R_{g} \subset D_{f},\)&lt;/span> 则由下式确定 的函数&lt;span class="math inline">\(y=f[g(x)], \quad x \in D_{g}\)&lt;/span>称为由 函数 &lt;span class="math inline">\(u=g(x)\)&lt;/span> 与函数 &lt;span class="math inline">\(y=f(u)\)&lt;/span> 构成的复合 函数，它的定义域为 &lt;span class="math inline">\(D_g\)&lt;/span>,变量 u 称为中间变量.&lt;/p>
&lt;h5 id="初等函数">初等函数&lt;/h5>
&lt;h6 id="基本初等函数">基本初等函数&lt;/h6>
&lt;p>常值函数：C&lt;/p>
&lt;p>幂函数：&lt;span class="math inline">\(x^a\)&lt;/span>&lt;/p>
&lt;p>指数函数：&lt;span class="math inline">\(a^x\)&lt;/span>&lt;/p>
&lt;p>对数函数：&lt;span class="math inline">\(\log _{a} x\)&lt;/span>&lt;/p>
&lt;p>三角函数：&lt;span class="math inline">\(\sin x, \cos x, \tan x\)&lt;/span>&lt;/p>
&lt;p>反三角函数： &lt;span class="math inline">\(\arcsin x, x \in[-1,1]\)&lt;/span> &lt;span class="math inline">\(\arccos x, x \in[-1,1]\)&lt;/span> &lt;span class="math inline">\(\arctan x, x \in \mathbf{R}\)&lt;/span> &lt;span class="math inline">\(\operatorname{arccot} x, x \in \mathbf{R}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>初等函数&lt;/strong>：由基本初等函数经过有限次加减乘除后获得的函数&lt;/p>
&lt;h4 id="函数的运算">函数的运算&lt;/h4>
&lt;p>可以定义函数的四则运算&lt;/p>
&lt;h3 id="极限">极限&lt;/h3>
&lt;p>数列的极限&lt;span class="math inline">\(\lim _{n \rightarrow \infty} u_{n}=A\)&lt;/span>，函数的极限，无穷小，无穷大，无穷小的比较&lt;/p>
&lt;p>极限是极限概念是在探求某些实际问题的精确解答过程中产生的。比如，内接正多边形的边数越多，越接近圆。无穷多边形的面积，就是圆的面积。&lt;/p>
&lt;h4 id="数列的极限">数列的极限&lt;/h4>
&lt;p>当 n 无限增大时(即 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span> 时 ) ,对 应的 &lt;span class="math inline">\(x_{n}=f(n)\)&lt;/span> 是否能无限接近于某个确定的数值？如果能够的话,这个数值等&lt;/p>
&lt;h5 id="数列的定义">数列的定义&lt;/h5>
&lt;p>如果按照某一法则，对每个 &lt;span class="math inline">\(n \in \mathbf{N}_{+}\)&lt;/span>,对应着一个确定的 实数 x, 这些实数 x按照下标 n 从小到大排列得到的一个序列&lt;span class="math inline">\(x_{1}, x_{2}, x_{3}, \cdots, x_{n}, \cdots\)&lt;/span>，就叫做&lt;strong>数列&lt;/strong>，简记数列 &lt;span class="math inline">\(\left\{x_{n}\right\} .\)&lt;/span> 数列中的每一个数叫做&lt;strong>数列的项&lt;/strong>, 第 n 项 &lt;span class="math inline">\(x_{n}\)&lt;/span> 叫做&lt;strong>数列的一般项&lt;/strong>(或通项)&lt;/p>
&lt;h5 id="数列极限的定义">数列极限的定义&lt;/h5>
&lt;p>对于一个数列&lt;span class="math inline">\(\{x_n\}\)&lt;/span>，如果 n 无限增大时（即 &lt;span class="math inline">\(n \rightarrow \infty\)&lt;/span> 时）,对应的 &lt;span class="math inline">\(x_{n}=f(n)\)&lt;/span> 如果能无限接近于某个确定的数值S，那么称这个数列的极限为a，记作&lt;span class="math inline">\(\lim_{n \rightarrow \infty} x_n = a\)&lt;/span>&lt;/p>
&lt;p>而度量两个数&lt;span class="math inline">\(a,b\)&lt;/span>之间的接近程度，可以用两个数差的绝对值&lt;span class="math inline">\(|a-b|\)&lt;/span>。所以有极限的如下定义：&lt;/p>
&lt;p>&lt;strong>定义&lt;/strong>：设 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 为一数列 , 如果存在常数 &lt;span class="math inline">\(a,\)&lt;/span> 对于任意给定的正数 &lt;span class="math inline">\(\varepsilon\)&lt;/span> ( 不论它 多么小）, 总存在正整数 N, 使得当 n&amp;gt;N 时,不等式&lt;span class="math inline">\(\left|x_{n}-a\right|&amp;lt;\varepsilon\)&lt;/span>都成立, 那么就称常数 a 是数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 的&lt;strong>极限&lt;/strong>,或者称数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> &lt;strong>收敛&lt;/strong>于 &lt;span class="math inline">\(a,\)&lt;/span> 记为&lt;span class="math inline">\(\lim _{n \rightarrow \infty} x_{n}=a\)&lt;/span>或&lt;span class="math inline">\(x_{n} \rightarrow a(n \rightarrow \infty)\)&lt;/span> 如果不存在这样的常数a，就称数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 没有极限，或者称数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> &lt;strong>发散&lt;/strong>。&lt;/p>
&lt;p>即数列极限&lt;span class="math inline">\(\lim _{n \rightarrow \infty} x_{n}=a \Leftrightarrow \forall \varepsilon&amp;gt;0, \exists\)&lt;/span> 正整数 N, 当&lt;span class="math inline">\(n&amp;gt;N\)&lt;/span> 时 &lt;span class="math inline">\(,\)&lt;/span> 有 &lt;span class="math inline">\(\left|x_{n}-a\right|&amp;lt;\varepsilon\)&lt;/span>&lt;/p>
&lt;h5 id="收敛数列的性质">收敛数列的性质&lt;/h5>
&lt;p>（收敛数列极限的唯一性）如果数列&lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 收敛，那么它的极限唯一。 （收敛数列的有界性） 如果数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 收敛, 那么数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 一定有界. （收敛数列的保号性）如果 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} x_{n}=a,\)&lt;/span> 且 &lt;span class="math inline">\(a&amp;gt;0(\)&lt;/span> 或 &lt;span class="math inline">\(a&amp;lt;0),\)&lt;/span> 那么存在正 整数 &lt;span class="math inline">\(N,\)&lt;/span> 当 &lt;span class="math inline">\(n&amp;gt;N\)&lt;/span> 时,都有 &lt;span class="math inline">\(x_{n}&amp;gt;0 （\)&lt;/span> 或 &lt;span class="math inline">\(\left.x_{n}&amp;lt;0\right)\)&lt;/span> （收敛数列保号性的推论）如果数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span>从某项起有 &lt;span class="math inline">\(x_{n} \geqslant 0\left(\right.\)&lt;/span> 或 &lt;span class="math inline">\(\left.x_{n} \leqslant 0\right),\)&lt;/span> 且 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} x_{n}=a,\)&lt;/span> 那么 $ a $&lt;span class="math inline">\((\)&lt;/span> 或 &lt;span class="math inline">\(a \leqslant 0)\)&lt;/span> （收敛数列与其子数列间的关系） 如果数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 收敛于 &lt;span class="math inline">\(a,\)&lt;/span> 那么它 的任一子数列也收敛，且极限也是 &lt;span class="math inline">\(a\)&lt;/span>&lt;/p>
&lt;h4 id="函数的极限">函数的极限&lt;/h4>
&lt;p>函数极限是数列极限的推广。数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 可看作自变量为 &lt;span class="math inline">\(n\)&lt;/span> 的函数。&lt;/p>
&lt;p>函数极限的一般概念：在自变量的某个变化过程中，如果对应的函数值无限接近于某个确定的数，那么这个确定的数称作在在这一变化过程中&lt;strong>函数的极限&lt;/strong>。 只是函数的自变量的变化过程，除了可以趋于无穷，还可以趋于某个有限值。&lt;/p>
&lt;h5 id="x-rightarrow-x_0时函数极限的定义">&lt;span class="math inline">\(x \rightarrow x_0\)&lt;/span>时函数极限的定义&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某一去心邻域内有定义. 如果存在 常数 &lt;span class="math inline">\(A\)&lt;/span>, 对 于任意给定的正数 &lt;span class="math inline">\(\varepsilon\)&lt;/span> ( 不 论 它多 么小)， 总存在正数 &lt;span class="math inline">\(\delta,\)&lt;/span> 使得 当 &lt;span class="math inline">\(x\)&lt;/span> 满足不等 式&lt;span class="math inline">\(0&amp;lt;\left|x-x_{0}\right|&amp;lt;\delta\)&lt;/span> 时， 对 应的函数值 &lt;span class="math inline">\(f(x)\)&lt;/span> 都满足不等式&lt;span class="math inline">\(|f(x)-A|&amp;lt;\varepsilon\)&lt;/span>, 那么常数 A 就叫做函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 当 &lt;span class="math inline">\(x \rightarrow x_{0}\)&lt;/span> 时的极限,记作&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A \quad\)&lt;/span> 或 &lt;span class="math inline">\(f(x) \rightarrow A\left(\text{当} x \rightarrow x_{0}\right)\)&lt;/span>&lt;/p>
&lt;p>左极限、右极限、单侧极限的定义略&lt;/p>
&lt;h5 id="x-rightarrow-infty时函数极限的定义">&lt;span class="math inline">\(x \rightarrow \infty\)&lt;/span>时函数极限的定义&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 当 &lt;span class="math inline">\(|x|\)&lt;/span> 大于某一正数 时有定义. 如果存在常数 A, 对于任意给定的正数 &lt;span class="math inline">\(\varepsilon\)&lt;/span> (不论它多 么小）， 总 存 在 着 正 数 X， 使 得 当 x 满 足 不 等 式 &lt;span class="math inline">\(|x|&amp;gt;X\)&lt;/span> 时 &lt;span class="math inline">\(,\)&lt;/span> 对应的函数值 &lt;span class="math inline">\(f(x)\)&lt;/span> 都满足不等式&lt;span class="math inline">\(|f(x)-A|&amp;lt;\varepsilon\)&lt;/span> 那么常数 A 就叫做函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 当 &lt;span class="math inline">\(x \rightarrow \infty\)&lt;/span> 时的极限, 记作&lt;span class="math inline">\(\lim _{x \rightarrow \infty} f(x)=A \quad\)&lt;/span> 或 &lt;span class="math inline">\(\quad f(x) \rightarrow A \quad(\stackrel{\text { 当 }}{x} x \rightarrow \infty)\)&lt;/span>&lt;/p>
&lt;p>注意，&lt;span class="math inline">\(x \rightarrow \infty\)&lt;/span>时，实际上需要分&lt;span class="math inline">\(+\infty\)&lt;/span>和&lt;span class="math inline">\(-\infty\)&lt;/span>两种情况，分别讨论两种情况下极限是否存在&lt;/p>
&lt;h5 id="函数极限的性质">函数极限的性质&lt;/h5>
&lt;p>函数极限可看作数列极限的推广，函数有极限时的性质，可以类比数列有极限时存在性质&lt;/p>
&lt;p>（函数极限的唯一性） 如果 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span> 存在,那么这极限唯一。&lt;/p>
&lt;p>（函数极限的局部有界性） 如果 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A,\)&lt;/span> 那么存在常数 &lt;span class="math inline">\(M&amp;gt;0\)&lt;/span> 和 &lt;span class="math inline">\(\delta&amp;gt;0,\)&lt;/span> 使得 当 &lt;span class="math inline">\(0&amp;lt;\left|x-x_{0}\right|&amp;lt;\delta\)&lt;/span> 时, 有 &lt;span class="math inline">\(|f(x)| \leqslant M\)&lt;/span>&lt;/p>
&lt;p>（函数极限的局部保号性）如果 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A,\)&lt;/span> 且 &lt;span class="math inline">\(A&amp;gt;0 （\)&lt;/span> 或 &lt;span class="math inline">\(\left.A&amp;lt;0\right)\)&lt;/span>,那么 存在常数 &lt;span class="math inline">\(\delta&amp;gt;0,\)&lt;/span> 使得当 &lt;span class="math inline">\(0&amp;lt;\left|x-x_{0}\right|&amp;lt;\delta\)&lt;/span> 时,有 &lt;span class="math inline">\(f(x)&amp;gt;0 （\)&lt;/span> 或 &lt;span class="math inline">\(\left.f(x)&amp;lt;0\right)\)&lt;/span>&lt;/p>
&lt;p>（函数极限的局部保号性的推论）如果在 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某去心邻域内 &lt;span class="math inline">\(f(x) \geqslant 0(\)&lt;/span> 或 &lt;span class="math inline">\(f(x) \leqslant 0),\)&lt;/span> 而且 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A,\)&lt;/span> 那么&lt;span class="math inline">\(A \geqslant 0\)&lt;/span> ( 或 &lt;span class="math inline">\(A \leqslant 0)\)&lt;/span>&lt;/p>
&lt;p>（函数极限与数列极限的关系） 如果极限 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span> 存在， &lt;span class="math inline">\(x_{n}\)&lt;/span> 为函 数 &lt;span class="math inline">\(f(x)\)&lt;/span> 的定义域内任一收敛于 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的数列,且满足 &lt;span class="math inline">\(: x_{n} \neq x_{0}\left(n \in \mathbf{N}_{+}\right)\)&lt;/span>,那么相应的 函数值数列 &lt;span class="math inline">\(\left\{f\left(x_{n}\right) \right\}\)&lt;/span> 必收敛 &lt;span class="math inline">\(,\)&lt;/span> 且 &lt;span class="math inline">\(\lim _{n \rightarrow \infty} f\left(x_{n}\right)=\lim _{x \rightarrow x_{0}} f(x) .\)&lt;/span>&lt;/p>
&lt;h4 id="无穷小的概念">无穷小的概念&lt;/h4>
&lt;p>无穷小和极限一般配套使用，见&lt;a href="#无穷小与函数极限的关系">无穷小和极限的关系&lt;/a>、洛必达法则、无穷小替换等&lt;/p>
&lt;h5 id="无穷小的定义">无穷小的定义&lt;/h5>
&lt;p>如果函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 当 &lt;span class="math inline">\(x \rightarrow x_{0}\)&lt;/span> （或 &lt;span class="math inline">\(x \rightarrow \infty\)&lt;/span> ) 时的极 限 为 零, 那么 称 函 数 定义&lt;span class="math inline">\(f(x)\)&lt;/span> 为 当 &lt;span class="math inline">\(x \rightarrow x_{0}(\)&lt;/span> 或 &lt;span class="math inline">\(x \rightarrow \infty)\)&lt;/span> 时的&lt;strong>无穷小&lt;/strong>. 特别地，以零为极限的数列 $ {x_{n}}$ 称为 $n $时的&lt;strong>无穷小&lt;/strong>.&lt;/p>
&lt;h5 id="无穷小与函数极限的关系">无穷小与函数极限的关系&lt;/h5>
&lt;p>在自变量的同一变化过程 &lt;span class="math inline">\(x \rightarrow x_{0}(\)&lt;/span> 或 &lt;span class="math inline">\(x \rightarrow \infty)\)&lt;/span> 中,函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 具有极限 &lt;span class="math inline">\(A\)&lt;/span> 的充分必要条件是 &lt;span class="math inline">\(f(x)=A+\alpha,\)&lt;/span> 其中 &lt;span class="math inline">\(\alpha\)&lt;/span> 是无穷小.&lt;/p>
&lt;h5 id="无穷大的定义">无穷大的定义&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某一去 心邻域内有定义（或|x|大于某一正数时 定 有定义）.如果对于任意给定的正数 M（不论它多么大）,总存在正数 &lt;span class="math inline">\(\delta\)&lt;/span> (或正数&lt;span class="math inline">\(X),\)&lt;/span> 只要 &lt;span class="math inline">\(x\)&lt;/span> 适合不等式 &lt;span class="math inline">\(0&amp;lt;\left|x-x_{0}\right|&amp;lt;\delta(\)&lt;/span> 或 &lt;span class="math inline">\(|x|&amp;gt;X),\)&lt;/span> 对 应的 函数值 &lt;span class="math inline">\(f(x)\)&lt;/span> 总 满足不等式&lt;span class="math inline">\(|f(x)|&amp;gt;M\)&lt;/span>，那么称函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 是当 &lt;span class="math inline">\(x \rightarrow x_{0}(\)&lt;/span> 或 &lt;span class="math inline">\(x \rightarrow \infty)\)&lt;/span> 时的无穷大.&lt;/p>
&lt;h5 id="无穷小和无穷大的关系">无穷小和无穷大的关系&lt;/h5>
&lt;p>在自变量的同一变化过程中,如果 &lt;span class="math inline">\(f(x)\)&lt;/span> 为无穷大,那么 &lt;span class="math inline">\(\frac{1}{f(x)}\)&lt;/span> 为 无 穷小；反之,如果 &lt;span class="math inline">\(f(x)\)&lt;/span> 为无穷小,且 &lt;span class="math inline">\(f(x) \neq 0,\)&lt;/span> 那么 &lt;span class="math inline">\(\frac{1}{f(x)}\)&lt;/span> 为无穷大.&lt;/p>
&lt;h5 id="无穷小的比较">无穷小的比较&lt;/h5>
&lt;p>我们知道,两个无穷小的和 ,差及乘积仍旧是无穷小。 关于两个无穷小的商,却会出现不同的情况。两个无穷小之比的极限的各种不同情况，反映了不同的无穷小趋于零的“快慢”。&lt;/p>
&lt;p>设&lt;span class="math inline">\(\lim _{x \rightarrow *} \frac{\alpha(x)}{\beta(x)}=A\)&lt;/span>， 若&lt;span class="math inline">\(A \neq 0\)&lt;/span>，称&lt;span class="math inline">\(x \rightarrow *\)&lt;/span>时&lt;span class="math inline">\(\alpha (x)\)&lt;/span>与&lt;span class="math inline">\(\beta (x)\)&lt;/span>为&lt;strong>同阶无穷小&lt;/strong>。 若&lt;span class="math inline">\(A = 1\)&lt;/span>，称&lt;span class="math inline">\(x \rightarrow *\)&lt;/span>时&lt;span class="math inline">\(\alpha (x)\)&lt;/span>与&lt;span class="math inline">\(\beta (x)\)&lt;/span>为&lt;strong>等价无穷小&lt;/strong>，记&lt;span class="math inline">\(\alpha(x) \sim \beta(x)\)&lt;/span>。 若&lt;span class="math inline">\(A = 0\)&lt;/span>，称&lt;span class="math inline">\(x \rightarrow *\)&lt;/span>时&lt;span class="math inline">\(\alpha (x)\)&lt;/span>是&lt;span class="math inline">\(\beta (x)\)&lt;/span>的&lt;strong>高阶无穷小&lt;/strong>，记&lt;span class="math inline">\(\alpha(x)=o(\beta(x))\)&lt;/span>。 若&lt;span class="math inline">\(\lim _{x \rightarrow *} \frac{\alpha(x)}{\beta(x)}=\infin\)&lt;/span>，称&lt;span class="math inline">\(x \rightarrow *\)&lt;/span>时&lt;span class="math inline">\(\alpha (x)\)&lt;/span>是&lt;span class="math inline">\(\beta (x)\)&lt;/span>的&lt;strong>低阶无穷小&lt;/strong>。&lt;/p>
&lt;p>设&lt;span class="math inline">\(\lim _{x \rightarrow *} f(x)=\infty\)&lt;/span>，则&lt;span class="math inline">\(\lim _{x \rightarrow+\infty} \frac{1}{f(x)}= 0\)&lt;/span>&lt;/p>
&lt;p>（等价无穷小的充分必要条件）&lt;span class="math inline">\(\beta\)&lt;/span> 与 &lt;span class="math inline">\(\alpha\)&lt;/span> 是等价无穷小的充分必要条件为&lt;span class="math inline">\(\beta=\alpha+o(\alpha)\)&lt;/span>&lt;/p>
&lt;p>（等价无穷小定理：在计算极限时非常有用）设 &lt;span class="math inline">\(\alpha \sim \tilde{\alpha}, \beta \sim \widetilde{\beta},\)&lt;/span> 且 &lt;span class="math inline">\(\lim \frac{\widetilde{\beta}}{\widetilde{\alpha}}\)&lt;/span> 存在 &lt;span class="math inline">\(,\)&lt;/span> 则&lt;span class="math inline">\(\lim \frac{\beta}{\alpha}=\lim \frac{\widetilde{\beta}}{\widetilde{\alpha}}\)&lt;/span>&lt;/p>
&lt;h5 id="等价无穷小">等价无穷小&lt;/h5>
&lt;h6 id="等价无穷小替换">等价无穷小替换&lt;/h6>
&lt;p>若&lt;span class="math inline">\(x \rightarrow *\)&lt;/span>时有&lt;span class="math inline">\(\alpha(x) \sim a(x), \beta(x) \sim b(x)\)&lt;/span>，则&lt;span class="math inline">\(\lim _{x \rightarrow*} \frac{\alpha(x) \gamma(x)}{\beta(x) \delta(x)}=\lim _{x \rightarrow *} \frac{a(x) \gamma(x)}{b(x) \delta(x)}\)&lt;/span>&lt;/p>
&lt;p>注意，极限加法和极限部分乘法不能使用等价无穷小替换&lt;/p>
&lt;p>常见的等价无穷小见&lt;a href="#等价无穷小">等价无穷小&lt;/a>一节&lt;/p>
&lt;h6 id="常见的等价无穷小">常见的等价无穷小&lt;/h6>
&lt;p>&lt;span class="math inline">\(x\rightarrow 0\)&lt;/span> ，有如下等价无穷小&lt;/p>
&lt;table>
&lt;thead>
&lt;tr class="header">
&lt;th>三角函数的等价&lt;/th>
&lt;th>指数函数的等价&lt;/th>
&lt;th>对数函数的等价&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\sin x \sim x\)&lt;/span>&lt;/td>
&lt;td>$ ^{x}-1 x $&lt;/td>
&lt;td>&lt;span class="math inline">\(\ln (1+x) \sim x\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>$ x x$&lt;/td>
&lt;td>&lt;span class="math inline">\(a^{x}-1 \sim x \ln a,(a&amp;gt;0, a \neq 1)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>$ x x$&lt;/td>
&lt;td>&lt;span class="math inline">\((1+x)^{a}-1 \sim a x\)&lt;/span> 可以用来去幂和高次方根&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>$ x x $&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>$ 1-x x^{2}$&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(1-\cos ^{a} x \sim \frac{a}{2} x^{2}\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h6 id="泰勒公式替换使用麦克劳林公式替换">泰勒公式替换（使用麦克劳林公式替换）&lt;/h6>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>处存在n阶导数，则有公式&lt;span class="math inline">\(f(x)=f\left(x_{0}\right)+f^{\prime}\left(x_{0}\right)\left(x-x_{0}\right)+\frac{1}{2 !} f^{\prime \prime}\left(x_{0}\right)\left(x-x_{0}\right)^{2}+\cdots+\frac{1}{n !} f^{(n)}\left(x_{0}\right)\left(x-x_{0}\right)^{n}+o\left(\left(x-x_{0}\right)^{n}\right)\)&lt;/span>，称为&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>处展开的&lt;a href="#佩亚诺余项泰勒公式">具有佩亚诺余项的n阶泰勒公式&lt;/a>，其中&lt;span class="math inline">\(R_{n}(x)=o\left(\left(x-x_{0}\right)^{n}\right)\)&lt;/span>称为佩亚诺余项。特殊的，如果&lt;span class="math inline">\(x_0=0\)&lt;/span>,即在0处展开的佩亚诺余项泰勒公式又称&lt;strong>麦克劳林公式&lt;/strong>。&lt;/p>
&lt;p>常见的等价无穷小也可以看作将原式是展开到1阶的泰勒展开。&lt;/p>
&lt;p>几个常用函数在x=0处展开的佩亚诺余项泰勒公式（常见的麦克劳林公式）如下：&lt;/p>
&lt;table>
&lt;colgroup>
&lt;col style="width: 64%" />
&lt;col style="width: 35%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>常见的麦克劳林公式&lt;/th>
&lt;th>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\sin x=x-\frac{1}{3 !} x^{3}+\cdots+\frac{(-1)^{n}}{(2 n+1) !} x^{2 n+1}+o\left(x^{2 n+2}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\cos x=1-\frac{1}{2 !} x^{2}+\dots+\frac{(-1)^{n}}{(2 n) !} x^{2 n}+o\left(x^{2 n+1}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\mathrm{e}^{x}=1+x+\frac{1}{2 !} x^{2}+\cdots+\frac{1}{n !} x^{n}+o\left(x^{n}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\ln (1+x)=x-\frac{x^{2}}{2}+\frac{x^{3}}{3}-\dots+(-1)^{n-1} \frac{x^{n}}{n}+o\left(x^{n}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\((1+x)^{m}=1+m x+\frac{m(m-1)}{2 !} x^{2}+\dots+\frac{m(m-1) \cdots(m-n+1)}{n !} x^{n}+o\left(x^{n}\right)\)&lt;/span>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;span class="math inline">\(\frac{1}{1+x}=1-x+x^{2}-x^{3}+\cdots+(-1)^{n} x^{n}+o\left(x^{n}\right)\)&lt;/span>&lt;/td>
&lt;td>可看作&lt;span class="math inline">\((1+x)^{m}\)&lt;/span>的特例&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;span class="math inline">\(\frac{1}{1-x}=1+x+x^{2}+x^{3}+\cdots+x^{n}+o\left(x^{n}\right)\)&lt;/span>&lt;/td>
&lt;td>可看作取-x情况下的&lt;span class="math inline">\(\frac{1}{1+x}\)&lt;/span>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="极限性质">极限性质&lt;/h4>
&lt;table>
&lt;colgroup>
&lt;col style="width: 20%" />
&lt;col style="width: 62%" />
&lt;col style="width: 16%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>名称&lt;/th>
&lt;th>解释&lt;/th>
&lt;th>与极限存在的关系&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>&lt;/td>
&lt;td>&lt;span class="math inline">\(\lim f=A\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(f=A+\alpha, \alpha \rightarrow 0\)&lt;/span>&lt;/td>
&lt;td>充要&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;/td>
&lt;td>函数极限&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(f\left(x_{0}^{-}\right)=f\left(x_{0}^{+}\right)=A\)&lt;/span>&lt;/td>
&lt;td>充要&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>&lt;/td>
&lt;td>数列极限&lt;span class="math inline">\(\lim _{n \rightarrow \infty} u_{n}=A\)&lt;/span> &lt;span class="math inline">\(\Leftrightarrow\)&lt;/span> &lt;span class="math inline">\(\lim _{n \rightarrow \infty} u_{2 n}=\lim _{n \rightarrow \infty} u_{2 n-1}=A\)&lt;/span>&lt;/td>
&lt;td>充要&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>单调有界定理&lt;/td>
&lt;td>单调有限函数必有极限；单调有界数列必有极限&lt;/td>
&lt;td>充分条件&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>夹逼定理&lt;/td>
&lt;td>&lt;/td>
&lt;td>充分条件&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>极限唯一性&lt;/td>
&lt;td>&lt;/td>
&lt;td>必要条件&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>函数极限保号性&lt;/td>
&lt;td>如果函数极限&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=A\)&lt;/span>（极限收敛于A），若A&amp;gt;0，那么存在常数&lt;span class="math inline">\(\delta&amp;gt;0\)&lt;/span>，&lt;span class="math inline">\(0&amp;lt;|x-x_0|&amp;lt;\delta\)&lt;/span>时，&lt;span class="math inline">\(f(x)&amp;gt;0\)&lt;/span>；同理A&amp;lt;0时，&lt;span class="math inline">\(\delta\)&lt;/span>的邻域内&lt;span class="math inline">\(f(x)&amp;gt;0\)&lt;/span>&lt;/td>
&lt;td>必要条件&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>收敛数列极限的保号性&lt;/td>
&lt;td>如果数列极限&lt;span class="math inline">\(\lim _{n \rightarrow \infty} u_{n}=A\)&lt;/span>（极限收敛于A），若A&amp;gt;0，那么存在正整数N，当n&amp;gt;N时，有&lt;span class="math inline">\(u_n &amp;gt;0\)&lt;/span>； 同理A&amp;lt;0时， 第N项之后都保证&lt;span class="math inline">\(u_n&amp;lt;0\)&lt;/span>&lt;/td>
&lt;td>必要条件&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>洛必达法则&lt;/td>
&lt;td>&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>和&lt;span class="math inline">\(\frac{\infty}{\infty}\)&lt;/span>极限，对分子分母分别求导，极限不变&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>四则运算&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h5 id="极限四则运算法则">极限四则运算法则&lt;/h5>
&lt;p>两个（或有限个）无穷小的和是无穷小&lt;/p>
&lt;p>有界函数与无穷小的乘积是无穷小。&lt;/p>
&lt;p>函数极限的四则运算：如果&lt;span class="math inline">\(\lim u(x)=A, \lim v(x)=B\)&lt;/span>，那么有： &lt;span class="math inline">\(\lim [u(x) \pm v(x)]=\lim u(x) \pm \lim v(x)=A \pm B ;\)&lt;/span> &lt;span class="math inline">\(\lim _{x \rightarrow*}(u(x) v(x))=\left(\lim _{x \rightarrow*} u(x)\right)\left(\lim _{x \rightarrow*} v(x)\right)=A B\)&lt;/span> &lt;span class="math inline">\(\lim _{x \rightarrow*}(c u(x))=c \lim _{x \rightarrow*} u(x)=c A\)&lt;/span> &lt;span class="math inline">\(\lim _{x \rightarrow*} \frac{u(x)}{v(x)}=\frac{\lim _{x \rightarrow *} u(x)}{\lim _{x \rightarrow*} v(x)}=\frac{A}{B}\)&lt;/span>&lt;/p>
&lt;p>数列极限的四则运算：与函数极限的四则运算一致。&lt;/p>
&lt;p>函数极限减法的推论：如果 &lt;span class="math inline">\(\varphi(x) \geqslant \psi(x),\)&lt;/span> 而 &lt;span class="math inline">\(\lim \varphi(x)=A, \lim \psi(x)=B,\)&lt;/span> 那么 $ A B$&lt;/p>
&lt;h5 id="洛必达法则">洛必达法则&lt;/h5>
&lt;h5 id="复合函数极限运算法则">复合函数极限运算法则&lt;/h5>
&lt;p>前提： 1）函数&lt;span class="math inline">\(y=f(g(x))\)&lt;/span>是由函数&lt;span class="math inline">\(u=g(x)\)&lt;/span>和函数&lt;span class="math inline">\(y=f(u)\)&lt;/span>复合而成 2）&lt;span class="math inline">\(y=f(g(x))\)&lt;/span>在点&lt;span class="math inline">\(x_0\)&lt;/span>的去心邻域内有定义 条件： 1）&lt;span class="math inline">\(\lim _{\mathfrak{u} \rightarrow \mathfrak{u}_{0}} \mathrm{f}(\mathrm{u})=A\)&lt;/span> 2）&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} g(x)=u_{0}\)&lt;/span> 3）存在&lt;span class="math inline">\(\delta_0 &amp;gt;0\)&lt;/span>，当&lt;span class="math inline">\(\mathbf{x} \in \mathring{U}{a}\left(\mathbf{x}_{0}, \delta_{0}\right)\)&lt;/span>时，有&lt;span class="math inline">\(g(x) \neq u_{0}\)&lt;/span> 结论： 则&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f[g(x)]=\lim _{u \rightarrow u_{0}} f(u)=A\)&lt;/span>&lt;/p>
&lt;h5 id="数列极限的性质">&lt;a href="#收敛数列的性质">数列极限的性质&lt;/a>&lt;/h5>
&lt;p>即数列极限存在时的一些必要条件&lt;/p>
&lt;p>（唯一性、有界性、保号性以及推论、收敛数列与子数列关系）&lt;/p>
&lt;h5 id="函数极限性质">&lt;a href="#函数极限的性质">函数极限性质&lt;/a>&lt;/h5>
&lt;p>即函数极限存在时的一些必要条件&lt;/p>
&lt;p>（唯一性、局部有界性、局部保号性以及推论、数列极限与函数极限关系）&lt;/p>
&lt;h5 id="极限存在准则">极限存在准则&lt;/h5>
&lt;p>讲极限存在的充分与充分必要条件。&lt;/p>
&lt;p>（数列极限存在充分条件：夹逼准则）如果数列 &lt;span class="math inline">\(\left\{x_{n}\right\},\left\{y_{n} \right\}\)&lt;/span> 及 &lt;span class="math inline">\(\left\{z_{n} \right\}\)&lt;/span> 满足下列条件： 1）从某项起,即 &lt;span class="math inline">\(\exists n_{0} \in \mathbf{N}_{+},\)&lt;/span> 当 &lt;span class="math inline">\(n&amp;gt;n_{0}\)&lt;/span> 时 &lt;span class="math inline">\(,\)&lt;/span> 有&lt;span class="math inline">\(y_{n} \leqslant x_{n} \leqslant z_{n}\)&lt;/span>； 2）&lt;span class="math inline">\(\lim _{n \rightarrow \infty} y_{n}=a, \lim _{n \rightarrow \infty} z_{n}=a\)&lt;/span> 那么数列 &lt;span class="math inline">\(\left\{x_{n}\right\}\)&lt;/span> 的极 限存在, &lt;span class="math inline">\(\operatorname{llim}_{n \rightarrow \infty} x_{n}=a\)&lt;/span>&lt;/p>
&lt;p>（函数极限存在的充分条件：夹逼准则）如果： 1）当 &lt;span class="math inline">\(x \in \mathring{U}\left(x_{0}, r\right)(\)&lt;/span> 或 &lt;span class="math inline">\(|x|&amp;gt;M)\)&lt;/span> 时&lt;span class="math inline">\(g(x) \leqslant f(x) \leqslant h(x)\)&lt;/span>； 2）&lt;span class="math inline">\(\lim _{x \rightarrow x_{0} \atop(x \rightarrow \infty)} g(x)=A, \lim _{x \rightarrow x_{0} \atop(x \rightarrow \infty)} h(x)=A\)&lt;/span> 那么 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0} \atop(x \rightarrow \infty)} f(x)\)&lt;/span> 存在,且等于 &lt;span class="math inline">\(A\)&lt;/span>&lt;/p>
&lt;p>（数列极限存在的充分条件：单调有界）单调有界数列必有极限。&lt;/p>
&lt;p>（函数极限存在的充分条件：单调有界）设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某个左邻域内单调并且有界,则 &lt;span class="math inline">\(f(x)\)&lt;/span> 在 &lt;span class="math inline">\(x_{0}\)&lt;/span>的左极限 &lt;span class="math inline">\(f\left(x_{0}^{-}\right)\)&lt;/span> 必定存在.&lt;/p>
&lt;p>（数列收敛的充分必要条件：柯西极限存在准则）对于任意给定的正数 &lt;span class="math inline">\(\varepsilon,\)&lt;/span> 存在正整数 &lt;span class="math inline">\(N,\)&lt;/span> 使得 当 &lt;span class="math inline">\(m&amp;gt;N, n&amp;gt;N\)&lt;/span> 时, 有&lt;span class="math inline">\(\left|x_{n}-x_{m}\right|&amp;lt;\varepsilon\)&lt;/span> 参考&lt;a href="#数列极限的定义">数列极限的定义&lt;/a>，会发现，数列极限的定义和柯西极限准则其实是差不多的。&lt;/p>
&lt;h4 id="极限的计算">极限的计算&lt;/h4>
&lt;p>计算函数、数列的极限，可以借助极限的定义、性质、运算法则、等价替换、洛必达法则、泰勒公式替换、复合函数求极限、特殊极限定义、化为对数形式等方法求得。&lt;/p>
&lt;p>大体上的极限计算过程： 1）代入对应的点，判断是否可直接计算出极限。否则为7种待定型。 2）如果能直接计算极限，代入计算 3）如果是待定型，根据其待定型类型，试用对应的方法求解， 4）如果无法根据待定型求解，考虑拆分为多个极限相加或相乘、或者考虑特殊极限定义、夹逼定理和泰勒公式等方法&lt;/p>
&lt;h5 id="待定型求极限">待定型求极限&lt;/h5>
&lt;p>共七种待定型，以下是一般解题思路，若无法根据待定型解题，则考虑泰勒展开和夹逼定理等&lt;/p>
&lt;h6 id="frac00型fracinftyinfty型">&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>型、&lt;span class="math inline">\(\frac{\infty}{\infty}\)&lt;/span>型&lt;/h6>
&lt;ul>
&lt;li>常用洛必达法则&lt;/li>
&lt;li>因式分解或者根式有理化+极限运算法则/连续函数求极限&lt;/li>
&lt;li>等价无穷小&lt;/li>
&lt;li>变量替换（洛必达反而更复杂，考虑变量替换）&lt;/li>
&lt;/ul>
&lt;h6 id="infty---infty型求极限">&lt;span class="math inline">\(\infty - \infty\)&lt;/span>型求极限&lt;/h6>
&lt;ul>
&lt;li>通分，化为&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>&lt;/li>
&lt;li>根式有理化，化为&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>&lt;/li>
&lt;li>变量替换&lt;/li>
&lt;/ul>
&lt;h6 id="cdot-infty型求极限">&lt;span class="math inline">\(0\cdot \infty\)&lt;/span>型求极限&lt;/h6>
&lt;ul>
&lt;li>乘一个数等于处以一个数的倒数，化为&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>型、&lt;span class="math inline">\(\frac{\infty}{\infty}\)&lt;/span>型&lt;/li>
&lt;/ul>
&lt;h6 id="infty型00型infty0型求极限">&lt;span class="math inline">\(1^\infty\)&lt;/span>型、&lt;span class="math inline">\(0^0\)&lt;/span>型、&lt;span class="math inline">\(\infty^0\)&lt;/span>型求极限&lt;/h6>
&lt;ul>
&lt;li>凑&lt;span class="math inline">\(\lim _{x \rightarrow 0}(1+x)^{\frac{1}{x}}\)&lt;/span>&lt;/li>
&lt;li>将&lt;span class="math inline">\(u(x)^{v(x)}\)&lt;/span>化成指数形式&lt;span class="math inline">\(u(x)^{v(x)}=e^{v(x) \ln (x)}\)&lt;/span>&lt;/li>
&lt;/ul>
&lt;h5 id="特殊极限定义">特殊极限定义&lt;/h5>
&lt;p>&lt;span class="math inline">\(\lim _{x \rightarrow 0}(1+x)^{\frac{1}{x}}=\mathrm{e}\)&lt;/span>这是自然对数的定义&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{n \rightarrow \infty} u_{n}=\lim _{n \rightarrow \infty} \frac{1}{n} \sum_{i=1}^{n} f\left(\frac{i}{n}\right)=\int_{0}^{1} f(x) \mathrm{d} x\)&lt;/span>，要求&lt;span class="math inline">\(f(x)\)&lt;/span>在[0,1]上连续。这是积分的定义&lt;/p>
&lt;p>&lt;span class="math inline">\(x^{m}+x^{k} \sim x^{m},(m&amp;gt;k&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{n \rightarrow \infty} \sqrt[n]{n}=1\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{n \rightarrow \infty} \sqrt[n]{a}=1\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{x \rightarrow 0^{+}} x^{\delta}(\ln x)^{k}=0\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\lim _{x \rightarrow+\infty} x^{k} \mathrm{e}^{-\delta x}=0\)&lt;/span>&lt;/p>
&lt;h5 id="已知极限求其他">已知极限求其他&lt;/h5>
&lt;h6 id="已知极限求参数">已知极限求参数&lt;/h6>
&lt;ul>
&lt;li>带参数求一下极限，各种求极限的方法见&lt;a href="#极限的计算">极限的计算&lt;/a>一节，将得出的结果与已知比较&lt;/li>
&lt;li>若只说明极限存在，则在求极限的过程中注意参数应满足的条件&lt;/li>
&lt;/ul>
&lt;h6 id="已知极限求另一极限">已知极限求另一极限&lt;/h6>
&lt;ul>
&lt;li>利用极限和无穷小的关系：&lt;span class="math inline">\(\lim {f(x) }= A\)&lt;/span>，则&lt;span class="math inline">\(f(x)=A+\alpha\)&lt;/span>求出&lt;span class="math inline">\(f(x)\)&lt;/span>进而代入另一个极限中&lt;/li>
&lt;li>将欲求极限凑成用已知极限表示的形式&lt;/li>
&lt;/ul>
&lt;h5 id="含有绝对值取整函数或为分段函数求极限">含有绝对值，取整函数，或为分段函数求极限&lt;/h5>
&lt;p>从正负两个方向分别求极限&lt;/p>
&lt;h5 id="求数列的极限">求数列的极限&lt;/h5>
&lt;p>&lt;strong>n个因式的积&lt;/strong>的极限，取对数可以变成n项和的形式，&lt;/p>
&lt;p>&lt;strong>n项和&lt;/strong>用公式或者积分定义等方法求解&lt;/p>
&lt;p>&lt;strong>以递推形式给出的数列&lt;/strong>，求极限常用单调有界准则和夹逼定理&lt;/p>
&lt;p>求&lt;strong>以极限定义的函数的表达式&lt;/strong>，一般用夹逼定理求解&lt;/p>
&lt;h3 id="函数的连续性">函数的连续性&lt;/h3>
&lt;h4 id="连续与间断的概念">连续与间断的概念&lt;/h4>
&lt;h5 id="增量的定义">增量的定义&lt;/h5>
&lt;p>设变量 u 从它的一个初值 &lt;span class="math inline">\(u_{1}\)&lt;/span> 变到终值 &lt;span class="math inline">\(u_{2},\)&lt;/span> 终值与初值的差 &lt;span class="math inline">\(u_{2}-u_{1}\)&lt;/span> 就叫做脚 u 的增量,记作 &lt;span class="math inline">\(\Delta u\)&lt;/span>,即&lt;span class="math inline">\(\Delta u=u_{2}-u_{1}\)&lt;/span>&lt;/p>
&lt;h5 id="函数在某点连续的定义">函数在某点连续的定义&lt;/h5>
&lt;p>&lt;strong>定义1&lt;/strong>：设 函数 &lt;span class="math inline">\(y=f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某一邻域内有定义, 如果&lt;span class="math inline">\(\lim _{\Delta x \rightarrow 0} \Delta y=\lim _{\Delta x \rightarrow 0}\left[f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)\right]=0\)&lt;/span>那么就称函数 &lt;span class="math inline">\(y=f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 连续.&lt;/p>
&lt;p>（即自变量增量趋于0，函数增量也趋于0，称为连续）&lt;/p>
&lt;p>&lt;strong>定义2&lt;/strong>：设函数 &lt;span class="math inline">\(y=f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某一邻域 内有定义,如果&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)=f\left(x_{0}\right)\)&lt;/span>，那么就称函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 连续.&lt;/p>
&lt;p>（定义2的极限式两边各减一个&lt;span class="math inline">\(f(x_0)\)&lt;/span>，就变到了定义1，所以两个定义意思式相同的）&lt;/p>
&lt;p>（左连续/右连续定义略）&lt;/p>
&lt;h5 id="函数在区间上连续的定义">函数在区间上连续的定义&lt;/h5>
&lt;p>在区间上每一点都连续的函数, 叫做在该区间上的连续函数,或者说函数在区间上连续。 比如函数在(a,b)内，[a,b]上连续&lt;/p>
&lt;h5 id="函数在区间上一致连续的定义">函数在区间上一致连续的定义&lt;/h5>
&lt;p>&lt;strong>定义&lt;/strong>：设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\(I\)&lt;/span> 上有定义. 如果对于任意给定的正数 &lt;span class="math inline">\(\varepsilon\)&lt;/span>,总存在（同一个）正数 &lt;span class="math inline">\(\delta,\)&lt;/span> 使得对于区间$ I$ 上的任意两点 &lt;span class="math inline">\(x_{1}, x_{2},\)&lt;/span> 当 &lt;span class="math inline">\(\left|x_{1}-x_{2}\right|&amp;lt;\delta\)&lt;/span> 时, &lt;span class="math inline">\(,\)&lt;/span> 有&lt;span class="math inline">\(\left|f\left(x_{1}\right)-f\left(x_{2}\right)\right|&amp;lt;\varepsilon\)&lt;/span>，那么称函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 I 上一致连续.&lt;/p>
&lt;p>一致连续性表示,不论在区间 I 的任何部分,只要自变量的两个数值接近到一定程度,就可使对应的函数值达到所指定的接近程度.&lt;/p>
&lt;p>如果函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 I 上一致连续,那么 &lt;span class="math inline">\(f(x)\)&lt;/span> 在区间 I 上也是连续的。反之不一定成立。&lt;/p>
&lt;p>(一致连续性定理) 如果函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在闭区间 [ a,b]上连续, 那么它 在该区间上一致连续.&lt;/p>
&lt;h5 id="函数间断点的定义">函数间断点的定义&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某去心邻域内有定义，但是在&lt;span class="math inline">\(x_0\)&lt;/span>点&lt;strong>不连续&lt;/strong>，那么点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 称为 函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 的不连续点或间断点. 具体的讲，函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 的某去心邻域内有定义，如下3种情况任一都是间断点： （1）在 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 没有定义 （2）虽在 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 有定义, 但 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span> 不存在 （3）虽在 &lt;span class="math inline">\(x=x_{0}\)&lt;/span> 有定义，且 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span> 存在 &lt;span class="math inline">\(,\)&lt;/span> 但 &lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x) \neq f\left(x_{0}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="第一类间断点">第一类间断点&lt;/h5>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>的某去心邻域内有定义，且&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span>存在，但&lt;span class="math inline">\(f(x_0)\)&lt;/span>无定义，或者虽有定义，但是与&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f(x)\)&lt;/span>不相等，称&lt;span class="math inline">\(x=x_0\)&lt;/span>为&lt;strong>可去间断点&lt;/strong>&lt;/p>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>的某去心邻域内有定义，&lt;span class="math inline">\(\lim _{x \rightarrow x_{0+}} f(x)\)&lt;/span>和&lt;span class="math inline">\(\lim _{x \rightarrow x_{0-}} f(x)\)&lt;/span>都存在，但不相等，称&lt;span class="math inline">\(x=x_0\)&lt;/span>为&lt;strong>跳跃间断点&lt;/strong>&lt;/p>
&lt;p>可去间断点和跳跃间断点统称为&lt;strong>第一类间断点&lt;/strong>&lt;/p>
&lt;h5 id="第二类间断点">第二类间断点&lt;/h5>
&lt;p>设&lt;span class="math inline">\(f(x)\)&lt;/span>在&lt;span class="math inline">\(x=x_0\)&lt;/span>的某去心邻域内有定义，&lt;span class="math inline">\(\lim _{x \rightarrow x_{0+}} f(x)\)&lt;/span>和&lt;span class="math inline">\(\lim _{x \rightarrow x_{0-}} f(x)\)&lt;/span>至少有一个不存在，称&lt;span class="math inline">\(x=x_0\)&lt;/span>为&lt;span class="math inline">\(f(x)\)&lt;/span>的第二类间断点&lt;/p>
&lt;h4 id="连续函数的运算性质">连续函数的运算性质&lt;/h4>
&lt;h5 id="连续函数的四则运算仍连续">连续函数的四则运算仍连续&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 和 &lt;span class="math inline">\(g(x)\)&lt;/span> 在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 连续,则 它们的和（差 ) &lt;span class="math inline">\(f \pm g\)&lt;/span>, 积 &lt;span class="math inline">\(f \cdot g\)&lt;/span> 及商&lt;span class="math inline">\(\frac{f}{g}\left(\right.\)&lt;/span> 当 &lt;span class="math inline">\(g\left(x_{0}\right) \neq 0\)&lt;/span> 时 &lt;span class="math inline">\()\)&lt;/span> 都在点 &lt;span class="math inline">\(x_{0}\)&lt;/span> 连续.&lt;/p>
&lt;h5 id="反函数的连续性">反函数的连续性&lt;/h5>
&lt;p>如果函数 &lt;span class="math inline">\(y=f(x)\)&lt;/span> 在区间 &lt;span class="math inline">\(I_{x}\)&lt;/span> 上单调增加（或单调减少）且连续,那么它的反函数 &lt;span class="math inline">\(x=f^{-1}(y)\)&lt;/span> 也在对应的区间 &lt;span class="math inline">\(I_{y}=\left\{y \mid y=f(x), x \in I_{x}\right\}\)&lt;/span> 上单调增加（或单 调减少）且连续。&lt;/p>
&lt;h5 id="复合函数的连续性">复合函数的连续性&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(y=f[g(x)]\)&lt;/span> 由 函数 &lt;span class="math inline">\(u=g(x)\)&lt;/span> 与函数 &lt;span class="math inline">\(y=f(u)\)&lt;/span> 复 合而成，&lt;span class="math inline">\(U^{\circ}\left(x_{0}\right) \subset D_{f \circ g}\)&lt;/span> 若 &lt;span class="math inline">\(\operatorname{limg}_{x \rightarrow x_{0}}(x)=u_{0},\)&lt;/span> 而 函数 &lt;span class="math inline">\(y=f(u)\)&lt;/span> 在 &lt;span class="math inline">\(u=u_{0}\)&lt;/span> 连 续 &lt;span class="math inline">\(,\)&lt;/span> 则&lt;span class="math inline">\(\lim _{x \rightarrow x_{0}} f[g(x)]=\lim _{u \rightarrow u_{0}} f(u)=f\left(u_{0}\right)\)&lt;/span>&lt;/p>
&lt;h5 id="初等函数的连续性">初等函数的连续性&lt;/h5>
&lt;p>&lt;strong>基本初等函数&lt;/strong>在它们的定义域内都是连续的.&lt;/p>
&lt;p>一切&lt;strong>初等函数&lt;/strong>在其定义区间内都是连续的。&lt;/p>
&lt;h4 id="闭区间上连续函数的定理或性质">闭区间上连续函数的定理或性质&lt;/h4>
&lt;h5 id="有界性定理">有界性定理&lt;/h5>
&lt;p>函数在&lt;strong>闭区间连续&lt;/strong> &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 一定&lt;strong>有界&lt;/strong>（有界性定理）&lt;/p>
&lt;h5 id="最值定理">最值定理&lt;/h5>
&lt;p>函数在&lt;strong>闭区间连续&lt;/strong> &lt;span class="math inline">\(\Rightarrow\)&lt;/span> 一定&lt;strong>有最大值与最小值&lt;/strong>（最值定理）&lt;/p>
&lt;h5 id="介值定理">介值定理&lt;/h5>
&lt;p>设函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在闭区间 [ a,b]上连续,且在这区间的端点取不同的函数值&lt;span class="math inline">\(f(a)=A\)&lt;/span> 及 &lt;span class="math inline">\(f(b)=B\)&lt;/span>，则 对于 A 与 B 之间的任意一个数 &lt;span class="math inline">\(C,\)&lt;/span> 在开区间 ( &lt;span class="math inline">\(a, b)\)&lt;/span> 内至少有一点 &lt;span class="math inline">\(\xi,\)&lt;/span> 使得&lt;span class="math inline">\(f(\xi)=C \quad(a&amp;lt;\xi&amp;lt;b)\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>推论&lt;/strong>：函数在&lt;strong>闭区间[a,b]连续&lt;/strong>，设&lt;span class="math inline">\(\mu\)&lt;/span>满足&lt;span class="math inline">\(m \leqslant \mu \leqslant M\)&lt;/span>，m与M是&lt;span class="math inline">\(f(x)\)&lt;/span>在[a,b]上的最小、最大值， &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;strong>闭区间&lt;/strong>至少存在一点&lt;span class="math inline">\(\delta \in [a,b]\)&lt;/span>，使得&lt;span class="math inline">\(f(\xi)=\mu\)&lt;/span> （介值定理）&lt;/p>
&lt;h5 id="零点定理">零点定理&lt;/h5>
&lt;p>函数在&lt;strong>闭区间连续&lt;/strong>，若&lt;span class="math inline">\(f(a) f(b)&amp;lt;0\)&lt;/span>， &lt;span class="math inline">\(\Rightarrow\)&lt;/span> &lt;strong>开区间&lt;/strong>至少存在一点&lt;span class="math inline">\(\xi \in(a, b)\)&lt;/span>，使&lt;span class="math inline">\(f(\xi)=0\)&lt;/span> （零点定理）&lt;/p>
&lt;h5 id="一致连续性定理">一致连续性定理&lt;/h5>
&lt;p>如果函数 &lt;span class="math inline">\(f(x)\)&lt;/span> 在闭区间 [ a,b]上连续, 那么它 在该区间上一致连续.&lt;/p>
&lt;h4 id="讨论函数的间断与连续">讨论函数的间断与连续&lt;/h4>
&lt;p>复合函数的连续性&lt;/p>
&lt;p>基本初等函数的连续性&lt;/p>
&lt;p>初等函数的连续性&lt;/p>
&lt;p>由极限定义的函数的连续性&lt;/p>
&lt;h4 id="已知连续求参数">已知连续求参数&lt;/h4>
&lt;p>一般是分段函数，函数连续则在&lt;strong>分段点左极限等于右极限&lt;/strong>&lt;/p></description></item><item><title>高等数学-基础概念-函数与极限习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 06 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-基础概念-函数与极限习题">高等数学-基础概念-函数与极限习题&lt;/h1>
&lt;p>首先判断未定式类型，使用对应的方法 无法根据未定式求解时，考虑根据定义来做，或者夹逼定理，泰勒展开等 对于含有绝对值的式子求极限，需要分类讨论&lt;/p>
&lt;h2 id="根据未定式的形式求极限">根据未定式的形式求极限&lt;/h2>
&lt;h3 id="frac00型fracinftyinfty型">&lt;span class="math inline">\(\frac{0}{0}\)&lt;/span>型、&lt;span class="math inline">\(\frac{\infty}{\infty}\)&lt;/span>型&lt;/h3>
&lt;h4 id="等价无穷小求极限">等价无穷小求极限&lt;/h4>
&lt;h6 id="例1">例1&lt;/h6>
&lt;p>&lt;span class="math inline">\(\lim _{x \rightarrow 0} \frac{e^{x}-e^{\ln (1+x)}}{x \arcsin 2 x}\)&lt;/span>=？&lt;/p>
&lt;p>答：&lt;/p>
&lt;p>&lt;span class="math inline">\(\frac{e^{x}-e^{\ln (1+x)}}{x+0} \frac{e^{x}}{x \arcsin 2 x}=\lim _{x \rightarrow 0} e^{\ln (1+x)} \cdot \frac{e^{x-\ln (1+x)}-1}{2 x^{2}}=\lim _{x \rightarrow 0} \frac{e^{x-\ln (1+x)}-1}{2 x^{2}}\)&lt;/span> &lt;span class="math inline">\(=\lim _{x \rightarrow 0} \frac{x-\ln (1+x)}{2 x^{2}}=\lim _{x \rightarrow 0} \frac{1-\frac{1}{1+x}}{4 x}=\frac{1}{4}\)&lt;/span>&lt;/p>
&lt;h6 id="例2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401180016813.png" alt="" />&lt;figcaption>image-20200401180016813&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401180054656.png" alt="" />&lt;figcaption>image-20200401180054656&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402090331972.png" alt="" />&lt;figcaption>image-20200402090331972&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402090433834.png" alt="" />&lt;figcaption>image-20200402090433834&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403111854513.png" alt="" />&lt;figcaption>image-20200403111854513&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403112000737.png" alt="" />&lt;figcaption>image-20200403112000737&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403171516699.png" alt="" />&lt;figcaption>image-20200403171516699&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403171545204.png" alt="" />&lt;figcaption>image-20200403171545204&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403172337378.png" alt="" />&lt;figcaption>image-20200403172337378&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403172416159.png" alt="" />&lt;figcaption>image-20200403172416159&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409084345553.png" alt="" />&lt;figcaption>image-20200409084345553&lt;/figcaption>
&lt;/figure>
&lt;p>这里使用等价无穷小，也可以使用和差化积+泰勒展开&lt;/p>
&lt;h6 id="例8">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409095405172.png" alt="" />&lt;figcaption>image-20200409095405172&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409195127908.png" alt="" />&lt;figcaption>image-20200409195127908&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409195157677.png" alt="" />&lt;figcaption>image-20200409195157677&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根式有理化或因式分解求极限">根式有理化或因式分解求极限&lt;/h4>
&lt;p>目的是尽可能的消去0或无穷因子，再用极限运算法则或连续函数极限的求法。&lt;/p>
&lt;h6 id="例1-1">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401173229962.png" alt="" />&lt;figcaption>image-20200401173229962&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-1">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401174147992.png" alt="" />&lt;figcaption>image-20200401174147992&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-1">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403145442719.png" alt="" />&lt;figcaption>image-20200403145442719&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-2">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403151532719.png" alt="" />&lt;figcaption>image-20200403151532719&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403151554964.png" alt="" />&lt;figcaption>image-20200403151554964&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-1">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408113236261.png" alt="" />&lt;figcaption>image-20200408113236261&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-1">例5&lt;/h6>
&lt;p>方法1根式有理化，方法2等价无穷小替换&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409083319678.png" alt="" />&lt;figcaption>image-20200409083319678&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-1">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409135232993.png" alt="" />&lt;figcaption>image-20200409135232993&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409135256885.png" alt="" />&lt;figcaption>image-20200409135256885&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-1">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409194230309.png" alt="" />&lt;figcaption>image-20200409194230309&lt;/figcaption>
&lt;/figure>
&lt;h4 id="洛必达法则求极限">洛必达法则求极限&lt;/h4>
&lt;h6 id="例1-2">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409133844661.png" alt="" />&lt;figcaption>image-20200409133844661&lt;/figcaption>
&lt;/figure>
&lt;h4 id="变量替换求极限">变量替换求极限&lt;/h4>
&lt;p>使用洛必达法则运算后，若式子反而比原来更复杂，应想到用变量替换。&lt;/p>
&lt;h6 id="例1-3">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402120405369.png" alt="" />&lt;figcaption>image-20200402120405369&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402120441134.png" alt="" />&lt;figcaption>image-20200402120441134&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-2">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403111022713.png" alt="" />&lt;figcaption>image-20200403111022713&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-3">例3&lt;/h6>
&lt;p>本题用等价无穷小+变量替换&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409213546435.png" alt="" />&lt;figcaption>image-20200409213546435&lt;/figcaption>
&lt;/figure>
&lt;h4 id="直接凑成或者添加因子凑成两个极限的积或和">直接凑成或者添加因子凑成两个极限的积或和&lt;/h4>
&lt;h6 id="例1-4">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401173605340.png" alt="" />&lt;figcaption>image-20200401173605340&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-3">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402114333742.png" alt="" />&lt;figcaption>image-20200402114333742&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402114527807.png" alt="" />&lt;figcaption>image-20200402114527807&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402114546435.png" alt="" />&lt;figcaption>image-20200402114546435&lt;/figcaption>
&lt;/figure>
&lt;p>解此题还有一种方法见&lt;a href="#泰勒公式求极限">泰勒公式求极限&lt;/a>的例1&lt;/p>
&lt;h6 id="例3-4">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403211023057.png" alt="" />&lt;figcaption>image-20200403211023057&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403211111078.png" alt="" />&lt;figcaption>image-20200403211111078&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-2">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403213629732.png" alt="" />&lt;figcaption>image-20200403213629732&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403213729881.png" alt="" />&lt;figcaption>image-20200403213729881&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403213752899.png" alt="" />&lt;figcaption>image-20200403213752899&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-2">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408111935970.png" alt="" />&lt;figcaption>image-20200408111935970&lt;/figcaption>
&lt;/figure>
&lt;p>此题也可对sin部分直接做等价无穷小代换&lt;/p>
&lt;h6 id="例6-2">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408114007744.png" alt="" />&lt;figcaption>image-20200408114007744&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-2">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408115523423.png" alt="" />&lt;figcaption>image-20200408115523423&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408115612174.png" alt="" />&lt;figcaption>image-20200408115612174&lt;/figcaption>
&lt;/figure>
&lt;p>这道题先凑成两个极限的积，然后多次使用等价无穷小替换&lt;/p>
&lt;h6 id="例8-1">例8&lt;/h6>
&lt;p>凑因子+洛必达+分子有理化&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409082831059.png" alt="" />&lt;figcaption>image-20200409082831059&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409082922185.png" alt="" />&lt;figcaption>image-20200409082922185&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-1">例9&lt;/h6>
&lt;p>凑因子+等价无穷小&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409085232800.png" alt="" />&lt;figcaption>image-20200409085232800&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409100235923.png" alt="" />&lt;figcaption>image-20200409100235923&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409100315223.png" alt="" />&lt;figcaption>image-20200409100315223&lt;/figcaption>
&lt;/figure>
&lt;p>注意这里分母凑成两项的和，原式的倒数可以拆成两项使用等价无穷小替换，所以这里的分母也可以使用等价无穷小替换&lt;/p>
&lt;h6 id="例11">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409222303098.png" alt="" />&lt;figcaption>image-20200409222303098&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409222330272.png" alt="" />&lt;figcaption>image-20200409222330272&lt;/figcaption>
&lt;/figure>
&lt;p>这道题是凑因子+泰勒展开&lt;/p>
&lt;h4 id="提因子留常数加无穷小量">提因子留常数加无穷小量&lt;/h4>
&lt;h6 id="例1-5">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409101909351.png" alt="" />&lt;figcaption>image-20200409101909351&lt;/figcaption>
&lt;/figure>
&lt;h4 id="分子分母同除以因子求极限">分子分母同除以因子求极限&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402081042603.png" alt="" />&lt;figcaption>image-20200402081042603&lt;/figcaption>
&lt;/figure>
&lt;h4 id="化为对数形式">化为对数形式&lt;/h4>
&lt;h6 id="例1-6">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409094246742.png" alt="" />&lt;figcaption>image-20200409094246742&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-4">例2&lt;/h6>
&lt;p>化为对数形式+等价无穷小替换&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409095757376.png" alt="" />&lt;figcaption>image-20200409095757376&lt;/figcaption>
&lt;/figure>
&lt;h3 id="infty---infty型求极限">&lt;span class="math inline">\(\infty - \infty\)&lt;/span>型求极限&lt;/h3>
&lt;h4 id="通分求极限">通分求极限&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403171132716.png" alt="" />&lt;figcaption>image-20200403171132716&lt;/figcaption>
&lt;/figure>
&lt;h4 id="提因子变量替换求极限">提因子变量替换求极限&lt;/h4>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402121244291.png" alt="" />&lt;figcaption>image-20200402121244291&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402121320123.png" alt="" />&lt;figcaption>image-20200402121320123&lt;/figcaption>
&lt;/figure>
&lt;h3 id="cdot-infty型求极限">&lt;span class="math inline">\(0\cdot \infty\)&lt;/span>型求极限&lt;/h3>
&lt;h4 id="变量替换">变量替换&lt;/h4>
&lt;h6 id="例1-7">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409102707278.png" alt="" />&lt;figcaption>image-20200409102707278&lt;/figcaption>
&lt;/figure>
&lt;h3 id="infty型00型infty0型求极限">&lt;span class="math inline">\(1^\infty\)&lt;/span>型、&lt;span class="math inline">\(0^0\)&lt;/span>型、&lt;span class="math inline">\(\infty^0\)&lt;/span>型求极限&lt;/h3>
&lt;h4 id="凑自然对数e求极限">凑自然对数e求极限&lt;/h4>
&lt;h6 id="例1-8">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401170425559.png" alt="" />&lt;figcaption>image-20200401170425559&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401170936001.png" alt="" />&lt;figcaption>image-20200401170936001&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401172806959.png" alt="" />&lt;figcaption>image-20200401172806959&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402083707944.png" alt="" />&lt;figcaption>image-20200402083707944&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403083438225.png" alt="" />&lt;figcaption>image-20200403083438225&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403110611438.png" alt="" />&lt;figcaption>image-20200403110611438&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408224008399.png" alt="" />&lt;figcaption>image-20200408224008399&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408225037250.png" alt="" />&lt;figcaption>image-20200408225037250&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409104906094.png" alt="" />&lt;figcaption>image-20200409104906094&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-5">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402082646025.png" alt="" />&lt;figcaption>image-20200402082646025&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402082708438.png" alt="" />&lt;figcaption>image-20200402082708438&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-5">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403172706329.png" alt="" />&lt;figcaption>image-20200403172706329&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403172800970.png" alt="" />&lt;figcaption>image-20200403172800970&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-3">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409171545378.png" alt="" />&lt;figcaption>image-20200409171545378&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409171600823.png" alt="" />&lt;figcaption>image-20200409171600823&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-3">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409211604416.png" alt="" />&lt;figcaption>image-20200409211604416&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-3">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409212447319.png" alt="" />&lt;figcaption>image-20200409212447319&lt;/figcaption>
&lt;/figure>
&lt;h4 id="化为对数形式求极限">化为对数形式求极限&lt;/h4>
&lt;h6 id="例1-9">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402084323430.png" alt="" />&lt;figcaption>image-20200402084323430&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-6">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402120839749.png" alt="" />&lt;figcaption>image-20200402120839749&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402120904709.png" alt="" />&lt;figcaption>image-20200402120904709&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-6">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408234911947.png" alt="" />&lt;figcaption>image-20200408234911947&lt;/figcaption>
&lt;/figure>
&lt;p>注意这里将分子化为了对数形式，而没有使用e的定义&lt;/p>
&lt;h6 id="例4-4">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409105859946.png" alt="" />&lt;figcaption>image-20200409105859946&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-4">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409113225514.png" alt="" />&lt;figcaption>image-20200409113225514&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-4">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409174519319.png" alt="" />&lt;figcaption>image-20200409174519319&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409174546715.png" alt="" />&lt;figcaption>image-20200409174546715&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-3">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409215730291.png" alt="" />&lt;figcaption>image-20200409215730291&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409215744373.png" alt="" />&lt;figcaption>image-20200409215744373&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409215814285.png" alt="" />&lt;figcaption>image-20200409215814285&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-2">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409221224869.png" alt="" />&lt;figcaption>image-20200409221224869&lt;/figcaption>
&lt;/figure>
&lt;h2 id="未定式求极限解不出时">未定式求极限解不出时&lt;/h2>
&lt;h3 id="根据相关定义求极限">根据相关定义求极限&lt;/h3>
&lt;h4 id="根据导数定义求极限">根据导数定义求极限&lt;/h4>
&lt;h6 id="例1-10">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407180321560.png" alt="" />&lt;figcaption>image-20200407180321560&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407180409240.png" alt="" />&lt;figcaption>image-20200407180409240&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根据定积分定义求极限">根据定积分定义求极限&lt;/h4>
&lt;p>（分子齐，分母不齐 ）或者（分母齐，分子不齐）用夹逼定理。&lt;/p>
&lt;p>分子分母都齐次用积分。&lt;/p>
&lt;h6 id="例1-11">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409151202090.png" alt="" />&lt;figcaption>image-20200409151202090&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-7">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409152208272.png" alt="" />&lt;figcaption>image-20200409152208272&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409152229164.png" alt="" />&lt;figcaption>image-20200409152229164&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-7">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409153829510.png" alt="" />&lt;figcaption>image-20200409153829510&lt;/figcaption>
&lt;/figure>
&lt;h4 id="根据恒等变换求极限">根据恒等变换求极限&lt;/h4>
&lt;h6 id="例1-12">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409134517685.png" alt="" />&lt;figcaption>image-20200409134517685&lt;/figcaption>
&lt;/figure>
&lt;h3 id="夹逼定理求极限">夹逼定理求极限&lt;/h3>
&lt;p>（分子齐，分母不齐 ）或者（分母齐，分子不齐）用夹逼定理。&lt;/p>
&lt;p>分子分母都齐次用积分。&lt;/p>
&lt;h6 id="例1-13">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401174942343.png" alt="" />&lt;figcaption>image-20200401174942343&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200401175014552.png" alt="" />&lt;figcaption>image-20200401175014552&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-8">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402084750299.png" alt="" />&lt;figcaption>image-20200402084750299&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402084816913.png" alt="" />&lt;figcaption>image-20200402084816913&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-8">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402085514646.png" alt="" />&lt;figcaption>image-20200402085514646&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402085535719.png" alt="" />&lt;figcaption>image-20200402085535719&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-5">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403152536694.png" alt="" />&lt;figcaption>image-20200403152536694&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-5">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409140303145.png" alt="" />&lt;figcaption>image-20200409140303145&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409140348839.png" alt="" />&lt;figcaption>image-20200409140348839&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-5">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409170034727.png" alt="" />&lt;figcaption>image-20200409170034727&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409170105074.png" alt="" />&lt;figcaption>image-20200409170105074&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-4">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410110231206.png" alt="" />&lt;figcaption>image-20200410110231206&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410110246859.png" alt="" />&lt;figcaption>image-20200410110246859&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410110305106.png" alt="" />&lt;figcaption>image-20200410110305106&lt;/figcaption>
&lt;/figure>
&lt;h3 id="泰勒展开求极限">泰勒展开求极限&lt;/h3>
&lt;h6 id="例1-14">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402114333742.png" alt="" />&lt;figcaption>image-20200402114333742&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402114409390.png" alt="" />&lt;figcaption>image-20200402114409390&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-9">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403110311364.png" alt="" />&lt;figcaption>image-20200403110311364&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403110352803.png" alt="" />&lt;figcaption>image-20200403110352803&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-9">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403113555560.png" alt="" />&lt;figcaption>image-20200403113555560&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403113625395.png" alt="" />&lt;figcaption>image-20200403113625395&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403113646457.png" alt="" />&lt;figcaption>image-20200403113646457&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-6">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403170554784.png" alt="" />&lt;figcaption>image-20200403170554784&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403170623619.png" alt="" />&lt;figcaption>image-20200403170623619&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-6">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403204104384.png" alt="" />&lt;figcaption>image-20200403204104384&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403204145802.png" alt="" />&lt;figcaption>image-20200403204145802&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-6">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408211545241.png" alt="" />&lt;figcaption>image-20200408211545241&lt;/figcaption>
&lt;/figure>
&lt;p>可以使用泰勒展开+等价无穷小替换的方法：&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408213707165.png" alt="" />&lt;figcaption>image-20200408213707165&lt;/figcaption>
&lt;/figure>
&lt;p>也可以分母有理化+等价无穷小替换&lt;/p>
&lt;h6 id="例6-7">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408213558567.png" alt="" />&lt;figcaption>image-20200408213558567&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408214030306.png" alt="" />&lt;figcaption>image-20200408214030306&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-5">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408222016266.png" alt="" />&lt;figcaption>image-20200408222016266&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408222044801.png" alt="" />&lt;figcaption>image-20200408222044801&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-3">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409093413298.png" alt="" />&lt;figcaption>image-20200409093413298&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409093443187.png" alt="" />&lt;figcaption>image-20200409093443187&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-2">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409170649212.png" alt="" />&lt;figcaption>image-20200409170649212&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409170726281.png" alt="" />&lt;figcaption>image-20200409170726281&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-1">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409172653283.png" alt="" />&lt;figcaption>image-20200409172653283&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409172717891.png" alt="" />&lt;figcaption>image-20200409172717891&lt;/figcaption>
&lt;/figure>
&lt;p>本题也可以对分子使用和差化积公式+等价无穷小替换来做&lt;/p>
&lt;h6 id="例11-1">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409214148998.png" alt="" />&lt;figcaption>image-20200409214148998&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409214207249.png" alt="" />&lt;figcaption>image-20200409214207249&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409230443605.png" alt="" />&lt;figcaption>image-20200409230443605&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409230510176.png" alt="" />&lt;figcaption>image-20200409230510176&lt;/figcaption>
&lt;/figure>
&lt;h4 id="带绝对值式子求极限">带绝对值式子求极限&lt;/h4>
&lt;h6 id="例1-15">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409112205976.png" alt="" />&lt;figcaption>image-20200409112205976&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409112120006.png" alt="" />&lt;figcaption>image-20200409112120006&lt;/figcaption>
&lt;/figure>
&lt;h3 id="微分中值定理求极限">微分中值定理求极限&lt;/h3>
&lt;h6 id="例1-16">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409231519931.png" alt="" />&lt;figcaption>image-20200409231519931&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409231535956.png" alt="" />&lt;figcaption>image-20200409231535956&lt;/figcaption>
&lt;/figure>
&lt;h3 id="根据数列求极限">根据数列求极限&lt;/h3>
&lt;h6 id="例1-17">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410105341138.png" alt="" />&lt;figcaption>image-20200410105341138&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410105420203.png" alt="" />&lt;figcaption>image-20200410105420203&lt;/figcaption>
&lt;/figure>
&lt;h2 id="已知极限求其他">已知极限求其他&lt;/h2>
&lt;h3 id="已知极限求参数">已知极限求参数&lt;/h3>
&lt;h6 id="例1-18">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402112214648.png" alt="" />&lt;figcaption>image-20200402112214648&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402112246396.png" alt="" />&lt;figcaption>image-20200402112246396&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-10">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402113452321.png" alt="" />&lt;figcaption>image-20200402113452321&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402113525609.png" alt="" />&lt;figcaption>image-20200402113525609&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-10">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403153114432.png" alt="" />&lt;figcaption>image-20200403153114432&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403153241962.png" alt="" />&lt;figcaption>image-20200403153241962&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-7">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403153832394.png" alt="" />&lt;figcaption>image-20200403153832394&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200403153854869.png" alt="" />&lt;figcaption>image-20200403153854869&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-8">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408111104713.png" alt="" />&lt;figcaption>image-20200408111104713&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408111133728.png" alt="" />&lt;figcaption>image-20200408111133728&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-7">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409191806613.png" alt="" />&lt;figcaption>image-20200409191806613&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409191829180.png" alt="" />&lt;figcaption>image-20200409191829180&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-8">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409232006207.png" alt="" />&lt;figcaption>image-20200409232006207&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409232026647.png" alt="" />&lt;figcaption>image-20200409232026647&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-6">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409232901568.png" alt="" />&lt;figcaption>image-20200409232901568&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409232841333.png" alt="" />&lt;figcaption>image-20200409232841333&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-4">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409233805730.png" alt="" />&lt;figcaption>image-20200409233805730&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409233825209.png" alt="" />&lt;figcaption>image-20200409233825209&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-3">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409234117815.png" alt="" />&lt;figcaption>image-20200409234117815&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409234052074.png" alt="" />&lt;figcaption>image-20200409234052074&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例10-2">例10&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409234912572.png" alt="" />&lt;figcaption>image-20200409234912572&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409234848532.png" alt="" />&lt;figcaption>image-20200409234848532&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例11-2">例11&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409235700690.png" alt="" />&lt;figcaption>image-20200409235700690&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409235619618.png" alt="" />&lt;figcaption>image-20200409235619618&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409235636931.png" alt="" />&lt;figcaption>image-20200409235636931&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例12-1">例12&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410001000835.png" alt="" />&lt;figcaption>image-20200410001000835&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410000946751.png" alt="" />&lt;figcaption>image-20200410000946751&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例13">例13&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410075104792.png" alt="" />&lt;figcaption>image-20200410075104792&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410075125775.png" alt="" />&lt;figcaption>image-20200410075125775&lt;/figcaption>
&lt;/figure>
&lt;p>此题需要根据x的不同讨论极限值，然后根据连续性来做&lt;/p>
&lt;h3 id="已知极限求新极限">已知极限求新极限&lt;/h3>
&lt;p>主要方法有：&lt;/p>
&lt;p>1）想办法从待求极限中凑出已知极限，消去&lt;/p>
&lt;p>2）根据已知极限得分子分母无穷小阶数高低关系，可以得到一些值&lt;/p>
&lt;h6 id="例1-19">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409193221568.png" alt="" />&lt;figcaption>image-20200409193221568&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409193239734.png" alt="" />&lt;figcaption>image-20200409193239734&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409193254823.png" alt="" />&lt;figcaption>image-20200409193254823&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-11">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409193556405.png" alt="" />&lt;figcaption>image-20200409193556405&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409193611134.png" alt="" />&lt;figcaption>image-20200409193611134&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-11">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409205100252.png" alt="" />&lt;figcaption>image-20200409205100252&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409205045255.png" alt="" />&lt;figcaption>image-20200409205045255&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-9">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409210151299.png" alt="" />&lt;figcaption>image-20200409210151299&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409210107234.png" alt="" />&lt;figcaption>image-20200409210107234&lt;/figcaption>
&lt;/figure>
&lt;h2 id="比较无穷小阶数高低">比较无穷小阶数高低&lt;/h2>
&lt;h3 id="泰勒展开后比较是比较方便的">泰勒展开后比较是比较方便的&lt;/h3>
&lt;h6 id="例1-20">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200405164738198.png" alt="" />&lt;figcaption>image-20200405164738198&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200405164836822.png" alt="" />&lt;figcaption>image-20200405164836822&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-12">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200405165911537.png" alt="" />&lt;figcaption>image-20200405165911537&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200405165936116.png" alt="" />&lt;figcaption>image-20200405165936116&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200405165953828.png" alt="" />&lt;figcaption>image-20200405165953828&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-12">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409195624459.png" alt="" />&lt;figcaption>image-20200409195624459&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200409195559699.png" alt="" />&lt;figcaption>image-20200409195559699&lt;/figcaption>
&lt;/figure>
&lt;h3 id="比值求极限判断">比值求极限判断&lt;/h3>
&lt;h6 id="例1-21">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407155355560.png" alt="" />&lt;figcaption>image-20200407155355560&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407155410511.png" alt="" />&lt;figcaption>image-20200407155410511&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-13">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407160756844.png" alt="" />&lt;figcaption>image-20200407160756844&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407160905949.png" alt="" />&lt;figcaption>image-20200407160905949&lt;/figcaption>
&lt;/figure>
&lt;h2 id="证明极限存在与否">证明极限存在与否&lt;/h2>
&lt;h3 id="数列极限存在的证明">数列极限存在的证明&lt;/h3>
&lt;p>&lt;a href="https://wenku.baidu.com/view/bfb90800a6c30c2259019ea3.html">证明数列极限的6种方法&lt;/a>&lt;/p>
&lt;p>数列单调有界，则数列收敛，极限存在&lt;/p>
&lt;p>极限为A代入递推式可得A&lt;/p>
&lt;h6 id="例1-22">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402091535715.png" alt="" />&lt;figcaption>image-20200402091535715&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402091600412.png" alt="" />&lt;figcaption>image-20200402091600412&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-14">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410081359063.png" alt="" />&lt;figcaption>image-20200410081359063&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410081320778.png" alt="" />&lt;figcaption>image-20200410081320778&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410081338100.png" alt="" />&lt;figcaption>image-20200410081338100&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-13">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410082802166.png" alt="" />&lt;figcaption>image-20200410082802166&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410082738511.png" alt="" />&lt;figcaption>image-20200410082738511&lt;/figcaption>
&lt;/figure>
&lt;p>单调有界必收敛，设极限为A代入递推式可得A&lt;/p>
&lt;h3 id="反证极限不存在">反证极限不存在&lt;/h3>
&lt;h6 id="例1-23">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407161954527.png" alt="" />&lt;figcaption>image-20200407161954527&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407162022923.png" alt="" />&lt;figcaption>image-20200407162022923&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-15">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407162803153.png" alt="" />&lt;figcaption>image-20200407162803153&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407162825711.png" alt="" />&lt;figcaption>image-20200407162825711&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407162859298.png" alt="" />&lt;figcaption>image-20200407162859298&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-14">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410083730117.png" alt="" />&lt;figcaption>image-20200410083730117&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410083702402.png" alt="" />&lt;figcaption>image-20200410083702402&lt;/figcaption>
&lt;/figure>
&lt;h2 id="极限函数的分段讨论">极限函数的分段讨论&lt;/h2>
&lt;h3 id="极限函数连续性的讨论">极限函数连续性的讨论&lt;/h3>
&lt;h6 id="例1-24">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410113551367.png" alt="" />&lt;figcaption>image-20200410113551367&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410113529804.png" alt="" />&lt;figcaption>image-20200410113529804&lt;/figcaption>
&lt;/figure>
&lt;h2 id="间断点类型的判断">间断点类型的判断&lt;/h2>
&lt;h6 id="例1-25">例1&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402110419387.png" alt="" />&lt;figcaption>image-20200402110419387&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402110437703.png" alt="" />&lt;figcaption>image-20200402110437703&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402110455804.png" alt="" />&lt;figcaption>image-20200402110455804&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例2-16">例2&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402111129199.png" alt="" />&lt;figcaption>image-20200402111129199&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200402111203728.png" alt="" />&lt;figcaption>image-20200402111203728&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例3-15">例3&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407181603111.png" alt="" />&lt;figcaption>image-20200407181603111&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407181640029.png" alt="" />&lt;figcaption>image-20200407181640029&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例4-10">例4&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407182428846.png" alt="" />&lt;figcaption>image-20200407182428846&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200407182448155.png" alt="" />&lt;figcaption>image-20200407182448155&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例5-8">例5&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408111437487.png" alt="" />&lt;figcaption>image-20200408111437487&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200408111459030.png" alt="" />&lt;figcaption>image-20200408111459030&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例6-9">例6&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410111350520.png" alt="" />&lt;figcaption>image-20200410111350520&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410111326945.png" alt="" />&lt;figcaption>image-20200410111326945&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例7-7">例7&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410114229983.png" alt="" />&lt;figcaption>image-20200410114229983&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410114206304.png" alt="" />&lt;figcaption>image-20200410114206304&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例8-5">例8&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410115032665.png" alt="" />&lt;figcaption>image-20200410115032665&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410115047463.png" alt="" />&lt;figcaption>image-20200410115047463&lt;/figcaption>
&lt;/figure>
&lt;h6 id="例9-4">例9&lt;/h6>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410115355897.png" alt="" />&lt;figcaption>image-20200410115355897&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410115302884.png" alt="" />&lt;figcaption>image-20200410115302884&lt;/figcaption>
&lt;/figure>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200410115338182.png" alt="" />&lt;figcaption>image-20200410115338182&lt;/figcaption>
&lt;/figure></description></item><item><title>高等数学-一元微积分-脉络</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/</link><pubDate>Sun, 01 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学-一元微积分-脉络">高等数学-一元微积分-脉络&lt;/h1>
&lt;h2 id="极限与函数极限">极限与函数极限&lt;/h2>
&lt;p>微积分的基础是函数极限理论，也称无穷小理论。从趋于某个点的情况，研究附近的函数情况。&lt;/p>
&lt;h2 id="导数">导数&lt;/h2>
&lt;p>用极限定义了函数的导函数，简称导数。&lt;/p>
&lt;p>&lt;span class="math inline">\(y^{\prime} = f^{\prime}(x) = \lim_{x\rightarrow x_0} \frac{y(x) - y(x_0)}{x-x_0} = \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}\)&lt;/span>&lt;/p>
&lt;p>&lt;strong>根据导函数定义&lt;/strong>可以&lt;strong>求出&lt;/strong>常见函数（&lt;strong>初等函数&lt;/strong>）的导函数形式。（常函数、幂函数、指数函数、对数函数、三角函数等都有确定的导函数形式）&lt;/p>
&lt;h2 id="微分">微分&lt;/h2>
&lt;p>定义函数&lt;span class="math inline">\(y=f(x)\)&lt;/span>可微：&lt;span class="math inline">\(\Delta x \rightarrow 0\)&lt;/span>时，有&lt;span class="math inline">\(\Delta y = A \Delta x + o(\Delta x)\)&lt;/span>，称&lt;strong>函数&lt;span class="math inline">\(y(x)\)&lt;/span>可微&lt;/strong>。&lt;/p>
&lt;p>实际上，上式两边同时除以&lt;span class="math inline">\(\Delta x\)&lt;/span>取极限，可得&lt;span class="math inline">\(A = y^{\prime}(x)\)&lt;/span>，即： &lt;span class="math inline">\(\Delta x \rightarrow 0\)&lt;/span>时，有&lt;span class="math inline">\(\Delta y = y^{\prime} \Delta x + o(\Delta x)\)&lt;/span>，称&lt;strong>函数&lt;span class="math inline">\(y(x)\)&lt;/span>可微&lt;/strong>。&lt;/p>
&lt;p>函数差分&lt;span class="math inline">\(\Delta y\)&lt;/span>的主要部分&lt;span class="math inline">\(A \Delta x\)&lt;/span>称为&lt;strong>函数的微分&lt;/strong>。记为$dy = A x = y^{} x = y^{} d x $。&lt;/p>
&lt;p>在导数章节，我们求出了常见函数（初等函数）的导函数形式。 又根据函数的微分$dy = y^{} d x $， 我们可以得到常见函数&lt;strong>（初等函数）的微分&lt;/strong>。&lt;/p>
&lt;h2 id="原函数与不定积分">原函数与不定积分&lt;/h2>
&lt;p>求函数&lt;span class="math inline">\(F(x)\)&lt;/span>的导函数&lt;span class="math inline">\(F^{\prime}(x)\)&lt;/span>的反问题：寻求一个可导函数&lt;span class="math inline">\(F(x)\)&lt;/span>，使它的导函数等于已知函数&lt;span class="math inline">\(f(x)\)&lt;/span>，即&lt;span class="math inline">\(F^{\prime}(x) = f(x)\)&lt;/span>。这样的函数&lt;span class="math inline">\(F(x)\)&lt;/span>称为已知&lt;strong>函数的原函数&lt;/strong>。&lt;/p>
&lt;p>没有其余条件限制的情况下，已知函数&lt;span class="math inline">\(f(x)\)&lt;/span>的原函数是一个函数系列&lt;span class="math inline">\(F(x)+C\)&lt;/span>，即&lt;span class="math inline">\(F(x)+C\)&lt;/span>都是&lt;span class="math inline">\(f(x)\)&lt;/span>的原函数。&lt;/p>
&lt;p>实际上，&lt;span class="math inline">\(\Delta F = F - F_0 = \sum \Delta F_i\)&lt;/span>，而当&lt;span class="math inline">\(\Delta x\)&lt;/span>足够小时，可化为： &lt;span class="math inline">\(\Delta F = F - F_0 \\=\lim_{\Delta x \rightarrow 0} \sum \Delta F_i \\=\lim_{\Delta x \rightarrow 0} \sum d F_i \\= \int dF\)&lt;/span> 其中的&lt;span class="math inline">\(\lim_{\Delta x \rightarrow 0} \sum\)&lt;/span>称为积分操作，取记号为&lt;span class="math inline">\(\int = \lim_{\Delta x \rightarrow 0} \sum\)&lt;/span> 在微分章节，我们知道函数的微分$dF = F^{} d x &lt;span class="math inline">\(， 则\)&lt;/span>F = F - F_0 = dF = F^{} d x = f(x) d x$ 也即&lt;span class="math inline">\(\int F^{\prime} d x = F - F_0\)&lt;/span>&lt;/p>
&lt;p>则我们可定义&lt;strong>不定积分&lt;/strong>来表示&lt;span class="math inline">\(f(x)\)&lt;/span>的一系列原函数&lt;span class="math inline">\(F(x)+C\)&lt;/span> ： &lt;span class="math inline">\(\int f(x)dx = F(x) + C\)&lt;/span>&lt;/p>
&lt;p>即求函数的积分是求函数的微分的逆操作。&lt;/p>
&lt;h2 id="定积分">定积分&lt;/h2>
&lt;p>给定一定的边界条件（限制条件），就可以定出不定积分中的常数C。&lt;/p>
&lt;h2 id="faq">FAQ&lt;/h2>
&lt;p>&lt;strong>导数和积分是互逆关系,还是微分和积分是互逆关系呢?&lt;/strong>&lt;/p>
&lt;pre>&lt;code> 1.从字面意思上,微分和积分是互逆的.但是微分是不是一种运算?
2.从运算上,导数和积分是互逆的.那么这时(微分)有什么作用?&lt;/code>&lt;/pre>
&lt;pre>&lt;code>微分是一种运算，比如说x^2+1的微分记作：
d(x^2+1)=2xdx，也就是相当于把导数dy/dx=f&amp;#39;(x)，左边的分母dx乘到右边来，即得到微分公式：
dy=f&amp;#39;(x)dx
于是我们发现，如果将上式两边积分的话：
∫dy=∫f&amp;#39;(x)dx
也即y=∫f&amp;#39;(x)dx
另外再明确一点，积分分为定积分和不定积分，微分与不定积分是逆运算！
对于第二个问题，我们再明确，导数和微分是完全不同的两个概念，导数又称为微商，是dy/dx，也就是很小的函数值改变除以很小的自变量改变，而微分则是函数值的微小变化，可以用来求函数的近似值，比如说对如下近似公式：
(1+x)^n,当x&amp;lt;&amp;lt;1时，有如下近似：
(1+x)^n≈1+nx,事实上这可以由
Δy≈f&amp;#39;(x)Δx推导出来。&lt;/code>&lt;/pre></description></item><item><title>高等数学与数学分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 26 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="高等数学">高等数学&lt;/h1>
&lt;p>高等数学（理工科）与数学分析（数学系）实际上讲的是同一块内容。数学分析侧重讲思想与证明，高等数学侧重讲计算。高等数学里概念性的东西如果有疑问，可以去数学分析里找。&lt;/p>
&lt;p>初等数学的研究对象基本是不变的量，高等数学的研究对象是变动的量。 而函数关系是变量之间的依赖关系，极限方法是研究变量的一种基本方法。&lt;/p>
&lt;h1 id="数学分析">数学分析&lt;/h1>
&lt;p>&lt;strong>数学分析&lt;/strong>（英语：&lt;strong>mathematical analysis&lt;/strong>）区别于其他非数学类学生的&lt;a href="https://zh.wikipedia.org/wiki/高等数学">高等数学&lt;/a>内容，是分析学中最古老、最基本的分支，一般指以&lt;a href="https://zh.wikipedia.org/wiki/微积分学">微积分学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/无穷级数">无穷级数&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/解析函數">解析函数&lt;/a>等的一般理论为主要内容，并包括它们的理论基础（&lt;a href="https://zh.wikipedia.org/wiki/实数">实数&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/函数">函数&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/测度">测度&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/极限">极限&lt;/a>的基本理论）的一个较为完整的数学学科。它也是大学数学专业的一门基础课程。[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-gzfjt-1">1]&lt;/a>&lt;/p>
&lt;p>数学分析研究的内容包括&lt;a href="https://zh.wikipedia.org/wiki/實數">实数&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/複數">复数&lt;/a>、实函数及复变函数。&lt;strong>数学分析是由微积分演进而来，在微积分发展至现代阶段中，从应用中的方法总结升华为一类综合性分析方法&lt;/strong>，且初等微积分中也包括许多数学分析的基础概念及技巧，可以认为这些应用方法是高等微积分生成的前提。数学分析的方式和其几何有关，不过只要任一数学空间有定义邻域（&lt;a href="https://zh.wikipedia.org/wiki/拓扑空间">拓扑空间&lt;/a>）或是有针对两物件距离的定义（&lt;a href="https://zh.wikipedia.org/wiki/度量空间">度量空间&lt;/a>），就可以用数学分析的方式进行分析。&lt;/p>
&lt;p>数学分析又称高级&lt;a href="https://baike.baidu.com/item/微积分/6065">微积分&lt;/a>，&lt;a href="https://baike.baidu.com/item/分析学/2764797">分析学&lt;/a>中最古老、最基本的分支。一般指以&lt;a href="https://baike.baidu.com/item/微积分学/710552">微积分学&lt;/a>和&lt;a href="https://baike.baidu.com/item/无穷级数/7289408">无穷级数&lt;/a>一般理论为主要内容，并包括它们的理论基础（&lt;a href="https://baike.baidu.com/item/实数/296419">实数&lt;/a>、函数和&lt;a href="https://baike.baidu.com/item/极限/3564509">极限&lt;/a>的基本理论）的一个较为完整的数学学科。&lt;/p>
&lt;p>它的发展由微积分开始，并扩展到函数的&lt;a href="https://baike.baidu.com/item/连续性/8676216">连续性&lt;/a>、可&lt;a href="https://baike.baidu.com/item/微分/317988">微分&lt;/a>及可&lt;a href="https://baike.baidu.com/item/积分/5749068">积分&lt;/a>等各种特性。&lt;/p>
&lt;p>数学分析的主要内容是微积分学，微积分学的理论基础是极限理论，极限理论的理论基础是实数理论。&lt;/p>
&lt;p>数学分析的研究对象是函数，它从局部和整体这两个方面研究函数的基本形态，从而形成微分学和积分学的基本内容。&lt;/p>
&lt;p>数学分析的基本方法是&lt;a href="https://baike.baidu.com/item/极限">极限&lt;/a>的方法，或者说是无穷小分析。&lt;/p>
&lt;h2 id="数学分析分支领域">数学分析分支领域&lt;/h2>
&lt;p>数学分析在当前被分为以下几个分支领域：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/实分析">实分析&lt;/a>是数学分析中，专门处理实数及实值&lt;a href="https://zh.wikipedia.org/wiki/函数">函数&lt;/a>的一个分支[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-5">5]&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-6">6]&lt;/a>。这包括对&lt;a href="https://zh.wikipedia.org/wiki/极限">极限&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/微分">微分&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/积分">积分&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/幂级数">幂级数&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/测度">测度&lt;/a>的研究。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/複分析">复分析&lt;/a>，是对从&lt;a href="https://zh.wikipedia.org/wiki/複平面">复平面&lt;/a>到复平面的复数可微函数的研究，和复数的&lt;a href="https://zh.wikipedia.org/wiki/解析函數">解析函数&lt;/a>（或&lt;a href="https://zh.wikipedia.org/wiki/亚纯函数">亚纯函数&lt;/a>）有密切的关系。可以应用在许多不同的数学领域中，包括&lt;a href="https://zh.wikipedia.org/wiki/代數幾何">代数几何&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/數論">数论&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/應用數學">应用数学&lt;/a>等，也广为应用在物理领域中，例如&lt;a href="https://zh.wikipedia.org/wiki/流體力學">流体力学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/熱力學">热力学&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/機械工程">机械工程&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/電機工程">电机工程&lt;/a>及&lt;a href="https://zh.wikipedia.org/wiki/量子場論">量子场论&lt;/a>。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/泛函分析">泛函分析&lt;/a>探讨&lt;a href="https://zh.wikipedia.org/wiki/函数空间">函数空间&lt;/a>及一些和&lt;a href="https://zh.wikipedia.org/wiki/向量空間">向量空间&lt;/a>相关的结构（例如&lt;a href="https://zh.wikipedia.org/wiki/内积空间">内积&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/范数">范数&lt;/a>及&lt;a href="https://zh.wikipedia.org/wiki/拓扑空间">拓扑空间&lt;/a>）等，以及在作用在这些空间中的&lt;a href="https://zh.wikipedia.org/wiki/线性算子">线性算子&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-7">7]&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-8">8]&lt;/a>，也会介绍例如&lt;a href="https://zh.wikipedia.org/wiki/巴拿赫空间">巴拿赫空间&lt;/a>以及&lt;a href="https://zh.wikipedia.org/wiki/希尔伯特空间">希尔伯特空间&lt;/a>的概念。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/傅立叶分析">傅立叶分析&lt;/a>研究如何将一个函数或者信号表达为基本波形的叠加，并扩展成&lt;a href="https://zh.wikipedia.org/wiki/傅立叶级数">傅立叶级数&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/傅立叶变换">傅立叶变换&lt;/a>的概念。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/微分方程">微分方程&lt;/a>是未知数为一变数或多变数的函数，且方程和函数其&lt;a href="https://zh.wikipedia.org/wiki/導數">导数&lt;/a>或高阶导数有关的&lt;a href="https://zh.wikipedia.org/wiki/方程">方程&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-9">9]&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-10">10]&lt;/a>[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-11">11]&lt;/a>。微分方程在&lt;a href="https://zh.wikipedia.org/wiki/工程">工程&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/物理">物理&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/經濟">经济&lt;/a>、&lt;a href="https://zh.wikipedia.org/wiki/生物學">生物学&lt;/a>中都是重要的一部分。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/數值分析">数值分析&lt;/a>是研究数学分析中相关问题（和&lt;a href="https://zh.wikipedia.org/wiki/離散數學">离散数学&lt;/a>不同）中有关数值近似（和&lt;a href="https://zh.wikipedia.org/w/index.php?title=符號運算&amp;amp;action=edit&amp;amp;redlink=1">符号运算&lt;/a>不同）&lt;a href="https://zh.wikipedia.org/wiki/算法">算法&lt;/a>的研究。[&lt;a href="https://zh.wikipedia.org/wiki/数学分析#cite_note-12">12]&lt;/a>。许多问题的解析解是很难求得的，数值分析不在意解析解，比较著重在可接受的误差范围内找到近似解。&lt;/li>
&lt;/ul>
&lt;p>学科代码：34 &lt;a href="http://baike.baidu.com/subview/61939/5109876.htm">数学分析&lt;/a>▪ 3410:&lt;a href="http://baike.baidu.com/subview/1831905/1831905.htm">微分学&lt;/a>▪ 3420:&lt;a href="http://baike.baidu.com/subview/10907852/11213672.htm">积分学&lt;/a>▪ 3430:&lt;a href="http://baike.baidu.com/searchword/?word=级数论&amp;amp;pic=1&amp;amp;sug=1&amp;amp;enc=utf8">级数论&lt;/a>▪ 3499:&lt;a href="http://baike.baidu.com/searchword/?word=数学分析其他学科&amp;amp;pic=1&amp;amp;sug=1&amp;amp;enc=utf8">数学分析其他学科&lt;/a>&lt;/p>
&lt;h1 id="空间">空间&lt;/h1>
&lt;p>参考：网易公开课：上海交通大学公开课：数学之旅：函数空间 参考：https://zhuanlan.zhihu.com/p/42381836 参考：https://www.jianshu.com/p/42593a412339 参考：https://www.bilibili.com/read/cv3843646/&lt;/p>
&lt;h2 id="数学空间">数学空间&lt;/h2>
&lt;p>&lt;strong>空间&lt;/strong>即为点的集合&lt;/p>
&lt;p>在空间里 &lt;strong>原点&lt;/strong>, &lt;strong>基&lt;/strong> 这两个东西最重要. &lt;strong>原点&lt;/strong>就是坐标完全为0的一个点, &lt;strong>基&lt;/strong>为定义这个空间最基础的“方向”。以二维平面直角坐标系为例，O就是原点, 而 i, j 就是这个空间的两个基。空间中的任意点都可以表示为&lt;span class="math inline">\(P = a \boldsymbol i + b \boldsymbol j\)&lt;/span>，所有可能的权重&lt;span class="math inline">\((a,b)\)&lt;/span>代入上述关系式中，可以得到关于a,b的点集&lt;span class="math inline">\({a \boldsymbol i + b \boldsymbol j}\)&lt;/span>&lt;/p>
&lt;p>基其实不要求正交，但不能平行（平行的话相当于少了一条基）&lt;/p>
&lt;p>假设有n个不平行的基&lt;span class="math inline">\(\boldsymbol \varphi_n\)&lt;/span>，那么这组基张成的空间中的任意一点为&lt;span class="math inline">\(P = \Sigma_{i= 1}^n a_i \varphi_i\)&lt;/span>。这个空间是里面所有点的点集。&lt;/p>
&lt;p>实空间和复空间都是1维的，线性空间是n维的。&lt;/p>
&lt;p>&lt;strong>数学的空间&lt;/strong>：研究工作的对象（元素）和遵循的规则（结构）。 （线性结构：加法和数乘；拓扑结构：距离、范数、开集）&lt;/p>
&lt;p>&lt;strong>距离的定义&lt;/strong>：（抽象出必要的属性出来）： 非负、有对称性d(x,y)=d(y,x)、三角不等关系&lt;/p>
&lt;p>&lt;strong>线性结构&lt;/strong>的定义： 向量的加法、数乘 （内运算和外运算） 满足（八条规则）：加法的交换率、结合率、零元、负元；数乘的交换律、单位1；数乘与加法的结合率&lt;/p>
&lt;p>函数集中的任意两点，有一个内运算、一个外运算，满足八条规则，这样的空间叫做&lt;strong>线性空间&lt;/strong>（线性代数的内容）&lt;/p>
&lt;p>&lt;strong>范数&lt;/strong>的定义：（定义强化的距离） 线性空间中的任意两点，距离非负、&lt;span class="math inline">\(||\alpha x|| = |\alpha|.||x||\)&lt;/span>、三角不等关系&lt;/p>
&lt;p>&lt;strong>内积&lt;/strong>的定义：（比距离和范数有更深的内涵） 线性空间中的任意两点，有对称性、对第一变元的线性性、正定性（非负性）&lt;/p>
&lt;p>&lt;strong>拓扑空间&lt;/strong>：（范围更宽松：连续的概念不需要内积，甚至不需要距离） 用开集定义连续：对任意&lt;span class="math inline">\(\forall \epsilon, \exist \delta, st. ...\)&lt;/span>&lt;/p>
&lt;figure>
&lt;img src="https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/5117975-19c72093e3b4aa12.png" alt="" />&lt;figcaption>img&lt;/figcaption>
&lt;/figure>
&lt;h2 id="函数空间">函数空间&lt;/h2>
&lt;p>所谓的函数空间就是 “使用函数作为基的空间”&lt;/p>
&lt;p>&lt;strong>函数空间&lt;/strong>是函数的集合。数学上，函数空间指的是从集合 X 到集合 Y 的&lt;strong>给定种类的函数的集合&lt;/strong>。&lt;/p>
&lt;p>&lt;span class="math inline">\(f(x)=\sum_{i=1}^n a_{n} \varphi_{n}(x)\)&lt;/span>&lt;/p>
&lt;p>函数空间的讨论，在泛函分析中。&lt;/p>
&lt;p>注：&lt;strong>泛函分析&lt;/strong>（英语：Functional Analysis）是现代&lt;a href="https://zh.wikipedia.org/wiki/数学分析">数学分析&lt;/a>的一个分支，隶属于&lt;a href="https://zh.wikipedia.org/wiki/分析学">分析学&lt;/a>，其研究的主要对象是&lt;a href="https://zh.wikipedia.org/wiki/函数">函数&lt;/a>构成的&lt;a href="https://zh.wikipedia.org/wiki/函数空间">函数空间&lt;/a>。泛函分析历史根源是由对函数空间的研究和对函数的变换（如&lt;a href="https://zh.wikipedia.org/wiki/傅立叶变换">傅立叶变换&lt;/a>等）的性质的研究。这种观点被证明是对&lt;a href="https://zh.wikipedia.org/wiki/微分方程">微分方程&lt;/a>和&lt;a href="https://zh.wikipedia.org/wiki/积分方程">积分方程&lt;/a>的研究中特别有用。&lt;/p></description></item><item><title>基础数学-三角函数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="基础数学-三角函数">基础数学-三角函数&lt;/h1>
&lt;h4 id="诱导公式">诱导公式&lt;/h4>
&lt;table>
&lt;colgroup>
&lt;col style="width: 50%" />
&lt;col style="width: 50%" />
&lt;/colgroup>
&lt;thead>
&lt;tr class="header">
&lt;th>&lt;strong>公式一&lt;/strong>&lt;/th>
&lt;th>&lt;strong>公式二&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr class="odd">
&lt;td>sin（2kπ+α）=sin α&lt;br />cos（2kπ+α）=cos α&lt;br />tan（2kπ+α）=tan α&lt;br />cot（2kπ+α）=cot α&lt;br />sec（2kπ+α）=sec α&lt;br />csc（2kπ+α）=csc α&lt;/td>
&lt;td>sin（π+α）=-sin α&lt;br />cos（π+α）=-cos α&lt;br />tan（π+α）=tan α&lt;br />cot（π+α）=cot α&lt;br />sec（π+α）=-sec α&lt;br />csc（π+α）=-csc α&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>公式三&lt;/td>
&lt;td>&lt;strong>公式四&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>sin（-α）=-sin α&lt;br />cos（-α）=cos α&lt;br />tan（-α）=-tan α&lt;br />cot（-α）=-cot α&lt;br />sec（-α）=sec α&lt;br />csc（-α）=-csc α&lt;/td>
&lt;td>sin（π-α）=sin α&lt;br />cos（π-α）=-cos α&lt;br />tan（π-α）=-tan α&lt;br />cot（π-α）=-cot α&lt;br />sec（π-α）=-sec α&lt;br />csc（π-α）=csc α&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>公式五&lt;/td>
&lt;td>公式六&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>sin（α-π）=-sin α&lt;br />cos（α-π）=-cos α&lt;br />tan（α-π）=tan α&lt;br />cot（α-π）=cot α&lt;br />sec（α-π）=-sec α&lt;br />csc（α-π）=-csc α&lt;/td>
&lt;td>sin（2π-α）=-sin α&lt;br />cos（2π-α）=cos α&lt;br />tan（2π-α）=-tan α&lt;br />cot（2π-α）=-cot α&lt;br />sec（2π-α）=sec α&lt;br />csc（2π-α）=-csc α&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>&lt;strong>公式七&lt;/strong>&lt;/td>
&lt;td>&lt;strong>公式八&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>sin（π/2+α）=cosα&lt;br />cos（π/2+α）=−sinα&lt;br />tan（π/2+α）=-cotα&lt;br />cot（π/2+α）=-tanα&lt;br />sec（π/2+α）=-cscα&lt;br />csc（π/2+α）=secα&lt;/td>
&lt;td>sin（π/2-α）=cosα&lt;br />cos（π/2-α）=sinα&lt;br />tan（π/2-α）=cotα&lt;br />cot（π/2-α）=tanα&lt;br />sec（π/2-α）=cscα&lt;br />csc（π/2-α）=secα&lt;/td>
&lt;/tr>
&lt;tr class="even">
&lt;td>公式九&lt;/td>
&lt;td>&lt;strong>公式十&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr class="odd">
&lt;td>sin（3π/2+α）=-cosα&lt;br />cos（3π/2+α）=sinα&lt;br />tan（3π/2+α）=-cotα&lt;br />cot（3π/2+α）=-tanα&lt;br />sec（3π/2+α）=cscα&lt;br />csc（3π/2+α）=&lt;em>-secα&lt;/em>&lt;/td>
&lt;td>sin（3π/2-α）=-cosα&lt;br />cos（3π/2-α）=-sinα&lt;br />tan（3π/2-α）=cotα&lt;br />cot（3π/2-α）=tanα&lt;br />sec（3π/2-α）=-cscα&lt;br />csc（3π/2-α）=-secα&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="倍角公式">倍角公式&lt;/h4>
&lt;p>&lt;span class="math inline">\(\begin{aligned} \sin 2 \alpha &amp;amp;=2 \sin \alpha \cdot \cos \alpha \\ \cos 2 \alpha &amp;amp;=\cos ^{2} \alpha-\sin ^{2} \alpha=2 \cos ^{2} \alpha-1=1-2 \sin ^{2} \alpha \\ \tan 2 \alpha &amp;amp;=\frac{2 \tan \alpha}{1-\tan ^{2} \alpha} \end{aligned}\)&lt;/span>&lt;/p>
&lt;h4 id="半角公式">半角公式&lt;/h4>
&lt;p>&lt;span class="math inline">\(\sin ^{2} \frac{\alpha}{2}=\frac{1-\cos \alpha}{2}\)&lt;/span> &lt;span class="math inline">\(\cos ^{2} \frac{\alpha}{2}=\frac{1+\cos \alpha}{2}\)&lt;/span> &lt;span class="math inline">\(\tan ^{2} \frac{\alpha}{2}=\frac{1-\cos \alpha}{1+\cos \alpha}\)&lt;/span> &lt;span class="math inline">\(\tan \frac{\alpha}{2}=\frac{\sin \alpha}{1+\cos \alpha}=\frac{1-\cos \alpha}{\sin \alpha}=\csc \alpha-\cot \alpha\)&lt;/span> &lt;span class="math inline">\(\cot \frac{\alpha}{2}=\frac{\sin \alpha}{1-\cos \alpha}=\frac{1+\cos \alpha}{\sin \alpha}=\csc \alpha+\cot \alpha\)&lt;/span>&lt;/p>
&lt;h4 id="和角公式">和角公式&lt;/h4>
&lt;p>&lt;span class="math inline">\(\sin (\alpha+\beta)=\sin \alpha \cdot \cos \beta+\cos \alpha \cdot \sin \beta\)&lt;/span> &lt;span class="math inline">\(\sin (\alpha-\beta)=\sin \alpha \cdot \cos \beta-\cos \alpha \cdot \sin \beta\)&lt;/span> &lt;span class="math inline">\(\cos (\alpha+\beta)=\cos \alpha \cdot \cos \beta-\sin \alpha \cdot \sin \beta\)&lt;/span> &lt;span class="math inline">\(\cos (\alpha-\beta)=\cos \alpha \cdot \cos \beta+\sin \alpha \cdot \sin \beta\)&lt;/span> &lt;span class="math inline">\(\tan (\alpha+\beta)=\frac{\tan \alpha+\tan \beta}{1-\tan \alpha \cdot \tan \beta}\)&lt;/span> &lt;span class="math inline">\(\tan (\alpha-\beta)=\frac{\tan \alpha-\tan \beta}{1+\tan \alpha \cdot \tan \beta}\)&lt;/span>&lt;/p>
&lt;h4 id="积化和差">积化和差&lt;/h4>
&lt;p>&lt;span class="math inline">\(\sin \alpha \cos \beta=\frac{1}{2}[\sin (\alpha+\beta)+\sin (\alpha-\beta)]\)&lt;/span> &lt;span class="math inline">\(\cos \alpha \sin \beta=\frac{1}{2}[\sin (\alpha+\beta)-\sin (\alpha-\beta)]\)&lt;/span> &lt;span class="math inline">\(\cos \alpha \cos \beta=\frac{1}{2}[\cos (\alpha+\beta)+\cos (\alpha-\beta)]\)&lt;/span> &lt;span class="math inline">\(\sin \alpha \sin \beta=-\frac{1}{2}[\cos (\alpha+\beta)-\cos (\alpha-\beta)]\)&lt;/span>&lt;/p>
&lt;h4 id="和差化积">和差化积&lt;/h4>
&lt;p>&lt;span class="math inline">\(\sin \alpha+\sin \beta=2 \sin \frac{\alpha+\beta}{2} \cos \frac{\alpha-\beta}{2} \cdots \cdots(1)\)&lt;/span> &lt;span class="math inline">\(\sin \alpha-\sin \beta=2 \cos \frac{\alpha+\beta}{2} \sin \frac{\alpha-\beta}{2} \ldots \ldots\)&lt;/span> &lt;span class="math inline">\(\cos \alpha+\cos \beta=2 \cos \frac{\alpha+\beta}{2} \cos \frac{\alpha-\beta}{2} \cdots \cdots(3)\)&lt;/span> &lt;span class="math inline">\(\cos \alpha-\cos \beta=-2 \sin \frac{\alpha+\beta}{2} \sin \frac{\alpha-\beta}{2} \ldots \ldots(4)\)&lt;/span> &lt;span class="math inline">\(\tan \alpha+\tan \beta=\frac{\sin (\alpha+\beta)}{\cos \alpha \cos \beta} \cdots \cdots(5)\)&lt;/span> &lt;span class="math inline">\(\tan \alpha-\tan \beta=\frac{\sin (\alpha-\beta)}{\cos \alpha \cos \beta} \cdots \cdots(6)\)&lt;/span> &lt;span class="math inline">\(\cot \alpha+\cot \beta=\frac{\sin (\alpha+\beta)}{\sin \alpha \sin \beta} \cdots \cdots(7)\)&lt;/span> &lt;span class="math inline">\(\cot \alpha-\cot \beta=-\frac{\sin (\alpha-\beta)}{\sin \alpha \sin \beta} \cdots \cdots(8)\)&lt;/span> &lt;span class="math inline">\(\tan \alpha+\cot \beta=\frac{\cos (\alpha-\beta)}{\cos \alpha \sin \beta} \cdots \cdots(9)\)&lt;/span> &lt;span class="math inline">\(\tan \alpha-\cot \beta=-\frac{\cos (\alpha+\beta)}{\cos \alpha \sin \beta} \cdots \cdots(10)\)&lt;/span>&lt;/p>
&lt;h3 id="万能公式">万能公式&lt;/h3>
&lt;p>&lt;span class="math inline">\(\sin a=\frac{2 \tan \frac{a}{2}}{1+\tan ^{2} \frac{a}{2}}\)&lt;/span> &lt;span class="math inline">\(\cos a=\frac{1-\tan ^{2} \frac{a}{2}}{1+\tan ^{2} \frac{a}{2}}\)&lt;/span> &lt;span class="math inline">\(\tan a=\frac{2 \tan \frac{a}{2}}{1-\tan ^{2} \frac{a}{2}}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\cot \alpha=\frac{1-\tan ^{2} \frac{\alpha}{2}}{2 \tan \frac{\alpha}{2}}\)&lt;/span> &lt;span class="math inline">\(\sec \alpha=\frac{1+\tan ^{2} \frac{\alpha}{2}}{1-\tan ^{2} \frac{\alpha}{2}}\)&lt;/span> &lt;span class="math inline">\(\csc \alpha=\frac{1+\tan ^{2} \frac{\alpha}{2}}{2 \tan \frac{\alpha}{2}}\)&lt;/span>&lt;/p></description></item><item><title>基础数学-代数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="基础数学-代数">基础数学-代数&lt;/h1>
&lt;h3 id="代数等式">代数等式&lt;/h3>
&lt;p>&lt;span class="math inline">\(a^{3}+b^{3}=(a+b)\left(a^{2}-a b+b^{2}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(a^{3}-b^{3}=(a-b)\left(a^{2}+a b+b^{2}\right)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(1^{2}+2^{2}+\cdots+n^{2}=\frac{n(n+1)(2 n+1)}{6}\)&lt;/span>&lt;/p>
&lt;h3 id="复数运算">复数运算&lt;/h3>
&lt;p>&lt;span class="math inline">\(|x+y i|=\sqrt{x^{2}+y^{2}}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(|z|=|\bar{z}|\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(z+\bar{z}=2 a(\)&lt;/span> 实数 &lt;span class="math inline">\(), \quad z-\bar{z}=2 b i\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(z \cdot \bar{z}=|z|^{2}=a^{2}+b^{2}(\)&lt;/span> 实数 &lt;span class="math inline">\()\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\overline{z_{1}+z_{2}}=\bar{z}_{1}+\bar{z}_{2}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\overline{z_{1}-z_{2}}=\bar{z}_{1}-\bar{z}_{2}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\overline{z_{1} \cdot z_{2}}=\bar{z}_{1} \cdot \bar{z}_{2}\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\overline{z_{1} / z_{2}}=\bar{z}_{1} / \bar{z}_{2}\left(z_{2} \neq 0\right)\)&lt;/span>&lt;/p>
&lt;h3 id="代数不等式">代数不等式&lt;/h3>
&lt;h4 id="基本不等式均值不等式">基本不等式（均值不等式）&lt;/h4>
&lt;p>&lt;span class="math inline">\(\frac{a+b}{2} \geqslant \sqrt{a b} \quad(a&amp;gt;0, b&amp;gt;0)\)&lt;/span>，当且仅当&lt;span class="math inline">\(a=b\)&lt;/span>取等号。&lt;/p>
&lt;p>或&lt;span class="math inline">\(a+b \geq 2 \sqrt{a b},(a&amp;gt;0, b&amp;gt;0)\)&lt;/span>&lt;/p>
&lt;h4 id="基本不等式变形">基本不等式变形&lt;/h4>
&lt;p>&lt;span class="math inline">\(a+b \geq 2 \sqrt{a b}\)&lt;/span> ，当且仅当&lt;span class="math inline">\(a=b\)&lt;/span>取等号。&lt;/p>
&lt;p>&lt;span class="math inline">\(\frac{b}{a}+\frac{a}{b} \geq 2\)&lt;/span>，其中a, b同号。&lt;/p>
&lt;p>&lt;span class="math inline">\(a b \leq\left(\frac{a+b}{2}\right)^{2} \quad(a, b \in R)\)&lt;/span>&lt;/p>
&lt;p>&lt;span class="math inline">\(\left(\frac{a+b}{2}\right)^{2} \leq \frac{a^{2}+b^{2}}{2}(a, b \in R)\)&lt;/span>&lt;/p>
&lt;h3 id="代数算法">代数算法&lt;/h3>
&lt;h4 id="长除法">长除法&lt;/h4>
&lt;p>长除法俗称「长除」，适用于&lt;a href="https://baike.baidu.com/item/整式/5961855">整式&lt;/a>&lt;a href="https://baike.baidu.com/item/除法/6280598">除法&lt;/a>、小数除法、&lt;a href="https://baike.baidu.com/item/多项式除法/2703247">多项式除法&lt;/a>（即&lt;a href="https://baike.baidu.com/item/因式分解/384402">因式分解&lt;/a>）等较重视计算过程和商数的除法，过程中兼用了乘法和减法。是&lt;a href="https://baike.baidu.com/item/代数/1434787">代数&lt;/a>中的一种算法，用一个同次或低次的多项式去除另一个多项式。是常见算数技巧长除法的一个推广版本。&lt;/p>
&lt;p>它可以很容易地手算，因为它将一个相对复杂的除法问题分解成更小的一些问题。&lt;/p>
&lt;p>步骤：&lt;/p>
&lt;p>1）被除数与除数按同一字母的降幂排列，缺陷用零补齐； [1]&lt;/p>
&lt;p>2）用竖式进行运算；&lt;/p>
&lt;p>3）当余式次数低于除式次数时，运算终止，得到商式和余式。&lt;/p></description></item><item><title>基础数学-几何</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/</guid><description>&lt;script>MathJax = {tex: {inlineMath: [['$', '$'], ['\(', '\)']],displayMath: [['$$','$$'], ['\[', '\]']],processEscapes: true, processEnvironments: true},options: {skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']}};window.addEventListener('load', (event) => {document.querySelectorAll('mjx-container').forEach(function(x){x.parentElement.classList += 'has-jax'}) });&lt;/script>&lt;script src='https://polyfill.io/v3/polyfill.min.js?features=es6'>&lt;/script>&lt;script type='text/javascript' id='MathJax-script' async src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'>&lt;/script>&lt;h1 id="基础数学-几何">基础数学-几何&lt;/h1>
&lt;h2 id="距离公式">距离公式&lt;/h2>
&lt;h3 id="点到直线的距离">点到直线的距离&lt;/h3>
&lt;p>设直维L的方程为Ax+By+C=0，点 P的坐标为&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>，则点 P到直线L的距离为： &lt;span class="math inline">\(\frac{\left|A x_{0}+B y_{0}+C\right|}{\sqrt{A^{2}+B^{2}}}\)&lt;/span>&lt;/p>
&lt;h3 id="两条直线间的距离">两条直线间的距离&lt;/h3>
&lt;p>设直线L1的方程为 &lt;span class="math inline">\(A x+B y+C_{1}=0 \quad ;\)&lt;/span> 直线L2的方程为 &lt;span class="math inline">\(A x+B y+C_{2}=0\)&lt;/span> 则 2条平行线之间的间距 &lt;span class="math inline">\(: \frac{\left|C_{1}-C_{2}\right|}{\sqrt{A^{2}+B^{2}}}\)&lt;/span>&lt;/p>
&lt;h2 id="三角形中的公式">三角形中的公式&lt;/h2>
&lt;h3 id="正弦定理">正弦定理&lt;/h3>
&lt;h4 id="正弦定理-1">正弦定理&lt;/h4>
&lt;p>在任意&lt;span class="math inline">\(\triangle ABC\)&lt;/span>中，角A、B、C所对的边长分别为a、b、c，三角形外接圆的半径为R，直径为D。则有： &lt;span class="math inline">\(\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}=2 R=D\)&lt;/span> 一个三角形中，各边和所对角的正弦之比相等，且该比值等于该三角形外接圆的直径（半径的2倍）长度。&lt;/p>
&lt;h4 id="正弦定理的推广">正弦定理的推广&lt;/h4>
&lt;p>&lt;span class="math inline">\(\triangle A B C\)&lt;/span> 中，若角A, &lt;span class="math inline">\(B,\)&lt;/span> C所对的边为a, &lt;span class="math inline">\(b, c,\)&lt;/span> 三角形外接圆半径为 &lt;span class="math inline">\(R,\)&lt;/span> 直径为D，正弦定理进行变形有： &lt;span class="math inline">\(a=2 R \sin A, b=2 R \sin B, c=2 R \sin C\)&lt;/span> &lt;span class="math inline">\(a\sin B=b\sin A, b\sin C=c\sin B, a\sin C=c\sin A\)&lt;/span> &lt;span class="math inline">\(a: b: c=\sin A: \sin B: \sin C\)&lt;/span> &lt;span class="math inline">\(\frac{a}{\sin A}=\frac{a+b}{\sin A+\sin B}=\frac{a+b+c}{\sin A+\sin B+\sin C} \quad\)&lt;/span> (等比，不变) &lt;span class="math inline">\(S=\frac{1}{2} a b \sin C=\frac{1}{2} a c \sin B=\frac{1}{2} b c \sin A=\frac{a b c}{4 R}=\frac{a b c}{2 D} \quad\)&lt;/span> (三角形面积公式)&lt;/p>
&lt;h3 id="余弦定理">余弦定理&lt;/h3>
&lt;p>对于任意三角形，任何一边的平方等于其他两边平方的和减去这两边与它们夹角的余弦的积的两倍。&lt;/p>
&lt;p>若三边为a，b, c ，对角分别为A（ &lt;span class="math inline">\(\alpha\)&lt;/span> ), B ( &lt;span class="math inline">\(\beta\)&lt;/span> ) , &lt;span class="math inline">\(\mathrm{C}(\gamma)\)&lt;/span>，有：&lt;/p>
&lt;p>&lt;span class="math inline">\(c^{2}=a^{2}+b^{2}-2 a b \cos \gamma\)&lt;/span> &lt;span class="math inline">\(b^{2}=c^{2}+a^{2}-2 a c \cos \beta\)&lt;/span> &lt;span class="math inline">\(a^{2}=b^{2}+c^{2}-2 b c \cos \alpha\)&lt;/span>&lt;/p>
&lt;p>或者： &lt;span class="math inline">\(\cos \alpha=\frac{b^{2}+c^{2}-a^{2}}{2 b c}\)&lt;/span> &lt;span class="math inline">\(\cos \beta=\frac{c^{2}+a^{2}-b^{2}}{2 c a}\)&lt;/span> &lt;span class="math inline">\(\cos \gamma=\frac{a^{2}+b^{2}-c^{2}}{2 a b}\)&lt;/span>&lt;/p>
&lt;p>或者：&lt;/p>
&lt;p>&lt;span class="math inline">\(\cos \alpha=\frac{\sin ^{2} \beta+\sin ^{2} \gamma-\sin ^{2} \alpha}{2 \sin \beta \sin \gamma}\)&lt;/span> &lt;span class="math inline">\(\cos \beta=\frac{\sin ^{2} \gamma+\sin ^{2} \alpha-\sin ^{2} \beta}{2 \sin \gamma \sin \alpha}\)&lt;/span> &lt;span class="math inline">\(\cos \gamma=\frac{\sin ^{2} \alpha+\sin ^{2} \beta-\sin ^{2} \gamma}{2 \sin \alpha \sin \beta}\)&lt;/span>&lt;/p>
&lt;h2 id="解析几何">解析几何&lt;/h2>
&lt;h3 id="利用坐标求三角形面积">利用坐标求三角形面积&lt;/h3>
&lt;p>写成二阶行列式为：： &lt;span class="math inline">\(\mathbf{S}_{\Delta}=\left|\frac{1}{2}\left| \begin{array}{ll}\mathbf{x}_{2}-\mathbf{x}_{1} &amp;amp; \mathbf{y}_{2}-\mathbf{y}_{1} \\ \mathbf{x}_{3}-\mathbf{x}_{1} &amp;amp; \mathbf{y}_{3}-\mathbf{y}_{1}\end{array} \right|\right|=\left|\frac{1}{2} \vec{AB} \times \vec{AC}\right|\)&lt;/span>&lt;/p>
&lt;p>写成三阶行列式为： 略&lt;/p>
&lt;p>参考：三横先生.三角形的面积公式八叙.知乎.https://zhuanlan.zhihu.com/p/25793392&lt;/p>
&lt;h3 id="二次曲线圆锥曲线">二次曲线/圆锥曲线&lt;/h3>
&lt;p>https://zhuanlan.zhihu.com/p/36508439&lt;/p>
&lt;p>https://zhuanlan.zhihu.com/p/64426664&lt;/p>
&lt;p>https://baike.baidu.com/item/%E5%9C%86%E9%94%A5%E6%9B%B2%E7%BA%BF?fromtitle=%E4%BA%8C%E6%AC%A1%E6%9B%B2%E7%BA%BF&amp;amp;fromid=517812&lt;/p>
&lt;h4 id="椭圆的面积">椭圆的面积&lt;/h4>
&lt;p>&lt;span class="math inline">\(S=\pi a b\)&lt;/span>，其中a、b分别是椭圆的长半轴，短半轴的长&lt;/p>
&lt;h4 id="椭圆的切线方程">椭圆的切线方程&lt;/h4>
&lt;p>&lt;a href="https://wenku.baidu.com/view/dac006d049649b6648d74740.html">求圆的切线的几种方法&lt;/a>&lt;/p>
&lt;p>椭圆切线方程:&lt;span class="math inline">\(\frac{x_0}{a^2} x + \frac{y_0}{b^2} y=1\)&lt;/span>&lt;/p>
&lt;p>设椭圆&lt;span class="math inline">\(x^2/a^2+y^2/b^2=1\)&lt;/span>在&lt;span class="math inline">\((x_0,y_0)\)&lt;/span>处切线斜率为k 则求导得&lt;span class="math inline">\(2 x_0/a^2+2 k y_0/b^2=0\)&lt;/span> 解得&lt;span class="math inline">\(k=-x_0 b^2/y_0 a^2\)&lt;/span> 故切线方程&lt;span class="math inline">\(y-y_0=(-x_0 b^2/y_0 a^2)(x-x_0)\)&lt;/span> 整理得切线方程:&lt;span class="math inline">\(x_0 x/a^2 + y_0 y/b^2=1\)&lt;/span> 类似可得双曲线的切线方程,乃至二元二次曲线的切线方程&lt;/p>
&lt;h2 id="立体几何">立体几何&lt;/h2>
&lt;h3 id="四面体体积">四面体体积&lt;/h3>
&lt;p>四面体的体积 &lt;span class="math inline">\(V\)&lt;/span> 等于以向量 &lt;span class="math inline">\(\overrightarrow{A B}, \overrightarrow{A C}\)&lt;/span> 和&lt;span class="math inline">\(\overrightarrow{A D}\)&lt;/span>为棱的平行六面体的体积的1/6&lt;/p></description></item></channel></rss>