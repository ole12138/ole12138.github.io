<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on Jingmin's blog</title><link>https://ole12138.github.io/tags/http/</link><description>Recent content in HTTP on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Wed, 13 Jan 2021 20:23:43 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/tags/http/feed.xml" rel="self" type="application/rss+xml"/><item><title>HTTP认证方式</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 13 Jan 2021 20:23:43 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</guid><description>HTTP认证方式 本节参考： https://zhuanlan.zhihu.com/p/64584734 https://www.loginradius.com/blog/async/everything-you-want-to-know-about-authorization-headers/ https://www.cnblogs.com/xiongmaomengnan/p/6671206.html https://www.jianshu.com/p/cf5a900d4ef7
B/S和C/S形式的远程通信，一般都是基于HTTP和RFC的方式进行的。今天说一下HTTP通信过程中的身份认证。
服务器上的资源，并不都是公开的。某些资源的访问需要具有一定的权限才可以。
HTTP/1.0中在http头中引入了权限（Authorization）字段。
Basic Auth 最初的认证是简单认证，在HTTP报文（头部）中是这样的
Authorization: Basic &amp;lt;username:password的base64加密结果&amp;gt; 像这样：
Authorization: Basic AXVubzpwQDU1dzByYM== 但是HTTP报文在网络上是有可能被截获的，而base64加密过的结果，也很容易解密，从而导致用户名和密码被其他人获取。
Bearer Token 为了减少（加密过的）用户名和密码在网络上传递的次数，降低被盗用的风险， 可在简单认证通过后，服务器返回一个token。之后访问服务器需要权限的资源就不再使用（加密过的）用户名和密码，而是使用token。
可以把这个token放到HTTP报文头部，像这样的形式：
Authorization: Bearer &amp;lt;token&amp;gt; API Key 类似于Bearer Token，客户端调用服务器API时，常常需要携带token，一般叫做API Key。
常见的调用形式：
GET /endpoint?api_key=abcdefgh123456789 也常常将API Key放置到HTTP头部：
X-API-Key: abcdefgh123456789 Digest Auth Digest认证试图解决Basic认证的缺陷而设计，用户密码并没有在网络上传递，传递的是密码（和账号等其他几个参数）的hash值。而通过hash值破解出密码一般认为是不现实的。
摘要认证的一个改进之处是用摘要代替密码的传输，遵循的基本原则是“绝对不通过网络发送明文密码”，而是发送一个密码的摘要信息，并且这摘要信息是不可逆的，即无法通 过摘要信息反推出密码信息
客户端向服务器请求认证的过程：
客户端发起请求 服务返回401未认证， 并要求使用Digest认证， 并提供一个随机串nonce，以及支持的hash算法 客户端计算： hash(nonce+账号+密码)， 并将hash结果和账号名发送给服务器 服务器根据账号名，找到对应的账户信息， 同样计算hash(nonce+账号+密码)， 对比计算的hash值与客户端传回的hash值， 对比通过即可将原来客户端请求的资源发送给客户 摘要认证的一个改进之处可以防止重放攻击。摘要被截获也可能跟密码一起好用，为了防止重放攻击的发送，服务器可以向客户端发送一个称为随机数nonce的特殊令牌，这个数会经常发生变化(可能是每毫秒，或者每次认证都发生变化，具体由服务器控制)，客户端在计算摘要之前要先将这个随机数附加到密码上去。这样，在密码中加入随机数就会使得摘要随着随机数的每次变化而变化，记录下的密码摘要只对特定的随机数有效，而没有密码的话，攻击者就无法计算出正确的摘要，这样就可以防止重放攻击的发生。
但是，摘要认证并不能防止中间人攻击。即客户端的请求直接被中间人拦截，中间人拿着客户端的请求信息去请求服务器。实际上HTTP都不能解决中间人攻击问题，需要HTTPS才可以解决。
当前常用的认证方式（会话级别：登录认证） 本章节非原创，转载来源：https://www.cnblogs.com/fengzheng/p/8416393.html
场景说明 以一个电商系统，假设淘宝为例，如果我们想要下单，首先需要注册一个账号。拥有了账号之后，我们需要输入用户名（比如手机号或邮箱）、密码完成登录过程。之后如果你在一段时间内再次进入系统，是不需要输入用户名和密码的，只有在连续长时间不登录的情况下（例如一个月没登录过）访问系统，再次需要输入用户名和密码。如果使用频率很频繁，通常是一年都不用再输一次密码，所以经常在换了一台电脑或者一部手机之后，一些经常使用的网站或 APP 不记得密码了。
提炼出来整个过程大概就是如下几步：
首次使用，需要通过邮箱或手机号注册； 注册完成后，需要提供用户名和密码完成登录； 下次再使用，通常不会再次输入用户名和密码即可直接进入系统并使用其功能（除非连续长时间未使用）； OAuth 认证 OAuth 认证比较常见的就是微信登录、微博登录、qq登录等，简单来说就是利用这些比较权威的网站或应用开放的 API 来实现用户登录，用户可以不用在你的网站或应用上注册账号，直接用已有的微信、微博、qq 等账号登录。</description></item><item><title>发起HTTP请求：使用OkHttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/</link><pubDate>Wed, 13 Jan 2021 15:54:12 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/</guid><description>发起HTTP请求：使用OkHttpClient 现在java比较好用的http客户端是开源的OkHttp。支持HTTP/2, 简单易用且灵活。
官网：https://square.github.io/okhttp/
简单使用测试（http、https类型的get，post）：
class OkHttpClientUtilTest { @Test public void doGet() throws IOException { String url = &amp;#34;http://httpbin.org/anything&amp;#34;; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { String res = response.body().string(); System.out.println(res); } request = new Request.Builder() .get() .url(url + &amp;#34;?key1=value1&amp;amp;key2=value2&amp;#34;).header(&amp;#34;Cookie&amp;#34;, &amp;#34;cook1=sd;cook2=sdd;&amp;#34;).build(); try (Response response = client.newCall(request).execute()) { String res = response.body().string(); System.out.println(res); } url = &amp;#34;https://httpbin.org/anything&amp;#34;; request = new Request.</description></item><item><title>发起HTTP请求：使用HttpURLConnection</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</link><pubDate>Wed, 13 Jan 2021 13:25:34 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</guid><description>发起HTTP请求：使用HttpURLConnection 使用JDK原生的HttpURLConnection发起HTTP请求
注意：到Java8为止，HttpURLConnection不支持HTTP2，只支持到HTTP1.1。 要使用支持HTTP2的HttpURLConnection，需要升级到Java11 import lombok.Cleanup; import java.io.*; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.nio.charset.StandardCharsets; /** * 使用JDK原生的HttpURLConnection发起HTTP请求 */ public class HttpURLConnectionUtil { public static String doGet(String httpurl) { // 返回结果字符串 String result = null; try { // 创建远程url连接对象 URL url = new URL(httpurl); // 通过远程url连接对象打开一个连接，强转成httpURLConnection类 @Cleanup(&amp;#34;disconnect&amp;#34;) HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 设置连接方式：get connection.setRequestMethod(&amp;#34;GET&amp;#34;); // 设置连接主机服务器的超时时间：15000毫秒 connection.setConnectTimeout(15000); // 设置读取远程返回的数据时间：60000毫秒 connection.setReadTimeout(60000); // 发送请求 connection.</description></item><item><title>HTTPS简单介绍（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 12 Jan 2021 12:06:18 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>HTTPS简单介绍（转载） 本章节非原创，转载来源：https://juejin.cn/post/6844903599303032845
一、HTTP存在的问题 1.1 可能被窃听 HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送 由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:Wireshark) 1.2 认证问题 无法确认你发送到的服务器就是真正的目标服务器(可能服务器是伪装的) 无法确定返回的客户端是否是按照真实意图接收的客户端(可能是伪装的客户端) 无法确定正在通信的对方是否具备访问权限，Web 服务器上某些重要的信息，只想发给特定用户即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。 1.3 可能被篡改 1.请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack，MITM）。
二、HTTPS介绍 2.1 什么是HTTPS 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
2.2 HTTPS怎么解决上述问题 HTTPS是在通信接口部分用 TLS(Transport Layer Security 传输层安全性协议)，TLS协议采用主从式架构模型，用于在两个应用程序间通过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。
2.3 SSL和TLS的关系 传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。 网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。 IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。 2.4 TLS/SSL 协议 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</description></item><item><title>SSL或TLS协议运行机制的概述（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDssl%E6%88%96tls%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/</link><pubDate>Tue, 12 Jan 2021 10:14:27 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDssl%E6%88%96tls%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/</guid><description>互联网的通信安全，建立在SSL/TLS协议之上。
本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅RFC文档。
一、作用
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。
（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
（2） 篡改风险（tampering）：第三方可以修改通信内容。
（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。
SSL/TLS协议是为了解决这三大风险而设计的，希望达到：
（1） 所有信息都是加密传播，第三方无法窃听。
（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
（3） 配备身份证书，防止身份被冒充。
互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。
二、历史
互联网加密通信协议的历史，几乎与互联网一样长。
1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
1996年，SSL 3.0版问世，得到大规模应用。
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。
目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。
三、基本的运行过程
SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题。
（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个&amp;quot;对话密钥&amp;quot;（session key），用它来加密信息。由于&amp;quot;对话密钥&amp;quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&amp;quot;对话密钥&amp;quot;本身，这样就减少了加密运算的消耗时间。
因此，SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成&amp;quot;对话密钥&amp;quot;。
（3） 双方采用&amp;quot;对话密钥&amp;quot;进行加密通信。</description></item><item><title>彻底搞懂HTTPS的加密机制（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 12 Jan 2021 10:04:38 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6/</guid><description>彻底搞懂HTTPS的加密机制（为什么这么设计） 本章节非原创，转载来源：https://zhuanlan.zhihu.com/p/43789231
HTTPS（SSL/TLS）的加密机制虽然是个前端后端等都应了解的基本问题，但网上的很多HTTPS相关文章也总会忽略一些内容，我学习它的时候也废了挺大功夫。 对称加密、非对称加密、数字签名、数字证书等等，在学习过程中，除了了解“它是什么”，你是否有想过“为什么是它”？我认为理解了后者才真正理解了HTTPS的加密机制。
本文以问题的形式逐步展开，一步步解开HTTPS的面纱，希望能帮助你彻底搞懂HTTPS。特别是对于了解过HTTPS却在有些地方有所卡壳的人，希望本文能帮助你理清思路。
为什么需要加密？ 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密 。
什么是对称加密？ 就是有一个密钥，它可以对一段内容加密，加密后只能用它才能解密看到原本的内容，和我们日常生活中用的钥匙作用差不多。
用对称加密可行吗？ 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。 然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那这个传输过程中密钥被别人劫持弄到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。 换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行啦！这么做显然不现实。 怎么办？所以我们就需要神奇的非对称加密
什么是非对称加密？ 有两把密钥，通常一把叫做公钥、一把叫做私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。 用非对称加密可行吗？ 鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开这条数据。 然而由服务器到浏览器的这条路怎么保障安全？如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据时的安全性（其实仍有漏洞，下文会说），那利用这点你能想到什么解决方案吗？
改良的非对称加密方案，似乎可以？ 我们已经理解通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：
某网站拥有用于非对称加密的公钥A、私钥A’；浏览器拥有用于非对称加密的公钥B、私钥B’。 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。 浏览器把公钥B明文传输给服务器。 之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有这个私钥A’可以解密，所以能保证这条数据的安全。 服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。 的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心，而对称加密快很多，看来必须得用对称加密，那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？
非对称加密+对称加密？ 既然非对称加密耗时，非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。 请看一下这个过程：
某网站拥有用于非对称加密的公钥A、私钥A’。 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。 服务器拿到后用私钥A’解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。 完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。
中间人攻击 中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到密钥A’就能干坏事了。请看：
某网站拥有用于非对称加密的公钥A、私钥A’。 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。 浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器。 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。 服务器拿到后用私钥A’解密得到密钥X。 这样在双方都不会发现异常的情况下，中间人得到了密钥B。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决下面这个问题：
如何证明浏览器收到的公钥一定是该网站的公钥？ 现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？
数字证书 网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！
如何放防止数字证书被篡改？ 我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名：
数字签名 这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程（原图出处找不到了，可以看出来这图已经被转载了无数次了。。。）
数字签名的制作过程：
CA拥有非对称加密的私钥和公钥。 CA对证书明文信息进行hash。 对hash后的值用私钥加密，得到数字签名。 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。 那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）
浏览器验证过程：
拿到证书，得到明文T，数字签名S。 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。 用证书里说明的hash算法对明文T进行hash得到T’。 比较S’是否等于T’，等于则表明证书可信。 为什么这样可以证明证书可信呢？我们来仔细想一下。</description></item><item><title>发起HTTP请求：使用JDK11的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 17:08:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</guid><description>发起HTTP请求：使用JDK11的HttpClient JDK11 API中原生的增加了HTTP客户端类HttpClient，用于发起HTTP请求，支持HTTP/2.
以下内容非原创，参考/转载来源：https://www.dariawan.com/tutorials/java/java-11-standard-http-client-vs-apache-httpclient/
JDK11的HttpClient使用测试：
package com.wangjm.http.connection; import com.google.common.net.UrlEscapers; import org.junit.jupiter.api.Test; import java.net.ProxySelector; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.Duration; /** * @author : wangjm * @date : 2021/1/11 20:47 * JDK11 API 提供了HttpClient，支持HTTP/2 * 简单使用的情况下，http和https链接的请求都是相同的 */ class JDKHttpClientUtilTest { @Test public void doTest() throws Exception { final HttpClient HTTP_CLIENT = HttpClient.newBuilder() .version(HttpClient.Version.HTTP_2) // default .followRedirects(HttpClient.Redirect.NORMAL) // Always redirect, except from HTTPS URLs to HTTP URLs. .</description></item><item><title>发起HTTP请求：使用Apache的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 14:34:53 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</guid><description>Java发起HTTP请求：使用Apache的HttpClient 许多小伙伴都喜欢用apache的HttpComponts里的HttpClient来向远程发起HTTP请求
从HttpComponents官网的features说明来看，当前版本(HttpClient4.5)仅支持到HTTP/1.1。 但是HttpCore.5.1BETA将支持HTTP/2，可惜还在BETA阶段。
使用方式：
项目中引入对应的maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 参考了别人的代码,简单使用：
/** * 使用apache的HttpClient发起HTTP以及HTTPS请求 * 注意：当前的apache的HttpClient4.5只支持到HTTP/1.1 * 参考：https://zhuanlan.zhihu.com/p/69285935 * 参考：https://blog.csdn.net/happylee6688/article/details/47148227 */ public class HttpClientUtil { private static PoolingHttpClientConnectionManager connMgr; private static RequestConfig requestConfig; private static final int MAX_TIMEOUT = 7000; static { // 设置连接池 connMgr = new PoolingHttpClientConnectionManager(); // 设置连接池大小 connMgr.setMaxTotal(100); connMgr.setDefaultMaxPerRoute(connMgr.getMaxTotal()); RequestConfig.Builder configBuilder = RequestConfig.custom(); // 设置连接超时 configBuilder.setConnectTimeout(MAX_TIMEOUT); // 设置读取超时 configBuilder.setSocketTimeout(MAX_TIMEOUT); // 设置从连接池获取连接实例的超时 configBuilder.</description></item><item><title>发起HTTP请求：Spring中RestTemplate设置与携带请求头（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Fri, 08 Jan 2021 16:56:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>Rest设置请求头以及进一步配置 本章节“Rest设置与携带请求头”部分非原创，转载来源：https://juejin.cn/post/6844904202397827086
本节主要集中在如何携带自定义的请求头，如设置 User-Agent，携带 Cookie
Get 携带请求头 Post 携带请求头 拦截器方式设置统一请求头 I. 项目搭建 1. 配置 借助 SpringBoot 搭建一个 SpringWEB 项目，提供一些用于测试的 REST 服务
SpringBoot 版本: 2.2.1.RELEASE 核心依赖: spring-boot-stater-web &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件application.yml中，添加
logging: pattern: console: (%msg%n%n){blue} 2. Rest 服务 添加三个接口，分别提供 GET 请求，POST 表单，POST json 对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明
@RestController public class DemoRest { private String getHeaders(HttpServletRequest request) { Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); String name; JSONObject headers = new JSONObject(); while (headerNames.</description></item><item><title>发起HTTP请求：Spring中的RestTempalate的基本使用（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Jan 2021 17:28:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate的认识与基本使用 RestTemplate介绍 在Spring的生态下，则可以利用RestTemplate来发起Http请求。
spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。
RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如 Apache HttpComponents、Netty或OkHttp等其它HTTP library。
RestTemplate构成与实现逻辑：
RestTemplate包含以下几个部分：
HttpMessageConverter 对象转换器 ClientHttpRequestFactory 默认是JDK的HttpURLConnection ResponseErrorHandler 异常处理 ClientHttpRequestInterceptor 请求拦截器 用一张图可以很直观的理解：
RestTempalate的基本使用 本节&amp;quot;RestTempalate的基本使用&amp;quot;非原创，转载来源：https://juejin.cn/post/6844903656165212174
0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么
简单的给出了一下常见的问题如下
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本节主要关注在RestTemplate的简单Get/Post请求的使用方式上：
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种
// get 请求 public &amp;lt;T&amp;gt; T getForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public &amp;lt;T&amp;gt; T postForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; postForEntity(); // put 请求 public void put(); // pathch public &amp;lt;T&amp;gt; T patchForObject // delete public void delete() // options public Set&amp;lt;HttpMethod&amp;gt; optionsForAllow // exchange public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说</description></item><item><title>Java发起HTTP请求方式汇总</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</link><pubDate>Thu, 07 Jan 2021 16:31:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</guid><description>作为一个Java后端，需要通过HTTP请求其他的网络资源可以说是一个比较常见的case了；一般怎么做呢？
直接捞起Apache的HttpClient开始做 (只支持到HTTP/1.1,最近的Http5.1-beta开始支持HTTP/2) 知名的开源库如OkHttp 原生的HttpURLConnection （Since: JDK1.1） 原生的HttpClient （JDK11） Spring的生态中可以利用RestTemplate来发起Http请求。 发送HTTP请求时，要注意区分http和https类型的请求</description></item></channel></rss>