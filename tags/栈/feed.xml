<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>栈 on Jingmin's blog</title><link>https://ole12138.gitee.io/tags/%E6%A0%88/</link><description>Recent content in 栈 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Thu, 25 Jun 2020 05:24:48 +0800</lastBuildDate><atom:link href="https://ole12138.gitee.io/tags/%E6%A0%88/feed.xml" rel="self" type="application/rss+xml"/><item><title>PAT甲级习题</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</guid><description>PAT甲级习题 栈的模拟 例1 已知入栈顺序1-N，并给定栈最大容积M。判断出栈顺序是否正确, 以及是否爆栈
题目链接
方法：栈的模拟
由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈。利用这个过程来确定出入栈顺序。
package com.jingmin.advanced2; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Stack; /** * @author : wangjm * @date : 2020/6/26 09:55 * @discription : https://www.nowcoder.com/pat/5/problem/4090 * 已知入栈顺序，判断出栈顺序是否正确, 以及是否爆栈: 栈的模拟 * 由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈 */ public class Advanced1040 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] s = br.readLine().split(&amp;#34; &amp;#34;); int m = Integer.parseInt(s[0]); int n = Integer.parseInt(s[1]); int k = Integer.</description></item><item><title>数据结构-栈和队列</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</guid><description>栈和队列 image-20200328200545921 栈 基本概念 栈的定义 栈（ Stack）只允许在一端进行插入或删除操作的线性表
后进先出（LIFO）
共享栈的定义 将两个栈底设置在共享空间的两端，栈顶向空间中间延伸
优点：存取时间复杂度仍为O（1），但空间利用更加有效
栈的基本操作 Initstack（&amp;amp;S）：初始化一个空栈S StackEmpty（S）：判断一个栈是否为空，若栈为空则返回true，否则返回 False。 Push（&amp;amp;S,x）：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop（&amp;amp;S，&amp;amp;x）：出栈，若栈非空，则弹出栈顶元素，并用×返回。 GetTop（s，&amp;amp;x）：读栈顶元素，若栈非空则用×返回栈顶元素。 ClearStack（&amp;amp;S）：销毁栈，并释放S占用的内存空间。
存储结构 顺序存储 image-20200328201504762 而对于共享栈：
image-20200328203132531 链式存储 image-20200328203310146 所有的操作都在表头进行。入栈出栈对应于单链表在表头的插入和删除，判空也与单链表相同。
栈的应用 括号匹配 表达式求值 中缀表达式转后缀式1 表达式求值、表达式转二叉树
中缀表达式转后缀表达式主要有两种方法
根据中缀表达式，写出表达式树，然后后序遍历，即得到后缀表达式（去掉括号的输出）。 读取中缀表达式，直接输出操作数，利用栈保存操作符。向栈中保存操作符前，栈中优先级高的操作符要先输出/参与运算。这样得到的输出也是后缀表达式。 例如，中缀表达式a + bc + (d e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。
中缀表达式转换后缀表达式过程：使用栈（保存操作符）的方法，具体过程如下：
如果遇到操作数，我们就直接将其输出（加入到后缀表达式）。 如果遇到操作符，（栈中优先级高的操作符要先输出/参与运算，再把当前操作符入栈） 若为’(’，直接入栈 若为’)‘，则依次把栈中的运算符输出（加入到后缀表达式），直到出现’(‘，并从栈中删除’(’； 注意，左括号只弹出并不输出。 若为’+‘，’-‘，’*‘，’，‘/’ 若高于栈顶元素优先级，或栈空，或栈顶为’(’，直接入栈； 否则，先依次弹出栈顶运算符，直到一个优先级比它低的运算符或’(‘为止; 弹出完这些元素后，才将遇到的操作符压入到栈中。 有一点需要注意，只有在遇到"</description></item></channel></rss>