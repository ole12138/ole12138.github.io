<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring源码 on Jingmin's blog</title><link>https://ole12138.github.io/tags/spring%E6%BA%90%E7%A0%81/</link><description>Recent content in Spring源码 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Sat, 23 Jan 2021 15:06:16 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/tags/spring%E6%BA%90%E7%A0%81/feed.xml" rel="self" type="application/rss+xml"/><item><title>Spring从xml启动注解扫描的过程</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 23 Jan 2021 15:06:16 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</guid><description>Spring从xml启动注解扫描的过程 问题引入 实际的Spring项目中，往往是：
在配置文件中开启注解自动扫描（还需要引入context命名空间xmlns:context以及标签格式说明context.xsd)，
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;&amp;lt;其他一些schema&amp;gt; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.jingmin.*&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 然后在相应的包下直接使用注解直接注入Bean。
@Component class Xxx{ ... } 那么，使用过程中，就会有这样的疑问：
Spring是怎么实现读取context标签的？ 读取到context:component-scan又是怎么开启注解扫描的？ 扫描到注解之后又是怎么处理的？ 源码分析 AbstractApplicationContext#refresh 前文介绍过，
不论是用new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;)启动Spring， 还是在SpringMVC的web.xml配置监听器启动Spring， 最终都是调用AbstractApplicationContext的refresh()方法来完成Spring容器的启动和bean的管理的。
public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { ... @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { //为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); //为BeanFactory注册BeanPost事件处理器.</description></item><item><title>Spring源码分析起步</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</link><pubDate>Thu, 21 Jan 2021 12:01:24 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</guid><description>Spring源码分析起步 这是从网上找的一张Spring的类继承图，IDE中翻了一下源码，当前版本并没有什么变动。
普通应用程序启动Spring前的准备 对于Spring的普通应用程序（从XML加载配置），一般是从这样的代码开始的：
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;applicationContext.xml&amp;#34;); Message message = (Message) applicationContext.getBean(&amp;#34;message&amp;#34;); 其中ClassPathXmlApplicationContext的初始化过程：
public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { //调用父类初始化过程和记录配置文件位置 ... if (refresh) { //启动Spring的核心过程 refresh(); } } 注意到refresh()方法是在其祖先类AbstractApplicationContext中定义的。
下面我们先不往下跟refresh()方法，先看一下web项目，就会发现web项目在启动Spring的过程中，最终同样到达了AbstractApplicationContext中refresh()方法。
web项目启动Spring前的准备 而对于Spring的web项目（从XML加载配置），一般是在项目的web.xml添加了Spring的Listener：
&amp;lt;!--加载spring--&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath*:applicationContext.xml&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; 而其中这个Listener的类实现了ServletContextListener接口
public class ContextLoaderListener extends ContextLoader implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent event) { initWebApplicationContext(event.getServletContext()); } ... } 根据Servlet的规范，在web项目在Context初始化的过程中javax.servlet.ServletContextListener的contextInitialized(ServletContextEvent event)方法会被调用。</description></item></channel></rss>