<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>HTTP on Jingmin's blog</title><link>https://ole12138.github.io/categories/http/</link><description>Recent content in HTTP on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Mon, 11 Jan 2021 17:08:09 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/categories/http/feed.xml" rel="self" type="application/rss+xml"/><item><title>发起HTTP请求：使用JDK11的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 17:08:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</guid><description>发起HTTP请求：使用JDK11的HttpClient JDK11 API中原生的增加了HTTP客户端类，用于发起HTTP请求，支持HTTP/2.</description></item><item><title>Java发起HTTP请求：使用Apache的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 14:34:53 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</guid><description>Java发起HTTP请求：使用Apache的HttpClient 许多小伙伴都喜欢用apache的HttpComponts里的HttpClient来向远程发起HTTP请求
从HttpComponents官网的features说明来看，当前版本(HttpClient4.5)仅支持到HTTP/1.1。 但是HttpCore.5.1BETA将支持HTTP/2，可惜还在BETA阶段。
使用方式：
项目中引入对应的maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 简单使用： 参考：
public class HttpClientUtil { public static String doGet(String url) { String result = &amp;#34;&amp;#34;; try { // 通过址默认配置创建一个httpClient实例 @Cleanup CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建httpGet远程连接实例 HttpGet httpGet = new HttpGet(url); // 设置请求头信息，鉴权 httpGet.setHeader(&amp;#34;Authorization&amp;#34;, &amp;#34;Bearer da3efcbf-0845-4fe3-8aba-ee040be542c0&amp;#34;); // 设置配置请求参数 RequestConfig requestConfig = RequestConfig.custom() // 连接主机服务超时时间 .setConnectTimeout(35000) // 请求超时时间 .setConnectionRequestTimeout(35000) // 数据读取超时时间 .setSocketTimeout(60000) .</description></item><item><title>转载：HTTP协议入门</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</link><pubDate>Sun, 10 Jan 2021 18:52:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</guid><description>HTTP 协议介绍 本章节非原创，转载来源：http://www.ruanyifeng.com/blog/2016/08/http.html
HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。
本文介绍 HTTP 协议的历史演变和设计思路。
一、HTTP/0.9 HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。
最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。
GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。
协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt;Hello World&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 服务器发送完毕，就关闭TCP连接。
二、HTTP/1.0 2.1 简介 1996年5月，HTTP/1.0 版本发布，内容大大增加。
首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。
再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
2.2 请求格式 下面是一个1.0版的HTTP请求的例子。
GET / HTTP/1.0 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */* 可以看到，这个格式与0.9版有很大变化。
第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。
2.3 回应格式 服务器的回应如下。
HTTP/1.0 200 OK Content-Type: text/plain Content-Length: 137582 Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996 15:55:28 GMT Server: Apache 0.</description></item><item><title>转载：发起HTTP请求：Spring中RestTemplate设置与携带请求头</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Fri, 08 Jan 2021 16:56:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>Rest设置请求头以及进一步配置 本章节“Rest设置与携带请求头”部分非原创，转载来源：https://juejin.cn/post/6844904202397827086
本节主要集中在如何携带自定义的请求头，如设置 User-Agent，携带 Cookie
Get 携带请求头 Post 携带请求头 拦截器方式设置统一请求头 I. 项目搭建 1. 配置 借助 SpringBoot 搭建一个 SpringWEB 项目，提供一些用于测试的 REST 服务
SpringBoot 版本: 2.2.1.RELEASE 核心依赖: spring-boot-stater-web &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件application.yml中，添加
logging: pattern: console: (%msg%n%n){blue} 2. Rest 服务 添加三个接口，分别提供 GET 请求，POST 表单，POST json 对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明
@RestController public class DemoRest { private String getHeaders(HttpServletRequest request) { Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); String name; JSONObject headers = new JSONObject(); while (headerNames.</description></item><item><title>转载：发起HTTP请求：Spring中的RestTempalate的基本使用</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Jan 2021 17:28:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate的认识与基本使用 RestTemplate介绍 在Spring的生态下，则可以利用RestTemplate来发起Http请求。
spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。
RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如 Apache HttpComponents、Netty或OkHttp等其它HTTP library。
RestTemplate构成与实现逻辑：
RestTemplate包含以下几个部分：
HttpMessageConverter 对象转换器 ClientHttpRequestFactory 默认是JDK的HttpURLConnection ResponseErrorHandler 异常处理 ClientHttpRequestInterceptor 请求拦截器 用一张图可以很直观的理解：
RestTempalate的基本使用 本节&amp;quot;RestTempalate的基本使用&amp;quot;非原创，转载来源：https://juejin.cn/post/6844903656165212174
0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么
简单的给出了一下常见的问题如下
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本节主要关注在RestTemplate的简单Get/Post请求的使用方式上：
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种
// get 请求 public &amp;lt;T&amp;gt; T getForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public &amp;lt;T&amp;gt; T postForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; postForEntity(); // put 请求 public void put(); // pathch public &amp;lt;T&amp;gt; T patchForObject // delete public void delete() // options public Set&amp;lt;HttpMethod&amp;gt; optionsForAllow // exchange public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说</description></item><item><title>Java发起HTTP请求方式汇总</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</link><pubDate>Thu, 07 Jan 2021 16:31:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</guid><description>作为一个Java后端，需要通过HTTP请求其他的网络资源可以说是一个比较常见的case了；一般怎么做呢？
直接捞起Apache的HttpClient开始做 (只支持到HTTP/1.1,最近的Http5.1-beta开始支持HTTP/2) 知名的开源库如OkHttp 原生的HttpURLConnection （Since: JDK1.1） 原生的HttpClient （JDK11） Spring的生态中可以利用RestTemplate来发起Http请求。 发送HTTP请求时，要注意区分http和https类型的请求</description></item></channel></rss>