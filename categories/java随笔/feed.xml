<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java随笔 on Jingmin's blog</title><link>https://ole12138.gitee.io/categories/java%E9%9A%8F%E7%AC%94/</link><description>Recent content in Java随笔 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Thu, 28 Jan 2021 20:00:58 +0800</lastBuildDate><atom:link href="https://ole12138.gitee.io/categories/java%E9%9A%8F%E7%AC%94/feed.xml" rel="self" type="application/rss+xml"/><item><title>随笔-Spring及SpringMVC配置文件中annotation-config和annotation-driven和component-scan的区别（转载）</title><link>https://ole12138.gitee.io/post/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94-spring%E5%8F%8Aspringmvc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%ADannotation-config%E5%92%8Cannotation-driven%E5%92%8Ccomponent-scan%E7%9A%84%E5%8C%BA%E5%88%AB%E8%BD%AC%E8%BD%BD/</link><pubDate>Thu, 28 Jan 2021 20:00:58 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94-spring%E5%8F%8Aspringmvc%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%ADannotation-config%E5%92%8Cannotation-driven%E5%92%8Ccomponent-scan%E7%9A%84%E5%8C%BA%E5%88%AB%E8%BD%AC%E8%BD%BD/</guid><description>annotation-config和annotation-driven和component-scan的区别 本章非原创，转载来源：https://blog.csdn.net/catoop/article/details/50068573
本文开门见山，直接分别进行解释： 一、&amp;lt;context:annotation-config/&amp;gt; 隐式地向Spring容器中注册AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、PersistenceAnnotationBeanPostProcessor 及 equiredAnnotationBeanPostProcessor 这 4 个 BeanPostProcessor 对这个结果类做个解释： 1、如果你想使用@Autowired注解，那么就必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor Bean。 2、如果想使用@ Resource 、@ PostConstruct、@ PreDestroy等注解就必须声明CommonAnnotationBeanPostProcessor。 3、如果想使用@PersistenceContext注解，就必须声明PersistenceAnnotationBeanPostProcessor的Bean。 4、如果想使用 @Required的注解，就必须声明RequiredAnnotationBeanPostProcessor的Bean。 分别对应的传统声明方式为：
&amp;lt;bean class=&amp;quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor&amp;quot;/&amp;gt; &amp;lt;bean class=&amp;quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&amp;quot;/&amp;gt; &amp;lt;bean class=&amp;quot;org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor&amp;quot;/&amp;gt; &amp;lt;bean class=&amp;quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&amp;quot;/&amp;gt; 1234 一般来说，这些注解我们还是比较常用，尤其是Antowired的注解，在自动注入的时候更是经常使用，所以如果总是需要按照传统的方式一条一条配置显得有些繁琐和没有必要，于是spring给我们提供 &amp;lt;context:annotation-config&amp;gt; 的简化配置方式，自动帮你完成声明。
&amp;lt;context:annotation-config/&amp;gt; 将隐式地向 Spring 容器注册 AutowiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor、PersistenceAnnotationBeanPostProcessor 以及 equiredAnnotationBeanPostProcessor 这 4 个 BeanPostProcessor。
二、 &amp;lt;context:component-scan/&amp;gt; &amp;lt;context:component-scan/&amp;gt; 配置项不但启用了对类包进行扫描以实施注释驱动 Bean 定义的功能，同时还启用了注释驱动自动注入的功能（即还隐式地在内部注册了 AutowiredAnnotationBeanPostProcessor 和 CommonAnnotationBeanPostProcessor），因此当使用 &amp;lt;context:component-scan base-package=&amp;quot;xxx.xxx.xxx&amp;quot;/&amp;gt; 后，就可以将 &amp;lt;context:annotation-config/&amp;gt; 移除了。
默认情况下通过 @Component 定义的 Bean 都是 singleton 的，如果需要使用其它作用范围的 Bean，可以通过 @Scope 注释来达到目标，如：@Scope(“prototype”)，这样，当从 Spring 容器中获取 boss Bean 时，每次返回的都是新的实例了。</description></item><item><title>随笔-Spring项目配置文件xsd引用问题</title><link>https://ole12138.gitee.io/post/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94-spring%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6xsd%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</link><pubDate>Thu, 21 Jan 2021 17:53:27 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E9%9A%8F%E7%AC%94/%E9%9A%8F%E7%AC%94-spring%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6xsd%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</guid><description>随笔-Spring项目配置文件xsd引用问题 新建一个Spring项目（从XML配置文件），大概这样：
public class Main { public static void main(String[] args) { ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;applicationContext.xml&amp;#34;); //随便一个bean Message message = (Message) applicationContext.getBean(&amp;#34;message&amp;#34;); System.out.println(message); } } 然鹅却迟迟不能启动，好一会儿控制台报错：
[main] WARN org.springframework.beans.factory.xml.XmlBeanDefinitionReader - Ignored XML validation warning org.xml.sax.SAXParseException: schema_reference.4: Failed to read schema document '/spring-context-4.0.xsd', because 1) could not find the document; 2) the document could not be read; 3) the root element of the document is not &amp;lt;xsd:schema&amp;gt;. ... Spring配置文件是xml格式的，其中的标签需要对应的说明文档。这也就是Spring配置文件的格式说明文档没有加载上呗。</description></item></channel></rss>