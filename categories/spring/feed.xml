<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on Jingmin's blog</title><link>https://ole12138.github.io/categories/spring/</link><description>Recent content in Spring on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Mon, 08 Feb 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ole12138.github.io/categories/spring/feed.xml" rel="self" type="application/rss+xml"/><item><title>Spring的AOP的使用</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E7%9A%84aop%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E7%9A%84aop%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>Spring的AOP的使用 在Spring中可以进行面向切面的编程。
这里的意思是，
Spring AOP实现了对方法织入增强 Spring可以集成专门的AOP框架AspectJ。 一般直接考虑用Spring AOP即可。当需要对属性织入、多次织入、加载时织入、优化编织效果等再考虑集成AspectJ。
Spring AOP官方文档（概念与使用）：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop 翻译：https://docs.huihoo.com/spring/2.0.x/zh-cn/aop.html
Spring AOP官方文档（低级API）：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-api 翻译：https://docs.huihoo.com/spring/2.0.x/zh-cn/aop-api.html
虽然翻译的版本是Spring2.0的老版本，但至少aop章节是没多少改动的。
如果查看Spring的源码，会发现Spring内部使用的是低级API：Advice, Advisor, PointCut等。 但如果是我们使用AOP，直接引入aspectjweawer.jar包，使用AspectJ的注解即可。（注意，虽然用的是AspectJ的注解，但是底层用是Spring AOP的低级API，这也有利于项目将来集成AspectJ）
参考下面一篇博客，从Spring AOP的低级API使用示例讲起，到最终简化为使用AspectJ形式的注解结束：https://www.huaweicloud.com/articles/f4605f69bb89c46f54ab583a3b2ae3eb.html
有一个切面执行顺序的问题：
多个切面Aspect，类上标注的@Order越小越先切入，越后退出，这个没问题。（毕竟是用代理实现的，相当于有多层代理）
问题是同一个Aspect中，@Before，@After，@AfterReturning，@AfterThrowing，@Around注解的方法可能都切入增强了某个连接点，那么连接点上这几个方法的执行顺序是？
https://blog.csdn.net/qqXHwwqwq/article/details/51678595和https://www.hicode.club/articles/2018/03/02/1550590750209.html测试的结果是依次执行doAround方法，doBefore方法。然后执行method方法，最后依次执行doAfter、doAfterReturn方法。
我测试的结果是先进入@Around增强，然后执行@Before增强，然后是被代理切入的方法，然后是@AfterReturning增强，@After增强，最后从@Around增强退出。
stackoverflow上有人说这个与Spring版本相关。</description></item><item><title>Spring从xml启动注解扫描的过程</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 23 Jan 2021 15:06:16 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</guid><description>Spring从xml启动注解扫描的过程 问题引入 实际的Spring项目中，往往是：
在配置文件中开启注解自动扫描（还需要引入context命名空间xmlns:context以及标签格式说明context.xsd)，
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;&amp;lt;其他一些schema&amp;gt; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.jingmin.*&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 然后在相应的包下直接使用注解直接注入Bean。
@Component class Xxx{ ... } 那么，使用过程中，就会有这样的疑问：
Spring是怎么实现读取context标签的？ 读取到context:component-scan又是怎么开启注解扫描的？ 扫描到注解之后又是怎么处理的？ 源码分析 AbstractApplicationContext#refresh 前文介绍过，
不论是用new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;)启动Spring， 还是在SpringMVC的web.xml配置监听器启动Spring， 最终都是调用AbstractApplicationContext的refresh()方法来完成Spring容器的启动和bean的管理的。
public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { ... @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { //为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); //为BeanFactory注册BeanPost事件处理器.</description></item><item><title>Spring文档中文翻译(转载)</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%BD%AC%E8%BD%BD/</link><pubDate>Fri, 22 Jan 2021 23:10:10 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%BD%AC%E8%BD%BD/</guid><description>转载来源：https://juejin.cn/post/6844903960654921736
Spring 文档的中文翻译 以下所有文档均包含多个版本，并支持多语言（英文及中文）。
这个翻译比较好，但是暂时缺少aop部分的翻译：https://lfvepclr.gitbooks.io/spring-framework-5-doc-cn/content/ 这个翻译也比较好，同样缺少aop部分的翻译：https://muyinchen.gitbooks.io/spring-framework-5-0-0-m3/content/ https://docs.huihoo.com/spring/2.0.x/zh-cn/aop.html https://docs.huihoo.com/spring/2.0.x/zh-cn/aop-api.html 这个是aop部分的一个比较好的翻译，虽然是Spring2.0.x文档翻译来的，但现在的Spring5文档没多少区别 这个翻译比较全，但是翻译的不太好的样子：https://docs4dev.com/</description></item><item><title>Spring源码分析起步</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</link><pubDate>Thu, 21 Jan 2021 12:01:24 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</guid><description>Spring源码分析起步 这是从网上找的一张Spring的类继承图，IDE中翻了一下源码，当前版本并没有什么变动。
普通应用程序启动Spring前的准备 对于Spring的普通应用程序（从XML加载配置），一般是从这样的代码开始的：
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;applicationContext.xml&amp;#34;); Message message = (Message) applicationContext.getBean(&amp;#34;message&amp;#34;); 其中ClassPathXmlApplicationContext的初始化过程：
public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { //调用父类初始化过程和记录配置文件位置 ... if (refresh) { //启动Spring的核心过程 refresh(); } } 注意到refresh()方法是在其祖先类AbstractApplicationContext中定义的。
下面我们先不往下跟refresh()方法，先看一下web项目，就会发现web项目在启动Spring的过程中，最终同样到达了AbstractApplicationContext中refresh()方法。
web项目启动Spring前的准备 而对于Spring的web项目（从XML加载配置），一般是在项目的web.xml添加了Spring的Listener：
&amp;lt;!--加载spring--&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath*:applicationContext.xml&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; 而其中这个Listener的类实现了ServletContextListener接口
public class ContextLoaderListener extends ContextLoader implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent event) { initWebApplicationContext(event.getServletContext()); } ... } 根据Servlet的规范，在web项目在Context初始化的过程中javax.servlet.ServletContextListener的contextInitialized(ServletContextEvent event)方法会被调用。</description></item><item><title>Spring构建restfulWebService</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</link><pubDate>Wed, 06 Jan 2021 11:18:01 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</guid><description>Spring构建restfulWebService 这是官网提供的一个例子，这里练习。
实际上这里用的是Springboot来创建的。
What You Will Build build a service that will accept HTTP GET requests at http://localhost:8080/greeting.
It will respond with a JSON representation of a greeting, as the following listing shows:
{&amp;#34;id&amp;#34;:1,&amp;#34;content&amp;#34;:&amp;#34;Hello, World!&amp;#34;} You can customize the greeting with an optional name parameter in the query string, as the following listing shows:
http://localhost:8080/greeting?name=User The name parameter value overrides the default value of World and is reflected in the response, as the following listing shows:</description></item></channel></rss>