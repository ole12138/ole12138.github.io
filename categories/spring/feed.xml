<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Spring on Jingmin's blog</title><link>https://ole12138.github.io/categories/spring/</link><description>Recent content in Spring on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Sat, 23 Jan 2021 15:06:16 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/categories/spring/feed.xml" rel="self" type="application/rss+xml"/><item><title>Spring从xml启动注解扫描的过程</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</link><pubDate>Sat, 23 Jan 2021 15:06:16 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/</guid><description>Spring从xml启动注解扫描的过程 问题引入 实际的Spring项目中，往往是：
在配置文件中开启注解自动扫描（还需要引入context命名空间xmlns:context以及标签格式说明context.xsd)，
&amp;lt;beans xmlns=&amp;#34;http://www.springframework.org/schema/beans&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xmlns:context=&amp;#34;http://www.springframework.org/schema/context&amp;#34; xsi:schemaLocation=&amp;#34;&amp;lt;其他一些schema&amp;gt; http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&amp;#34;&amp;gt; &amp;lt;context:component-scan base-package=&amp;#34;com.jingmin.*&amp;#34;/&amp;gt; &amp;lt;/beans&amp;gt; 然后在相应的包下直接使用注解直接注入Bean。
@Component class Xxx{ ... } 那么，使用过程中，就会有这样的疑问：
Spring是怎么实现读取context标签的？ 读取到context:component-scan又是怎么开启注解扫描的？ 扫描到注解之后又是怎么处理的？ 源码分析 AbstractApplicationContext#refresh 前文介绍过，
不论是用new ClassPathXmlApplicationContext(&amp;quot;applicationContext.xml&amp;quot;)启动Spring， 还是在SpringMVC的web.xml配置监听器启动Spring， 最终都是调用AbstractApplicationContext的refresh()方法来完成Spring容器的启动和bean的管理的。
public abstract class AbstractApplicationContext extends DefaultResourceLoader implements ConfigurableApplicationContext { ... @Override public void refresh() throws BeansException, IllegalStateException { synchronized (this.startupShutdownMonitor) { //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识 prepareRefresh(); //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从 //子类的refreshBeanFactory()方法启动 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); //为BeanFactory配置容器特性，例如类加载器、事件处理器等 prepareBeanFactory(beanFactory); try { //为容器的某些子类指定特殊的BeanPost事件处理器 postProcessBeanFactory(beanFactory); //调用所有注册的BeanFactoryPostProcessor的Bean invokeBeanFactoryPostProcessors(beanFactory); //为BeanFactory注册BeanPost事件处理器.</description></item><item><title>Spring文档中文翻译(转载)</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%BD%AC%E8%BD%BD/</link><pubDate>Fri, 22 Jan 2021 23:10:10 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%BD%AC%E8%BD%BD/</guid><description>转载来源：https://juejin.cn/post/6844903960654921736
Spring 官方文档（中文翻译） 以下所有文档均包含多个版本，并支持多语言（英文及中文）。
Spring Boot 中文文档 Spring Framework 中文文档 Spring Cloud 中文文档 Spring Security 中文文档 Spring Session 中文文档 Spring AMQP 中文文档 Spring Data Spring Data JPA Spring Data JDBC Spring Data Redis 参与贡献 如果你希望参与文档的校对及翻译工作，请在 这里 提 PR。
项目地址 Github：github.com/docs4dev/do… 码云：gitee.com/docs4dev/do… 网站：docs4dev.com</description></item><item><title>Spring源码分析起步</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</link><pubDate>Thu, 21 Jan 2021 12:01:24 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/</guid><description>Spring源码分析起步 这是从网上找的一张Spring的类继承图，IDE中翻了一下源码，当前版本并没有什么变动。
普通应用程序启动Spring前的准备 对于Spring的普通应用程序（从XML加载配置），一般是从这样的代码开始的：
ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;applicationContext.xml&amp;#34;); Message message = (Message) applicationContext.getBean(&amp;#34;message&amp;#34;); 其中ClassPathXmlApplicationContext的初始化过程：
public ClassPathXmlApplicationContext( String[] configLocations, boolean refresh, @Nullable ApplicationContext parent) throws BeansException { //调用父类初始化过程和记录配置文件位置 ... if (refresh) { //启动Spring的核心过程 refresh(); } } 注意到refresh()方法是在其祖先类AbstractApplicationContext中定义的。
下面我们先不往下跟refresh()方法，先看一下web项目，就会发现web项目在启动Spring的过程中，最终同样到达了AbstractApplicationContext中refresh()方法。
web项目启动Spring前的准备 而对于Spring的web项目（从XML加载配置），一般是在项目的web.xml添加了Spring的Listener：
&amp;lt;!--加载spring--&amp;gt; &amp;lt;context-param&amp;gt; &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;classpath*:applicationContext.xml&amp;lt;/param-value&amp;gt; &amp;lt;/context-param&amp;gt; &amp;lt;listener&amp;gt; &amp;lt;listener-class&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-class&amp;gt; &amp;lt;/listener&amp;gt; 而其中这个Listener的类实现了ServletContextListener接口
public class ContextLoaderListener extends ContextLoader implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent event) { initWebApplicationContext(event.getServletContext()); } ... } 根据Servlet的规范，在web项目在Context初始化的过程中javax.servlet.ServletContextListener的contextInitialized(ServletContextEvent event)方法会被调用。</description></item><item><title>Spring构建restfulWebService</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</link><pubDate>Wed, 06 Jan 2021 11:18:01 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</guid><description>Spring构建restfulWebService 这是官网提供的一个例子，这里练习。
实际上这里用的是Springboot来创建的。
What You Will Build build a service that will accept HTTP GET requests at http://localhost:8080/greeting.
It will respond with a JSON representation of a greeting, as the following listing shows:
{&amp;#34;id&amp;#34;:1,&amp;#34;content&amp;#34;:&amp;#34;Hello, World!&amp;#34;} You can customize the greeting with an optional name parameter in the query string, as the following listing shows:
http://localhost:8080/greeting?name=User The name parameter value overrides the default value of World and is reflected in the response, as the following listing shows:</description></item></channel></rss>