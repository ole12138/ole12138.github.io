<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>数据结构与算法 on Jingmin's blog</title><link>https://ole12138.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link><description>Recent content in 数据结构与算法 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Thu, 25 Jun 2020 05:24:48 +0800</lastBuildDate><atom:link href="https://ole12138.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/feed.xml" rel="self" type="application/rss+xml"/><item><title>PAT甲级习题</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</guid><description>PAT甲级习题 栈的模拟 例1 已知入栈顺序1-N，并给定栈最大容积M。判断出栈顺序是否正确, 以及是否爆栈
题目链接
方法：栈的模拟
由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈。利用这个过程来确定出入栈顺序。
packagecom.jingmin.advanced2; importjava.io.BufferedReader; importjava.io.IOException; importjava.io.InputStreamReader; importjava.util.Stack; /** * @author : wangjm * @date : 2020/6/26 09:55 * @discription : https://www.nowcoder.com/pat/5/problem/4090 * 已知入栈顺序，判断出栈顺序是否正确, 以及是否爆栈: 栈的模拟 * 由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈 */ public class Advanced1040 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] s = br.readLine().split(&amp;quot; &amp;quot;); int m = Integer.</description></item><item><title>数据结构-栈和队列</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</guid><description>栈和队列 image-20200328200545921 栈 基本概念 栈的定义 栈（ Stack）只允许在一端进行插入或删除操作的线性表
后进先出（LIFO）
共享栈的定义 将两个栈底设置在共享空间的两端，栈顶向空间中间延伸
优点：存取时间复杂度仍为O（1），但空间利用更加有效
栈的基本操作 Initstack（&amp;amp;S）：初始化一个空栈S StackEmpty（S）：判断一个栈是否为空，若栈为空则返回true，否则返回 False。 Push（&amp;amp;S,x）：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop（&amp;amp;S，&amp;amp;x）：出栈，若栈非空，则弹出栈顶元素，并用×返回。 GetTop（s，&amp;amp;x）：读栈顶元素，若栈非空则用×返回栈顶元素。 ClearStack（&amp;amp;S）：销毁栈，并释放S占用的内存空间。
存储结构 顺序存储 image-20200328201504762 而对于共享栈：
image-20200328203132531 链式存储 image-20200328203310146 所有的操作都在表头进行。入栈出栈对应于单链表在表头的插入和删除，判空也与单链表相同。
栈的应用 括号匹配 表达式求值 中缀表达式转后缀式1 表达式求值、表达式转二叉树
中缀表达式转后缀表达式主要有两种方法
根据中缀表达式，写出表达式树，然后后序遍历，即得到后缀表达式（去掉括号的输出）。 读取中缀表达式，直接输出操作数，利用栈保存操作符。向栈中保存操作符前，栈中优先级高的操作符要先输出/参与运算。这样得到的输出也是后缀表达式。 例如，中缀表达式a + bc + (d e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。
中缀表达式转换后缀表达式过程：使用栈（保存操作符）的方法，具体过程如下：
如果遇到操作数，我们就直接将其输出（加入到后缀表达式）。 如果遇到操作符，（栈中优先级高的操作符要先输出/参与运算，再把当前操作符入栈） 若为’(’，直接入栈 若为’)‘，则依次把栈中的运算符输出（加入到后缀表达式），直到出现’(‘，并从栈中删除’(’； 注意，左括号只弹出并不输出。 若为’+‘，’-‘，’*‘，’，‘/’ 若高于栈顶元素优先级，或栈空，或栈顶为’(’，直接入栈； 否则，先依次弹出栈顶运算符，直到一个优先级比它低的运算符或’(‘为止; 弹出完这些元素后，才将遇到的操作符压入到栈中。 有一点需要注意，只有在遇到"</description></item><item><title>数据结构-线性表</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid><description>线性表 线性表是一种数据结构，其逻辑结构为线性结构；存储结构（实现）有两种：顺序、链式；对应的运算（操作）也略有不同：顺序表示可以随机访问，链式表示可以随机插入删除
线性表的定义和基本操作 线性表是具有相同类型的n（n&amp;gt;=0）个元素的有限序列，其中n为表长，当n=0时，该表为空表
若L命名为线性表，则一般表示为\(L=\left(a_{1}, a_{2}, \dots, a_{i}, a_{i+1}, \dots, a_{n}\right)\)
线性表的特点 表中元素个数有限
表中元素具有逻辑上的顺序性，在序列中各个元素排序有其先后次序
表中元素都是数据元素，每个元素都是单个元素
表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间
表中元素具有抽象性，即讨论元素间一对一的逻辑关系，而不考虑元素究竟表示的内容
线性表是一种逻辑结构，表示元素之间一对一相邻的关系
线性表的基本操作 9种基本操作：初始化、销毁、增删改查、遍历、是否为空、获取长度
InitList(8L)：初始化表。构造一个空的线性表 DestroyList（&amp;amp;L）：销毁操作。销毁线性表，并释放线性表所占用的内存空间。 LocateElem（L,e)按值查找操作。在表中查找具有给定关键值得元素。 GetELem(L,i) 按位查找操作。获取表中第个位置的元素的值。 Listlnsert(&amp;amp;L,i,e）插入操作。在表中的第个位置上插入指定元素e插 LIstDelete（&amp;amp;L, &amp;amp;e）：删除操作。删除表L中第个位置的元素，并用e返回删除元素的值。 Printlist（L)：输出操作。按前后顺序输出线性表的所有元素值。 Empty（L）：判空操作。若为空表，则返回TRUE否则返回ALSE。 Length（L）：求表长。返回线性表的长度，即L中数据元素的个数。
线性表的顺序表示 顺序表的定义 线性表的顺序存储又称顺序表
一组地址连续存放的存储单元依次存放线性表的元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
数组静态分配，数组动态分配（使用指针）
顺序表的基本操作 插入、删除、按值查找
线性表的链式表示 线性表的链式存储，简称链表
通过一组任意的存储单元来存储线性表中的数据元素，通过指针实现线性逻辑关系。
单链表 单链表的定义 带头节点的单链表和不带头节点的单链表
image-20200316185925947 带头节点单链表优点： 链表的第一个位置和其他位置的操作统一 空表和非空表的操作统一
单链表的基本操作 建立：头插、尾插
查找：按序号查找&amp;amp;按值查找
插入：按序号查找+插入（前插/后插）
前插与后插的转换：插入前交换节点内容
删除：按序号查找+删除
删除给定节点*p:交换节点内容+删除
表长
双链表 双链表可以看作是：一个带头节点的单链表+另一个不带头节点的单链表；所以其头节点并不能统一操作。
image-20200321134928900 插入
image-20200321135430055 删除
image-20200321135550537 循环链表 循环单链表 统一插入删除操作</description></item><item><title>数据结构与算法的基本概念</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>绪论 数据结构的基本概念 基本概念和术语 image-20200316002505193 数据 信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合
数据对象 具有相同性质的数据元素的集合，是数据的一个子集数据元素数据的基本单位，通常作为一个整体进行考虑和处理
数据项 构成数据元素的不可分割的最小单位
数据类型 数据结构的三要素 数据不是孤立的，他们存在着某种关系，这种相互关系我们叫做结构
数据结构是相互之间存在—种或多种特定关系的数据元素的集合
数据结构三要素：逻辑结构、物理结构、数据的运算
逻辑结构 分为：线性结构、非线性结构（集合、树形结构、图状结构）
与数据间的逻辑有关，与数据在计算机中如何存储无关
物理结构 也称存储结构
数据在计算机中的存储，包括数据元素在计算机中的存储、数据元素间关系的存储
分为：顺序存储、链式存储、索引存储、散列存储
数据的运算 运算（操作）包括运算的定义和实现，运算的定义针对逻辑结构，运算的实现针对存储结构
算法和算法评价 算法的基本概念 算法 对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。
算法的特性：有穷，可行，确定，输入，输出
算法（指导者） 程序（实施者） 解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有很多个算法。 程序是某种程序设计语言对算法的具体实现。 必须有穷 可以无穷 必须正确 可以错误 可以用伪代码，程序语言等描述 只能由程序语言编写并运行 算法效率的度量 好算法的标准 正确性算法应能够正确地解决求解问题
可读性算法应具有良好的可读性，以帮助人们理解
健壮性输入非法数据时，算法能适应的做出反应或进行处理
效率与存储量效率是指算法执行时间，存储量需求是指算法执行过程中所需最大存储空间
时间复杂度 语句频度 该条语句可能重复执行的次数
T(n) 所有语句的频度之和，其中n为问题的规模
时间复杂度 T(n)=O(f(n))，其中O表示T(n)与f(n)在\(n \rightarrow \infty\)时为同阶无穷大。即两者相同数量级。
最坏时间复杂度、最好时间复杂度、平均时间复杂度
加法规则：\(T(n)=T 1(n)+T 2(n)=O(f(n))+O(g(n))=O(\max (f(n), g(n))\)</description></item><item><title>数据结构总结</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>树 二叉树 二叉树搜索树 平衡二叉搜索树（AVL树） 参考：https://zhuanlan.zhihu.com/p/34899732 参考：https://oi-wiki.org/ds/avl/ 参考：https://www.jianshu.com/p/65c90aa1236d 参考：https://blog.csdn.net/wanderlustLee/article/details/81297253
AVL树是，在二叉搜索树的前提下，能保证平衡的树。
AVL树特点 二叉搜索树的特点：对树上的任意节点，其左子树上的值都小于当前节点的值，其右子树上的值都大约当前节点的值 平衡：对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1） AVL树的基本操作/功能 二叉搜索树的操作：插入/删除/搜索，可能还包括找上一个/下一个节点 维持树的平衡 维持树的平衡 平衡条件是什么？ 对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）
什么原因会失去平衡，哪些节点会失去平衡？ 假设当前的树已经平衡。当AVL树进行插入/删除操作时，可能造成某些节点左右子树高度的变动，破坏树的平衡。 具体的说，插入/删除位置的祖先节点可能会失去平衡。所以插入删除完成后，需要逆着查找路径，依次维护祖先节点的平衡性。
如何使失去平衡的某个节点恢复平衡？ 我们要做的操作是，调整该节点处的左右子树高度，使其重新平衡。形象的描述就是要进行旋转操作，使其重新平衡。
左旋操作、右旋操作示意图：
img 实际上，一次旋转操作并不能保证使失去平衡的树恢复平衡。
不平衡情况 前面说了插入/删除节点可能导致祖先节点失去平衡。以插入节点为例（删除类似），祖先节点具体会有4种不平衡情况：LL、RR、LR、RL。下面具体说明。
在左孩子的左子树插入节点导致不平衡LL 批注 2020-06-11 144254 这种情况只需在失去平衡的节点Y处，进行一次左旋操作即可。
在右孩子的右子树插入节点导致不平衡RR 批注 2020-06-11 144827 这种情况只需在失去平衡的节点X处，进行一次右旋操作即可。
在左孩子的右子树插入节点导致不平衡LR 批注 2020-06-11 145834 这种情况需在失去平衡的节点的左子节点X处，先进行一次左旋操作，再在当前节点Y进行一次右旋操作即可。
在右孩子的左子树插入节点导致不平衡RL 批注 2020-06-11 150123 这种情况需在失去平衡的节点的右子节点处，先进行一次右旋操作，再在当前节点进行一次左旋操作即可。
java实现：（插入/删除和中序遍历） packagecom.jingmin.datastructure; importjava.util.Scanner; importjava.util.Stack; /** * @author : wangjm * @date : 2020/6/11 16:38 * AVL树(插入/删除操作和中序遍历） * &amp;lt;p&amp;gt; * 参考（过程和逻辑）：https://zhuanlan.</description></item><item><title>树和二叉树</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>树和二叉树 树和森林 树的基本概念 树的定义 树是一种逻辑结构
image-20200410215743659 树是n（n≥0）个结点的有限集合，n=0时，称为空树。
而任意非空树应满足： 1）有且仅有一个特定的称为根的结点。 2）当n&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树。
树的特点之一：n个结点的树中只有n-1条边
树基本术语 祖先节点和子孙节点
双亲节点和孩子节点
兄弟节点
节点的度：树中一个结点的子结点的个数
树的度：树中最大的节点度数称为树的度
分支结点：度大于0的结点（子节点个数大于0的节点）
叶子结点：度为0的结点
节点的层次：从根节点开始数，根为第一层（也有的教材中定为0层）
节点的高度：节点到叶子节点所有路径上包含节点个数的最大值。
节点的深度：从根节点到该节点唯一的路径上包含的节点个数，根节点深度为1
树的高度（深度）：树中结点的最大层数
有序树和无序树
路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的。路径是有方向的，从上到下；不同兄弟树中节点不存在路径。
路径长度：路径上所经历边的个数。
森林：m（m≥0）棵互不相交的树的集合
树的性质 树中的结点数等于所有结点的度数加1 度为m的树中第层上至多有\(m^{i-1}\)个结点（i≥1） 高度为h的m叉树至多有\((m^h-1)/(m-1)\)个结点(由等比数列前n项和公式获得) 具有n个结点的m叉树的最小高度为\(\left\lceil\log _{\mathrm{m}}(\mathrm{n}(m-1)+1)\right\rceil\)，这是由上一条性质反推出来的 树的存储结构 树和森林的遍历 树和森林及二叉树的转换 树的应用——并查集 二叉树 二叉树的基本概念 定义及特点 二叉树的存储结构 二叉树的遍历 线索二叉树 二叉树的应用 二叉排序树 平衡二叉树 哈夫曼树及哈夫曼编码</description></item><item><title>算法总结</title><link>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.gitee.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>算法总结 算法 什么是算法 从字面上来说，算法也就是用于计算的方法。是用来解决某些问题的方法。通过这个方法，可以达到想要的计算结果。它就像我们小时候学些的一些数学公式和解题步骤。
算法特征 算法，一般有5个特征：
有穷性： 算法的执行步骤、时间、都是有限的。不会无休止的一直执行下去。 确切性： 算法的每一步都必须有明确的定义和描述。 输入： 一个算法应该有相应的输入条件，就像我们小时候做的应用题，已知什么什么。来求某个结果，已知部分便是输入条件。 输出： 算法必须有明确的结果输出。没有结果，那这个算法是没有任何意义的。 可行性： 算法的步骤必须是可行的，无法执行的则没有意义，也解决不了任何问题 算法分类 按照算法的应用来分：算法可以分为基本算法、几何算法、加密/解密算法、查找算法、图标数据分析算法等。 按照算法的思路（思想）来分：算法可以分为递推算法、递归算法、穷举算法、分治算法等。
按算法的应用来划分 基本算法：常规的循环、迭代、递归 递归、循环、迭代、遍历的区别 程序的运行快慢一般与其中重复执行的代码息息相关，而“重复执行”的方式又分为以下4种：
递归：一个函数反复调用自身的行为，特指函数本身； 循环：满足一定条件下，重复执行某些行为，如while结构； 迭代：按某种规则执行一个序列中的每一项，每次执行的结果又作为下次执行的初始值，直到满足某个精度或条件； 递推：由前一项可以推出后一项，是从前面的已知结果推出未知结果。当前一项的结果作为后一项的初始值时，就成了迭代。（有时候和迭代混用） 遍历：按某种规则访问图形结构中每一个节点，特指图形结构。 说明例子：
【递归】
你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。
【循环】
你去小卖铺买了一个玩具，拿回家后孩子不喜欢，你也没问他为什么不喜欢。然后你又去同一个小卖铺买了一个玩具，拿回家后孩子又不喜欢。。。如此往复 10 次，孩子才满意。
每次去买玩具的目标、行为都一样，这叫循环。
【迭代】
你去小卖铺买了个一个玩具，拿回家后孩子不喜欢。你耐心的询问后得知他喜欢乐高的玩具，于是你就去大超市给他买了乐高，回家后孩子还是不喜欢，耐心询问后得知他喜欢乐高玩具中最贵的那个玩具，于是你就去奢侈品商店给他买了乐高限量版玩具，拿回家后孩子很满意。
每次去买玩具都跟上一次不一样，或是有了新的目标，或是缩小了搜寻范围，这叫迭代。
来源：CyrusCao_知乎_https://www.zhihu.com/question/20278387/answer/109266159
递归、迭代、循环常常可以转换，且转换后程序的效率不一定相同。递归由于效率低的问题，经常要求转换成循环结构的非递归形式。
递归、分治策略、动态规划以及贪心算法之间的关系
最大公因数 辗转相减法是一种简便的求出两数最大公约数的方法。由其可推出辗转相除法。
辗转相除法求两正整数的迭代次数较少。
辗转相除,使余数消失的那个除数就是最大公因数
算法流程 gcb(m,n): m&amp;gt;n, r 是 m ÷ n 的余数， 若r不为0， 继续gcd(n,r); 若r为0，则n是最大公因数
递归法 int divisor(int m,int n) { if (m % n == 0) { return n; } else { return divisor(n,m % n); } } 迭代法 public static int gcd(int a,int b){ //如果相等 if(a==b){ return a; } //保证大数除以小数 int l,x=a,y=b; if(a&amp;gt;b){ x=b; y=a; } //迭代出现余数为0 while((l=(y%x))!</description></item></channel></rss>