<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate href=/index.xml type=application/rss+xml title="Jingmin's blog"><link rel=icon href=https://ole12138.github.io//favicon.ico><title>PAT甲级习题 - Jingmin's blog</title><link rel=stylesheet href=https://ole12138.github.io//css/highlight/github.css><link rel=stylesheet href=https://ole12138.github.io//css/bootstrap.min.css><link rel=stylesheet href=https://ole12138.github.io//css/bootstrap-theme.min.css><link rel=stylesheet href=https://ole12138.github.io//css/theme.css><link rel=stylesheet href=https://ole12138.github.io//css/bootie-docs.css><link rel=stylesheet href=https://ole12138.github.io//css/site.css></head><body role=document><nav class="navbar navbar-inverse navbar-fixed-top"><div class=container><div class=navbar-header><button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#navbar aria-expanded=false aria-controls=navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://ole12138.github.io//>Jingmin's blog</a></div><div id=navbar class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href=https://ole12138.github.io//>Home</a></li><li><a href=/post>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/series>Series</a></li><li><a href=/categories>Categories</a></li><li><a href=/about>About</a></li></ul></div></div></nav><div class=container><div class=row><div class="col-sm-8 doc-main"><main role=main><article><a id=title></a><h1 class=doc-entry-title>PAT甲级习题</h1><div class=doc-entry-meta><span><time datetime=2020-06-25>June 25, 2020</time></span></div><section><h1 id=pat甲级习题>PAT甲级习题</h1><h2 id=栈的模拟>栈的模拟</h2><h5 id=例1>例1</h5><p>已知入栈顺序1-N，并给定栈最大容积M。判断出栈顺序是否正确, 以及是否爆栈</p><p><a href=https://www.nowcoder.com/pat/5/problem/4090>题目链接</a></p><p>方法：栈的模拟</p><p>由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈。利用这个过程来确定出入栈顺序。</p><div class=sourceCode id=cb1><pre class="sourceCode java"><code class="sourceCode java"><span id=cb1-1><a href=#cb1-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb1-2><a href=#cb1-2></a></span>
<span id=cb1-3><a href=#cb1-3></a><span class=kw>import</span><span class=im> java.io.BufferedReader;</span></span>
<span id=cb1-4><a href=#cb1-4></a><span class=kw>import</span><span class=im> java.io.IOException;</span></span>
<span id=cb1-5><a href=#cb1-5></a><span class=kw>import</span><span class=im> java.io.InputStreamReader;</span></span>
<span id=cb1-6><a href=#cb1-6></a><span class=kw>import</span><span class=im> java.util.Stack;</span></span>
<span id=cb1-7><a href=#cb1-7></a></span>
<span id=cb1-8><a href=#cb1-8></a><span class=co>/**</span></span>
<span id=cb1-9><a href=#cb1-9></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb1-10><a href=#cb1-10></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/26</span> <span class=co>09:55</span></span>
<span id=cb1-11><a href=#cb1-11></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4090</span></span>
<span id=cb1-12><a href=#cb1-12></a> <span class=co>*</span> 已知入栈顺序，判断出栈顺序是否正确<span class=co>,</span> 以及是否爆栈<span class=co>:</span> 栈的模拟</span>
<span id=cb1-13><a href=#cb1-13></a> <span class=co>*</span> 由于入栈是固定从<span class=co>1到N的</span>，那么某元素出栈前，比它小的数都应当已经入栈</span>
<span id=cb1-14><a href=#cb1-14></a> <span class=co>*/</span></span>
<span id=cb1-15><a href=#cb1-15></a><span class=kw>public</span> <span class=kw>class</span> Advanced1040 {</span>
<span id=cb1-16><a href=#cb1-16></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) <span class=kw>throws</span> <span class=bu>IOException</span> {</span>
<span id=cb1-17><a href=#cb1-17></a>        <span class=bu>BufferedReader</span> br = <span class=kw>new</span> <span class=bu>BufferedReader</span>(<span class=kw>new</span> <span class=bu>InputStreamReader</span>(<span class=bu>System</span>.<span class=fu>in</span>));</span>
<span id=cb1-18><a href=#cb1-18></a>        <span class=bu>String</span>[] s = br.<span class=fu>readLine</span>().<span class=fu>split</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb1-19><a href=#cb1-19></a>        <span class=dt>int</span> m = <span class=bu>Integer</span>.<span class=fu>parseInt</span>(s[<span class=dv>0</span>]);</span>
<span id=cb1-20><a href=#cb1-20></a>        <span class=dt>int</span> n = <span class=bu>Integer</span>.<span class=fu>parseInt</span>(s[<span class=dv>1</span>]);</span>
<span id=cb1-21><a href=#cb1-21></a>        <span class=dt>int</span> k = <span class=bu>Integer</span>.<span class=fu>parseInt</span>(s[<span class=dv>2</span>]);</span>
<span id=cb1-22><a href=#cb1-22></a>        <span class=dt>int</span>[] test = <span class=kw>null</span>;</span>
<span id=cb1-23><a href=#cb1-23></a>        <span class=dt>int</span> index;</span>
<span id=cb1-24><a href=#cb1-24></a>        <span class=bu>Stack</span>&lt;<span class=bu>Integer</span>&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>&lt;&gt;();</span>
<span id=cb1-25><a href=#cb1-25></a>        <span class=kw>while</span> (k-- &gt; <span class=dv>0</span>) {</span>
<span id=cb1-26><a href=#cb1-26></a>            stack.<span class=fu>clear</span>();</span>
<span id=cb1-27><a href=#cb1-27></a>            test = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb1-28><a href=#cb1-28></a>            s = br.<span class=fu>readLine</span>().<span class=fu>split</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb1-29><a href=#cb1-29></a>            <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb1-30><a href=#cb1-30></a>                test[i] = <span class=bu>Integer</span>.<span class=fu>parseInt</span>(s[i]);</span>
<span id=cb1-31><a href=#cb1-31></a>            }</span>
<span id=cb1-32><a href=#cb1-32></a>            index = <span class=dv>1</span>;</span>
<span id=cb1-33><a href=#cb1-33></a>            <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb1-34><a href=#cb1-34></a>                <span class=kw>while</span> (stack.<span class=fu>isEmpty</span>() || test[i] &gt; stack.<span class=fu>peek</span>()) {</span>
<span id=cb1-35><a href=#cb1-35></a>                    stack.<span class=fu>push</span>(index++);</span>
<span id=cb1-36><a href=#cb1-36></a>                }</span>
<span id=cb1-37><a href=#cb1-37></a>                <span class=kw>if</span> (test[i] != stack.<span class=fu>peek</span>() || stack.<span class=fu>size</span>() &gt; m) {</span>
<span id=cb1-38><a href=#cb1-38></a>                    <span class=kw>break</span>;</span>
<span id=cb1-39><a href=#cb1-39></a>                } <span class=kw>else</span> {</span>
<span id=cb1-40><a href=#cb1-40></a>                    stack.<span class=fu>pop</span>();</span>
<span id=cb1-41><a href=#cb1-41></a>                }</span>
<span id=cb1-42><a href=#cb1-42></a>            }</span>
<span id=cb1-43><a href=#cb1-43></a>            <span class=kw>if</span> (stack.<span class=fu>isEmpty</span>() &amp;&amp; --index == n) {</span>
<span id=cb1-44><a href=#cb1-44></a>                <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=st>&quot;YES&quot;</span>);</span>
<span id=cb1-45><a href=#cb1-45></a>            } <span class=kw>else</span> {</span>
<span id=cb1-46><a href=#cb1-46></a>                <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=st>&quot;NO&quot;</span>);</span>
<span id=cb1-47><a href=#cb1-47></a>            }</span>
<span id=cb1-48><a href=#cb1-48></a>        }</span>
<span id=cb1-49><a href=#cb1-49></a>        br.<span class=fu>close</span>();</span>
<span id=cb1-50><a href=#cb1-50></a>    }</span>
<span id=cb1-51><a href=#cb1-51></a>}</span></code></pre></div><p>还有牛客网牛友在讨论区贴出的代码，更简洁</p><div class=sourceCode id=cb2><pre class="sourceCode c"><code class="sourceCode c"><span id=cb2-1><a href=#cb2-1></a><span class=co>//链接：https://www.nowcoder.com/questionTerminal/597a931ab1794139835ad2991faeab2d</span></span>
<span id=cb2-2><a href=#cb2-2></a><span class=co>//来源：牛客网    北航闫子浩</span></span>
<span id=cb2-3><a href=#cb2-3></a><span class=pp>#include</span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb2-4><a href=#cb2-4></a> </span>
<span id=cb2-5><a href=#cb2-5></a><span class=dt>int</span> main()</span>
<span id=cb2-6><a href=#cb2-6></a>{</span>
<span id=cb2-7><a href=#cb2-7></a>    <span class=dt>int</span> M,N,K,a[<span class=dv>1001</span>],i,j,l;</span>
<span id=cb2-8><a href=#cb2-8></a>    <span class=dt>char</span> c[<span class=dv>2</span>];</span>
<span id=cb2-9><a href=#cb2-9></a>    scanf(<span class=st>&quot;%d %d %d&quot;</span>,&amp;M,&amp;N,&amp;K);<span class=co>//M为栈长，N为数组长，K为组数</span></span>
<span id=cb2-10><a href=#cb2-10></a>    <span class=cf>while</span>(K--){</span>
<span id=cb2-11><a href=#cb2-11></a>        <span class=cf>for</span>(i=j=l=<span class=dv>0</span>;i&lt;N;i++){<span class=co>//l为当前栈长，j为最近入栈的数</span></span>
<span id=cb2-12><a href=#cb2-12></a>            scanf(<span class=st>&quot;%d&quot;</span>,a);</span>
<span id=cb2-13><a href=#cb2-13></a>            <span class=cf>while</span>(l&lt;M&amp;&amp;a[<span class=dv>0</span>]&gt;j)a[++l]=++j;</span>
<span id=cb2-14><a href=#cb2-14></a>            <span class=cf>if</span>((l==M&amp;&amp;a[<span class=dv>0</span>]&gt;j)||a[l--]&lt;a[<span class=dv>0</span>])i=N;</span>
<span id=cb2-15><a href=#cb2-15></a>        }</span>
<span id=cb2-16><a href=#cb2-16></a>        gets(c);</span>
<span id=cb2-17><a href=#cb2-17></a>        printf(i&gt;N?<span class=st>&quot;NO</span><span class=sc>\n</span><span class=st>&quot;</span>:<span class=st>&quot;YES</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb2-18><a href=#cb2-18></a>    }</span>
<span id=cb2-19><a href=#cb2-19></a>}</span></code></pre></div><h5 id=例2>例2</h5><p>已知二叉树中序遍历非递归的栈操作顺序，求该树的后序遍历。</p><p><a href=https://www.nowcoder.com/pat/1/problem/4314>题目链接</a></p><p>方法：模拟栈操作可以获得中序遍历序列，另外注意所有 Push 的节点组成的序列就是这棵树的先序遍历序列。于是问题转为从一棵树的先序遍历序列和中序遍历序列生成这棵树。</p><p>所以可以参考：算法总结.md#树的遍历#由前序和中序遍历重建二叉树</p><div class=sourceCode id=cb3><pre class="sourceCode java"><code class="sourceCode java"><span id=cb3-1><a href=#cb3-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced;</span></span>
<span id=cb3-2><a href=#cb3-2></a></span>
<span id=cb3-3><a href=#cb3-3></a><span class=kw>import</span><span class=im> java.util.*;</span></span>
<span id=cb3-4><a href=#cb3-4></a></span>
<span id=cb3-5><a href=#cb3-5></a><span class=co>/**</span></span>
<span id=cb3-6><a href=#cb3-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb3-7><a href=#cb3-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/2/4</span> <span class=co>14:27</span></span>
<span id=cb3-8><a href=#cb3-8></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/1/</span>problem<span class=co>/4314</span></span>
<span id=cb3-9><a href=#cb3-9></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb3-10><a href=#cb3-10></a> <span class=co>*</span> 中序遍历序列可以模拟出栈操作获得，另外注意所有 Push 的节点组成的序列就是这棵树的先序遍历序列。</span>
<span id=cb3-11><a href=#cb3-11></a> <span class=co>*</span> 于是问题转为从一棵树的先序遍历序列和中序遍历序列生成这棵树。</span>
<span id=cb3-12><a href=#cb3-12></a> <span class=co>*/</span></span>
<span id=cb3-13><a href=#cb3-13></a><span class=kw>public</span> <span class=kw>class</span> Advanced1004_<span class=dv>2</span> {</span>
<span id=cb3-14><a href=#cb3-14></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb3-15><a href=#cb3-15></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb3-16><a href=#cb3-16></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb3-17><a href=#cb3-17></a>        <span class=bu>List</span>&lt;BinaryTree&gt; preOrderList = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;(<span class=dv>8</span>);</span>
<span id=cb3-18><a href=#cb3-18></a>        <span class=bu>List</span>&lt;BinaryTree&gt; inOrderList = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;(<span class=dv>8</span>);</span>
<span id=cb3-19><a href=#cb3-19></a>        <span class=bu>Stack</span>&lt;BinaryTree&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>&lt;&gt;();</span>
<span id=cb3-20><a href=#cb3-20></a></span>
<span id=cb3-21><a href=#cb3-21></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; <span class=dv>2</span> * n; i++) {</span>
<span id=cb3-22><a href=#cb3-22></a>            <span class=bu>String</span> action = scanner.<span class=fu>next</span>();</span>
<span id=cb3-23><a href=#cb3-23></a>            <span class=kw>if</span> (<span class=st>&quot;Push&quot;</span>.<span class=fu>equals</span>(action)) {</span>
<span id=cb3-24><a href=#cb3-24></a>                BinaryTree node = <span class=kw>new</span> <span class=fu>BinaryTree</span>(scanner.<span class=fu>nextInt</span>());</span>
<span id=cb3-25><a href=#cb3-25></a>                stack.<span class=fu>push</span>(node);</span>
<span id=cb3-26><a href=#cb3-26></a>                preOrderList.<span class=fu>add</span>(node);</span>
<span id=cb3-27><a href=#cb3-27></a>            } <span class=kw>else</span> <span class=kw>if</span> (<span class=st>&quot;Pop&quot;</span>.<span class=fu>equals</span>(action)) {</span>
<span id=cb3-28><a href=#cb3-28></a>                inOrderList.<span class=fu>add</span>(stack.<span class=fu>pop</span>());</span>
<span id=cb3-29><a href=#cb3-29></a>            }</span>
<span id=cb3-30><a href=#cb3-30></a>        }</span>
<span id=cb3-31><a href=#cb3-31></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb3-32><a href=#cb3-32></a>        BinaryTree root = <span class=fu>rebuildBinaryTree</span>(preOrderList, inOrderList);</span>
<span id=cb3-33><a href=#cb3-33></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(root.<span class=fu>postOrderTraversal</span>().<span class=fu>trim</span>());</span>
<span id=cb3-34><a href=#cb3-34></a>    }</span>
<span id=cb3-35><a href=#cb3-35></a></span>
<span id=cb3-36><a href=#cb3-36></a>    <span class=co>/**</span></span>
<span id=cb3-37><a href=#cb3-37></a>     <span class=co>*</span> 由前序遍历和中序遍历重建二叉树</span>
<span id=cb3-38><a href=#cb3-38></a>     <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb3-39><a href=#cb3-39></a>     <span class=co>*</span> 参考： https<span class=co>://</span>zhuanlan<span class=co>.</span>zhihu<span class=co>.</span>com<span class=co>/</span>p<span class=co>/37265145</span></span>
<span id=cb3-40><a href=#cb3-40></a>     <span class=co>*/</span></span>
<span id=cb3-41><a href=#cb3-41></a>    <span class=kw>public</span> <span class=dt>static</span> BinaryTree <span class=fu>rebuildBinaryTree</span>(<span class=bu>List</span>&lt;BinaryTree&gt; preOrderList, <span class=bu>List</span>&lt;BinaryTree&gt; inOrderList) {</span>
<span id=cb3-42><a href=#cb3-42></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; preOrderList.<span class=fu>size</span>(); i++) {</span>
<span id=cb3-43><a href=#cb3-43></a>            <span class=kw>if</span> (preOrderList.<span class=fu>get</span>(<span class=dv>0</span>).<span class=fu>equals</span>(inOrderList.<span class=fu>get</span>(i))) {</span>
<span id=cb3-44><a href=#cb3-44></a>                preOrderList.<span class=fu>get</span>(<span class=dv>0</span>).<span class=fu>left</span> = <span class=fu>rebuildBinaryTree</span>(preOrderList.<span class=fu>subList</span>(<span class=dv>1</span>, i + <span class=dv>1</span>), inOrderList.<span class=fu>subList</span>(<span class=dv>0</span>, i));</span>
<span id=cb3-45><a href=#cb3-45></a>                preOrderList.<span class=fu>get</span>(<span class=dv>0</span>).<span class=fu>right</span> = <span class=fu>rebuildBinaryTree</span>(preOrderList.<span class=fu>subList</span>(i + <span class=dv>1</span>, preOrderList.<span class=fu>size</span>()),</span>
<span id=cb3-46><a href=#cb3-46></a>                        inOrderList.<span class=fu>subList</span>(i + <span class=dv>1</span>, inOrderList.<span class=fu>size</span>()));</span>
<span id=cb3-47><a href=#cb3-47></a>                <span class=kw>return</span> preOrderList.<span class=fu>get</span>(<span class=dv>0</span>);</span>
<span id=cb3-48><a href=#cb3-48></a>            }</span>
<span id=cb3-49><a href=#cb3-49></a>        }</span>
<span id=cb3-50><a href=#cb3-50></a>        <span class=kw>return</span> preOrderList.<span class=fu>isEmpty</span>() ? <span class=kw>null</span> : preOrderList.<span class=fu>get</span>(<span class=dv>0</span>);</span>
<span id=cb3-51><a href=#cb3-51></a>    }</span>
<span id=cb3-52><a href=#cb3-52></a></span>
<span id=cb3-53><a href=#cb3-53></a>    <span class=dt>static</span> <span class=kw>class</span> BinaryTree {</span>
<span id=cb3-54><a href=#cb3-54></a>        BinaryTree left;</span>
<span id=cb3-55><a href=#cb3-55></a>        BinaryTree right;</span>
<span id=cb3-56><a href=#cb3-56></a>        <span class=kw>private</span> <span class=dt>int</span> index;</span>
<span id=cb3-57><a href=#cb3-57></a>        <span class=kw>private</span> <span class=bu>UUID</span> uuid = <span class=bu>UUID</span>.<span class=fu>randomUUID</span>();</span>
<span id=cb3-58><a href=#cb3-58></a></span>
<span id=cb3-59><a href=#cb3-59></a>        <span class=kw>public</span> <span class=fu>BinaryTree</span>(<span class=dt>int</span> index) {</span>
<span id=cb3-60><a href=#cb3-60></a>            <span class=kw>this</span>.<span class=fu>index</span> = index;</span>
<span id=cb3-61><a href=#cb3-61></a>        }</span>
<span id=cb3-62><a href=#cb3-62></a></span>
<span id=cb3-63><a href=#cb3-63></a>        <span class=kw>public</span> <span class=bu>String</span> <span class=fu>postOrderTraversal</span>() {</span>
<span id=cb3-64><a href=#cb3-64></a>            <span class=kw>return</span> (left == <span class=kw>null</span> ? <span class=st>&quot;&quot;</span> : left.<span class=fu>postOrderTraversal</span>())</span>
<span id=cb3-65><a href=#cb3-65></a>                    + (right == <span class=kw>null</span> ? <span class=st>&quot;&quot;</span> : right.<span class=fu>postOrderTraversal</span>())</span>
<span id=cb3-66><a href=#cb3-66></a>                    + index + <span class=st>&quot; &quot;</span>;</span>
<span id=cb3-67><a href=#cb3-67></a>        }</span>
<span id=cb3-68><a href=#cb3-68></a></span>
<span id=cb3-69><a href=#cb3-69></a>        <span class=at>@Override</span></span>
<span id=cb3-70><a href=#cb3-70></a>        <span class=kw>public</span> <span class=dt>boolean</span> <span class=fu>equals</span>(<span class=bu>Object</span> object) {</span>
<span id=cb3-71><a href=#cb3-71></a>            <span class=kw>return</span> <span class=kw>this</span>.<span class=fu>uuid</span>.<span class=fu>equals</span>(((BinaryTree)object).<span class=fu>uuid</span>);</span>
<span id=cb3-72><a href=#cb3-72></a>        }</span>
<span id=cb3-73><a href=#cb3-73></a></span>
<span id=cb3-74><a href=#cb3-74></a>        <span class=at>@Override</span></span>
<span id=cb3-75><a href=#cb3-75></a>        <span class=kw>public</span> <span class=bu>String</span> <span class=fu>toString</span>() {</span>
<span id=cb3-76><a href=#cb3-76></a>            <span class=kw>return</span> <span class=kw>this</span>.<span class=fu>index</span>+ <span class=st>&quot;&quot;</span>;</span>
<span id=cb3-77><a href=#cb3-77></a>        }</span>
<span id=cb3-78><a href=#cb3-78></a>    }</span>
<span id=cb3-79><a href=#cb3-79></a>}</span>
<span id=cb3-80><a href=#cb3-80></a></span></code></pre></div><h2 id=树的深度>树的深度</h2><h5 id=例1-1>例1</h5><h6 id=供应商问题>供应商问题</h6><p>供应商，经销商，零售商组成多级供应链。每经过一级，价格提高一定比率。</p><p>给出每个节点的父亲序号，求最高价格，以及最高价格零售商有几个。</p><p><a href=https://www.nowcoder.com/pat/5/problem/4316>供应商问题题目链接</a></p><h6 id=方法1bfs树的广度优先层次遍历>方法1：BFS树的广度优先/层次遍历</h6><div class=sourceCode id=cb4><pre class="sourceCode java"><code class="sourceCode java"><span id=cb4-1><a href=#cb4-1></a> <span class=co>/**</span> </span>
<span id=cb4-2><a href=#cb4-2></a> <span class=co>*</span> 树形结构：层次遍历找最深的点<span class=co>(</span>本代码实现的方式）</span>
<span id=cb4-3><a href=#cb4-3></a> <span class=co>*/</span></span>
<span id=cb4-4><a href=#cb4-4></a><span class=kw>public</span> <span class=kw>class</span> Advanced1003 {</span>
<span id=cb4-5><a href=#cb4-5></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb4-6><a href=#cb4-6></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb4-7><a href=#cb4-7></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb4-8><a href=#cb4-8></a>        <span class=dt>double</span> p = scanner.<span class=fu>nextDouble</span>();</span>
<span id=cb4-9><a href=#cb4-9></a>        <span class=dt>double</span> r = scanner.<span class=fu>nextDouble</span>();</span>
<span id=cb4-10><a href=#cb4-10></a>        Node1003[] nodes = <span class=kw>new</span> Node1003[n];</span>
<span id=cb4-11><a href=#cb4-11></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb4-12><a href=#cb4-12></a>            nodes[i] = <span class=kw>new</span> <span class=fu>Node1003</span>(i);</span>
<span id=cb4-13><a href=#cb4-13></a>        }</span>
<span id=cb4-14><a href=#cb4-14></a>        <span class=co>//构造树</span></span>
<span id=cb4-15><a href=#cb4-15></a>        Node1003 root = <span class=kw>null</span>;</span>
<span id=cb4-16><a href=#cb4-16></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb4-17><a href=#cb4-17></a>            <span class=dt>int</span> father = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb4-18><a href=#cb4-18></a>            <span class=kw>if</span> (father != Const1003.<span class=fu>UNDEFINED</span>) {</span>
<span id=cb4-19><a href=#cb4-19></a>                nodes[father].<span class=fu>children</span>.<span class=fu>add</span>(nodes[i]);</span>
<span id=cb4-20><a href=#cb4-20></a>            } <span class=kw>else</span> {</span>
<span id=cb4-21><a href=#cb4-21></a>                root = nodes[i];</span>
<span id=cb4-22><a href=#cb4-22></a>            }</span>
<span id=cb4-23><a href=#cb4-23></a>        }</span>
<span id=cb4-24><a href=#cb4-24></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb4-25><a href=#cb4-25></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=fu>LFS</span>(root, p, r));</span>
<span id=cb4-26><a href=#cb4-26></a>    }</span>
<span id=cb4-27><a href=#cb4-27></a>    <span class=co>//层次遍历，返回最深层次的价格，以及最深层节点数</span></span>
<span id=cb4-28><a href=#cb4-28></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>String</span> <span class=fu>LFS</span>(Node1003 root, <span class=dt>double</span> price, <span class=dt>double</span> rate) {</span>
<span id=cb4-29><a href=#cb4-29></a>        <span class=dt>double</span> retPrice = <span class=dv>0</span>;</span>
<span id=cb4-30><a href=#cb4-30></a>        <span class=dt>int</span> retNum = -<span class=dv>1</span>;</span>
<span id=cb4-31><a href=#cb4-31></a>        <span class=bu>Queue</span>&lt;Node1003&gt; queue = <span class=kw>new</span> <span class=bu>LinkedList</span>&lt;Node1003&gt;();</span>
<span id=cb4-32><a href=#cb4-32></a>        queue.<span class=fu>add</span>(root);</span>
<span id=cb4-33><a href=#cb4-33></a>        <span class=dt>int</span> levelSize = <span class=dv>1</span>;</span>
<span id=cb4-34><a href=#cb4-34></a>        <span class=dt>int</span> level = <span class=dv>0</span>;</span>
<span id=cb4-35><a href=#cb4-35></a>        <span class=kw>while</span> (!queue.<span class=fu>isEmpty</span>()) {</span>
<span id=cb4-36><a href=#cb4-36></a>            <span class=dt>int</span> count = <span class=dv>0</span>;</span>
<span id=cb4-37><a href=#cb4-37></a>            <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; levelSize; i++) {</span>
<span id=cb4-38><a href=#cb4-38></a>                Node1003 node = queue.<span class=fu>poll</span>();</span>
<span id=cb4-39><a href=#cb4-39></a>                node.<span class=fu>price</span> = price;</span>
<span id=cb4-40><a href=#cb4-40></a>                <span class=kw>if</span> (!node.<span class=fu>children</span>.<span class=fu>isEmpty</span>()) {</span>
<span id=cb4-41><a href=#cb4-41></a>                    queue.<span class=fu>addAll</span>(node.<span class=fu>children</span>);</span>
<span id=cb4-42><a href=#cb4-42></a>                    count += node.<span class=fu>children</span>.<span class=fu>size</span>();</span>
<span id=cb4-43><a href=#cb4-43></a>                }</span>
<span id=cb4-44><a href=#cb4-44></a>            }</span>
<span id=cb4-45><a href=#cb4-45></a>            level++;</span>
<span id=cb4-46><a href=#cb4-46></a>            retPrice = price;</span>
<span id=cb4-47><a href=#cb4-47></a>            retNum = levelSize;</span>
<span id=cb4-48><a href=#cb4-48></a>            price *= <span class=dv>1</span> + rate * <span class=fl>0.</span><span class=bn>01</span>;</span>
<span id=cb4-49><a href=#cb4-49></a>            levelSize = count;</span>
<span id=cb4-50><a href=#cb4-50></a>        }</span>
<span id=cb4-51><a href=#cb4-51></a>        <span class=kw>return</span> <span class=bu>String</span><span class=fu>.format</span>(<span class=st>&quot;</span><span class=sc>%.2f</span><span class=st> </span><span class=sc>%d</span><span class=st>&quot;</span>, retPrice, retNum);</span>
<span id=cb4-52><a href=#cb4-52></a>    }</span>
<span id=cb4-53><a href=#cb4-53></a>}</span>
<span id=cb4-54><a href=#cb4-54></a><span class=co>//节点类</span></span>
<span id=cb4-55><a href=#cb4-55></a><span class=kw>class</span> Node1003 {</span>
<span id=cb4-56><a href=#cb4-56></a>    <span class=dt>int</span> id;</span>
<span id=cb4-57><a href=#cb4-57></a>    <span class=dt>double</span> price;</span>
<span id=cb4-58><a href=#cb4-58></a>    <span class=bu>List</span>&lt;Node1003&gt; children;</span>
<span id=cb4-59><a href=#cb4-59></a></span>
<span id=cb4-60><a href=#cb4-60></a>    <span class=kw>public</span> <span class=fu>Node1003</span>(<span class=dt>int</span> id) {</span>
<span id=cb4-61><a href=#cb4-61></a>        <span class=kw>this</span>.<span class=fu>id</span> = id;</span>
<span id=cb4-62><a href=#cb4-62></a>        <span class=kw>this</span>.<span class=fu>price</span> = Const1003.<span class=fu>UNDEFINED</span>;</span>
<span id=cb4-63><a href=#cb4-63></a>        <span class=kw>this</span>.<span class=fu>children</span> = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb4-64><a href=#cb4-64></a>    }</span>
<span id=cb4-65><a href=#cb4-65></a>}</span>
<span id=cb4-66><a href=#cb4-66></a><span class=co>//常量定义</span></span>
<span id=cb4-67><a href=#cb4-67></a><span class=kw>class</span> Const1003 {</span>
<span id=cb4-68><a href=#cb4-68></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>final</span> <span class=dt>int</span> UNDEFINED = -<span class=dv>1</span>;</span>
<span id=cb4-69><a href=#cb4-69></a>}</span></code></pre></div><h6 id=方法2dfs深度优先遍历>方法2：DFS深度优先遍历</h6><p>类似上一种方法，牛客网牛友提交的讨论代码：</p><div class=sourceCode id=cb5><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb5-1><a href=#cb5-1></a><span class=co>//链接：https://www.nowcoder.com/questionTerminal/24429a3319e4466790e65a647130b118</span></span>
<span id=cb5-2><a href=#cb5-2></a><span class=co>//来源：牛客网</span></span>
<span id=cb5-3><a href=#cb5-3></a></span>
<span id=cb5-4><a href=#cb5-4></a><span class=co>//爆搜dfs</span></span>
<span id=cb5-5><a href=#cb5-5></a><span class=pp>#include </span><span class=im>&lt;bits/stdc++.h&gt;</span></span>
<span id=cb5-6><a href=#cb5-6></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb5-7><a href=#cb5-7></a><span class=kw>typedef</span> <span class=dt>long</span> <span class=dt>long</span> LL;</span>
<span id=cb5-8><a href=#cb5-8></a><span class=at>const</span> <span class=dt>int</span> maxn=<span class=fl>1e5</span>+<span class=dv>5</span>;</span>
<span id=cb5-9><a href=#cb5-9></a><span class=dt>int</span> n,root,anscnt=<span class=dv>0</span>;<span class=dt>double</span> p,r;</span>
<span id=cb5-10><a href=#cb5-10></a>vector&lt;<span class=dt>int</span>&gt; G[maxn];</span>
<span id=cb5-11><a href=#cb5-11></a>map&lt;<span class=dt>int</span>,<span class=dt>int</span>&gt; mp;</span>
<span id=cb5-12><a href=#cb5-12></a>  </span>
<span id=cb5-13><a href=#cb5-13></a><span class=dt>void</span> dfs(<span class=dt>int</span> cur,<span class=dt>int</span> step){</span>
<span id=cb5-14><a href=#cb5-14></a>    <span class=dt>int</span> ok=<span class=dv>1</span>;</span>
<span id=cb5-15><a href=#cb5-15></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>;i&lt;G[cur].size();++i){</span>
<span id=cb5-16><a href=#cb5-16></a>        <span class=dt>int</span> v=G[cur][i];ok=<span class=dv>0</span>;</span>
<span id=cb5-17><a href=#cb5-17></a>        dfs(v,step+<span class=dv>1</span>); </span>
<span id=cb5-18><a href=#cb5-18></a>    }</span>
<span id=cb5-19><a href=#cb5-19></a>    <span class=cf>if</span>(ok){</span>
<span id=cb5-20><a href=#cb5-20></a>        <span class=cf>if</span>(step&gt;anscnt){</span>
<span id=cb5-21><a href=#cb5-21></a>            anscnt=step;++mp[anscnt];<span class=cf>return</span> ;</span>
<span id=cb5-22><a href=#cb5-22></a>        }</span>
<span id=cb5-23><a href=#cb5-23></a>        <span class=cf>if</span>(step==anscnt){</span>
<span id=cb5-24><a href=#cb5-24></a>            ++mp[anscnt];<span class=cf>return</span> ;</span>
<span id=cb5-25><a href=#cb5-25></a>        }</span>
<span id=cb5-26><a href=#cb5-26></a>    }</span>
<span id=cb5-27><a href=#cb5-27></a>}</span>
<span id=cb5-28><a href=#cb5-28></a><span class=dt>int</span> main(){</span>
<span id=cb5-29><a href=#cb5-29></a>    scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> </span><span class=sc>%lf</span><span class=st> </span><span class=sc>%lf</span><span class=st>&quot;</span>,&amp;n,&amp;p,&amp;r);</span>
<span id=cb5-30><a href=#cb5-30></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>,tmp;i&lt;n;++i){</span>
<span id=cb5-31><a href=#cb5-31></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>,&amp;tmp);</span>
<span id=cb5-32><a href=#cb5-32></a>        <span class=cf>if</span>(tmp==-<span class=dv>1</span>){ root=i;<span class=cf>continue</span>;}</span>
<span id=cb5-33><a href=#cb5-33></a>        G[tmp].push_back(i);</span>
<span id=cb5-34><a href=#cb5-34></a>    }</span>
<span id=cb5-35><a href=#cb5-35></a>    dfs(root,<span class=dv>0</span>);    </span>
<span id=cb5-36><a href=#cb5-36></a>    printf(<span class=st>&quot;%.2f </span><span class=sc>%d\n</span><span class=st>&quot;</span>,p*pow(<span class=dv>1</span>+r*<span class=fl>0.01</span>,anscnt),mp[anscnt]);</span>
<span id=cb5-37><a href=#cb5-37></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb5-38><a href=#cb5-38></a>} </span></code></pre></div><h6 id=方法3枚举>方法3：枚举</h6><div class=sourceCode id=cb6><pre class="sourceCode c"><code class="sourceCode c"><span id=cb6-1><a href=#cb6-1></a><span class=co>//牛客网牛友提交的代码</span></span>
<span id=cb6-2><a href=#cb6-2></a><span class=co>//https://www.nowcoder.com/profile/1701726/codeBookDetail?submissionId=10247559</span></span>
<span id=cb6-3><a href=#cb6-3></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb6-4><a href=#cb6-4></a><span class=pp>#include </span><span class=im>&lt;math.h&gt;</span></span>
<span id=cb6-5><a href=#cb6-5></a> </span>
<span id=cb6-6><a href=#cb6-6></a><span class=pp>#define MAXN 100000</span></span>
<span id=cb6-7><a href=#cb6-7></a> </span>
<span id=cb6-8><a href=#cb6-8></a><span class=dt>int</span> main()</span>
<span id=cb6-9><a href=#cb6-9></a>{</span>
<span id=cb6-10><a href=#cb6-10></a>    <span class=dt>int</span> N;</span>
<span id=cb6-11><a href=#cb6-11></a>    <span class=dt>double</span> P, R;</span>
<span id=cb6-12><a href=#cb6-12></a> </span>
<span id=cb6-13><a href=#cb6-13></a>    scanf(<span class=st>&quot;%d&quot;</span>, &amp;N);</span>
<span id=cb6-14><a href=#cb6-14></a>    scanf(<span class=st>&quot;%lf&quot;</span>, &amp;P);</span>
<span id=cb6-15><a href=#cb6-15></a>    scanf(<span class=st>&quot;%lf&quot;</span>, &amp;R);</span>
<span id=cb6-16><a href=#cb6-16></a> </span>
<span id=cb6-17><a href=#cb6-17></a>    <span class=dt>int</span> shit[MAXN];</span>
<span id=cb6-18><a href=#cb6-18></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; N; i++)</span>
<span id=cb6-19><a href=#cb6-19></a>    {</span>
<span id=cb6-20><a href=#cb6-20></a>        scanf(<span class=st>&quot;%d&quot;</span>, &amp;shit[i]);</span>
<span id=cb6-21><a href=#cb6-21></a>    }</span>
<span id=cb6-22><a href=#cb6-22></a> </span>
<span id=cb6-23><a href=#cb6-23></a>    <span class=dt>int</span> maxlevel = <span class=dv>0</span>, templevel = <span class=dv>0</span>, maxnum = <span class=dv>0</span>;</span>
<span id=cb6-24><a href=#cb6-24></a>    <span class=dt>int</span> end;</span>
<span id=cb6-25><a href=#cb6-25></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; N; i++)</span>
<span id=cb6-26><a href=#cb6-26></a>    {</span>
<span id=cb6-27><a href=#cb6-27></a>        end = i;</span>
<span id=cb6-28><a href=#cb6-28></a>        <span class=cf>while</span> (shit[end] != -<span class=dv>1</span>)</span>
<span id=cb6-29><a href=#cb6-29></a>        {</span>
<span id=cb6-30><a href=#cb6-30></a>            templevel++;</span>
<span id=cb6-31><a href=#cb6-31></a>            end = shit[end];</span>
<span id=cb6-32><a href=#cb6-32></a>        }</span>
<span id=cb6-33><a href=#cb6-33></a>        <span class=cf>if</span> (templevel &gt; maxlevel)</span>
<span id=cb6-34><a href=#cb6-34></a>        {</span>
<span id=cb6-35><a href=#cb6-35></a>            maxlevel = templevel;</span>
<span id=cb6-36><a href=#cb6-36></a>            maxnum = <span class=dv>1</span>;</span>
<span id=cb6-37><a href=#cb6-37></a>        }</span>
<span id=cb6-38><a href=#cb6-38></a>        <span class=cf>else</span> <span class=cf>if</span> (templevel == maxlevel)</span>
<span id=cb6-39><a href=#cb6-39></a>            maxnum++;</span>
<span id=cb6-40><a href=#cb6-40></a>        templevel = <span class=dv>0</span>;</span>
<span id=cb6-41><a href=#cb6-41></a>    }</span>
<span id=cb6-42><a href=#cb6-42></a> </span>
<span id=cb6-43><a href=#cb6-43></a> </span>
<span id=cb6-44><a href=#cb6-44></a> </span>
<span id=cb6-45><a href=#cb6-45></a>    <span class=dt>double</span> max;</span>
<span id=cb6-46><a href=#cb6-46></a> </span>
<span id=cb6-47><a href=#cb6-47></a>    max = P * pow(<span class=dv>1</span> + (R / <span class=fl>100.0</span>), maxlevel);</span>
<span id=cb6-48><a href=#cb6-48></a> </span>
<span id=cb6-49><a href=#cb6-49></a>    printf(<span class=st>&quot;%.2f %d&quot;</span>, max, maxnum);</span>
<span id=cb6-50><a href=#cb6-50></a>}</span></code></pre></div><h6 id=方法4枚举优化保存搜索过的答案>方法4：枚举优化：保存搜索过的答案</h6><p>其实是对枚举时的操作做了优化：保存搜索过的内容，下次搜索就不用向下搜索了</p><div class=sourceCode id=cb7><pre class="sourceCode java"><code class="sourceCode java"><span id=cb7-1><a href=#cb7-1></a><span class=co>/**</span></span>
<span id=cb7-2><a href=#cb7-2></a> <span class=co>*</span> 或者使用数组，记录father<span class=co>[]</span>和price<span class=co>[]</span>，level<span class=co>[]</span>信息<span class=co>,</span>循环查找各点的价钱和层次，注意保存一下搜索过的答案<span class=co>(</span>本代码使用的方法）</span>
<span id=cb7-3><a href=#cb7-3></a> <span class=co>*/</span></span>
<span id=cb7-4><a href=#cb7-4></a><span class=kw>public</span> <span class=kw>class</span> Advanced1003_<span class=dv>2</span> {</span>
<span id=cb7-5><a href=#cb7-5></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb7-6><a href=#cb7-6></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb7-7><a href=#cb7-7></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb7-8><a href=#cb7-8></a>        <span class=dt>double</span> p = scanner.<span class=fu>nextDouble</span>();</span>
<span id=cb7-9><a href=#cb7-9></a>        <span class=dt>double</span> r = scanner.<span class=fu>nextDouble</span>();</span>
<span id=cb7-10><a href=#cb7-10></a>        <span class=dt>int</span>[] father = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb7-11><a href=#cb7-11></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb7-12><a href=#cb7-12></a>            father[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb7-13><a href=#cb7-13></a>        }</span>
<span id=cb7-14><a href=#cb7-14></a>        <span class=dt>int</span>[] level = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb7-15><a href=#cb7-15></a>        <span class=dt>int</span> maxLevel = <span class=dv>0</span>;</span>
<span id=cb7-16><a href=#cb7-16></a>        <span class=dt>int</span> maxLevelCount = <span class=dv>0</span>;</span>
<span id=cb7-17><a href=#cb7-17></a>        <span class=dt>int</span> thisLevel = <span class=dv>0</span>;</span>
<span id=cb7-18><a href=#cb7-18></a>        <span class=co>//枚举找最深层，并记录个数</span></span>
<span id=cb7-19><a href=#cb7-19></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb7-20><a href=#cb7-20></a>            thisLevel = <span class=fu>getLevel</span>(father, level, i);</span>
<span id=cb7-21><a href=#cb7-21></a>            <span class=kw>if</span> (thisLevel &gt; maxLevel) {</span>
<span id=cb7-22><a href=#cb7-22></a>                maxLevel = thisLevel;</span>
<span id=cb7-23><a href=#cb7-23></a>                maxLevelCount = <span class=dv>1</span>;</span>
<span id=cb7-24><a href=#cb7-24></a>            } <span class=kw>else</span> <span class=kw>if</span> (thisLevel == maxLevel) {</span>
<span id=cb7-25><a href=#cb7-25></a>                maxLevelCount++;</span>
<span id=cb7-26><a href=#cb7-26></a>            }</span>
<span id=cb7-27><a href=#cb7-27></a>        }</span>
<span id=cb7-28><a href=#cb7-28></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb7-29><a href=#cb7-29></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=bu>String</span><span class=fu>.format</span>(<span class=st>&quot;</span><span class=sc>%.2f</span><span class=st> </span><span class=sc>%d</span><span class=st>&quot;</span>, p * <span class=bu>Math</span>.<span class=fu>pow</span>(<span class=dv>1</span> + r * <span class=fl>0.</span><span class=bn>01</span>, maxLevel - <span class=dv>1</span>), maxLevelCount));</span>
<span id=cb7-30><a href=#cb7-30></a>    }</span>
<span id=cb7-31><a href=#cb7-31></a></span>
<span id=cb7-32><a href=#cb7-32></a>    <span class=co>/**</span></span>
<span id=cb7-33><a href=#cb7-33></a>     <span class=co>*</span> 递归获取level方法(同时保存计算结果，方便重复使用<span class=co>)</span></span>
<span id=cb7-34><a href=#cb7-34></a>     <span class=co>*/</span></span>
<span id=cb7-35><a href=#cb7-35></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>int</span> <span class=fu>getLevel</span>(<span class=dt>int</span>[] father, <span class=dt>int</span>[] level, <span class=dt>int</span> i) {</span>
<span id=cb7-36><a href=#cb7-36></a>        <span class=kw>if</span> (father[i] == -<span class=dv>1</span>) {</span>
<span id=cb7-37><a href=#cb7-37></a>            level[i] = <span class=dv>1</span>;</span>
<span id=cb7-38><a href=#cb7-38></a>        } <span class=kw>else</span> {</span>
<span id=cb7-39><a href=#cb7-39></a>            <span class=kw>if</span> (level[father[i]] != <span class=dv>0</span>) {</span>
<span id=cb7-40><a href=#cb7-40></a>                level[i] = level[father[i]] + <span class=dv>1</span>;</span>
<span id=cb7-41><a href=#cb7-41></a>            } <span class=kw>else</span> {</span>
<span id=cb7-42><a href=#cb7-42></a>                level[i] = <span class=fu>getLevel</span>(father, level, father[i]) + <span class=dv>1</span>;</span>
<span id=cb7-43><a href=#cb7-43></a>            }</span>
<span id=cb7-44><a href=#cb7-44></a>        }</span>
<span id=cb7-45><a href=#cb7-45></a>        <span class=kw>return</span> level[i];</span>
<span id=cb7-46><a href=#cb7-46></a>    }</span>
<span id=cb7-47><a href=#cb7-47></a>}</span></code></pre></div><p>还可以将上面获取level的递归函数改为非递归函数</p><div class=sourceCode id=cb8><pre class="sourceCode c"><code class="sourceCode c"><span id=cb8-1><a href=#cb8-1></a><span class=co>//牛客网牛友提交的代码，不过确实是这个思路</span></span>
<span id=cb8-2><a href=#cb8-2></a><span class=co>//https://www.nowcoder.com/profile/6639688/codeBookDetail?submissionId=6510475</span></span>
<span id=cb8-3><a href=#cb8-3></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb8-4><a href=#cb8-4></a><span class=pp>#include </span><span class=im>&lt;math.h&gt;</span></span>
<span id=cb8-5><a href=#cb8-5></a><span class=dt>int</span> main()</span>
<span id=cb8-6><a href=#cb8-6></a>{</span>
<span id=cb8-7><a href=#cb8-7></a>    <span class=dt>int</span> n, s[<span class=dv>100001</span>], g[<span class=dv>100001</span>] = {<span class=dv>0</span>}, i, t, c, mc = <span class=dv>0</span>, x, m = <span class=dv>0</span>;</span>
<span id=cb8-8><a href=#cb8-8></a>    <span class=dt>double</span> p, r;</span>
<span id=cb8-9><a href=#cb8-9></a>     </span>
<span id=cb8-10><a href=#cb8-10></a>    scanf( <span class=st>&quot;%d&quot;</span>, &amp;n );</span>
<span id=cb8-11><a href=#cb8-11></a>    scanf( <span class=st>&quot;%lf%lf&quot;</span>, &amp;p, &amp;r );</span>
<span id=cb8-12><a href=#cb8-12></a>     </span>
<span id=cb8-13><a href=#cb8-13></a>    <span class=cf>for</span>( i = <span class=dv>0</span>; i &lt; n; i ++ )</span>
<span id=cb8-14><a href=#cb8-14></a>        scanf( <span class=st>&quot;%d&quot;</span>, s + i );</span>
<span id=cb8-15><a href=#cb8-15></a>     </span>
<span id=cb8-16><a href=#cb8-16></a>    <span class=cf>for</span>( i = <span class=dv>0</span>; i &lt; n; i ++ ){</span>
<span id=cb8-17><a href=#cb8-17></a>        <span class=cf>if</span>( !g[i] ){</span>
<span id=cb8-18><a href=#cb8-18></a>            t = i, c = <span class=dv>0</span>;</span>
<span id=cb8-19><a href=#cb8-19></a>             </span>
<span id=cb8-20><a href=#cb8-20></a>            <span class=cf>while</span>( t &gt;= <span class=dv>0</span> &amp;&amp; !g[t] ){</span>
<span id=cb8-21><a href=#cb8-21></a>                c ++;</span>
<span id=cb8-22><a href=#cb8-22></a>                t = s[t];</span>
<span id=cb8-23><a href=#cb8-23></a>            }</span>
<span id=cb8-24><a href=#cb8-24></a>            <span class=cf>if</span>( t &gt;= <span class=dv>0</span> )  <span class=co>//g[t]前面已经求过</span></span>
<span id=cb8-25><a href=#cb8-25></a>                x = g[t] + c;</span>
<span id=cb8-26><a href=#cb8-26></a>            <span class=cf>else</span></span>
<span id=cb8-27><a href=#cb8-27></a>                x = c;</span>
<span id=cb8-28><a href=#cb8-28></a>            <span class=co>//判断当前深度</span></span>
<span id=cb8-29><a href=#cb8-29></a>            <span class=cf>if</span>( x &gt; m )</span>
<span id=cb8-30><a href=#cb8-30></a>                mc = <span class=dv>1</span>, m = x;</span>
<span id=cb8-31><a href=#cb8-31></a>            <span class=cf>else</span> <span class=cf>if</span>( x == m )</span>
<span id=cb8-32><a href=#cb8-32></a>                mc ++;</span>
<span id=cb8-33><a href=#cb8-33></a>             </span>
<span id=cb8-34><a href=#cb8-34></a>            <span class=co>//储存结果</span></span>
<span id=cb8-35><a href=#cb8-35></a>            t = i;</span>
<span id=cb8-36><a href=#cb8-36></a>            <span class=cf>while</span>( t &gt;= <span class=dv>0</span> &amp;&amp; !g[t] ) g[t] = x --, t = s[t];</span>
<span id=cb8-37><a href=#cb8-37></a>        }</span>
<span id=cb8-38><a href=#cb8-38></a>    }</span>
<span id=cb8-39><a href=#cb8-39></a>    printf( <span class=st>&quot;%.2lf %d</span><span class=sc>\n</span><span class=st>&quot;</span>, p * pow( <span class=dv>1</span> + r / <span class=dv>100</span>, m - <span class=fl>1.0</span> ), mc );</span>
<span id=cb8-40><a href=#cb8-40></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb8-41><a href=#cb8-41></a>}</span></code></pre></div><h5 id=例2-1>例2</h5><h6 id=族谱中人最多的一代>族谱中人最多的一代</h6><p>给定某一族谱，找族谱中人最多的一代，以及这一代的人数。</p><p><a href=https://www.nowcoder.com/pat/5/problem/4318>找族谱中人数最多一代的题目链接</a></p><h6 id=方法一穷举>方法一：穷举</h6><div class=sourceCode id=cb9><pre class="sourceCode c"><code class="sourceCode c"><span id=cb9-1><a href=#cb9-1></a>链接：https:<span class=co>//www.nowcoder.com/questionTerminal/324faf954885435ba3b1c9bbd2a7a81e</span></span>
<span id=cb9-2><a href=#cb9-2></a>来源：牛客网YuanYuan的讨论</span>
<span id=cb9-3><a href=#cb9-3></a></span>
<span id=cb9-4><a href=#cb9-4></a><span class=pp>#include </span><span class=im>&lt;stdio.h&gt;</span></span>
<span id=cb9-5><a href=#cb9-5></a><span class=pp>#include </span><span class=im>&lt;malloc.h&gt;</span></span>
<span id=cb9-6><a href=#cb9-6></a> </span>
<span id=cb9-7><a href=#cb9-7></a><span class=dt>int</span> get_gen(<span class=dt>int</span> *family, <span class=dt>int</span> child) {</span>
<span id=cb9-8><a href=#cb9-8></a>    <span class=dt>int</span> gen = <span class=dv>1</span>;</span>
<span id=cb9-9><a href=#cb9-9></a>    <span class=cf>while</span> (family[child] != child) {</span>
<span id=cb9-10><a href=#cb9-10></a>        gen++;</span>
<span id=cb9-11><a href=#cb9-11></a>        child = family[child];</span>
<span id=cb9-12><a href=#cb9-12></a>    }</span>
<span id=cb9-13><a href=#cb9-13></a>    <span class=cf>return</span> gen;</span>
<span id=cb9-14><a href=#cb9-14></a>}</span>
<span id=cb9-15><a href=#cb9-15></a><span class=dt>int</span> main() {</span>
<span id=cb9-16><a href=#cb9-16></a>    <span class=dt>int</span> N, M;</span>
<span id=cb9-17><a href=#cb9-17></a>    scanf(<span class=st>&quot;%d %d&quot;</span>, &amp;N, &amp;M);</span>
<span id=cb9-18><a href=#cb9-18></a>    <span class=dt>int</span> *family = (<span class=dt>int</span> *) malloc((N + <span class=dv>1</span>) * <span class=kw>sizeof</span>(<span class=dt>int</span>));</span>
<span id=cb9-19><a href=#cb9-19></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt;= N; ++i) {</span>
<span id=cb9-20><a href=#cb9-20></a>        family[i] = i;</span>
<span id=cb9-21><a href=#cb9-21></a>    }</span>
<span id=cb9-22><a href=#cb9-22></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; M; ++i) {</span>
<span id=cb9-23><a href=#cb9-23></a>        <span class=dt>int</span> parent;</span>
<span id=cb9-24><a href=#cb9-24></a>        <span class=dt>int</span> child_num;</span>
<span id=cb9-25><a href=#cb9-25></a>        scanf(<span class=st>&quot;%d %d&quot;</span>, &amp;parent, &amp;child_num);</span>
<span id=cb9-26><a href=#cb9-26></a>        <span class=cf>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; child_num; ++j) {</span>
<span id=cb9-27><a href=#cb9-27></a>            <span class=dt>int</span> child;</span>
<span id=cb9-28><a href=#cb9-28></a>            scanf(<span class=st>&quot;%d&quot;</span>, &amp;child);</span>
<span id=cb9-29><a href=#cb9-29></a>            family[child] = parent;</span>
<span id=cb9-30><a href=#cb9-30></a>        }</span>
<span id=cb9-31><a href=#cb9-31></a>    }</span>
<span id=cb9-32><a href=#cb9-32></a> </span>
<span id=cb9-33><a href=#cb9-33></a>    <span class=dt>int</span> *gen = (<span class=dt>int</span> *) malloc((N + <span class=dv>1</span>) * <span class=kw>sizeof</span>(<span class=dt>int</span>));</span>
<span id=cb9-34><a href=#cb9-34></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt;= N; ++i) {</span>
<span id=cb9-35><a href=#cb9-35></a>        gen[i] = <span class=dv>0</span>;</span>
<span id=cb9-36><a href=#cb9-36></a>    }</span>
<span id=cb9-37><a href=#cb9-37></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= N; ++i) {</span>
<span id=cb9-38><a href=#cb9-38></a>        gen[get_gen(family, i)]++;</span>
<span id=cb9-39><a href=#cb9-39></a>    }</span>
<span id=cb9-40><a href=#cb9-40></a>    <span class=dt>int</span> max_gen = <span class=dv>0</span>, max_member = <span class=dv>0</span>;</span>
<span id=cb9-41><a href=#cb9-41></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= N; ++i) {</span>
<span id=cb9-42><a href=#cb9-42></a>        <span class=cf>if</span> (gen[i] &gt; max_member) {</span>
<span id=cb9-43><a href=#cb9-43></a>            max_member = gen[i];</span>
<span id=cb9-44><a href=#cb9-44></a>            max_gen = i;</span>
<span id=cb9-45><a href=#cb9-45></a>        }</span>
<span id=cb9-46><a href=#cb9-46></a>    }</span>
<span id=cb9-47><a href=#cb9-47></a>    printf(<span class=st>&quot;%d %d&quot;</span>, max_member, max_gen);</span>
<span id=cb9-48><a href=#cb9-48></a>    free(family);</span>
<span id=cb9-49><a href=#cb9-49></a>    free(gen);</span>
<span id=cb9-50><a href=#cb9-50></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb9-51><a href=#cb9-51></a>}</span></code></pre></div><h6 id=方法二dfs>方法二：DFS</h6><div class=sourceCode id=cb10><pre class="sourceCode java"><code class="sourceCode java"><span id=cb10-1><a href=#cb10-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb10-2><a href=#cb10-2></a></span>
<span id=cb10-3><a href=#cb10-3></a><span class=kw>import</span><span class=im> java.util.*;</span></span>
<span id=cb10-4><a href=#cb10-4></a></span>
<span id=cb10-5><a href=#cb10-5></a><span class=co>/**</span></span>
<span id=cb10-6><a href=#cb10-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb10-7><a href=#cb10-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/5/27</span> <span class=co>16:34</span></span>
<span id=cb10-8><a href=#cb10-8></a> <span class=co>*</span> <span class=co>@</span>discription<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4318</span></span>
<span id=cb10-9><a href=#cb10-9></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb10-10><a href=#cb10-10></a> <span class=co>*</span> 从树中找节点数最多的那一层，以及那一层的节点数</span>
<span id=cb10-11><a href=#cb10-11></a> <span class=co>*</span> dfs （本代码实现的方法）</span>
<span id=cb10-12><a href=#cb10-12></a> <span class=co>*/</span></span>
<span id=cb10-13><a href=#cb10-13></a><span class=kw>public</span> <span class=kw>class</span> Advanced1005 {</span>
<span id=cb10-14><a href=#cb10-14></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb10-15><a href=#cb10-15></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb10-16><a href=#cb10-16></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb10-17><a href=#cb10-17></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb10-18><a href=#cb10-18></a>        <span class=bu>Map</span>&lt;<span class=bu>String</span>, Node1005&gt; map = <span class=kw>new</span> <span class=bu>HashMap</span>&lt;&gt;(<span class=dv>16</span>);</span>
<span id=cb10-19><a href=#cb10-19></a>        <span class=co>//建map，建树</span></span>
<span id=cb10-20><a href=#cb10-20></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; m; i++) {</span>
<span id=cb10-21><a href=#cb10-21></a>            <span class=bu>String</span> id = scanner.<span class=fu>next</span>();</span>
<span id=cb10-22><a href=#cb10-22></a>            Node1005 father = map.<span class=fu>get</span>(id);</span>
<span id=cb10-23><a href=#cb10-23></a>            <span class=kw>if</span> (father == <span class=kw>null</span>) {</span>
<span id=cb10-24><a href=#cb10-24></a>                father = <span class=kw>new</span> <span class=fu>Node1005</span>(id);</span>
<span id=cb10-25><a href=#cb10-25></a>                map.<span class=fu>put</span>(id, father);</span>
<span id=cb10-26><a href=#cb10-26></a>            }</span>
<span id=cb10-27><a href=#cb10-27></a>            <span class=dt>int</span> childrenNum = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb10-28><a href=#cb10-28></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; childrenNum; j++) {</span>
<span id=cb10-29><a href=#cb10-29></a>                id = scanner.<span class=fu>next</span>();</span>
<span id=cb10-30><a href=#cb10-30></a>                Node1005 child = map.<span class=fu>get</span>(id);</span>
<span id=cb10-31><a href=#cb10-31></a>                <span class=kw>if</span> (child == <span class=kw>null</span>) {</span>
<span id=cb10-32><a href=#cb10-32></a>                    child = <span class=kw>new</span> <span class=fu>Node1005</span>(id);</span>
<span id=cb10-33><a href=#cb10-33></a>                    map.<span class=fu>put</span>(id, child);</span>
<span id=cb10-34><a href=#cb10-34></a>                }</span>
<span id=cb10-35><a href=#cb10-35></a>                father.<span class=fu>children</span>.<span class=fu>add</span>(child);</span>
<span id=cb10-36><a href=#cb10-36></a>            }</span>
<span id=cb10-37><a href=#cb10-37></a>        }</span>
<span id=cb10-38><a href=#cb10-38></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb10-39><a href=#cb10-39></a>        <span class=bu>ArrayList</span>&lt;<span class=bu>Integer</span>&gt; list = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb10-40><a href=#cb10-40></a>        <span class=fu>dfs</span>(map.<span class=fu>get</span>(<span class=st>&quot;01&quot;</span>), <span class=dv>1</span>, list);</span>
<span id=cb10-41><a href=#cb10-41></a>        <span class=dt>int</span> maxCount = <span class=dv>0</span>;</span>
<span id=cb10-42><a href=#cb10-42></a>        <span class=dt>int</span> level = <span class=dv>0</span>;</span>
<span id=cb10-43><a href=#cb10-43></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; list.<span class=fu>size</span>(); i++) {</span>
<span id=cb10-44><a href=#cb10-44></a>            <span class=dt>int</span> count = list.<span class=fu>get</span>(i);</span>
<span id=cb10-45><a href=#cb10-45></a>            <span class=kw>if</span> (count &gt; maxCount) {</span>
<span id=cb10-46><a href=#cb10-46></a>                maxCount = count;</span>
<span id=cb10-47><a href=#cb10-47></a>                level = i + <span class=dv>1</span>;</span>
<span id=cb10-48><a href=#cb10-48></a>            }</span>
<span id=cb10-49><a href=#cb10-49></a>        }</span>
<span id=cb10-50><a href=#cb10-50></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(maxCount + <span class=st>&quot; &quot;</span> + level);</span>
<span id=cb10-51><a href=#cb10-51></a>    }</span>
<span id=cb10-52><a href=#cb10-52></a></span>
<span id=cb10-53><a href=#cb10-53></a>    <span class=co>/**</span></span>
<span id=cb10-54><a href=#cb10-54></a>     <span class=co>*</span> 递归dfs</span>
<span id=cb10-55><a href=#cb10-55></a>     <span class=co>*/</span></span>
<span id=cb10-56><a href=#cb10-56></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>dfs</span>(Node1005 root, <span class=dt>int</span> level, <span class=bu>List</span>&lt;<span class=bu>Integer</span>&gt; list) {</span>
<span id=cb10-57><a href=#cb10-57></a>        <span class=kw>if</span> (list.<span class=fu>size</span>() &gt;= level) {</span>
<span id=cb10-58><a href=#cb10-58></a>            list.<span class=fu>set</span>(level - <span class=dv>1</span>, list.<span class=fu>get</span>(level - <span class=dv>1</span>) + <span class=dv>1</span>);</span>
<span id=cb10-59><a href=#cb10-59></a>        } <span class=kw>else</span> {</span>
<span id=cb10-60><a href=#cb10-60></a>            list.<span class=fu>add</span>(<span class=dv>1</span>);</span>
<span id=cb10-61><a href=#cb10-61></a>        }</span>
<span id=cb10-62><a href=#cb10-62></a>        <span class=kw>for</span> (Node1005 node : root.<span class=fu>children</span>) {</span>
<span id=cb10-63><a href=#cb10-63></a>            <span class=fu>dfs</span>(node, level + <span class=dv>1</span>, list);</span>
<span id=cb10-64><a href=#cb10-64></a>        }</span>
<span id=cb10-65><a href=#cb10-65></a>    }</span>
<span id=cb10-66><a href=#cb10-66></a>}</span>
<span id=cb10-67><a href=#cb10-67></a></span>
<span id=cb10-68><a href=#cb10-68></a><span class=kw>class</span> Node1005 {</span>
<span id=cb10-69><a href=#cb10-69></a>    <span class=bu>String</span> id;</span>
<span id=cb10-70><a href=#cb10-70></a>    <span class=bu>List</span>&lt;Node1005&gt; children;</span>
<span id=cb10-71><a href=#cb10-71></a></span>
<span id=cb10-72><a href=#cb10-72></a>    <span class=kw>public</span> <span class=fu>Node1005</span>(<span class=bu>String</span> id) {</span>
<span id=cb10-73><a href=#cb10-73></a>        <span class=kw>this</span>.<span class=fu>id</span> = id;</span>
<span id=cb10-74><a href=#cb10-74></a>        <span class=kw>this</span>.<span class=fu>children</span> = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb10-75><a href=#cb10-75></a>    }</span>
<span id=cb10-76><a href=#cb10-76></a>}</span></code></pre></div><h6 id=方法三bfs>方法三：BFS</h6><div class=sourceCode id=cb11><pre class="sourceCode java"><code class="sourceCode java"><span id=cb11-1><a href=#cb11-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb11-2><a href=#cb11-2></a></span>
<span id=cb11-3><a href=#cb11-3></a><span class=kw>import</span><span class=im> java.util.*;</span></span>
<span id=cb11-4><a href=#cb11-4></a></span>
<span id=cb11-5><a href=#cb11-5></a><span class=co>/**</span></span>
<span id=cb11-6><a href=#cb11-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb11-7><a href=#cb11-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/5/27</span> <span class=co>16:34</span></span>
<span id=cb11-8><a href=#cb11-8></a> <span class=co>*</span> <span class=co>@</span>discription<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4318</span></span>
<span id=cb11-9><a href=#cb11-9></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb11-10><a href=#cb11-10></a> <span class=co>*</span> 从树中找节点数最多的那一层，以及那一层的节点数</span>
<span id=cb11-11><a href=#cb11-11></a> <span class=co>*</span> bfs （本代码的方法）</span>
<span id=cb11-12><a href=#cb11-12></a> <span class=co>*/</span></span>
<span id=cb11-13><a href=#cb11-13></a><span class=kw>public</span> <span class=kw>class</span> Advanced1005_<span class=dv>2</span> {</span>
<span id=cb11-14><a href=#cb11-14></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb11-15><a href=#cb11-15></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb11-16><a href=#cb11-16></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb11-17><a href=#cb11-17></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb11-18><a href=#cb11-18></a>        <span class=bu>Map</span>&lt;<span class=bu>String</span>, Node1005_<span class=dv>2</span>&gt; map = <span class=kw>new</span> <span class=bu>HashMap</span>&lt;&gt;(<span class=dv>16</span>);</span>
<span id=cb11-19><a href=#cb11-19></a>        <span class=co>//建map，建树</span></span>
<span id=cb11-20><a href=#cb11-20></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; m; i++) {</span>
<span id=cb11-21><a href=#cb11-21></a>            <span class=bu>String</span> id = scanner.<span class=fu>next</span>();</span>
<span id=cb11-22><a href=#cb11-22></a>            Node1005_<span class=dv>2</span> father = map.<span class=fu>get</span>(id);</span>
<span id=cb11-23><a href=#cb11-23></a>            <span class=kw>if</span> (father == <span class=kw>null</span>) {</span>
<span id=cb11-24><a href=#cb11-24></a>                father = <span class=kw>new</span> <span class=fu>Node1005_2</span>(id);</span>
<span id=cb11-25><a href=#cb11-25></a>                map.<span class=fu>put</span>(id, father);</span>
<span id=cb11-26><a href=#cb11-26></a>            }</span>
<span id=cb11-27><a href=#cb11-27></a>            <span class=dt>int</span> childrenNum = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb11-28><a href=#cb11-28></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; childrenNum; j++) {</span>
<span id=cb11-29><a href=#cb11-29></a>                id = scanner.<span class=fu>next</span>();</span>
<span id=cb11-30><a href=#cb11-30></a>                Node1005_<span class=dv>2</span> child = map.<span class=fu>get</span>(id);</span>
<span id=cb11-31><a href=#cb11-31></a>                <span class=kw>if</span> (child == <span class=kw>null</span>) {</span>
<span id=cb11-32><a href=#cb11-32></a>                    child = <span class=kw>new</span> <span class=fu>Node1005_2</span>(id);</span>
<span id=cb11-33><a href=#cb11-33></a>                    map.<span class=fu>put</span>(id, child);</span>
<span id=cb11-34><a href=#cb11-34></a>                }</span>
<span id=cb11-35><a href=#cb11-35></a>                father.<span class=fu>children</span>.<span class=fu>add</span>(child);</span>
<span id=cb11-36><a href=#cb11-36></a>            }</span>
<span id=cb11-37><a href=#cb11-37></a>        }</span>
<span id=cb11-38><a href=#cb11-38></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb11-39><a href=#cb11-39></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=fu>bfs</span>(map.<span class=fu>get</span>(<span class=st>&quot;01&quot;</span>)));</span>
<span id=cb11-40><a href=#cb11-40></a>    }</span>
<span id=cb11-41><a href=#cb11-41></a></span>
<span id=cb11-42><a href=#cb11-42></a>    <span class=co>/**</span></span>
<span id=cb11-43><a href=#cb11-43></a>     <span class=co>*</span> bfs</span>
<span id=cb11-44><a href=#cb11-44></a>     <span class=co>*/</span></span>
<span id=cb11-45><a href=#cb11-45></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>String</span> <span class=fu>bfs</span>(Node1005_<span class=dv>2</span> root) {</span>
<span id=cb11-46><a href=#cb11-46></a>        <span class=dt>int</span> maxLevel = <span class=dv>0</span>;</span>
<span id=cb11-47><a href=#cb11-47></a>        <span class=dt>int</span> maxCount = <span class=dv>0</span>;</span>
<span id=cb11-48><a href=#cb11-48></a>        <span class=bu>Queue</span>&lt;Node1005_<span class=dv>2</span>&gt; queue = <span class=kw>new</span> <span class=bu>LinkedList</span>&lt;&gt;();</span>
<span id=cb11-49><a href=#cb11-49></a>        queue.<span class=fu>add</span>(root);</span>
<span id=cb11-50><a href=#cb11-50></a>        <span class=dt>int</span> level = <span class=dv>1</span>;</span>
<span id=cb11-51><a href=#cb11-51></a>        <span class=dt>int</span> levelSize = queue.<span class=fu>size</span>();</span>
<span id=cb11-52><a href=#cb11-52></a>        <span class=kw>while</span> (levelSize &gt; <span class=dv>0</span>) {</span>
<span id=cb11-53><a href=#cb11-53></a>            <span class=co>//判断当前层节点是否最多</span></span>
<span id=cb11-54><a href=#cb11-54></a>            <span class=kw>if</span> (levelSize &gt; maxCount) {</span>
<span id=cb11-55><a href=#cb11-55></a>                maxCount = levelSize;</span>
<span id=cb11-56><a href=#cb11-56></a>                maxLevel = level;</span>
<span id=cb11-57><a href=#cb11-57></a>            }</span>
<span id=cb11-58><a href=#cb11-58></a>            <span class=co>//下一层节点入队</span></span>
<span id=cb11-59><a href=#cb11-59></a>            <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; levelSize; i++) {</span>
<span id=cb11-60><a href=#cb11-60></a>                Node1005_<span class=dv>2</span> node = queue.<span class=fu>poll</span>();</span>
<span id=cb11-61><a href=#cb11-61></a>                <span class=kw>if</span> (!node.<span class=fu>children</span>.<span class=fu>isEmpty</span>()) {</span>
<span id=cb11-62><a href=#cb11-62></a>                    queue.<span class=fu>addAll</span>(node.<span class=fu>children</span>);</span>
<span id=cb11-63><a href=#cb11-63></a>                }</span>
<span id=cb11-64><a href=#cb11-64></a>            }</span>
<span id=cb11-65><a href=#cb11-65></a>            level++;</span>
<span id=cb11-66><a href=#cb11-66></a>            levelSize = queue.<span class=fu>size</span>();</span>
<span id=cb11-67><a href=#cb11-67></a>        }</span>
<span id=cb11-68><a href=#cb11-68></a>        <span class=bu>String</span> res = maxCount + <span class=st>&quot; &quot;</span> + maxLevel;</span>
<span id=cb11-69><a href=#cb11-69></a>        <span class=kw>return</span> res;</span>
<span id=cb11-70><a href=#cb11-70></a>    }</span>
<span id=cb11-71><a href=#cb11-71></a>}</span>
<span id=cb11-72><a href=#cb11-72></a></span>
<span id=cb11-73><a href=#cb11-73></a><span class=kw>class</span> Node1005_<span class=dv>2</span> {</span>
<span id=cb11-74><a href=#cb11-74></a>    <span class=bu>String</span> id;</span>
<span id=cb11-75><a href=#cb11-75></a>    <span class=bu>List</span>&lt;Node1005_<span class=dv>2</span>&gt; children;</span>
<span id=cb11-76><a href=#cb11-76></a></span>
<span id=cb11-77><a href=#cb11-77></a>    <span class=kw>public</span> <span class=fu>Node1005_2</span>(<span class=bu>String</span> id) {</span>
<span id=cb11-78><a href=#cb11-78></a>        <span class=kw>this</span>.<span class=fu>id</span> = id;</span>
<span id=cb11-79><a href=#cb11-79></a>        <span class=kw>this</span>.<span class=fu>children</span> = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb11-80><a href=#cb11-80></a>    }</span>
<span id=cb11-81><a href=#cb11-81></a>}</span></code></pre></div><h6 id=优化使用二维数组或list数组保存树>优化：使用二维数组或list数组保存树</h6><div class=sourceCode id=cb12><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb12-1><a href=#cb12-1></a><span class=co>//牛客网牛友提交的代码，使用二维数组保存树</span></span>
<span id=cb12-2><a href=#cb12-2></a><span class=co>//https://www.nowcoder.com/profile/4739176/codeBookDetail?submissionId=11875064</span></span>
<span id=cb12-3><a href=#cb12-3></a><span class=pp>#include </span><span class=im>&quot;iostream&quot;</span></span>
<span id=cb12-4><a href=#cb12-4></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb12-5><a href=#cb12-5></a> </span>
<span id=cb12-6><a href=#cb12-6></a><span class=dt>int</span> main(){</span>
<span id=cb12-7><a href=#cb12-7></a>    <span class=dt>int</span> member[<span class=dv>103</span>][<span class=dv>103</span>]; <span class=co>//存放输入成员的下一代成员编号</span></span>
<span id=cb12-8><a href=#cb12-8></a>    <span class=dt>int</span> n,m;</span>
<span id=cb12-9><a href=#cb12-9></a>    cin&gt;&gt;n&gt;&gt;m;</span>
<span id=cb12-10><a href=#cb12-10></a>    <span class=co>//输入</span></span>
<span id=cb12-11><a href=#cb12-11></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>;i&lt;m;i++){</span>
<span id=cb12-12><a href=#cb12-12></a>        <span class=dt>int</span> id,ct;</span>
<span id=cb12-13><a href=#cb12-13></a>        cin&gt;&gt;id&gt;&gt;ct;</span>
<span id=cb12-14><a href=#cb12-14></a>        <span class=cf>for</span>(<span class=dt>int</span> j=<span class=dv>0</span>;j&lt;ct;j++){</span>
<span id=cb12-15><a href=#cb12-15></a>            <span class=dt>int</span> temp;</span>
<span id=cb12-16><a href=#cb12-16></a>            cin&gt;&gt;temp;</span>
<span id=cb12-17><a href=#cb12-17></a>            member[id][<span class=dv>0</span>]++;</span>
<span id=cb12-18><a href=#cb12-18></a>            member[id][member[id][<span class=dv>0</span>]]=temp;</span>
<span id=cb12-19><a href=#cb12-19></a>        }</span>
<span id=cb12-20><a href=#cb12-20></a>    }</span>
<span id=cb12-21><a href=#cb12-21></a>    <span class=co>//最大的数量和该层数</span></span>
<span id=cb12-22><a href=#cb12-22></a>    <span class=dt>int</span> maxcount=<span class=dv>1</span>,maxlayer=<span class=dv>1</span>;</span>
<span id=cb12-23><a href=#cb12-23></a>    <span class=co>//按辈分存放成员，从1开始 ，fmlfree[i][0]用于存放该辈的成员数量</span></span>
<span id=cb12-24><a href=#cb12-24></a>    <span class=dt>int</span> fmltree[<span class=dv>103</span>][<span class=dv>103</span>];</span>
<span id=cb12-25><a href=#cb12-25></a>    fmltree[<span class=dv>1</span>][<span class=dv>0</span>]=<span class=dv>1</span>;</span>
<span id=cb12-26><a href=#cb12-26></a>    fmltree[<span class=dv>1</span>][<span class=dv>1</span>]=<span class=dv>1</span>;</span>
<span id=cb12-27><a href=#cb12-27></a>    <span class=co>//逐层向fmltree添加成员</span></span>
<span id=cb12-28><a href=#cb12-28></a>    <span class=cf>for</span>(<span class=dt>int</span> layer=<span class=dv>1</span>;;layer++){</span>
<span id=cb12-29><a href=#cb12-29></a>        <span class=dt>int</span> count=<span class=dv>0</span>;</span>
<span id=cb12-30><a href=#cb12-30></a>        <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>1</span>;i&lt;=fmltree[layer][<span class=dv>0</span>];i++){</span>
<span id=cb12-31><a href=#cb12-31></a>            fmltree[layer+<span class=dv>1</span>][<span class=dv>0</span>]+=member[fmltree[layer][i]][<span class=dv>0</span>];</span>
<span id=cb12-32><a href=#cb12-32></a>            <span class=cf>for</span>(<span class=dt>int</span> j=<span class=dv>1</span>;j&lt;=member[fmltree[layer][i]][<span class=dv>0</span>];j++){</span>
<span id=cb12-33><a href=#cb12-33></a>                count++;</span>
<span id=cb12-34><a href=#cb12-34></a>                <span class=co>//向下一层添加本层成员的每个下一代</span></span>
<span id=cb12-35><a href=#cb12-35></a>                fmltree[layer+<span class=dv>1</span>][count]=member[fmltree[layer][i]][j];</span>
<span id=cb12-36><a href=#cb12-36></a>            }</span>
<span id=cb12-37><a href=#cb12-37></a>        }</span>
<span id=cb12-38><a href=#cb12-38></a>        <span class=co>//更新maxcount和maxlayer</span></span>
<span id=cb12-39><a href=#cb12-39></a>        <span class=cf>if</span>(count&gt;maxcount){</span>
<span id=cb12-40><a href=#cb12-40></a>            maxcount=count;</span>
<span id=cb12-41><a href=#cb12-41></a>            maxlayer=layer+<span class=dv>1</span>;</span>
<span id=cb12-42><a href=#cb12-42></a>        }</span>
<span id=cb12-43><a href=#cb12-43></a>        <span class=cf>if</span>(count==<span class=dv>0</span>)<span class=cf>break</span>;</span>
<span id=cb12-44><a href=#cb12-44></a>    }</span>
<span id=cb12-45><a href=#cb12-45></a>    <span class=co>//输出</span></span>
<span id=cb12-46><a href=#cb12-46></a>    cout&lt;&lt;maxcount&lt;&lt;<span class=st>&quot; &quot;</span>&lt;&lt;maxlayer;</span>
<span id=cb12-47><a href=#cb12-47></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb12-48><a href=#cb12-48></a>}</span></code></pre></div><h2 id=树的构造>树的构造</h2><h5 id=例1-2>例1</h5><p>已知二叉搜索树的所有输入，要求生成一个二叉搜索树，且为完全二叉树。（生成的二叉搜索树不一定要与输入顺序对应）</p><p>题目最后要求层次遍历输出此树。</p><p><a href=https://www.nowcoder.com/pat/5/problem/4115>题目链接</a></p><h6 id=方法1引用非数组按层次建树中序遍历写值>方法1：（引用/非数组）按层次建树，中序遍历写值</h6><p>（引用/非数组）按层次建树，中序遍历写值</p><div class=sourceCode id=cb13><pre class="sourceCode java"><code class="sourceCode java"><span id=cb13-1><a href=#cb13-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb13-2><a href=#cb13-2></a></span>
<span id=cb13-3><a href=#cb13-3></a><span class=kw>import</span><span class=im> java.util.*;</span></span>
<span id=cb13-4><a href=#cb13-4></a></span>
<span id=cb13-5><a href=#cb13-5></a><span class=co>/**</span></span>
<span id=cb13-6><a href=#cb13-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb13-7><a href=#cb13-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/9</span> <span class=co>21:21</span></span>
<span id=cb13-8><a href=#cb13-8></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4115</span></span>
<span id=cb13-9><a href=#cb13-9></a> <span class=co>*</span> 建立二叉搜索树，且要求为完全二叉树（唯一），然后层次遍历输出</span>
<span id=cb13-10><a href=#cb13-10></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb13-11><a href=#cb13-11></a> <span class=co>*</span> 按层次建树，中序遍历写值，再层次遍历取值</span>
<span id=cb13-12><a href=#cb13-12></a> <span class=co>*/</span></span>
<span id=cb13-13><a href=#cb13-13></a><span class=kw>public</span> <span class=kw>class</span> Advanced1022 {</span>
<span id=cb13-14><a href=#cb13-14></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb13-15><a href=#cb13-15></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb13-16><a href=#cb13-16></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb13-17><a href=#cb13-17></a>        <span class=dt>int</span>[] a = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb13-18><a href=#cb13-18></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb13-19><a href=#cb13-19></a>            a[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb13-20><a href=#cb13-20></a>        }</span>
<span id=cb13-21><a href=#cb13-21></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb13-22><a href=#cb13-22></a></span>
<span id=cb13-23><a href=#cb13-23></a>        <span class=bu>Arrays</span>.<span class=fu>sort</span>(a);</span>
<span id=cb13-24><a href=#cb13-24></a>        <span class=co>//建树</span></span>
<span id=cb13-25><a href=#cb13-25></a>        Node1022 root = <span class=fu>setupCompleteBinaryTree</span>(n);</span>
<span id=cb13-26><a href=#cb13-26></a>        <span class=co>//中序遍历，向树中对应位置写值</span></span>
<span id=cb13-27><a href=#cb13-27></a>        <span class=bu>ArrayList</span>&lt;Node1022&gt; inOrdrList = <span class=fu>inOrderTraversal</span>(root);</span>
<span id=cb13-28><a href=#cb13-28></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb13-29><a href=#cb13-29></a>            inOrdrList.<span class=fu>get</span>(i).<span class=fu>value</span> = a[i];</span>
<span id=cb13-30><a href=#cb13-30></a>        }</span>
<span id=cb13-31><a href=#cb13-31></a>        <span class=co>//层次遍历输出</span></span>
<span id=cb13-32><a href=#cb13-32></a>        <span class=bu>ArrayList</span>&lt;Node1022&gt; levelOrderList = <span class=fu>bfs</span>(root);</span>
<span id=cb13-33><a href=#cb13-33></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb13-34><a href=#cb13-34></a>        <span class=kw>for</span> (Node1022 node : levelOrderList) {</span>
<span id=cb13-35><a href=#cb13-35></a>            sb.<span class=fu>append</span>(node.<span class=fu>value</span>).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb13-36><a href=#cb13-36></a>        }</span>
<span id=cb13-37><a href=#cb13-37></a>        sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb13-38><a href=#cb13-38></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(sb);</span>
<span id=cb13-39><a href=#cb13-39></a>    }</span>
<span id=cb13-40><a href=#cb13-40></a></span>
<span id=cb13-41><a href=#cb13-41></a>    <span class=co>/**</span></span>
<span id=cb13-42><a href=#cb13-42></a>     <span class=co>*</span> 层次建树，初始化一个n个节点的完全二叉树<span class=co>(</span>n<span class=co>&gt;=1)</span></span>
<span id=cb13-43><a href=#cb13-43></a>     <span class=co>*</span> 注意，这个二叉树只建立起结构，没有存入值</span>
<span id=cb13-44><a href=#cb13-44></a>     <span class=co>*/</span></span>
<span id=cb13-45><a href=#cb13-45></a>    <span class=kw>private</span> <span class=dt>static</span> Node1022 <span class=fu>setupCompleteBinaryTree</span>(<span class=dt>int</span> n) {</span>
<span id=cb13-46><a href=#cb13-46></a>        <span class=dt>int</span> count = <span class=dv>0</span>;</span>
<span id=cb13-47><a href=#cb13-47></a>        Node1022 root = <span class=kw>new</span> <span class=fu>Node1022</span>();</span>
<span id=cb13-48><a href=#cb13-48></a>        <span class=bu>Queue</span>&lt;Node1022&gt; queue = <span class=kw>new</span> <span class=bu>LinkedList</span>&lt;&gt;();</span>
<span id=cb13-49><a href=#cb13-49></a>        queue.<span class=fu>add</span>(root);</span>
<span id=cb13-50><a href=#cb13-50></a>        count++;</span>
<span id=cb13-51><a href=#cb13-51></a>        <span class=kw>while</span> (!queue.<span class=fu>isEmpty</span>() &amp;&amp; count &lt; n) {</span>
<span id=cb13-52><a href=#cb13-52></a>            Node1022 node = queue.<span class=fu>poll</span>();</span>
<span id=cb13-53><a href=#cb13-53></a>            <span class=kw>if</span> (count &lt; n) {</span>
<span id=cb13-54><a href=#cb13-54></a>                node.<span class=fu>lChild</span> = <span class=kw>new</span> <span class=fu>Node1022</span>();</span>
<span id=cb13-55><a href=#cb13-55></a>                queue.<span class=fu>add</span>(node.<span class=fu>lChild</span>);</span>
<span id=cb13-56><a href=#cb13-56></a>                count++;</span>
<span id=cb13-57><a href=#cb13-57></a>            }</span>
<span id=cb13-58><a href=#cb13-58></a>            <span class=kw>if</span> (count &lt; n) {</span>
<span id=cb13-59><a href=#cb13-59></a>                node.<span class=fu>rChild</span> = <span class=kw>new</span> <span class=fu>Node1022</span>();</span>
<span id=cb13-60><a href=#cb13-60></a>                queue.<span class=fu>add</span>(node.<span class=fu>rChild</span>);</span>
<span id=cb13-61><a href=#cb13-61></a>                count++;</span>
<span id=cb13-62><a href=#cb13-62></a>            }</span>
<span id=cb13-63><a href=#cb13-63></a>        }</span>
<span id=cb13-64><a href=#cb13-64></a>        <span class=kw>return</span> root;</span>
<span id=cb13-65><a href=#cb13-65></a>    }</span>
<span id=cb13-66><a href=#cb13-66></a></span>
<span id=cb13-67><a href=#cb13-67></a>    <span class=co>/**</span></span>
<span id=cb13-68><a href=#cb13-68></a>     <span class=co>*</span> 中序遍历</span>
<span id=cb13-69><a href=#cb13-69></a>     <span class=co>*/</span></span>
<span id=cb13-70><a href=#cb13-70></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>ArrayList</span>&lt;Node1022&gt; <span class=fu>inOrderTraversal</span>(Node1022 node) {</span>
<span id=cb13-71><a href=#cb13-71></a>        <span class=bu>ArrayList</span>&lt;Node1022&gt; list = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb13-72><a href=#cb13-72></a>        <span class=bu>Stack</span>&lt;Node1022&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>&lt;&gt;();</span>
<span id=cb13-73><a href=#cb13-73></a>        <span class=kw>while</span> (!stack.<span class=fu>isEmpty</span>() || node != <span class=kw>null</span>) {</span>
<span id=cb13-74><a href=#cb13-74></a>            <span class=kw>while</span> (node != <span class=kw>null</span>) {</span>
<span id=cb13-75><a href=#cb13-75></a>                stack.<span class=fu>push</span>(node);</span>
<span id=cb13-76><a href=#cb13-76></a>                node = node.<span class=fu>lChild</span>;</span>
<span id=cb13-77><a href=#cb13-77></a>            }</span>
<span id=cb13-78><a href=#cb13-78></a>            node = stack.<span class=fu>pop</span>();</span>
<span id=cb13-79><a href=#cb13-79></a>            list.<span class=fu>add</span>(node);</span>
<span id=cb13-80><a href=#cb13-80></a>            node = node.<span class=fu>rChild</span>;</span>
<span id=cb13-81><a href=#cb13-81></a>        }</span>
<span id=cb13-82><a href=#cb13-82></a>        <span class=kw>return</span> list;</span>
<span id=cb13-83><a href=#cb13-83></a>    }</span>
<span id=cb13-84><a href=#cb13-84></a></span>
<span id=cb13-85><a href=#cb13-85></a>    <span class=co>/**</span></span>
<span id=cb13-86><a href=#cb13-86></a>     <span class=co>*</span> 层次遍历</span>
<span id=cb13-87><a href=#cb13-87></a>     <span class=co>*/</span></span>
<span id=cb13-88><a href=#cb13-88></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>ArrayList</span>&lt;Node1022&gt; <span class=fu>bfs</span>(Node1022 root) {</span>
<span id=cb13-89><a href=#cb13-89></a>        <span class=bu>ArrayList</span>&lt;Node1022&gt; list = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb13-90><a href=#cb13-90></a>        <span class=bu>Queue</span>&lt;Node1022&gt; queue = <span class=kw>new</span> <span class=bu>LinkedList</span>&lt;&gt;();</span>
<span id=cb13-91><a href=#cb13-91></a>        queue.<span class=fu>add</span>(root);</span>
<span id=cb13-92><a href=#cb13-92></a>        <span class=kw>while</span> (!queue.<span class=fu>isEmpty</span>()) {</span>
<span id=cb13-93><a href=#cb13-93></a>            Node1022 node = queue.<span class=fu>poll</span>();</span>
<span id=cb13-94><a href=#cb13-94></a>            list.<span class=fu>add</span>(node);</span>
<span id=cb13-95><a href=#cb13-95></a>            <span class=kw>if</span> (node.<span class=fu>lChild</span> != <span class=kw>null</span>) {</span>
<span id=cb13-96><a href=#cb13-96></a>                queue.<span class=fu>add</span>(node.<span class=fu>lChild</span>);</span>
<span id=cb13-97><a href=#cb13-97></a>            }</span>
<span id=cb13-98><a href=#cb13-98></a>            <span class=kw>if</span> (node.<span class=fu>rChild</span> != <span class=kw>null</span>) {</span>
<span id=cb13-99><a href=#cb13-99></a>                queue.<span class=fu>add</span>(node.<span class=fu>rChild</span>);</span>
<span id=cb13-100><a href=#cb13-100></a>            }</span>
<span id=cb13-101><a href=#cb13-101></a>        }</span>
<span id=cb13-102><a href=#cb13-102></a>        <span class=kw>return</span> list;</span>
<span id=cb13-103><a href=#cb13-103></a>    }</span>
<span id=cb13-104><a href=#cb13-104></a>}</span>
<span id=cb13-105><a href=#cb13-105></a></span>
<span id=cb13-106><a href=#cb13-106></a><span class=kw>class</span> Node1022 {</span>
<span id=cb13-107><a href=#cb13-107></a>    <span class=dt>int</span> value;</span>
<span id=cb13-108><a href=#cb13-108></a>    Node1022 lChild, rChild;</span>
<span id=cb13-109><a href=#cb13-109></a>}</span></code></pre></div><h6 id=方法2二叉树的数组存储中序递归建树写值>方法2：二叉树的数组存储，中序递归建树写值</h6><div class=sourceCode id=cb14><pre class="sourceCode java"><code class="sourceCode java"><span id=cb14-1><a href=#cb14-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb14-2><a href=#cb14-2></a></span>
<span id=cb14-3><a href=#cb14-3></a><span class=kw>import</span><span class=im> java.util.ArrayList;</span></span>
<span id=cb14-4><a href=#cb14-4></a><span class=kw>import</span><span class=im> java.util.Arrays;</span></span>
<span id=cb14-5><a href=#cb14-5></a><span class=kw>import</span><span class=im> java.util.List;</span></span>
<span id=cb14-6><a href=#cb14-6></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb14-7><a href=#cb14-7></a></span>
<span id=cb14-8><a href=#cb14-8></a><span class=co>/**</span></span>
<span id=cb14-9><a href=#cb14-9></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb14-10><a href=#cb14-10></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/9</span> <span class=co>23:22</span></span>
<span id=cb14-11><a href=#cb14-11></a> <span class=co>*</span> <span class=co>@</span>discription<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4115</span></span>
<span id=cb14-12><a href=#cb14-12></a> <span class=co>*</span> 建立二叉搜索树且为完全二叉树</span>
<span id=cb14-13><a href=#cb14-13></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb14-14><a href=#cb14-14></a> <span class=co>*</span> 考虑二叉树的数组存储结构，数组的优点是随机访问，方便建树。</span>
<span id=cb14-15><a href=#cb14-15></a> <span class=co>*</span> 所有的值都填到数组的前面，则对应的二叉树是完全二叉树。</span>
<span id=cb14-16><a href=#cb14-16></a> <span class=co>*</span> 数组的顺次访问，对应的就是二叉树的层次遍历</span>
<span id=cb14-17><a href=#cb14-17></a> <span class=co>*/</span></span>
<span id=cb14-18><a href=#cb14-18></a><span class=kw>public</span> <span class=kw>class</span> Advanced1022_<span class=dv>2</span> {</span>
<span id=cb14-19><a href=#cb14-19></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb14-20><a href=#cb14-20></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb14-21><a href=#cb14-21></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb14-22><a href=#cb14-22></a>        <span class=dt>int</span>[] a = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb14-23><a href=#cb14-23></a>        <span class=dt>int</span>[] tree = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb14-24><a href=#cb14-24></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb14-25><a href=#cb14-25></a>            a[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb14-26><a href=#cb14-26></a>        }</span>
<span id=cb14-27><a href=#cb14-27></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb14-28><a href=#cb14-28></a>        <span class=bu>Arrays</span>.<span class=fu>sort</span>(a);</span>
<span id=cb14-29><a href=#cb14-29></a>        <span class=co>//中序遍历建树</span></span>
<span id=cb14-30><a href=#cb14-30></a>        <span class=bu>ArrayList</span>&lt;<span class=bu>Integer</span>&gt; inOrderList = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb14-31><a href=#cb14-31></a>        <span class=fu>inOrderTraversal</span>(tree, <span class=dv>0</span>, inOrderList);</span>
<span id=cb14-32><a href=#cb14-32></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb14-33><a href=#cb14-33></a>            tree[inOrderList.<span class=fu>get</span>(i)] = a[i];</span>
<span id=cb14-34><a href=#cb14-34></a>        }</span>
<span id=cb14-35><a href=#cb14-35></a>        <span class=co>//层次遍历输出</span></span>
<span id=cb14-36><a href=#cb14-36></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb14-37><a href=#cb14-37></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb14-38><a href=#cb14-38></a>            sb.<span class=fu>append</span>(tree[i]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb14-39><a href=#cb14-39></a>        }</span>
<span id=cb14-40><a href=#cb14-40></a>        sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb14-41><a href=#cb14-41></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(sb);</span>
<span id=cb14-42><a href=#cb14-42></a>    }</span>
<span id=cb14-43><a href=#cb14-43></a></span>
<span id=cb14-44><a href=#cb14-44></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>inOrderTraversal</span>(<span class=dt>int</span>[] tree, <span class=dt>int</span> node, <span class=bu>List</span>&lt;<span class=bu>Integer</span>&gt; list) {</span>
<span id=cb14-45><a href=#cb14-45></a>        <span class=dt>int</span> lChild = (node &lt;&lt; <span class=dv>1</span>) + <span class=dv>1</span>;</span>
<span id=cb14-46><a href=#cb14-46></a>        <span class=dt>int</span> rChild = lChild + <span class=dv>1</span>;</span>
<span id=cb14-47><a href=#cb14-47></a>        <span class=kw>if</span> (lChild &lt; tree.<span class=fu>length</span>) {</span>
<span id=cb14-48><a href=#cb14-48></a>            <span class=fu>inOrderTraversal</span>(tree, lChild, list);</span>
<span id=cb14-49><a href=#cb14-49></a>        }</span>
<span id=cb14-50><a href=#cb14-50></a>        list.<span class=fu>add</span>(node);</span>
<span id=cb14-51><a href=#cb14-51></a>        <span class=kw>if</span> (rChild &lt; tree.<span class=fu>length</span>) {</span>
<span id=cb14-52><a href=#cb14-52></a>            <span class=fu>inOrderTraversal</span>(tree, rChild, list);</span>
<span id=cb14-53><a href=#cb14-53></a>        }</span>
<span id=cb14-54><a href=#cb14-54></a>    }</span>
<span id=cb14-55><a href=#cb14-55></a>}</span></code></pre></div><h2 id=最短路径问题>最短路径问题</h2><h3 id=路径最短累计值最小最大平均值最小最大>路径最短，累计值最小/最大，平均值最小最大</h3><h5 id=例1-3>例1</h5><h6 id=公共自行车问题>公共自行车问题</h6><p>从源点出发到某点去摆放自行车，经过路径节点上的自行车都要调整为半满。 要找最短路径； 若存在多条最短路径，则选出发前带的自行车最少的路径； 若还是存在多条路径，则选带回去最少自行车的路径。</p><p><a href=https://www.nowcoder.com/pat/5/problem/4324>公共自行车问题题目链接</a></p><h6 id=方法1穷举>方法1：穷举</h6><h6 id=方法2dfs回溯>方法2：DFS回溯</h6><p>不是我写的，看人家思路就好</p><div class=sourceCode id=cb15><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb15-1><a href=#cb15-1></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb15-2><a href=#cb15-2></a><span class=pp>#include </span><span class=im>&lt;vector&gt;</span></span>
<span id=cb15-3><a href=#cb15-3></a><span class=pp>#include </span><span class=im>&lt;limits.h&gt;</span></span>
<span id=cb15-4><a href=#cb15-4></a> </span>
<span id=cb15-5><a href=#cb15-5></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb15-6><a href=#cb15-6></a> </span>
<span id=cb15-7><a href=#cb15-7></a><span class=dt>void</span> dfs(<span class=dt>int</span> start, <span class=dt>int</span> index, <span class=dt>int</span> end);</span>
<span id=cb15-8><a href=#cb15-8></a> </span>
<span id=cb15-9><a href=#cb15-9></a><span class=dt>int</span> cmax, N, sp, M;</span>
<span id=cb15-10><a href=#cb15-10></a><span class=dt>int</span> costTimes, outBikes, inBikes;</span>
<span id=cb15-11><a href=#cb15-11></a><span class=dt>int</span> resultTimes = INT_MAX;</span>
<span id=cb15-12><a href=#cb15-12></a><span class=dt>int</span> resultOutBikes, resultInBikes;</span>
<span id=cb15-13><a href=#cb15-13></a>vector&lt;<span class=dt>int</span>&gt; bikes, path, resultPath;</span>
<span id=cb15-14><a href=#cb15-14></a>vector&lt;vector&lt;<span class=dt>int</span>&gt; &gt; times;</span>
<span id=cb15-15><a href=#cb15-15></a>vector&lt;<span class=dt>bool</span>&gt; visited;</span>
<span id=cb15-16><a href=#cb15-16></a> </span>
<span id=cb15-17><a href=#cb15-17></a><span class=dt>int</span> main()</span>
<span id=cb15-18><a href=#cb15-18></a>{</span>
<span id=cb15-19><a href=#cb15-19></a>    ios::sync_with_stdio(<span class=kw>false</span>);</span>
<span id=cb15-20><a href=#cb15-20></a>    <span class=co>// 输入数据</span></span>
<span id=cb15-21><a href=#cb15-21></a>    cin &gt;&gt; cmax &gt;&gt; N &gt;&gt; sp &gt;&gt; M;</span>
<span id=cb15-22><a href=#cb15-22></a>    bikes.resize(N+<span class=dv>1</span>, <span class=dv>0</span>);</span>
<span id=cb15-23><a href=#cb15-23></a>    visited.resize(N+<span class=dv>1</span>, <span class=kw>false</span>);</span>
<span id=cb15-24><a href=#cb15-24></a>    times.resize(N+<span class=dv>1</span>, vector&lt;<span class=dt>int</span>&gt;(N+<span class=dv>1</span>, <span class=dv>0</span>));</span>
<span id=cb15-25><a href=#cb15-25></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>1</span>; i&lt;=N; i++) {</span>
<span id=cb15-26><a href=#cb15-26></a>        cin &gt;&gt; bikes[i];</span>
<span id=cb15-27><a href=#cb15-27></a>    }</span>
<span id=cb15-28><a href=#cb15-28></a>    <span class=dt>int</span> m, n, dist;</span>
<span id=cb15-29><a href=#cb15-29></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>; i&lt;M; i++) {</span>
<span id=cb15-30><a href=#cb15-30></a>        cin &gt;&gt; m &gt;&gt; n &gt;&gt; dist;</span>
<span id=cb15-31><a href=#cb15-31></a>        times[m][n] = dist;</span>
<span id=cb15-32><a href=#cb15-32></a>        times[n][m] = dist;</span>
<span id=cb15-33><a href=#cb15-33></a>    }</span>
<span id=cb15-34><a href=#cb15-34></a> </span>
<span id=cb15-35><a href=#cb15-35></a>    <span class=co>// 深搜并输出结果</span></span>
<span id=cb15-36><a href=#cb15-36></a>    dfs(<span class=dv>0</span>, <span class=dv>0</span>, sp);</span>
<span id=cb15-37><a href=#cb15-37></a>    cout &lt;&lt; resultOutBikes &lt;&lt; <span class=st>&quot; 0&quot;</span>;</span>
<span id=cb15-38><a href=#cb15-38></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>1</span>; i&lt;resultPath.size(); i++) {</span>
<span id=cb15-39><a href=#cb15-39></a>        cout &lt;&lt; <span class=st>&quot;-&gt;&quot;</span> &lt;&lt; resultPath[i];</span>
<span id=cb15-40><a href=#cb15-40></a>    }</span>
<span id=cb15-41><a href=#cb15-41></a>    cout &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; resultInBikes;</span>
<span id=cb15-42><a href=#cb15-42></a> </span>
<span id=cb15-43><a href=#cb15-43></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb15-44><a href=#cb15-44></a>}</span>
<span id=cb15-45><a href=#cb15-45></a> </span>
<span id=cb15-46><a href=#cb15-46></a><span class=dt>void</span> dfs(<span class=dt>int</span> start, <span class=dt>int</span> index, <span class=dt>int</span> end)</span>
<span id=cb15-47><a href=#cb15-47></a>{</span>
<span id=cb15-48><a href=#cb15-48></a>    <span class=co>// 访问</span></span>
<span id=cb15-49><a href=#cb15-49></a>    visited[index] = <span class=kw>true</span>;</span>
<span id=cb15-50><a href=#cb15-50></a>    path.push_back(index);</span>
<span id=cb15-51><a href=#cb15-51></a>    costTimes += times[start][index];</span>
<span id=cb15-52><a href=#cb15-52></a> </span>
<span id=cb15-53><a href=#cb15-53></a>    <span class=co>// 处理</span></span>
<span id=cb15-54><a href=#cb15-54></a>    <span class=cf>if</span>(index == end) {</span>
<span id=cb15-55><a href=#cb15-55></a>        <span class=co>// 计算这条路上带去的车和带回的车</span></span>
<span id=cb15-56><a href=#cb15-56></a>        inBikes = <span class=dv>0</span>, outBikes = <span class=dv>0</span>;</span>
<span id=cb15-57><a href=#cb15-57></a>        <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>1</span>; i&lt;path.size(); i++) {</span>
<span id=cb15-58><a href=#cb15-58></a>            <span class=cf>if</span>(bikes[path[i]] &gt; cmax/<span class=dv>2</span>) {</span>
<span id=cb15-59><a href=#cb15-59></a>                inBikes += bikes[path[i]] -cmax/<span class=dv>2</span>;</span>
<span id=cb15-60><a href=#cb15-60></a>            } <span class=cf>else</span> {</span>
<span id=cb15-61><a href=#cb15-61></a>                <span class=cf>if</span>((cmax/<span class=dv>2</span> - bikes[path[i]]) &lt; inBikes) {</span>
<span id=cb15-62><a href=#cb15-62></a>                    inBikes -= (cmax/<span class=dv>2</span> - bikes[path[i]]);</span>
<span id=cb15-63><a href=#cb15-63></a>                } <span class=cf>else</span> {</span>
<span id=cb15-64><a href=#cb15-64></a>                    outBikes += (cmax/<span class=dv>2</span> - bikes[path[i]]) - inBikes;</span>
<span id=cb15-65><a href=#cb15-65></a>                    inBikes = <span class=dv>0</span>;</span>
<span id=cb15-66><a href=#cb15-66></a>                }</span>
<span id=cb15-67><a href=#cb15-67></a>            }</span>
<span id=cb15-68><a href=#cb15-68></a>        }</span>
<span id=cb15-69><a href=#cb15-69></a>        <span class=co>// 判断这条路是否更好</span></span>
<span id=cb15-70><a href=#cb15-70></a>        <span class=cf>if</span>(costTimes != resultTimes) {</span>
<span id=cb15-71><a href=#cb15-71></a>            <span class=cf>if</span>(costTimes &lt; resultTimes) {</span>
<span id=cb15-72><a href=#cb15-72></a>                resultTimes = costTimes;</span>
<span id=cb15-73><a href=#cb15-73></a>                resultPath = path;</span>
<span id=cb15-74><a href=#cb15-74></a>                resultOutBikes = outBikes;</span>
<span id=cb15-75><a href=#cb15-75></a>                resultInBikes = inBikes;</span>
<span id=cb15-76><a href=#cb15-76></a>            }</span>
<span id=cb15-77><a href=#cb15-77></a>        } <span class=cf>else</span> <span class=cf>if</span>(outBikes != resultOutBikes) {</span>
<span id=cb15-78><a href=#cb15-78></a>            <span class=cf>if</span>(outBikes &lt; resultOutBikes) {</span>
<span id=cb15-79><a href=#cb15-79></a>                resultPath = path;</span>
<span id=cb15-80><a href=#cb15-80></a>                resultOutBikes = outBikes;</span>
<span id=cb15-81><a href=#cb15-81></a>                resultInBikes = inBikes;</span>
<span id=cb15-82><a href=#cb15-82></a>            }</span>
<span id=cb15-83><a href=#cb15-83></a>        } <span class=cf>else</span> <span class=cf>if</span>(inBikes &lt; resultInBikes) {</span>
<span id=cb15-84><a href=#cb15-84></a>            resultPath = path;</span>
<span id=cb15-85><a href=#cb15-85></a>            resultOutBikes = outBikes;</span>
<span id=cb15-86><a href=#cb15-86></a>            resultInBikes = inBikes;</span>
<span id=cb15-87><a href=#cb15-87></a>        }</span>
<span id=cb15-88><a href=#cb15-88></a>    } <span class=cf>else</span> {</span>
<span id=cb15-89><a href=#cb15-89></a>        <span class=co>// 递归</span></span>
<span id=cb15-90><a href=#cb15-90></a>        <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>1</span>; i&lt;=N; i++) {</span>
<span id=cb15-91><a href=#cb15-91></a>            <span class=cf>if</span>(times[index][i] != <span class=dv>0</span> &amp;&amp; !visited[i]) {</span>
<span id=cb15-92><a href=#cb15-92></a>                dfs(index, i, end);</span>
<span id=cb15-93><a href=#cb15-93></a>            }</span>
<span id=cb15-94><a href=#cb15-94></a>        }</span>
<span id=cb15-95><a href=#cb15-95></a>    }</span>
<span id=cb15-96><a href=#cb15-96></a> </span>
<span id=cb15-97><a href=#cb15-97></a>    <span class=co>// 回溯</span></span>
<span id=cb15-98><a href=#cb15-98></a>    visited[index] = <span class=kw>false</span>;</span>
<span id=cb15-99><a href=#cb15-99></a>    path.pop_back();</span>
<span id=cb15-100><a href=#cb15-100></a>    costTimes -= times[start][index];</span>
<span id=cb15-101><a href=#cb15-101></a>}</span></code></pre></div><p>另有人写的，有点像dfs的非递归形式，也可能算动态规划：</p><div class=sourceCode id=cb16><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb16-1><a href=#cb16-1></a><span class=co>//https://www.nowcoder.com/profile/156003592/codeBookDetail?submissionId=54952529</span></span>
<span id=cb16-2><a href=#cb16-2></a><span class=pp>#include </span><span class=im>&lt;cstdio&gt;</span></span>
<span id=cb16-3><a href=#cb16-3></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb16-4><a href=#cb16-4></a><span class=pp>#include </span><span class=im>&lt;queue&gt;</span></span>
<span id=cb16-5><a href=#cb16-5></a><span class=pp>#include </span><span class=im>&lt;utility&gt;</span></span>
<span id=cb16-6><a href=#cb16-6></a> </span>
<span id=cb16-7><a href=#cb16-7></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb16-8><a href=#cb16-8></a> </span>
<span id=cb16-9><a href=#cb16-9></a><span class=pp>#define INF </span><span class=bn>0x3f3f3f3f</span></span>
<span id=cb16-10><a href=#cb16-10></a> </span>
<span id=cb16-11><a href=#cb16-11></a><span class=kw>struct</span> Edge{</span>
<span id=cb16-12><a href=#cb16-12></a>    <span class=dt>int</span> from;</span>
<span id=cb16-13><a href=#cb16-13></a>    <span class=dt>int</span> to;</span>
<span id=cb16-14><a href=#cb16-14></a>    <span class=dt>int</span> cost;</span>
<span id=cb16-15><a href=#cb16-15></a>    vector&lt;<span class=dt>int</span>&gt; trace;</span>
<span id=cb16-16><a href=#cb16-16></a> </span>
<span id=cb16-17><a href=#cb16-17></a>    Edge(<span class=dt>int</span> <span class=va>from_</span>, <span class=dt>int</span> <span class=va>to_</span>, <span class=dt>int</span> <span class=va>cost_</span>):</span>
<span id=cb16-18><a href=#cb16-18></a>        from(<span class=va>from_</span>), to(<span class=va>to_</span>), cost(<span class=va>cost_</span>), trace(){}</span>
<span id=cb16-19><a href=#cb16-19></a>};</span>
<span id=cb16-20><a href=#cb16-20></a> </span>
<span id=cb16-21><a href=#cb16-21></a><span class=dt>bool</span> <span class=kw>operator</span> &gt;(<span class=at>const</span> Edge&amp; lhs, <span class=at>const</span> Edge&amp; rhs){</span>
<span id=cb16-22><a href=#cb16-22></a>    <span class=cf>return</span> lhs.cost &gt; rhs.cost;</span>
<span id=cb16-23><a href=#cb16-23></a>}</span>
<span id=cb16-24><a href=#cb16-24></a> </span>
<span id=cb16-25><a href=#cb16-25></a><span class=dt>int</span> main(){</span>
<span id=cb16-26><a href=#cb16-26></a>    <span class=dt>int</span> C_max, N, sp, M;</span>
<span id=cb16-27><a href=#cb16-27></a>    cin &gt;&gt; C_max &gt;&gt; N &gt;&gt; sp &gt;&gt; M;</span>
<span id=cb16-28><a href=#cb16-28></a>    <span class=dt>int</span> perfect = C_max / <span class=dv>2</span>;</span>
<span id=cb16-29><a href=#cb16-29></a>    vector&lt;<span class=dt>int</span>&gt; ss(N + <span class=dv>1</span>);</span>
<span id=cb16-30><a href=#cb16-30></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= N; i++){</span>
<span id=cb16-31><a href=#cb16-31></a>        cin &gt;&gt; ss[i];</span>
<span id=cb16-32><a href=#cb16-32></a>    }</span>
<span id=cb16-33><a href=#cb16-33></a>    vector&lt;vector&lt;Edge&gt;&gt; graph(N + <span class=dv>1</span>);</span>
<span id=cb16-34><a href=#cb16-34></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; M; i++){</span>
<span id=cb16-35><a href=#cb16-35></a>        <span class=dt>int</span> s1, s2, t;</span>
<span id=cb16-36><a href=#cb16-36></a>        cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; t;</span>
<span id=cb16-37><a href=#cb16-37></a>        graph[s1].emplace_back(s1, s2, t);</span>
<span id=cb16-38><a href=#cb16-38></a>        graph[s2].emplace_back(s2, s1, t);</span>
<span id=cb16-39><a href=#cb16-39></a>    }</span>
<span id=cb16-40><a href=#cb16-40></a>    vector&lt;<span class=dt>int</span>&gt; dist(N + <span class=dv>1</span>, INF);</span>
<span id=cb16-41><a href=#cb16-41></a>    priority_queue&lt;Edge, deque&lt;Edge&gt;, greater&lt;Edge&gt;&gt; pq;</span>
<span id=cb16-42><a href=#cb16-42></a>    vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt; paths;</span>
<span id=cb16-43><a href=#cb16-43></a>    Edge e(<span class=dv>0</span>, <span class=dv>0</span>, <span class=dv>0</span>);</span>
<span id=cb16-44><a href=#cb16-44></a>    e.trace.push_back(<span class=dv>0</span>);</span>
<span id=cb16-45><a href=#cb16-45></a>    pq.push(e);</span>
<span id=cb16-46><a href=#cb16-46></a>    <span class=cf>while</span>(!pq.empty()){</span>
<span id=cb16-47><a href=#cb16-47></a>        Edge e = pq.top(); pq.pop();</span>
<span id=cb16-48><a href=#cb16-48></a>        <span class=cf>if</span>(e.cost &gt; dist[sp]) <span class=cf>break</span>;</span>
<span id=cb16-49><a href=#cb16-49></a>        <span class=cf>if</span>(e.cost &gt; dist[e.to]) <span class=cf>continue</span>;</span>
<span id=cb16-50><a href=#cb16-50></a>        dist[e.to] = e.cost;</span>
<span id=cb16-51><a href=#cb16-51></a>        <span class=cf>if</span>(e.to == sp){</span>
<span id=cb16-52><a href=#cb16-52></a>            paths.push_back(e.trace);</span>
<span id=cb16-53><a href=#cb16-53></a>        }</span>
<span id=cb16-54><a href=#cb16-54></a>        <span class=cf>for</span>(<span class=kw>auto</span>&amp; ne : graph[e.to]){</span>
<span id=cb16-55><a href=#cb16-55></a>            <span class=dt>int</span> ncost = e.cost + ne.cost;</span>
<span id=cb16-56><a href=#cb16-56></a>            <span class=cf>if</span>(ncost &gt; dist[ne.to]) <span class=cf>continue</span>;</span>
<span id=cb16-57><a href=#cb16-57></a>            Edge ee(e.from, ne.to, ncost);</span>
<span id=cb16-58><a href=#cb16-58></a>            ee.trace = e.trace;</span>
<span id=cb16-59><a href=#cb16-59></a>            ee.trace.push_back(ne.to);</span>
<span id=cb16-60><a href=#cb16-60></a>            pq.push(ee);</span>
<span id=cb16-61><a href=#cb16-61></a>        }</span>
<span id=cb16-62><a href=#cb16-62></a>    }</span>
<span id=cb16-63><a href=#cb16-63></a>    pair&lt;<span class=dt>int</span>, <span class=dt>int</span>&gt; opt(INF, INF);</span>
<span id=cb16-64><a href=#cb16-64></a>    <span class=dt>int</span> idx = -<span class=dv>1</span>;</span>
<span id=cb16-65><a href=#cb16-65></a>    <span class=dt>int</span> ans_sent, ans_back;</span>
<span id=cb16-66><a href=#cb16-66></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; (<span class=dt>int</span>)paths.size(); i++){</span>
<span id=cb16-67><a href=#cb16-67></a>        <span class=dt>int</span> current = <span class=dv>0</span>;</span>
<span id=cb16-68><a href=#cb16-68></a>        <span class=dt>int</span> tot = <span class=dv>0</span>;</span>
<span id=cb16-69><a href=#cb16-69></a>        <span class=kw>auto</span>&amp; path = paths[i];</span>
<span id=cb16-70><a href=#cb16-70></a>        <span class=cf>for</span>(<span class=dt>int</span> j = <span class=dv>1</span>; j &lt; (<span class=dt>int</span>)path.size(); j++){</span>
<span id=cb16-71><a href=#cb16-71></a>            <span class=dt>int</span> d = ss[path[j]] - perfect;</span>
<span id=cb16-72><a href=#cb16-72></a>            current += d;</span>
<span id=cb16-73><a href=#cb16-73></a>            <span class=cf>if</span>(current &lt; <span class=dv>0</span>){</span>
<span id=cb16-74><a href=#cb16-74></a>                tot += -current;</span>
<span id=cb16-75><a href=#cb16-75></a>                current = <span class=dv>0</span>;</span>
<span id=cb16-76><a href=#cb16-76></a>            }</span>
<span id=cb16-77><a href=#cb16-77></a>        }</span>
<span id=cb16-78><a href=#cb16-78></a>        <span class=cf>if</span>(make_pair(tot, current) &lt; opt){</span>
<span id=cb16-79><a href=#cb16-79></a>            opt = make_pair(tot, current);</span>
<span id=cb16-80><a href=#cb16-80></a>            idx = i;</span>
<span id=cb16-81><a href=#cb16-81></a>            ans_sent = tot;</span>
<span id=cb16-82><a href=#cb16-82></a>            ans_back = current;</span>
<span id=cb16-83><a href=#cb16-83></a>        }</span>
<span id=cb16-84><a href=#cb16-84></a>    }</span>
<span id=cb16-85><a href=#cb16-85></a>    printf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> &quot;</span>, ans_sent);</span>
<span id=cb16-86><a href=#cb16-86></a>    <span class=cf>for</span>(<span class=dt>int</span> v : paths[idx]){</span>
<span id=cb16-87><a href=#cb16-87></a>        <span class=cf>if</span>(v != <span class=dv>0</span>) printf(<span class=st>&quot;-&gt;&quot;</span>);</span>
<span id=cb16-88><a href=#cb16-88></a>        printf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>, v);</span>
<span id=cb16-89><a href=#cb16-89></a>    }</span>
<span id=cb16-90><a href=#cb16-90></a>    printf(<span class=st>&quot; </span><span class=sc>%d</span><span class=st>&quot;</span>, ans_back);</span>
<span id=cb16-91><a href=#cb16-91></a>    puts(<span class=st>&quot;&quot;</span>);</span>
<span id=cb16-92><a href=#cb16-92></a>}</span></code></pre></div><h6 id=方法3保存各种状态dijkstra算法>方法3：保存各种状态Dijkstra算法</h6><p><strong>主要的状态</strong>：</p><p>bikes[]保存各点需要调整的自行车数</p><p>D[]保存从源点到各点的最短距离</p><p>need[]保存各点需要的自行车数</p><p>back[]保存各点需要带回的自行车数</p><p>visited[]保存各点是否已找到最短距离</p><p>trace[]记录到各点最短路径上，该点的前一个节点号</p><p><strong>过程</strong>：</p><p>从源点开始，</p><p>根据D、need、back选最合适的点加入到已visited集，并更新未visited点的D、need、back、trace</p><p>重复上一步的步骤，直到点都加入visited集。</p><p>（注意：更新need、back值时要根据路径上前一点累计计算）</p><p><strong>过程例子</strong>：</p><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200518215729206.png alt><figcaption>image-20200518215729206</figcaption></figure><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200518215701043.png alt><figcaption>image-20200518215701043</figcaption></figure><p>代码：</p><div class=sourceCode id=cb17><pre class="sourceCode java"><code class="sourceCode java"><span id=cb17-1><a href=#cb17-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb17-2><a href=#cb17-2></a></span>
<span id=cb17-3><a href=#cb17-3></a><span class=kw>import</span><span class=im> java.util.*;</span></span>
<span id=cb17-4><a href=#cb17-4></a></span>
<span id=cb17-5><a href=#cb17-5></a><span class=co>/**</span></span>
<span id=cb17-6><a href=#cb17-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb17-7><a href=#cb17-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/3/17</span> <span class=co>17:30</span></span>
<span id=cb17-8><a href=#cb17-8></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4324</span></span>
<span id=cb17-9><a href=#cb17-9></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb17-10><a href=#cb17-10></a> <span class=co>*</span> 图上起点到终点路径的距离最短，要求子路径距离最短</span>
<span id=cb17-11><a href=#cb17-11></a> <span class=co>*</span> 在各段最短子路径上，要求运去<span class=co>/</span>need的车最少（每段累加）</span>
<span id=cb17-12><a href=#cb17-12></a> <span class=co>*</span> 在各段最短子路径上，运去的车need最少的前提下，要求运回的车最少</span>
<span id=cb17-13><a href=#cb17-13></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb17-14><a href=#cb17-14></a> <span class=co>*</span> 参考：https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>profile<span class=co>/1011153/</span>codeBookDetail<span class=co>?</span>submissionId<span class=co>=8013527</span></span>
<span id=cb17-15><a href=#cb17-15></a> <span class=co>*/</span></span>
<span id=cb17-16><a href=#cb17-16></a><span class=kw>public</span> <span class=kw>class</span> Advanced1001 {</span>
<span id=cb17-17><a href=#cb17-17></a></span>
<span id=cb17-18><a href=#cb17-18></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb17-19><a href=#cb17-19></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb17-20><a href=#cb17-20></a>        <span class=dt>int</span> c = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-21><a href=#cb17-21></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-22><a href=#cb17-22></a>        <span class=dt>int</span> sp = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-23><a href=#cb17-23></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-24><a href=#cb17-24></a>        <span class=co>//每个顶点上多出的自行车数</span></span>
<span id=cb17-25><a href=#cb17-25></a>        <span class=dt>int</span>[] bikes = <span class=kw>new</span> <span class=dt>int</span>[n + <span class=dv>1</span>];</span>
<span id=cb17-26><a href=#cb17-26></a>        <span class=co>//代表了边及上面的权值</span></span>
<span id=cb17-27><a href=#cb17-27></a>        Roads roads = <span class=kw>new</span> <span class=fu>Roads</span>(n + <span class=dv>1</span>);</span>
<span id=cb17-28><a href=#cb17-28></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb17-29><a href=#cb17-29></a>            bikes[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-30><a href=#cb17-30></a>            bikes[i] -= (c / <span class=dv>2</span>);</span>
<span id=cb17-31><a href=#cb17-31></a>        }</span>
<span id=cb17-32><a href=#cb17-32></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= m; i++) {</span>
<span id=cb17-33><a href=#cb17-33></a>            <span class=dt>int</span> a = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-34><a href=#cb17-34></a>            <span class=dt>int</span> b = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-35><a href=#cb17-35></a>            <span class=dt>int</span> v = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb17-36><a href=#cb17-36></a>            roads.<span class=fu>setRoad</span>(a, b, v);</span>
<span id=cb17-37><a href=#cb17-37></a>            roads.<span class=fu>setRoad</span>(b, a, v);</span>
<span id=cb17-38><a href=#cb17-38></a>        }</span>
<span id=cb17-39><a href=#cb17-39></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb17-40><a href=#cb17-40></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=fu>dijkstra</span>(bikes, c, roads, sp));</span>
<span id=cb17-41><a href=#cb17-41></a>    }</span>
<span id=cb17-42><a href=#cb17-42></a></span>
<span id=cb17-43><a href=#cb17-43></a>    <span class=co>/**</span></span>
<span id=cb17-44><a href=#cb17-44></a>     <span class=co>*</span> dijkstra单源点最短路径算法，固定源点是顶点<span class=co>0</span></span>
<span id=cb17-45><a href=#cb17-45></a>     <span class=co>*/</span></span>
<span id=cb17-46><a href=#cb17-46></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>String</span> <span class=fu>dijkstra</span>(<span class=dt>int</span>[] bikes, <span class=dt>int</span> capacity, Roads roads, <span class=dt>int</span> dest) {</span>
<span id=cb17-47><a href=#cb17-47></a>        <span class=dt>int</span>[] D = <span class=kw>new</span> <span class=dt>int</span>[bikes.<span class=fu>length</span>];</span>
<span id=cb17-48><a href=#cb17-48></a>        <span class=co>//记录路径上到达每个顶点的前一个顶点</span></span>
<span id=cb17-49><a href=#cb17-49></a>        <span class=dt>int</span>[] trace = <span class=kw>new</span> <span class=dt>int</span>[bikes.<span class=fu>length</span>];</span>
<span id=cb17-50><a href=#cb17-50></a>        <span class=dt>int</span>[] need = <span class=kw>new</span> <span class=dt>int</span>[bikes.<span class=fu>length</span>];</span>
<span id=cb17-51><a href=#cb17-51></a>        <span class=dt>int</span>[] back = <span class=kw>new</span> <span class=dt>int</span>[bikes.<span class=fu>length</span>];</span>
<span id=cb17-52><a href=#cb17-52></a>        <span class=dt>boolean</span>[] visited = <span class=kw>new</span> <span class=dt>boolean</span>[bikes.<span class=fu>length</span>];</span>
<span id=cb17-53><a href=#cb17-53></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; bikes.<span class=fu>length</span>; i++) {</span>
<span id=cb17-54><a href=#cb17-54></a>            D[i] = Const.<span class=fu>INFTY</span>;</span>
<span id=cb17-55><a href=#cb17-55></a>        }</span>
<span id=cb17-56><a href=#cb17-56></a>        <span class=bu>Arrays</span>.<span class=fu>fill</span>(trace, -<span class=dv>1</span>);</span>
<span id=cb17-57><a href=#cb17-57></a></span>
<span id=cb17-58><a href=#cb17-58></a>        D[<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb17-59><a href=#cb17-59></a>        <span class=dt>int</span> min = <span class=dv>0</span>;</span>
<span id=cb17-60><a href=#cb17-60></a>        <span class=kw>while</span> (min != -<span class=dv>1</span>) {</span>
<span id=cb17-61><a href=#cb17-61></a>            <span class=co>//标记已加入最短集</span></span>
<span id=cb17-62><a href=#cb17-62></a>            visited[min] = <span class=kw>true</span>;</span>
<span id=cb17-63><a href=#cb17-63></a>            <span class=co>//更新与之相关的非最短集</span></span>
<span id=cb17-64><a href=#cb17-64></a>            <span class=kw>for</span> (<span class=bu>Map</span>.<span class=fu>Entry</span>&lt;<span class=bu>Integer</span>, <span class=bu>Integer</span>&gt; entry : roads.<span class=fu>getRoadsOfNode</span>(min).<span class=fu>entrySet</span>()) {</span>
<span id=cb17-65><a href=#cb17-65></a>                <span class=co>//对于边(i,j,v)：顶点i与j存在一条边，距离是v，对应这里roads[i].entry(j,v)</span></span>
<span id=cb17-66><a href=#cb17-66></a>                <span class=dt>int</span> j = entry.<span class=fu>getKey</span>();</span>
<span id=cb17-67><a href=#cb17-67></a>                <span class=dt>int</span> v = entry.<span class=fu>getValue</span>();</span>
<span id=cb17-68><a href=#cb17-68></a>                <span class=kw>if</span> (!visited[j]) {</span>
<span id=cb17-69><a href=#cb17-69></a>                    <span class=kw>if</span> (D[min] + v &lt; D[j]) {</span>
<span id=cb17-70><a href=#cb17-70></a>                        <span class=co>//找最短路径</span></span>
<span id=cb17-71><a href=#cb17-71></a>                        D[j] = D[min] + v;</span>
<span id=cb17-72><a href=#cb17-72></a>                        trace[j] = min;</span>
<span id=cb17-73><a href=#cb17-73></a>                        <span class=co>//在此基础上，带来和送回的自行车数目要累加(优化过的结果为：）</span></span>
<span id=cb17-74><a href=#cb17-74></a>                        back[j] = back[min] + bikes[j];</span>
<span id=cb17-75><a href=#cb17-75></a>                        need[j] = need[min];</span>
<span id=cb17-76><a href=#cb17-76></a>                        <span class=kw>if</span> (back[j] &lt; <span class=dv>0</span>) {</span>
<span id=cb17-77><a href=#cb17-77></a>                            need[j] -= back[j];</span>
<span id=cb17-78><a href=#cb17-78></a>                            back[j] = <span class=dv>0</span>;</span>
<span id=cb17-79><a href=#cb17-79></a>                        }</span>
<span id=cb17-80><a href=#cb17-80></a>                    } <span class=kw>else</span> <span class=kw>if</span> (D[min] + v == D[j]) {</span>
<span id=cb17-81><a href=#cb17-81></a>                        <span class=co>//先把算出来的值临时用n存起来，和之前的need比较</span></span>
<span id=cb17-82><a href=#cb17-82></a>                        <span class=dt>int</span> b = back[min] + bikes[j];</span>
<span id=cb17-83><a href=#cb17-83></a>                        <span class=dt>int</span> n = need[min];</span>
<span id=cb17-84><a href=#cb17-84></a>                        <span class=kw>if</span> (b &lt; <span class=dv>0</span>) {</span>
<span id=cb17-85><a href=#cb17-85></a>                            n -= b;</span>
<span id=cb17-86><a href=#cb17-86></a>                            b = <span class=dv>0</span>;</span>
<span id=cb17-87><a href=#cb17-87></a>                        }</span>
<span id=cb17-88><a href=#cb17-88></a>                        <span class=kw>if</span> (n &lt; need[j] || (n == need[j] &amp;&amp; b &lt; back[j])) {</span>
<span id=cb17-89><a href=#cb17-89></a>                            trace[j] = min;</span>
<span id=cb17-90><a href=#cb17-90></a>                            back[j] = b;</span>
<span id=cb17-91><a href=#cb17-91></a>                            need[j] = n;</span>
<span id=cb17-92><a href=#cb17-92></a>                        }</span>
<span id=cb17-93><a href=#cb17-93></a>                    }</span>
<span id=cb17-94><a href=#cb17-94></a>                }</span>
<span id=cb17-95><a href=#cb17-95></a>            }</span>
<span id=cb17-96><a href=#cb17-96></a>            <span class=co>//从非最短集中找最短</span></span>
<span id=cb17-97><a href=#cb17-97></a>            min = -<span class=dv>1</span>;</span>
<span id=cb17-98><a href=#cb17-98></a>            <span class=dt>int</span> minD = Const.<span class=fu>INFTY</span>;</span>
<span id=cb17-99><a href=#cb17-99></a>            <span class=dt>int</span> minNeed = Const.<span class=fu>INFTY</span>;</span>
<span id=cb17-100><a href=#cb17-100></a>            <span class=dt>int</span> minBack = Const.<span class=fu>INFTY</span>;</span>
<span id=cb17-101><a href=#cb17-101></a>            <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt; bikes.<span class=fu>length</span>; i++) {</span>
<span id=cb17-102><a href=#cb17-102></a>                <span class=kw>if</span> (!visited[i]) {</span>
<span id=cb17-103><a href=#cb17-103></a>                    <span class=dt>boolean</span> isDisLess = D[i] &lt; minD;</span>
<span id=cb17-104><a href=#cb17-104></a>                    <span class=dt>boolean</span> isNeedLess = D[i] == minD &amp;&amp; need[i] &lt; minNeed;</span>
<span id=cb17-105><a href=#cb17-105></a>                    <span class=dt>boolean</span> isBackLess = D[i] == minD &amp;&amp; need[i] == minNeed &amp;&amp; back[i] &lt; minBack;</span>
<span id=cb17-106><a href=#cb17-106></a>                    <span class=kw>if</span> (isDisLess || isNeedLess || isBackLess) {</span>
<span id=cb17-107><a href=#cb17-107></a>                        min = i;</span>
<span id=cb17-108><a href=#cb17-108></a>                        minD = D[i];</span>
<span id=cb17-109><a href=#cb17-109></a>                        minNeed = need[i];</span>
<span id=cb17-110><a href=#cb17-110></a>                        minBack = back[i];</span>
<span id=cb17-111><a href=#cb17-111></a>                    }</span>
<span id=cb17-112><a href=#cb17-112></a>                }</span>
<span id=cb17-113><a href=#cb17-113></a>            }</span>
<span id=cb17-114><a href=#cb17-114></a>        }<span class=co>//dijkstra完成</span></span>
<span id=cb17-115><a href=#cb17-115></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb17-116><a href=#cb17-116></a>        sb.<span class=fu>append</span>(need[dest]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb17-117><a href=#cb17-117></a>        <span class=bu>Stack</span>&lt;<span class=bu>Integer</span>&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>();</span>
<span id=cb17-118><a href=#cb17-118></a>        stack.<span class=fu>push</span>(dest);</span>
<span id=cb17-119><a href=#cb17-119></a>        <span class=dt>int</span> i = dest;</span>
<span id=cb17-120><a href=#cb17-120></a>        <span class=kw>while</span>(trace[i] != -<span class=dv>1</span>) {</span>
<span id=cb17-121><a href=#cb17-121></a>            stack.<span class=fu>push</span>(trace[i]);</span>
<span id=cb17-122><a href=#cb17-122></a>            i = trace[i];</span>
<span id=cb17-123><a href=#cb17-123></a>        }</span>
<span id=cb17-124><a href=#cb17-124></a>        <span class=kw>while</span> (!stack.<span class=fu>isEmpty</span>()) {</span>
<span id=cb17-125><a href=#cb17-125></a>            sb.<span class=fu>append</span>(stack.<span class=fu>pop</span>()).<span class=fu>append</span>(<span class=st>&quot;-&gt;&quot;</span>);</span>
<span id=cb17-126><a href=#cb17-126></a>        }</span>
<span id=cb17-127><a href=#cb17-127></a>        sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>2</span>);</span>
<span id=cb17-128><a href=#cb17-128></a>        sb.<span class=fu>append</span>(<span class=st>&quot; &quot;</span>).<span class=fu>append</span>(back[dest]);</span>
<span id=cb17-129><a href=#cb17-129></a>        <span class=kw>return</span> sb.<span class=fu>toString</span>();</span>
<span id=cb17-130><a href=#cb17-130></a>    }</span>
<span id=cb17-131><a href=#cb17-131></a>}</span>
<span id=cb17-132><a href=#cb17-132></a></span>
<span id=cb17-133><a href=#cb17-133></a><span class=kw>class</span> Roads {</span>
<span id=cb17-134><a href=#cb17-134></a>    <span class=dt>int</span> nodeNum;</span>
<span id=cb17-135><a href=#cb17-135></a>    <span class=bu>HashMap</span>&lt;<span class=bu>Integer</span>, <span class=bu>Integer</span>&gt;[] roads;</span>
<span id=cb17-136><a href=#cb17-136></a></span>
<span id=cb17-137><a href=#cb17-137></a>    <span class=kw>public</span> <span class=fu>Roads</span>(<span class=dt>int</span> nodeNum) {</span>
<span id=cb17-138><a href=#cb17-138></a>        <span class=kw>this</span>.<span class=fu>nodeNum</span> = nodeNum;</span>
<span id=cb17-139><a href=#cb17-139></a>        <span class=kw>this</span>.<span class=fu>roads</span> = <span class=kw>new</span> <span class=bu>HashMap</span>[nodeNum];</span>
<span id=cb17-140><a href=#cb17-140></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; nodeNum; i++) {</span>
<span id=cb17-141><a href=#cb17-141></a>            roads[i] = <span class=kw>new</span> <span class=bu>HashMap</span>&lt;&gt;(<span class=dv>8</span>);</span>
<span id=cb17-142><a href=#cb17-142></a>        }</span>
<span id=cb17-143><a href=#cb17-143></a>    }</span>
<span id=cb17-144><a href=#cb17-144></a></span>
<span id=cb17-145><a href=#cb17-145></a>    <span class=kw>public</span> <span class=dt>int</span> <span class=fu>getRoad</span>(<span class=dt>int</span> i, <span class=dt>int</span> j) {</span>
<span id=cb17-146><a href=#cb17-146></a>        <span class=bu>Integer</span> res = <span class=kw>this</span>.<span class=fu>roads</span>[i].<span class=fu>get</span>(j);</span>
<span id=cb17-147><a href=#cb17-147></a>        <span class=kw>return</span> res == <span class=kw>null</span> ? Const.<span class=fu>INFTY</span> : res;</span>
<span id=cb17-148><a href=#cb17-148></a>    }</span>
<span id=cb17-149><a href=#cb17-149></a></span>
<span id=cb17-150><a href=#cb17-150></a>    <span class=kw>public</span> <span class=dt>void</span> <span class=fu>setRoad</span>(<span class=dt>int</span> i, <span class=dt>int</span> j, <span class=dt>int</span> value) {</span>
<span id=cb17-151><a href=#cb17-151></a>        <span class=kw>this</span>.<span class=fu>roads</span>[i].<span class=fu>put</span>(j, value);</span>
<span id=cb17-152><a href=#cb17-152></a>        <span class=kw>this</span>.<span class=fu>roads</span>[j].<span class=fu>put</span>(i, value);</span>
<span id=cb17-153><a href=#cb17-153></a>    }</span>
<span id=cb17-154><a href=#cb17-154></a></span>
<span id=cb17-155><a href=#cb17-155></a>    <span class=kw>public</span> <span class=bu>HashMap</span>&lt;<span class=bu>Integer</span>, <span class=bu>Integer</span>&gt; <span class=fu>getRoadsOfNode</span>(<span class=dt>int</span> i) {</span>
<span id=cb17-156><a href=#cb17-156></a>        <span class=kw>return</span> <span class=kw>this</span>.<span class=fu>roads</span>[i];</span>
<span id=cb17-157><a href=#cb17-157></a>    }</span>
<span id=cb17-158><a href=#cb17-158></a>}</span>
<span id=cb17-159><a href=#cb17-159></a></span>
<span id=cb17-160><a href=#cb17-160></a><span class=kw>class</span> Const {</span>
<span id=cb17-161><a href=#cb17-161></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>final</span> <span class=dt>int</span> INFTY = <span class=bu>Integer</span>.<span class=fu>MAX_VALUE</span> / <span class=dv>2</span>;</span>
<span id=cb17-162><a href=#cb17-162></a>}</span></code></pre></div><p><strong>优化后的过程</strong>：</p><p>题目要求： 找距离最短（首要），从源点带来的自行车最少（次要），带回去的自行车最少（次次要）的路径。 合并带来最少和带回去最少的要求，则要求cost最小。 （cost为正时表时要带来的数量，为负时绝对值代表要带回去的数量。） （比如某两条路径距离都最短，第一条路径cost为正，需要带来自行车；第二条路径cost为负，需要带回去自行车，带来的自行车为0，那么选第二条路径）</p><p>则题目变成： 找距离最短（首要），cost最小（次要）的路径。 即多重最短/最小值问题。</p><p>这样的问题，只要在原生的Dijkstra算法中，判断首要最短的语句后，加上次要最小的判断即可。</p><p><strong>优化后的代码</strong>：</p><div class=sourceCode id=cb18><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb18-1><a href=#cb18-1></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb18-2><a href=#cb18-2></a><span class=pp>#include </span><span class=im>&lt;vector&gt;</span></span>
<span id=cb18-3><a href=#cb18-3></a><span class=pp>#include </span><span class=im>&lt;climits&gt;</span></span>
<span id=cb18-4><a href=#cb18-4></a> </span>
<span id=cb18-5><a href=#cb18-5></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb18-6><a href=#cb18-6></a> </span>
<span id=cb18-7><a href=#cb18-7></a><span class=dt>void</span> dijkstra(<span class=dt>int</span> &amp;n, <span class=dt>int</span> &amp;cmax, vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt; &amp;map, vector&lt;<span class=dt>int</span>&gt; &amp;bikeNum, <span class=dt>int</span> endV) {</span>
<span id=cb18-8><a href=#cb18-8></a>    vector&lt;<span class=dt>bool</span>&gt; visited(n + <span class=dv>1</span>, <span class=kw>false</span>);</span>
<span id=cb18-9><a href=#cb18-9></a>    vector&lt;<span class=dt>int</span>&gt; dist(n + <span class=dv>1</span>, INT_MAX);</span>
<span id=cb18-10><a href=#cb18-10></a>    vector&lt;<span class=dt>int</span>&gt; cost(n + <span class=dv>1</span>, <span class=dv>0</span>);</span>
<span id=cb18-11><a href=#cb18-11></a>    vector&lt;<span class=dt>int</span>&gt; preV(n + <span class=dv>1</span>, -<span class=dv>1</span>);</span>
<span id=cb18-12><a href=#cb18-12></a>    dist[<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb18-13><a href=#cb18-13></a>    visited[<span class=dv>0</span>] = <span class=kw>true</span>;</span>
<span id=cb18-14><a href=#cb18-14></a>    cost[<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb18-15><a href=#cb18-15></a>    <span class=dt>int</span> u = <span class=dv>0</span>;</span>
<span id=cb18-16><a href=#cb18-16></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb18-17><a href=#cb18-17></a>        <span class=dt>int</span> minDist = INT_MAX;</span>
<span id=cb18-18><a href=#cb18-18></a>        <span class=cf>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt;= n; j++) {</span>
<span id=cb18-19><a href=#cb18-19></a>            <span class=cf>if</span> (!visited[j] &amp;&amp; dist[j] &lt; minDist) {</span>
<span id=cb18-20><a href=#cb18-20></a>                minDist = dist[j];</span>
<span id=cb18-21><a href=#cb18-21></a>                u = j;</span>
<span id=cb18-22><a href=#cb18-22></a>            }</span>
<span id=cb18-23><a href=#cb18-23></a>        }</span>
<span id=cb18-24><a href=#cb18-24></a>        visited[u] = <span class=kw>true</span>;</span>
<span id=cb18-25><a href=#cb18-25></a>        <span class=cf>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt;= n; j++) {</span>
<span id=cb18-26><a href=#cb18-26></a>            <span class=cf>if</span> (!visited[j] &amp;&amp; map[u][j] &lt; INT_MAX) {</span>
<span id=cb18-27><a href=#cb18-27></a>                <span class=cf>if</span> (dist[j] &gt; dist[u] + map[u][j]) {</span>
<span id=cb18-28><a href=#cb18-28></a>                    dist[j] = dist[u] + map[u][j];</span>
<span id=cb18-29><a href=#cb18-29></a>                    cost[j] = cost[u] + cmax - bikeNum[j];</span>
<span id=cb18-30><a href=#cb18-30></a>                    preV[j] = u;</span>
<span id=cb18-31><a href=#cb18-31></a>                } <span class=cf>else</span> <span class=cf>if</span> (dist[j] == dist[u] + map[u][j]) {</span>
<span id=cb18-32><a href=#cb18-32></a>                    <span class=cf>if</span> (cost[j] &gt; cost[u] + cmax - bikeNum[j]) {</span>
<span id=cb18-33><a href=#cb18-33></a>                        cost[j] = cost[u] + cmax - bikeNum[j];</span>
<span id=cb18-34><a href=#cb18-34></a>                        preV[j] = u;</span>
<span id=cb18-35><a href=#cb18-35></a>                    }</span>
<span id=cb18-36><a href=#cb18-36></a>                }</span>
<span id=cb18-37><a href=#cb18-37></a>            }</span>
<span id=cb18-38><a href=#cb18-38></a>        }</span>
<span id=cb18-39><a href=#cb18-39></a>    }</span>
<span id=cb18-40><a href=#cb18-40></a>    <span class=dt>int</span> p = endV;</span>
<span id=cb18-41><a href=#cb18-41></a>    <span class=dt>int</span> nums[<span class=dv>501</span>], size = <span class=dv>0</span>, minBike = <span class=dv>0</span>;</span>
<span id=cb18-42><a href=#cb18-42></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb18-43><a href=#cb18-43></a>        <span class=cf>if</span> (preV[p] == -<span class=dv>1</span>) {</span>
<span id=cb18-44><a href=#cb18-44></a>            <span class=cf>break</span>;</span>
<span id=cb18-45><a href=#cb18-45></a>        }</span>
<span id=cb18-46><a href=#cb18-46></a>        <span class=cf>if</span> (cost[p] + minBike &gt; <span class=dv>0</span>) {</span>
<span id=cb18-47><a href=#cb18-47></a>            minBike = -cost[p];</span>
<span id=cb18-48><a href=#cb18-48></a>        }</span>
<span id=cb18-49><a href=#cb18-49></a>        nums[size++] = p;</span>
<span id=cb18-50><a href=#cb18-50></a>        p = preV[p];</span>
<span id=cb18-51><a href=#cb18-51></a>    }</span>
<span id=cb18-52><a href=#cb18-52></a>    printf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> 0&quot;</span>, -minBike);</span>
<span id=cb18-53><a href=#cb18-53></a>    <span class=cf>for</span> (<span class=dt>int</span> i = size - <span class=dv>1</span>; i &gt;= <span class=dv>0</span>; i--) {</span>
<span id=cb18-54><a href=#cb18-54></a>        printf(<span class=st>&quot;-&gt;</span><span class=sc>%d</span><span class=st>&quot;</span>, nums[i]);</span>
<span id=cb18-55><a href=#cb18-55></a>    }</span>
<span id=cb18-56><a href=#cb18-56></a>    <span class=cf>if</span> (cost[endV] + minBike&gt; <span class=dv>0</span>) {</span>
<span id=cb18-57><a href=#cb18-57></a>        printf(<span class=st>&quot; 0</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb18-58><a href=#cb18-58></a>    } <span class=cf>else</span> printf(<span class=st>&quot;% d</span><span class=sc>\n</span><span class=st>&quot;</span>, -minBike-cost[endV]);</span>
<span id=cb18-59><a href=#cb18-59></a>}</span>
<span id=cb18-60><a href=#cb18-60></a> </span>
<span id=cb18-61><a href=#cb18-61></a><span class=dt>int</span> main(<span class=dt>int</span> argc, <span class=at>const</span> <span class=dt>char</span> * argv[]) {</span>
<span id=cb18-62><a href=#cb18-62></a>    <span class=dt>int</span> cmax, n, endv, m;</span>
<span id=cb18-63><a href=#cb18-63></a>    scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> </span><span class=sc>%d</span><span class=st> </span><span class=sc>%d</span><span class=st> </span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;cmax, &amp;n, &amp;endv, &amp;m);</span>
<span id=cb18-64><a href=#cb18-64></a>    vector&lt;<span class=dt>int</span>&gt; bikeNum(n + <span class=dv>1</span>);</span>
<span id=cb18-65><a href=#cb18-65></a>    bikeNum[<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb18-66><a href=#cb18-66></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb18-67><a href=#cb18-67></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;bikeNum[i]);</span>
<span id=cb18-68><a href=#cb18-68></a>    }</span>
<span id=cb18-69><a href=#cb18-69></a>    vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt; map(n + <span class=dv>1</span>, vector&lt;<span class=dt>int</span>&gt; (n + <span class=dv>1</span>, INT_MAX));</span>
<span id=cb18-70><a href=#cb18-70></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; m; i++) {</span>
<span id=cb18-71><a href=#cb18-71></a>        <span class=dt>int</span> u, v;</span>
<span id=cb18-72><a href=#cb18-72></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> </span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;u, &amp;v);</span>
<span id=cb18-73><a href=#cb18-73></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;map[u][v]);</span>
<span id=cb18-74><a href=#cb18-74></a>        map[v][u] = map[u][v];</span>
<span id=cb18-75><a href=#cb18-75></a>    }</span>
<span id=cb18-76><a href=#cb18-76></a>    <span class=dt>int</span> c = cmax/<span class=dv>2</span>;</span>
<span id=cb18-77><a href=#cb18-77></a>    dijkstra(n, c, map, bikeNum, endv);</span>
<span id=cb18-78><a href=#cb18-78></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb18-79><a href=#cb18-79></a>}</span></code></pre></div><h5 id=例2-2>例2</h5><h6 id=条条大路通罗马问题>条条大路通罗马问题</h6><p>指定出发城市，去到罗马。 要求路径最短； 次要要求总愉悦值最大（每经过一个城市都会带来一定程度的愉悦感）； 次次要要求平均愉悦值最大（总愉悦值相同时，考虑平均愉悦值，那么要求经过城市越少越好）</p><h6 id=方法1保存各种状态的dijkstra算法>方法1：保存各种状态的Dijkstra算法</h6><p>过程：</p><p>初始化各种状态（各点的累计距离值、累计快乐值、步数值） 从源点开始，挑选累计距离值最小（首要）、累计快乐值最大（次要）、步数值最小（次次要）的点，进行visited 更新没有visited各点的距离值、累计快乐值最、步数值最小 重复上面个两步，直到所有点都visited</p><p>过程例子：</p><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200520233158842.png alt><figcaption>image-20200520233158842</figcaption></figure><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/image-20200520233303611.png alt><figcaption>image-20200520233303611</figcaption></figure><p>编写代码：</p><div class=sourceCode id=cb19><pre class="sourceCode java"><code class="sourceCode java"><span id=cb19-1><a href=#cb19-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb19-2><a href=#cb19-2></a></span>
<span id=cb19-3><a href=#cb19-3></a><span class=kw>import</span><span class=im> java.util.Arrays;</span></span>
<span id=cb19-4><a href=#cb19-4></a><span class=kw>import</span><span class=im> java.util.HashMap;</span></span>
<span id=cb19-5><a href=#cb19-5></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb19-6><a href=#cb19-6></a><span class=kw>import</span><span class=im> java.util.Stack;</span></span>
<span id=cb19-7><a href=#cb19-7></a></span>
<span id=cb19-8><a href=#cb19-8></a><span class=co>/**</span></span>
<span id=cb19-9><a href=#cb19-9></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb19-10><a href=#cb19-10></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/5/19</span> <span class=co>17:25</span></span>
<span id=cb19-11><a href=#cb19-11></a> <span class=co>*</span> <span class=co>@</span>discription<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4315</span></span>
<span id=cb19-12><a href=#cb19-12></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb19-13><a href=#cb19-13></a> <span class=co>*</span> 要求路径最短，累加值最大，平均值最大（或步数最少）</span>
<span id=cb19-14><a href=#cb19-14></a> <span class=co>*</span> 这里用Dijkstra算法，（代码已实现）</span>
<span id=cb19-15><a href=#cb19-15></a> <span class=co>*</span> 还可以使用优先队列优化dijkstra算法中循环找最小的过程（这里的代码没有实现优化）</span>
<span id=cb19-16><a href=#cb19-16></a> <span class=co>*/</span></span>
<span id=cb19-17><a href=#cb19-17></a><span class=kw>public</span> <span class=kw>class</span> Advanced1002 {</span>
<span id=cb19-18><a href=#cb19-18></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb19-19><a href=#cb19-19></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb19-20><a href=#cb19-20></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb19-21><a href=#cb19-21></a>        <span class=dt>int</span> k = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb19-22><a href=#cb19-22></a>        <span class=bu>String</span> startName = scanner.<span class=fu>next</span>();</span>
<span id=cb19-23><a href=#cb19-23></a>        City1002[] citys = <span class=kw>new</span> City1002[n];</span>
<span id=cb19-24><a href=#cb19-24></a>        citys[<span class=dv>0</span>] = <span class=kw>new</span> <span class=fu>City1002</span>(<span class=dv>0</span>, startName, <span class=dv>0</span>);</span>
<span id=cb19-25><a href=#cb19-25></a>        <span class=bu>HashMap</span>&lt;<span class=bu>String</span>, <span class=bu>Integer</span>&gt; nameIdMap = <span class=kw>new</span> <span class=bu>HashMap</span>&lt;&gt;(<span class=dv>8</span>);</span>
<span id=cb19-26><a href=#cb19-26></a>        nameIdMap.<span class=fu>put</span>(startName, <span class=dv>0</span>);</span>
<span id=cb19-27><a href=#cb19-27></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt; n; i++) {</span>
<span id=cb19-28><a href=#cb19-28></a>            City1002 city = <span class=kw>new</span> <span class=fu>City1002</span>(i, scanner.<span class=fu>next</span>(), scanner.<span class=fu>nextInt</span>());</span>
<span id=cb19-29><a href=#cb19-29></a>            citys[i] = city;</span>
<span id=cb19-30><a href=#cb19-30></a>            nameIdMap.<span class=fu>put</span>(city.<span class=fu>name</span>, city.<span class=fu>id</span>);</span>
<span id=cb19-31><a href=#cb19-31></a>        }</span>
<span id=cb19-32><a href=#cb19-32></a>        <span class=dt>int</span>[][] roads = <span class=kw>new</span> <span class=dt>int</span>[n][n];</span>
<span id=cb19-33><a href=#cb19-33></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb19-34><a href=#cb19-34></a>            <span class=bu>Arrays</span>.<span class=fu>fill</span>(roads[i], Const1002.<span class=fu>INFTY</span>);</span>
<span id=cb19-35><a href=#cb19-35></a>        }</span>
<span id=cb19-36><a href=#cb19-36></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; k; i++) {</span>
<span id=cb19-37><a href=#cb19-37></a>            <span class=bu>String</span> c1 = scanner.<span class=fu>next</span>();</span>
<span id=cb19-38><a href=#cb19-38></a>            <span class=bu>String</span> c2 = scanner.<span class=fu>next</span>();</span>
<span id=cb19-39><a href=#cb19-39></a>            <span class=dt>int</span> cost = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb19-40><a href=#cb19-40></a>            roads[nameIdMap.<span class=fu>get</span>(c1)][nameIdMap.<span class=fu>get</span>(c2)] = cost;</span>
<span id=cb19-41><a href=#cb19-41></a>            roads[nameIdMap.<span class=fu>get</span>(c2)][nameIdMap.<span class=fu>get</span>(c1)] = cost;</span>
<span id=cb19-42><a href=#cb19-42></a>        }</span>
<span id=cb19-43><a href=#cb19-43></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb19-44><a href=#cb19-44></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=fu>dijkstra2Rom</span>(citys, roads, nameIdMap));</span>
<span id=cb19-45><a href=#cb19-45></a>    }</span>
<span id=cb19-46><a href=#cb19-46></a></span>
<span id=cb19-47><a href=#cb19-47></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=bu>String</span> <span class=fu>dijkstra2Rom</span>(City1002[] citys, <span class=dt>int</span>[][] road, <span class=bu>HashMap</span>&lt;<span class=bu>String</span>, <span class=bu>Integer</span>&gt; nameIdMap) {</span>
<span id=cb19-48><a href=#cb19-48></a>        <span class=dt>int</span>[] cost = <span class=kw>new</span> <span class=dt>int</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-49><a href=#cb19-49></a>        <span class=dt>int</span>[] happiCumu = <span class=kw>new</span> <span class=dt>int</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-50><a href=#cb19-50></a>        <span class=dt>boolean</span>[] visited = <span class=kw>new</span> <span class=dt>boolean</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-51><a href=#cb19-51></a>        <span class=dt>int</span>[] trace = <span class=kw>new</span> <span class=dt>int</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-52><a href=#cb19-52></a>        <span class=dt>int</span>[] pass = <span class=kw>new</span> <span class=dt>int</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-53><a href=#cb19-53></a>        <span class=dt>int</span>[] minCostCount = <span class=kw>new</span> <span class=dt>int</span>[citys.<span class=fu>length</span>];</span>
<span id=cb19-54><a href=#cb19-54></a>        <span class=bu>Arrays</span>.<span class=fu>fill</span>(cost, Const1002.<span class=fu>INFTY</span>);</span>
<span id=cb19-55><a href=#cb19-55></a>        <span class=bu>Arrays</span>.<span class=fu>fill</span>(trace, Const1002.<span class=fu>NONE</span>);</span>
<span id=cb19-56><a href=#cb19-56></a>        <span class=bu>Arrays</span>.<span class=fu>fill</span>(minCostCount, <span class=dv>1</span>);</span>
<span id=cb19-57><a href=#cb19-57></a>        cost[<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb19-58><a href=#cb19-58></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; citys.<span class=fu>length</span>; i++) {</span>
<span id=cb19-59><a href=#cb19-59></a>            <span class=co>//没visited的点中按优先级找距离最小、快乐和最大、平均快乐最大的点</span></span>
<span id=cb19-60><a href=#cb19-60></a>            <span class=dt>int</span> minCost = Const1002.<span class=fu>INFTY</span>;</span>
<span id=cb19-61><a href=#cb19-61></a>            <span class=dt>int</span> maxHappiCumu = <span class=dv>0</span>;</span>
<span id=cb19-62><a href=#cb19-62></a>            <span class=dt>int</span> minStep = Const1002.<span class=fu>INFTY</span>;</span>
<span id=cb19-63><a href=#cb19-63></a>            <span class=dt>int</span> k = Const1002.<span class=fu>NONE</span>;</span>
<span id=cb19-64><a href=#cb19-64></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; citys.<span class=fu>length</span>; j++) {</span>
<span id=cb19-65><a href=#cb19-65></a>                <span class=kw>if</span> (!visited[j]) {</span>
<span id=cb19-66><a href=#cb19-66></a>                    <span class=co>//首要cost最小，次要happiCumu最大，次次要averHapp最大/步数最少</span></span>
<span id=cb19-67><a href=#cb19-67></a>                    <span class=kw>if</span> (cost[j] &lt; minCost) {</span>
<span id=cb19-68><a href=#cb19-68></a>                        k = j;</span>
<span id=cb19-69><a href=#cb19-69></a>                        minCost = cost[j];</span>
<span id=cb19-70><a href=#cb19-70></a>                        maxHappiCumu = happiCumu[j];</span>
<span id=cb19-71><a href=#cb19-71></a>                        minStep = pass[j];</span>
<span id=cb19-72><a href=#cb19-72></a>                    } <span class=kw>else</span> <span class=kw>if</span> (cost[j] == minCost) {</span>
<span id=cb19-73><a href=#cb19-73></a>                        <span class=kw>if</span> (happiCumu[j] &gt; maxHappiCumu) {</span>
<span id=cb19-74><a href=#cb19-74></a>                            k = j;</span>
<span id=cb19-75><a href=#cb19-75></a>                            maxHappiCumu = happiCumu[j];</span>
<span id=cb19-76><a href=#cb19-76></a>                            minStep = pass[j];</span>
<span id=cb19-77><a href=#cb19-77></a>                        } <span class=kw>else</span> <span class=kw>if</span> (happiCumu[j] == maxHappiCumu) {</span>
<span id=cb19-78><a href=#cb19-78></a>                            <span class=kw>if</span> (pass[j] &lt; minStep) {</span>
<span id=cb19-79><a href=#cb19-79></a>                                k = j;</span>
<span id=cb19-80><a href=#cb19-80></a>                                minStep = pass[j];</span>
<span id=cb19-81><a href=#cb19-81></a>                            }</span>
<span id=cb19-82><a href=#cb19-82></a>                        }</span>
<span id=cb19-83><a href=#cb19-83></a>                    }</span>
<span id=cb19-84><a href=#cb19-84></a>                }</span>
<span id=cb19-85><a href=#cb19-85></a>            }</span>
<span id=cb19-86><a href=#cb19-86></a>            <span class=kw>if</span> (k == Const1002.<span class=fu>NONE</span>) {</span>
<span id=cb19-87><a href=#cb19-87></a>                <span class=kw>break</span>;</span>
<span id=cb19-88><a href=#cb19-88></a>            }</span>
<span id=cb19-89><a href=#cb19-89></a>            <span class=co>//访问该点</span></span>
<span id=cb19-90><a href=#cb19-90></a>            visited[k] = <span class=kw>true</span>;</span>
<span id=cb19-91><a href=#cb19-91></a>            <span class=co>//更新未访问点的各种状态</span></span>
<span id=cb19-92><a href=#cb19-92></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; citys.<span class=fu>length</span>; j++) {</span>
<span id=cb19-93><a href=#cb19-93></a>                <span class=kw>if</span> (!visited[j]) {</span>
<span id=cb19-94><a href=#cb19-94></a>                    <span class=dt>int</span> costThroughK = cost[k] + road[k][j];</span>
<span id=cb19-95><a href=#cb19-95></a>                    <span class=dt>int</span> happiThroughK = happiCumu[k] + citys[j].<span class=fu>happiness</span>;</span>
<span id=cb19-96><a href=#cb19-96></a>                    <span class=dt>int</span> stepThoughK = pass[k] + <span class=dv>1</span>;</span>
<span id=cb19-97><a href=#cb19-97></a>                    <span class=dt>boolean</span> changeRoute = <span class=kw>false</span>;</span>
<span id=cb19-98><a href=#cb19-98></a>                    <span class=kw>if</span> (costThroughK &lt; cost[j]) {</span>
<span id=cb19-99><a href=#cb19-99></a>                        changeRoute = <span class=kw>true</span>;</span>
<span id=cb19-100><a href=#cb19-100></a>                        minCostCount[j] = minCostCount[k];</span>
<span id=cb19-101><a href=#cb19-101></a>                    } <span class=kw>else</span> <span class=kw>if</span> (costThroughK == cost[j]) {</span>
<span id=cb19-102><a href=#cb19-102></a>                        minCostCount[j] += minCostCount[k];</span>
<span id=cb19-103><a href=#cb19-103></a>                        <span class=dt>boolean</span> happiMore = happiThroughK &gt; happiCumu[j];</span>
<span id=cb19-104><a href=#cb19-104></a>                        <span class=dt>boolean</span> stepLess = happiThroughK == happiCumu[j] &amp;&amp; stepThoughK &lt; pass[j];</span>
<span id=cb19-105><a href=#cb19-105></a>                        <span class=kw>if</span> (happiMore || stepLess) {</span>
<span id=cb19-106><a href=#cb19-106></a>                            changeRoute = <span class=kw>true</span>;</span>
<span id=cb19-107><a href=#cb19-107></a>                        }</span>
<span id=cb19-108><a href=#cb19-108></a>                    }</span>
<span id=cb19-109><a href=#cb19-109></a>                    <span class=kw>if</span> (changeRoute) {</span>
<span id=cb19-110><a href=#cb19-110></a>                        trace[j] = k;</span>
<span id=cb19-111><a href=#cb19-111></a>                        cost[j] = costThroughK;</span>
<span id=cb19-112><a href=#cb19-112></a>                        happiCumu[j] = happiThroughK;</span>
<span id=cb19-113><a href=#cb19-113></a>                        pass[j] = stepThoughK;</span>
<span id=cb19-114><a href=#cb19-114></a>                    }</span>
<span id=cb19-115><a href=#cb19-115></a>                }</span>
<span id=cb19-116><a href=#cb19-116></a>            }</span>
<span id=cb19-117><a href=#cb19-117></a>        }</span>
<span id=cb19-118><a href=#cb19-118></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb19-119><a href=#cb19-119></a>        <span class=dt>int</span> romId = nameIdMap.<span class=fu>get</span>(<span class=st>&quot;ROM&quot;</span>);</span>
<span id=cb19-120><a href=#cb19-120></a>        sb.<span class=fu>append</span>(minCostCount[romId]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>)</span>
<span id=cb19-121><a href=#cb19-121></a>                .<span class=fu>append</span>(cost[romId]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>)</span>
<span id=cb19-122><a href=#cb19-122></a>                .<span class=fu>append</span>(happiCumu[romId]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>)</span>
<span id=cb19-123><a href=#cb19-123></a>                .<span class=fu>append</span>(happiCumu[romId] / pass[romId]).<span class=fu>append</span>(<span class=st>&quot;</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb19-124><a href=#cb19-124></a>        <span class=bu>Stack</span>&lt;<span class=bu>Integer</span>&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>&lt;&gt;();</span>
<span id=cb19-125><a href=#cb19-125></a>        <span class=kw>while</span> (romId != Const1002.<span class=fu>NONE</span>) {</span>
<span id=cb19-126><a href=#cb19-126></a>            stack.<span class=fu>push</span>(romId);</span>
<span id=cb19-127><a href=#cb19-127></a>            romId = trace[romId];</span>
<span id=cb19-128><a href=#cb19-128></a>        }</span>
<span id=cb19-129><a href=#cb19-129></a>        <span class=kw>while</span> (!stack.<span class=fu>isEmpty</span>()) {</span>
<span id=cb19-130><a href=#cb19-130></a>            sb.<span class=fu>append</span>(citys[stack.<span class=fu>pop</span>()].<span class=fu>name</span>).<span class=fu>append</span>(<span class=st>&quot;-&gt;&quot;</span>);</span>
<span id=cb19-131><a href=#cb19-131></a>        }</span>
<span id=cb19-132><a href=#cb19-132></a>        sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>2</span>);</span>
<span id=cb19-133><a href=#cb19-133></a>        <span class=kw>return</span> sb.<span class=fu>toString</span>();</span>
<span id=cb19-134><a href=#cb19-134></a>    }</span>
<span id=cb19-135><a href=#cb19-135></a>}</span>
<span id=cb19-136><a href=#cb19-136></a></span>
<span id=cb19-137><a href=#cb19-137></a><span class=kw>class</span> City1002 {</span>
<span id=cb19-138><a href=#cb19-138></a>    <span class=dt>int</span> id;</span>
<span id=cb19-139><a href=#cb19-139></a>    <span class=bu>String</span> name;</span>
<span id=cb19-140><a href=#cb19-140></a>    <span class=dt>int</span> happiness;</span>
<span id=cb19-141><a href=#cb19-141></a></span>
<span id=cb19-142><a href=#cb19-142></a>    <span class=kw>public</span> <span class=fu>City1002</span>(<span class=dt>int</span> id, <span class=bu>String</span> name, <span class=dt>int</span> happiness) {</span>
<span id=cb19-143><a href=#cb19-143></a>        <span class=kw>this</span>.<span class=fu>id</span> = id;</span>
<span id=cb19-144><a href=#cb19-144></a>        <span class=kw>this</span>.<span class=fu>name</span> = name;</span>
<span id=cb19-145><a href=#cb19-145></a>        <span class=kw>this</span>.<span class=fu>happiness</span> = happiness;</span>
<span id=cb19-146><a href=#cb19-146></a>    }</span>
<span id=cb19-147><a href=#cb19-147></a>}</span>
<span id=cb19-148><a href=#cb19-148></a></span>
<span id=cb19-149><a href=#cb19-149></a><span class=kw>class</span> Const1002 {</span>
<span id=cb19-150><a href=#cb19-150></a>    <span class=kw>public</span> <span class=dt>final</span> <span class=dt>static</span> <span class=dt>int</span> INFTY = <span class=bu>Integer</span>.<span class=fu>MAX_VALUE</span> / <span class=dv>2</span>;</span>
<span id=cb19-151><a href=#cb19-151></a>    <span class=kw>public</span> <span class=dt>final</span> <span class=dt>static</span> <span class=dt>int</span> NONE = -<span class=dv>1</span>;</span>
<span id=cb19-152><a href=#cb19-152></a>}</span>
<span id=cb19-153><a href=#cb19-153></a></span></code></pre></div><h6 id=方法2dijkstra找最短多条最短dfs找最优>方法2：Dijkstra找最短，多条最短dfs找最优</h6><p>Dijkstra找最短路径，如果最短路径有多条，存入队列/数组中待用； 然后用dfs遍历各条最短路径，计算每条路径的愉悦值和步数，从中选最优路径</p><p>此方法的两个实现：</p><div class=sourceCode id=cb20><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb20-1><a href=#cb20-1></a><span class=co>//转自牛客网牛友提交的代码：</span></span>
<span id=cb20-2><a href=#cb20-2></a><span class=co>//https://www.nowcoder.com/profile/5832296/codeBookDetail?submissionId=10915168</span></span>
<span id=cb20-3><a href=#cb20-3></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span><span class=pp> </span></span>
<span id=cb20-4><a href=#cb20-4></a><span class=pp>#include </span><span class=im>&lt;vector&gt;</span><span class=pp> </span></span>
<span id=cb20-5><a href=#cb20-5></a><span class=pp>#include </span><span class=im>&lt;set&gt;</span><span class=pp> </span></span>
<span id=cb20-6><a href=#cb20-6></a><span class=pp>#include </span><span class=im>&lt;algorithm&gt;</span><span class=pp> </span></span>
<span id=cb20-7><a href=#cb20-7></a><span class=pp>#include </span><span class=im>&lt;string&gt;</span><span class=pp> </span></span>
<span id=cb20-8><a href=#cb20-8></a><span class=pp>#include </span><span class=im>&lt;map&gt;</span><span class=pp> </span></span>
<span id=cb20-9><a href=#cb20-9></a><span class=kw>using</span> <span class=kw>namespace</span> std; </span>
<span id=cb20-10><a href=#cb20-10></a><span class=pp>#define INF </span><span class=dv>9999999</span><span class=pp> </span></span>
<span id=cb20-11><a href=#cb20-11></a>   </span>
<span id=cb20-12><a href=#cb20-12></a><span class=kw>struct</span> city{ </span>
<span id=cb20-13><a href=#cb20-13></a>    city(string _n, <span class=dt>int</span> _h){name=_n; happy=_h;} </span>
<span id=cb20-14><a href=#cb20-14></a>    string name; </span>
<span id=cb20-15><a href=#cb20-15></a>    <span class=dt>int</span> happy; </span>
<span id=cb20-16><a href=#cb20-16></a>}; </span>
<span id=cb20-17><a href=#cb20-17></a>vector&lt;city&gt; cities;   </span>
<span id=cb20-18><a href=#cb20-18></a>vector&lt;vector&lt;<span class=dt>int</span>&gt; &gt; cost; </span>
<span id=cb20-19><a href=#cb20-19></a>vector&lt;vector&lt;<span class=dt>int</span>&gt; &gt; allPath; </span>
<span id=cb20-20><a href=#cb20-20></a>vector&lt;<span class=dt>int</span>&gt; bestPath; </span>
<span id=cb20-21><a href=#cb20-21></a>vector&lt;<span class=dt>int</span>&gt; possiblePath; </span>
<span id=cb20-22><a href=#cb20-22></a>vector&lt;<span class=dt>bool</span>&gt; visited; </span>
<span id=cb20-23><a href=#cb20-23></a>vector&lt;<span class=dt>int</span>&gt; dist; <span class=co>//记录起点到各个点的距离  </span></span>
<span id=cb20-24><a href=#cb20-24></a>map&lt;string, <span class=dt>int</span>&gt; name2id; </span>
<span id=cb20-25><a href=#cb20-25></a><span class=dt>int</span> cityNum, roadNum; </span>
<span id=cb20-26><a href=#cb20-26></a><span class=dt>int</span> cnt = <span class=dv>0</span>; </span>
<span id=cb20-27><a href=#cb20-27></a><span class=dt>void</span> dijkstra(<span class=dt>int</span> s){ </span>
<span id=cb20-28><a href=#cb20-28></a>    <span class=dt>int</span> i; </span>
<span id=cb20-29><a href=#cb20-29></a>    dist[s] = <span class=dv>0</span>; </span>
<span id=cb20-30><a href=#cb20-30></a>    <span class=cf>while</span>(<span class=kw>true</span>){ </span>
<span id=cb20-31><a href=#cb20-31></a>        <span class=dt>int</span> v = -<span class=dv>1</span>; </span>
<span id=cb20-32><a href=#cb20-32></a>        <span class=cf>for</span>(<span class=dt>int</span> u=<span class=dv>0</span>; u&lt;cityNum; u++){ </span>
<span id=cb20-33><a href=#cb20-33></a>            <span class=cf>if</span>(!visited[u]&amp;&amp;(v==-<span class=dv>1</span>||dist[u]&lt;dist[v]))    v=u; </span>
<span id=cb20-34><a href=#cb20-34></a>        } </span>
<span id=cb20-35><a href=#cb20-35></a>        <span class=cf>if</span>(v==-<span class=dv>1</span>) <span class=cf>break</span>; </span>
<span id=cb20-36><a href=#cb20-36></a>        visited[v]=<span class=kw>true</span>; </span>
<span id=cb20-37><a href=#cb20-37></a>        <span class=cf>for</span>(<span class=dt>int</span> u=<span class=dv>0</span>; u&lt;cityNum; u++){ </span>
<span id=cb20-38><a href=#cb20-38></a>            <span class=cf>if</span>(dist[u] &gt; dist[v] + cost[v][u]){ </span>
<span id=cb20-39><a href=#cb20-39></a>                dist[u] = dist[v] + cost[v][u]; </span>
<span id=cb20-40><a href=#cb20-40></a>                allPath[u].clear(); </span>
<span id=cb20-41><a href=#cb20-41></a>                allPath[u].push_back(v); </span>
<span id=cb20-42><a href=#cb20-42></a>            }<span class=cf>else</span> <span class=cf>if</span>(dist[u]==dist[v]+cost[v][u]){        </span>
<span id=cb20-43><a href=#cb20-43></a>                allPath[u].push_back(v); </span>
<span id=cb20-44><a href=#cb20-44></a>            } </span>
<span id=cb20-45><a href=#cb20-45></a>        } </span>
<span id=cb20-46><a href=#cb20-46></a>    } </span>
<span id=cb20-47><a href=#cb20-47></a>} </span>
<span id=cb20-48><a href=#cb20-48></a><span class=dt>int</span> maxHappy = <span class=dv>0</span>; </span>
<span id=cb20-49><a href=#cb20-49></a><span class=dt>double</span> maxAve = <span class=dv>0</span>; </span>
<span id=cb20-50><a href=#cb20-50></a><span class=dt>int</span> pathNum = <span class=dv>0</span>; <span class=co>//最短路的条数  </span></span>
<span id=cb20-51><a href=#cb20-51></a><span class=dt>void</span> findBestPath(<span class=dt>int</span> t){ </span>
<span id=cb20-52><a href=#cb20-52></a>    possiblePath.push_back(t); </span>
<span id=cb20-53><a href=#cb20-53></a>    <span class=cf>if</span>(t==<span class=dv>0</span>){    </span>
<span id=cb20-54><a href=#cb20-54></a>        pathNum++;   </span>
<span id=cb20-55><a href=#cb20-55></a>        <span class=dt>int</span> happy = <span class=dv>0</span>; </span>
<span id=cb20-56><a href=#cb20-56></a>        <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>; i&lt;possiblePath.size(); i++){ </span>
<span id=cb20-57><a href=#cb20-57></a>            <span class=dt>int</span> index = possiblePath[i]; </span>
<span id=cb20-58><a href=#cb20-58></a>            happy += cities[index].happy; </span>
<span id=cb20-59><a href=#cb20-59></a>        }    </span>
<span id=cb20-60><a href=#cb20-60></a>        <span class=cf>if</span>(happy &gt; maxHappy){ </span>
<span id=cb20-61><a href=#cb20-61></a>            bestPath = possiblePath; </span>
<span id=cb20-62><a href=#cb20-62></a>            maxHappy = happy; </span>
<span id=cb20-63><a href=#cb20-63></a>            maxAve = (<span class=dt>double</span>)happy/(<span class=dt>double</span>)(possiblePath.size()-<span class=dv>1</span>); </span>
<span id=cb20-64><a href=#cb20-64></a>        }<span class=cf>else</span> <span class=cf>if</span>(happy==maxHappy){ </span>
<span id=cb20-65><a href=#cb20-65></a>            <span class=dt>double</span> aveNow = (<span class=dt>double</span>)happy/(<span class=dt>double</span>)(possiblePath.size()-<span class=dv>1</span>); </span>
<span id=cb20-66><a href=#cb20-66></a>            <span class=cf>if</span>(aveNow&gt;maxAve){ </span>
<span id=cb20-67><a href=#cb20-67></a>                bestPath = possiblePath; </span>
<span id=cb20-68><a href=#cb20-68></a>                maxAve = aveNow;     </span>
<span id=cb20-69><a href=#cb20-69></a>            } </span>
<span id=cb20-70><a href=#cb20-70></a>        } </span>
<span id=cb20-71><a href=#cb20-71></a>        <span class=cf>return</span>; </span>
<span id=cb20-72><a href=#cb20-72></a>    } </span>
<span id=cb20-73><a href=#cb20-73></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>; i&lt;allPath[t].size(); i++){ </span>
<span id=cb20-74><a href=#cb20-74></a>        findBestPath(allPath[t][i]);     </span>
<span id=cb20-75><a href=#cb20-75></a>        possiblePath.pop_back();      </span>
<span id=cb20-76><a href=#cb20-76></a>    }    </span>
<span id=cb20-77><a href=#cb20-77></a>} </span>
<span id=cb20-78><a href=#cb20-78></a>   </span>
<span id=cb20-79><a href=#cb20-79></a><span class=dt>int</span> main(<span class=dt>int</span> argc, <span class=dt>char</span>** argv) { </span>
<span id=cb20-80><a href=#cb20-80></a>    <span class=dt>int</span> c, i, j, happy; </span>
<span id=cb20-81><a href=#cb20-81></a>    string start, from, to, str; </span>
<span id=cb20-82><a href=#cb20-82></a>    scanf(<span class=st>&quot;</span><span class=sc>%d%d</span><span class=st>&quot;</span>,&amp;cityNum, &amp;roadNum); </span>
<span id=cb20-83><a href=#cb20-83></a>    cin&gt;&gt;start; </span>
<span id=cb20-84><a href=#cb20-84></a>    cities.push_back(city(start,<span class=dv>0</span>)); </span>
<span id=cb20-85><a href=#cb20-85></a>    name2id[start] = <span class=dv>0</span>;<span class=co>//起点  </span></span>
<span id=cb20-86><a href=#cb20-86></a>    <span class=cf>for</span>(i=<span class=dv>1</span>; i&lt;cityNum; i++){ </span>
<span id=cb20-87><a href=#cb20-87></a>        cin&gt;&gt;str&gt;&gt;happy; </span>
<span id=cb20-88><a href=#cb20-88></a>        name2id[str] = i; </span>
<span id=cb20-89><a href=#cb20-89></a>        cities.push_back(city(str,happy)); </span>
<span id=cb20-90><a href=#cb20-90></a>    } </span>
<span id=cb20-91><a href=#cb20-91></a>    cost.resize(cityNum, vector&lt;<span class=dt>int</span>&gt;(cityNum,INF)); </span>
<span id=cb20-92><a href=#cb20-92></a>       </span>
<span id=cb20-93><a href=#cb20-93></a>    <span class=cf>for</span>(i=<span class=dv>0</span>; i&lt;roadNum; i++){ </span>
<span id=cb20-94><a href=#cb20-94></a>        cin&gt;&gt;from&gt;&gt;to&gt;&gt;c; </span>
<span id=cb20-95><a href=#cb20-95></a>        <span class=dt>int</span> a = name2id[from]; </span>
<span id=cb20-96><a href=#cb20-96></a>        <span class=dt>int</span> b = name2id[to];     </span>
<span id=cb20-97><a href=#cb20-97></a>        cost[a][b] = cost[b][a] = c;     </span>
<span id=cb20-98><a href=#cb20-98></a>    } </span>
<span id=cb20-99><a href=#cb20-99></a>    dist.resize(cityNum,INF); </span>
<span id=cb20-100><a href=#cb20-100></a>    <span class=cf>for</span>(i=<span class=dv>0</span>; i&lt;cityNum; i++) </span>
<span id=cb20-101><a href=#cb20-101></a>       dist[i] = cost[<span class=dv>0</span>][i]; </span>
<span id=cb20-102><a href=#cb20-102></a>           </span>
<span id=cb20-103><a href=#cb20-103></a>    <span class=dt>int</span> s = <span class=dv>0</span>;<span class=co>//起点 </span></span>
<span id=cb20-104><a href=#cb20-104></a>    <span class=dt>int</span> t = name2id[<span class=st>&quot;ROM&quot;</span>];<span class=co>//终点  </span></span>
<span id=cb20-105><a href=#cb20-105></a>    visited.resize(cityNum,<span class=kw>false</span>); </span>
<span id=cb20-106><a href=#cb20-106></a>    allPath.resize(cityNum); </span>
<span id=cb20-107><a href=#cb20-107></a>    dijkstra(s);<span class=co>//查找从起点出发的所有最短路  </span></span>
<span id=cb20-108><a href=#cb20-108></a>    findBestPath(t);<span class=co>//找到最短路中的最优解  </span></span>
<span id=cb20-109><a href=#cb20-109></a>    <span class=dt>int</span> minCost=<span class=dv>0</span>; </span>
<span id=cb20-110><a href=#cb20-110></a>    <span class=cf>for</span>(i=bestPath.size()-<span class=dv>1</span>; i&gt;<span class=dv>0</span>; i--){ </span>
<span id=cb20-111><a href=#cb20-111></a>        <span class=dt>int</span> a = bestPath[i]; </span>
<span id=cb20-112><a href=#cb20-112></a>        <span class=dt>int</span> b = bestPath[i-<span class=dv>1</span>]; </span>
<span id=cb20-113><a href=#cb20-113></a>        minCost += cost[a][b]; </span>
<span id=cb20-114><a href=#cb20-114></a>    }        </span>
<span id=cb20-115><a href=#cb20-115></a>    cout&lt;&lt;pathNum&lt;&lt;<span class=st>&quot; &quot;</span>&lt;&lt;minCost&lt;&lt;<span class=st>&quot; &quot;</span>&lt;&lt;maxHappy&lt;&lt;<span class=st>&quot; &quot;</span>&lt;&lt;(<span class=dt>int</span>)maxAve&lt;&lt;endl; </span>
<span id=cb20-116><a href=#cb20-116></a>    <span class=cf>for</span>(i=bestPath.size()-<span class=dv>1</span>; i&gt;=<span class=dv>0</span>; i--){ </span>
<span id=cb20-117><a href=#cb20-117></a>        string name = cities[bestPath[i]].name; </span>
<span id=cb20-118><a href=#cb20-118></a>        <span class=cf>if</span>(i!=<span class=dv>0</span>)  </span>
<span id=cb20-119><a href=#cb20-119></a>            cout&lt;&lt;name&lt;&lt;<span class=st>&quot;-&gt;&quot;</span>; </span>
<span id=cb20-120><a href=#cb20-120></a>        <span class=cf>else</span> </span>
<span id=cb20-121><a href=#cb20-121></a>            cout&lt;&lt;name&lt;&lt;endl; </span>
<span id=cb20-122><a href=#cb20-122></a>    }    </span>
<span id=cb20-123><a href=#cb20-123></a>    <span class=cf>return</span> <span class=dv>0</span>; </span>
<span id=cb20-124><a href=#cb20-124></a>}</span></code></pre></div><p>另一个相似实现</p><div class=sourceCode id=cb21><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb21-1><a href=#cb21-1></a><span class=co>//转自牛客网牛友提交的代码</span></span>
<span id=cb21-2><a href=#cb21-2></a><span class=co>//https://www.nowcoder.com/profile/7316467/codeBookDetail?submissionId=9006304</span></span>
<span id=cb21-3><a href=#cb21-3></a><span class=pp>#include</span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb21-4><a href=#cb21-4></a><span class=pp>#include</span><span class=im>&lt;vector&gt;</span></span>
<span id=cb21-5><a href=#cb21-5></a><span class=pp>#include</span><span class=im>&lt;string&gt;</span></span>
<span id=cb21-6><a href=#cb21-6></a><span class=pp>#include</span><span class=im>&lt;map&gt;</span></span>
<span id=cb21-7><a href=#cb21-7></a><span class=pp>#define INF </span><span class=bn>0x3f3f3f3f</span></span>
<span id=cb21-8><a href=#cb21-8></a> </span>
<span id=cb21-9><a href=#cb21-9></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb21-10><a href=#cb21-10></a> </span>
<span id=cb21-11><a href=#cb21-11></a><span class=kw>struct</span> City</span>
<span id=cb21-12><a href=#cb21-12></a>{</span>
<span id=cb21-13><a href=#cb21-13></a>    <span class=dt>int</span> Position, Happy;</span>
<span id=cb21-14><a href=#cb21-14></a>};</span>
<span id=cb21-15><a href=#cb21-15></a> </span>
<span id=cb21-16><a href=#cb21-16></a>City cst_cty(<span class=dt>int</span> happy, <span class=dt>int</span> position) {</span>
<span id=cb21-17><a href=#cb21-17></a>    City new_city;</span>
<span id=cb21-18><a href=#cb21-18></a>    new_city.Happy = happy;</span>
<span id=cb21-19><a href=#cb21-19></a>    new_city.Position = position;</span>
<span id=cb21-20><a href=#cb21-20></a>    <span class=cf>return</span> new_city;</span>
<span id=cb21-21><a href=#cb21-21></a>}</span>
<span id=cb21-22><a href=#cb21-22></a> </span>
<span id=cb21-23><a href=#cb21-23></a><span class=dt>void</span> dfs(<span class=dt>int</span> cur, vector&lt;<span class=dt>bool</span>&gt;&amp; vis, vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt;&amp; pre, vector&lt;<span class=dt>int</span>&gt;&amp; path, <span class=dt>double</span>&amp; max_avg, <span class=dt>int</span>&amp; max_happiness,<span class=dt>int</span> end,<span class=dt>int</span> temp_hap, map&lt;<span class=dt>int</span>, string&gt;&amp; pos_name, map&lt;string, City&gt;&amp; name_info, vector&lt;<span class=dt>int</span>&gt;&amp; temp_path) {</span>
<span id=cb21-24><a href=#cb21-24></a>    vis[cur] = <span class=kw>true</span>;</span>
<span id=cb21-25><a href=#cb21-25></a>    temp_path.push_back(cur);</span>
<span id=cb21-26><a href=#cb21-26></a>    <span class=co>//temp_hap += name_info[pos_name[cur]].Happy;</span></span>
<span id=cb21-27><a href=#cb21-27></a>    <span class=cf>if</span> (cur==end)</span>
<span id=cb21-28><a href=#cb21-28></a>    {</span>
<span id=cb21-29><a href=#cb21-29></a>        <span class=dt>int</span> temp_hap = <span class=dv>0</span>;</span>
<span id=cb21-30><a href=#cb21-30></a>        <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; <span class=dt>int</span>(temp_path.size()); i++)</span>
<span id=cb21-31><a href=#cb21-31></a>        {</span>
<span id=cb21-32><a href=#cb21-32></a>            <span class=dt>int</span> cur = temp_path[i];</span>
<span id=cb21-33><a href=#cb21-33></a>            temp_hap += name_info[pos_name[cur]].Happy;</span>
<span id=cb21-34><a href=#cb21-34></a>        }</span>
<span id=cb21-35><a href=#cb21-35></a>        <span class=dt>double</span> temp_avg = temp_hap*<span class=fl>1.0</span> / (temp_path.size() - <span class=dv>1</span>);</span>
<span id=cb21-36><a href=#cb21-36></a>        <span class=cf>if</span> (temp_hap&gt;max_happiness)</span>
<span id=cb21-37><a href=#cb21-37></a>        {</span>
<span id=cb21-38><a href=#cb21-38></a>            max_happiness = temp_hap;</span>
<span id=cb21-39><a href=#cb21-39></a>            path = temp_path;</span>
<span id=cb21-40><a href=#cb21-40></a>            max_avg = temp_avg;</span>
<span id=cb21-41><a href=#cb21-41></a>        }</span>
<span id=cb21-42><a href=#cb21-42></a>        <span class=cf>else</span> <span class=cf>if</span> (temp_hap==max_happiness&amp;&amp;temp_avg&gt;max_avg)</span>
<span id=cb21-43><a href=#cb21-43></a>        {</span>
<span id=cb21-44><a href=#cb21-44></a>            max_avg = temp_avg;</span>
<span id=cb21-45><a href=#cb21-45></a>            path = temp_path;</span>
<span id=cb21-46><a href=#cb21-46></a>        }</span>
<span id=cb21-47><a href=#cb21-47></a>    }</span>
<span id=cb21-48><a href=#cb21-48></a>    <span class=cf>for</span> (vector&lt;<span class=dt>int</span>&gt;::iterator it = pre[cur].begin(); it != pre[cur].end(); it++)</span>
<span id=cb21-49><a href=#cb21-49></a>    {</span>
<span id=cb21-50><a href=#cb21-50></a>        <span class=co>//if (vis[*it]==false)</span></span>
<span id=cb21-51><a href=#cb21-51></a>        <span class=co>//{</span></span>
<span id=cb21-52><a href=#cb21-52></a>            dfs(*it, vis, pre, path, max_avg, max_happiness, end, temp_hap, pos_name, name_info, temp_path);</span>
<span id=cb21-53><a href=#cb21-53></a>        <span class=co>//}</span></span>
<span id=cb21-54><a href=#cb21-54></a>    }</span>
<span id=cb21-55><a href=#cb21-55></a>    <span class=co>//temp_hap -= name_info[pos_name[cur]].Happy;</span></span>
<span id=cb21-56><a href=#cb21-56></a>    temp_path.pop_back();</span>
<span id=cb21-57><a href=#cb21-57></a>}</span>
<span id=cb21-58><a href=#cb21-58></a> </span>
<span id=cb21-59><a href=#cb21-59></a><span class=dt>int</span> main() {</span>
<span id=cb21-60><a href=#cb21-60></a>    <span class=dt>int</span> N, K;</span>
<span id=cb21-61><a href=#cb21-61></a>    string start;</span>
<span id=cb21-62><a href=#cb21-62></a>    cin &gt;&gt; N &gt;&gt; K &gt;&gt; start;</span>
<span id=cb21-63><a href=#cb21-63></a>    map&lt;string, City&gt; name_info;</span>
<span id=cb21-64><a href=#cb21-64></a>    map&lt;<span class=dt>int</span>, string&gt; pos_name;</span>
<span id=cb21-65><a href=#cb21-65></a>    name_info[start] = cst_cty(<span class=dv>0</span>, <span class=dv>0</span>);</span>
<span id=cb21-66><a href=#cb21-66></a>    pos_name[<span class=dv>0</span>] = start;</span>
<span id=cb21-67><a href=#cb21-67></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt; N; i++)</span>
<span id=cb21-68><a href=#cb21-68></a>    {</span>
<span id=cb21-69><a href=#cb21-69></a>        <span class=dt>int</span> temp_happy;</span>
<span id=cb21-70><a href=#cb21-70></a>        string temp_name;</span>
<span id=cb21-71><a href=#cb21-71></a>        cin &gt;&gt; temp_name &gt;&gt; temp_happy;</span>
<span id=cb21-72><a href=#cb21-72></a>        name_info[temp_name] = cst_cty(temp_happy, i);</span>
<span id=cb21-73><a href=#cb21-73></a>        pos_name[i] = temp_name;</span>
<span id=cb21-74><a href=#cb21-74></a>    }</span>
<span id=cb21-75><a href=#cb21-75></a>    vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt; mat(N, vector&lt;<span class=dt>int</span>&gt;(N, <span class=dv>0</span>));</span>
<span id=cb21-76><a href=#cb21-76></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; K; i++)</span>
<span id=cb21-77><a href=#cb21-77></a>    {</span>
<span id=cb21-78><a href=#cb21-78></a>        string name_a, name_b;</span>
<span id=cb21-79><a href=#cb21-79></a>        <span class=dt>int</span> cost;</span>
<span id=cb21-80><a href=#cb21-80></a>        cin &gt;&gt; name_a &gt;&gt; name_b &gt;&gt; cost;</span>
<span id=cb21-81><a href=#cb21-81></a>        mat[name_info[name_a].Position][name_info[name_b].Position] = mat[name_info[name_b].Position][name_info[name_a].Position] = cost;</span>
<span id=cb21-82><a href=#cb21-82></a>    }</span>
<span id=cb21-83><a href=#cb21-83></a>    <span class=co>//初始化</span></span>
<span id=cb21-84><a href=#cb21-84></a>    <span class=co>//djk</span></span>
<span id=cb21-85><a href=#cb21-85></a>    vector&lt;vector&lt;<span class=dt>int</span>&gt;&gt; pre(N, vector&lt;<span class=dt>int</span>&gt;());<span class=co>//记录最短路径的自终点开始的前驱节点</span></span>
<span id=cb21-86><a href=#cb21-86></a>    vector&lt;<span class=dt>int</span>&gt; dis(N, INF);</span>
<span id=cb21-87><a href=#cb21-87></a>    vector&lt;<span class=dt>bool</span>&gt; vis(N, <span class=kw>false</span>);</span>
<span id=cb21-88><a href=#cb21-88></a>    <span class=dt>int</span> start_cty = name_info[start].Position, end_cty = name_info[<span class=st>&quot;ROM&quot;</span>].Position;</span>
<span id=cb21-89><a href=#cb21-89></a>    dis[start_cty] = <span class=dv>0</span>;<span class=co>//dis[i]记录起始点到i点的最短距离</span></span>
<span id=cb21-90><a href=#cb21-90></a>    vector&lt;<span class=dt>int</span>&gt; path_cnt(N, <span class=dv>0</span>);</span>
<span id=cb21-91><a href=#cb21-91></a>    path_cnt[start_cty] = <span class=dv>1</span>;</span>
<span id=cb21-92><a href=#cb21-92></a>    <span class=cf>while</span> (<span class=kw>true</span>)</span>
<span id=cb21-93><a href=#cb21-93></a>    {</span>
<span id=cb21-94><a href=#cb21-94></a>        <span class=dt>int</span> cur_node = -<span class=dv>1</span>, min_dis = INF;</span>
<span id=cb21-95><a href=#cb21-95></a>        <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; N; i++)</span>
<span id=cb21-96><a href=#cb21-96></a>        {</span>
<span id=cb21-97><a href=#cb21-97></a>            <span class=cf>if</span> (vis[i]==<span class=kw>false</span>&amp;&amp;dis[i]&lt;min_dis)</span>
<span id=cb21-98><a href=#cb21-98></a>            {</span>
<span id=cb21-99><a href=#cb21-99></a>                min_dis = dis[i];</span>
<span id=cb21-100><a href=#cb21-100></a>                cur_node = i;</span>
<span id=cb21-101><a href=#cb21-101></a>            }</span>
<span id=cb21-102><a href=#cb21-102></a>        }<span class=co>//找到当前情况下既没有访问过同时又离起始节点距离最小的节点</span></span>
<span id=cb21-103><a href=#cb21-103></a> </span>
<span id=cb21-104><a href=#cb21-104></a>        <span class=co>//if (min_dis == INF || cur_node == end_cty)</span></span>
<span id=cb21-105><a href=#cb21-105></a>        <span class=cf>if</span> (cur_node==-<span class=dv>1</span>)</span>
<span id=cb21-106><a href=#cb21-106></a>        {</span>
<span id=cb21-107><a href=#cb21-107></a>            <span class=cf>break</span>;</span>
<span id=cb21-108><a href=#cb21-108></a>        }</span>
<span id=cb21-109><a href=#cb21-109></a>        <span class=co>//min_dis为无穷表示找不到最小的边</span></span>
<span id=cb21-110><a href=#cb21-110></a> </span>
<span id=cb21-111><a href=#cb21-111></a>        vis[cur_node] = <span class=kw>true</span>;</span>
<span id=cb21-112><a href=#cb21-112></a> </span>
<span id=cb21-113><a href=#cb21-113></a>        <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; N; i++)</span>
<span id=cb21-114><a href=#cb21-114></a>        {</span>
<span id=cb21-115><a href=#cb21-115></a>            <span class=cf>if</span> (vis[i]==<span class=kw>false</span>&amp;&amp;mat[cur_node][i]&gt;<span class=dv>0</span>)<span class=co>//考察离起始点最近的节点相连的节点是否需要更新</span></span>
<span id=cb21-116><a href=#cb21-116></a>            {</span>
<span id=cb21-117><a href=#cb21-117></a>                <span class=cf>if</span> (dis[i]&gt;dis[cur_node]+mat[cur_node][i])</span>
<span id=cb21-118><a href=#cb21-118></a>                {</span>
<span id=cb21-119><a href=#cb21-119></a>                    dis[i] = dis[cur_node] + mat[cur_node][i];</span>
<span id=cb21-120><a href=#cb21-120></a>                    pre[i].clear();</span>
<span id=cb21-121><a href=#cb21-121></a>                    pre[i].push_back(cur_node);</span>
<span id=cb21-122><a href=#cb21-122></a>                    path_cnt[i] = path_cnt[cur_node];</span>
<span id=cb21-123><a href=#cb21-123></a>                }</span>
<span id=cb21-124><a href=#cb21-124></a>                <span class=cf>else</span> <span class=cf>if</span> (dis[i]==dis[cur_node]+mat[cur_node][i])<span class=co>//不能写成if，否则前面修改了dis[i]之后，后面必然是相等的，这样，两个if语句都会执行</span></span>
<span id=cb21-125><a href=#cb21-125></a>                {</span>
<span id=cb21-126><a href=#cb21-126></a>                    pre[i].push_back(cur_node);</span>
<span id=cb21-127><a href=#cb21-127></a>                    path_cnt[i] += path_cnt[cur_node];</span>
<span id=cb21-128><a href=#cb21-128></a>                }</span>
<span id=cb21-129><a href=#cb21-129></a>            }</span>
<span id=cb21-130><a href=#cb21-130></a>        }</span>
<span id=cb21-131><a href=#cb21-131></a>    }</span>
<span id=cb21-132><a href=#cb21-132></a>    <span class=co>//pre记录前驱节点，然后使用dfs从终点逆序遍历</span></span>
<span id=cb21-133><a href=#cb21-133></a>     </span>
<span id=cb21-134><a href=#cb21-134></a>    <span class=co>//dfs部分</span></span>
<span id=cb21-135><a href=#cb21-135></a>    vector&lt;<span class=dt>int</span>&gt; temp_path, path;</span>
<span id=cb21-136><a href=#cb21-136></a>    <span class=dt>int</span>  max_happiness = <span class=dv>0</span>;</span>
<span id=cb21-137><a href=#cb21-137></a>    <span class=dt>double</span> max_avg = <span class=fl>0.0</span>;</span>
<span id=cb21-138><a href=#cb21-138></a>    dfs(end_cty, vis, pre, path, max_avg, max_happiness, start_cty, <span class=dv>0</span>, pos_name, name_info, temp_path);</span>
<span id=cb21-139><a href=#cb21-139></a>    cout &lt;&lt; path_cnt[end_cty] &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; dis[end_cty] &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; max_happiness &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; <span class=dt>int</span>(max_avg) &lt;&lt; endl;</span>
<span id=cb21-140><a href=#cb21-140></a>    cout &lt;&lt; pos_name[start_cty];</span>
<span id=cb21-141><a href=#cb21-141></a>    <span class=cf>for</span> (<span class=dt>int</span> i = <span class=dt>int</span>(path.size()-<span class=dv>2</span>); i &gt;= <span class=dv>0</span>; i--)</span>
<span id=cb21-142><a href=#cb21-142></a>    {</span>
<span id=cb21-143><a href=#cb21-143></a>        cout &lt;&lt; <span class=st>&quot;-&gt;&quot;</span> &lt;&lt; pos_name[path[i]];</span>
<span id=cb21-144><a href=#cb21-144></a>    }</span>
<span id=cb21-145><a href=#cb21-145></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb21-146><a href=#cb21-146></a>}</span></code></pre></div><h6 id=方法3dfs加剪枝>方法3：DFS加剪枝</h6><div class=sourceCode id=cb22><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb22-1><a href=#cb22-1></a><span class=co>//链接：https://www.nowcoder.com/questionTerminal/bf8045decb1348a3bd6967305cbdad4c</span></span>
<span id=cb22-2><a href=#cb22-2></a><span class=co>//来源：牛客网——牛客156003592号的讨论代码</span></span>
<span id=cb22-3><a href=#cb22-3></a></span>
<span id=cb22-4><a href=#cb22-4></a><span class=pp>#include </span><span class=im>&lt;cstdio&gt;</span></span>
<span id=cb22-5><a href=#cb22-5></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb22-6><a href=#cb22-6></a><span class=pp>#include </span><span class=im>&lt;queue&gt;</span></span>
<span id=cb22-7><a href=#cb22-7></a><span class=pp>#include </span><span class=im>&lt;utility&gt;</span></span>
<span id=cb22-8><a href=#cb22-8></a><span class=pp>#include </span><span class=im>&lt;string&gt;</span></span>
<span id=cb22-9><a href=#cb22-9></a><span class=pp>#include </span><span class=im>&lt;map&gt;</span></span>
<span id=cb22-10><a href=#cb22-10></a> </span>
<span id=cb22-11><a href=#cb22-11></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb22-12><a href=#cb22-12></a> </span>
<span id=cb22-13><a href=#cb22-13></a><span class=pp>#define INF </span><span class=bn>0x3f3f3f3f</span></span>
<span id=cb22-14><a href=#cb22-14></a> </span>
<span id=cb22-15><a href=#cb22-15></a> </span>
<span id=cb22-16><a href=#cb22-16></a>map&lt;string, <span class=dt>int</span>&gt; to_id;</span>
<span id=cb22-17><a href=#cb22-17></a>map&lt;<span class=dt>int</span>, string&gt; to_name;</span>
<span id=cb22-18><a href=#cb22-18></a> </span>
<span id=cb22-19><a href=#cb22-19></a> </span>
<span id=cb22-20><a href=#cb22-20></a>vector&lt;<span class=dt>int</span>&gt; hps(<span class=dv>200</span>);</span>
<span id=cb22-21><a href=#cb22-21></a>vector&lt;vector&lt;pair&lt;<span class=dt>int</span>, <span class=dt>int</span>&gt;&gt;&gt; graph(<span class=dv>200</span>);</span>
<span id=cb22-22><a href=#cb22-22></a>vector&lt;<span class=dt>bool</span>&gt; visited(<span class=dv>200</span>);</span>
<span id=cb22-23><a href=#cb22-23></a>vector&lt;<span class=dt>int</span>&gt; path;</span>
<span id=cb22-24><a href=#cb22-24></a>vector&lt;<span class=dt>int</span>&gt; ans;</span>
<span id=cb22-25><a href=#cb22-25></a><span class=dt>int</span> min_cost = INF;</span>
<span id=cb22-26><a href=#cb22-26></a><span class=dt>int</span> max_hp = -INF;</span>
<span id=cb22-27><a href=#cb22-27></a><span class=dt>int</span> avg_hp = -INF;</span>
<span id=cb22-28><a href=#cb22-28></a><span class=dt>int</span> diff_cnt = <span class=dv>0</span>;</span>
<span id=cb22-29><a href=#cb22-29></a> </span>
<span id=cb22-30><a href=#cb22-30></a><span class=dt>void</span> dfs(<span class=dt>int</span> curr, <span class=dt>int</span> cost, <span class=dt>int</span> hp){</span>
<span id=cb22-31><a href=#cb22-31></a>    visited[curr] = <span class=kw>true</span>;</span>
<span id=cb22-32><a href=#cb22-32></a>    path.push_back(curr);</span>
<span id=cb22-33><a href=#cb22-33></a>    <span class=cf>if</span>(curr == to_id[string(<span class=st>&quot;ROM&quot;</span>)]){</span>
<span id=cb22-34><a href=#cb22-34></a>        <span class=cf>if</span>(cost &lt; min_cost){</span>
<span id=cb22-35><a href=#cb22-35></a>            min_cost = cost;</span>
<span id=cb22-36><a href=#cb22-36></a>            max_hp = hp;</span>
<span id=cb22-37><a href=#cb22-37></a>            avg_hp = hp / (path.size() - <span class=dv>1</span>);</span>
<span id=cb22-38><a href=#cb22-38></a>            diff_cnt = <span class=dv>1</span>;</span>
<span id=cb22-39><a href=#cb22-39></a>            ans = path;</span>
<span id=cb22-40><a href=#cb22-40></a>        }</span>
<span id=cb22-41><a href=#cb22-41></a>        <span class=cf>else</span>{</span>
<span id=cb22-42><a href=#cb22-42></a>            diff_cnt++;</span>
<span id=cb22-43><a href=#cb22-43></a>            <span class=cf>if</span>(hp &gt; max_hp){</span>
<span id=cb22-44><a href=#cb22-44></a>                max_hp = hp;</span>
<span id=cb22-45><a href=#cb22-45></a>                avg_hp = hp / (path.size() - <span class=dv>1</span>);</span>
<span id=cb22-46><a href=#cb22-46></a>                ans = path;</span>
<span id=cb22-47><a href=#cb22-47></a>            }</span>
<span id=cb22-48><a href=#cb22-48></a>            <span class=cf>else</span> <span class=cf>if</span>(hp == max_hp){</span>
<span id=cb22-49><a href=#cb22-49></a>                <span class=cf>if</span>((<span class=dt>int</span>) (hp / (path.size() - <span class=dv>1</span>)) &gt; avg_hp){</span>
<span id=cb22-50><a href=#cb22-50></a>                    avg_hp = hp / (path.size() - <span class=dv>1</span>);</span>
<span id=cb22-51><a href=#cb22-51></a>                    ans = path;</span>
<span id=cb22-52><a href=#cb22-52></a>                }</span>
<span id=cb22-53><a href=#cb22-53></a>            }</span>
<span id=cb22-54><a href=#cb22-54></a>        }</span>
<span id=cb22-55><a href=#cb22-55></a>    }</span>
<span id=cb22-56><a href=#cb22-56></a>    <span class=cf>for</span>(<span class=kw>auto</span>&amp; p : graph[curr]){</span>
<span id=cb22-57><a href=#cb22-57></a>        <span class=dt>int</span> to = p.first;</span>
<span id=cb22-58><a href=#cb22-58></a>        <span class=dt>int</span> c = p.second;</span>
<span id=cb22-59><a href=#cb22-59></a>        <span class=cf>if</span>(visited[to]) <span class=cf>continue</span>;</span>
<span id=cb22-60><a href=#cb22-60></a>        <span class=cf>if</span>(cost + c &gt; min_cost) <span class=cf>continue</span>;</span>
<span id=cb22-61><a href=#cb22-61></a>        dfs(to, cost + c, hp + hps[to]);</span>
<span id=cb22-62><a href=#cb22-62></a>    }</span>
<span id=cb22-63><a href=#cb22-63></a>    visited[curr] = <span class=kw>false</span>;</span>
<span id=cb22-64><a href=#cb22-64></a>    path.pop_back();</span>
<span id=cb22-65><a href=#cb22-65></a>}</span>
<span id=cb22-66><a href=#cb22-66></a> </span>
<span id=cb22-67><a href=#cb22-67></a><span class=dt>int</span> main(){</span>
<span id=cb22-68><a href=#cb22-68></a>    ios::sync_with_stdio(<span class=kw>false</span>);</span>
<span id=cb22-69><a href=#cb22-69></a>    <span class=dt>int</span> N, K;</span>
<span id=cb22-70><a href=#cb22-70></a>    string start;</span>
<span id=cb22-71><a href=#cb22-71></a>    cin &gt;&gt; N &gt;&gt; K &gt;&gt; start;</span>
<span id=cb22-72><a href=#cb22-72></a>    to_id[start] = <span class=dv>0</span>;</span>
<span id=cb22-73><a href=#cb22-73></a>    to_name[<span class=dv>0</span>] = start;</span>
<span id=cb22-74><a href=#cb22-74></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= N - <span class=dv>1</span>; i++){</span>
<span id=cb22-75><a href=#cb22-75></a>        string city;</span>
<span id=cb22-76><a href=#cb22-76></a>        <span class=dt>int</span> hp;</span>
<span id=cb22-77><a href=#cb22-77></a>        cin &gt;&gt; city &gt;&gt; hp;</span>
<span id=cb22-78><a href=#cb22-78></a>        to_id[city] = i;</span>
<span id=cb22-79><a href=#cb22-79></a>        to_name[i] = city;</span>
<span id=cb22-80><a href=#cb22-80></a>        hps[i] = hp;</span>
<span id=cb22-81><a href=#cb22-81></a>    }</span>
<span id=cb22-82><a href=#cb22-82></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; K; i++){</span>
<span id=cb22-83><a href=#cb22-83></a>        string city1, city2;</span>
<span id=cb22-84><a href=#cb22-84></a>        <span class=dt>int</span> from, to, cost;</span>
<span id=cb22-85><a href=#cb22-85></a>        cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; cost;</span>
<span id=cb22-86><a href=#cb22-86></a>        from = to_id[city1];</span>
<span id=cb22-87><a href=#cb22-87></a>        to = to_id[city2];</span>
<span id=cb22-88><a href=#cb22-88></a>        graph[from].emplace_back(to, cost);</span>
<span id=cb22-89><a href=#cb22-89></a>        graph[to].emplace_back(from, cost);</span>
<span id=cb22-90><a href=#cb22-90></a>    }</span>
<span id=cb22-91><a href=#cb22-91></a>    dfs(<span class=dv>0</span>, <span class=dv>0</span>, <span class=dv>0</span>);</span>
<span id=cb22-92><a href=#cb22-92></a>    cout &lt;&lt; diff_cnt &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; min_cost &lt;&lt; <span class=st>&quot; &quot;</span>;</span>
<span id=cb22-93><a href=#cb22-93></a>    cout &lt;&lt; max_hp &lt;&lt; <span class=st>&quot; &quot;</span> &lt;&lt; avg_hp &lt;&lt; endl;</span>
<span id=cb22-94><a href=#cb22-94></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; (<span class=dt>int</span>)ans.size(); i++){</span>
<span id=cb22-95><a href=#cb22-95></a>        <span class=cf>if</span>(i) cout &lt;&lt; <span class=st>&quot;-&gt;&quot;</span>;</span>
<span id=cb22-96><a href=#cb22-96></a>        cout &lt;&lt; to_name[ans[i]];</span>
<span id=cb22-97><a href=#cb22-97></a>    }</span>
<span id=cb22-98><a href=#cb22-98></a>    cout &lt;&lt; endl;</span>
<span id=cb22-99><a href=#cb22-99></a>}</span></code></pre></div><p>总感觉这位牛友diff_cnt++;这句代码应该加个判断是不是cost相等。但是人家的代码通过了，amazing。</p><h2 id=排序问题>排序问题</h2><h5 id=例1-4>例1</h5><h6 id=插入还是堆排序>插入还是堆排序</h6><p>给原始序列、排序排到一半的序列。问排序方法是插入排序还是堆排序。然后要求给出下一步的排序结果</p><p>两种排序的区别： 插入排序前面部分是排好的，后面的部分没有改变（稳定的排序） 堆排序后面部分是排好的，前面部分也发生了改变（不稳定） 可根据以上两种排序的特点确定是堆排序还是插入排序。</p><p>注意插入排序和堆排序的排序过程，继续排一步</p><h6 id=题解>题解</h6><div class=sourceCode id=cb23><pre class="sourceCode java"><code class="sourceCode java"><span id=cb23-1><a href=#cb23-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb23-2><a href=#cb23-2></a></span>
<span id=cb23-3><a href=#cb23-3></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb23-4><a href=#cb23-4></a></span>
<span id=cb23-5><a href=#cb23-5></a><span class=co>/**</span></span>
<span id=cb23-6><a href=#cb23-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb23-7><a href=#cb23-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/1</span> <span class=co>10:25</span></span>
<span id=cb23-8><a href=#cb23-8></a> <span class=co>*</span> <span class=co>@</span>discription<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4322</span></span>
<span id=cb23-9><a href=#cb23-9></a> <span class=co>*</span> 插入排序、堆排序</span>
<span id=cb23-10><a href=#cb23-10></a> <span class=co>*/</span></span>
<span id=cb23-11><a href=#cb23-11></a><span class=kw>public</span> <span class=kw>class</span> Advanced1009 {</span>
<span id=cb23-12><a href=#cb23-12></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb23-13><a href=#cb23-13></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb23-14><a href=#cb23-14></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb23-15><a href=#cb23-15></a>        <span class=dt>int</span>[] a = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb23-16><a href=#cb23-16></a>        <span class=dt>int</span>[] b = <span class=kw>new</span> <span class=dt>int</span>[n];</span>
<span id=cb23-17><a href=#cb23-17></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb23-18><a href=#cb23-18></a>            a[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb23-19><a href=#cb23-19></a>        }</span>
<span id=cb23-20><a href=#cb23-20></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb23-21><a href=#cb23-21></a>            b[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb23-22><a href=#cb23-22></a>        }</span>
<span id=cb23-23><a href=#cb23-23></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb23-24><a href=#cb23-24></a>        <span class=co>//如果是插入排序，返回的是一个大于0的数（已排序个数）</span></span>
<span id=cb23-25><a href=#cb23-25></a>        <span class=dt>int</span> insertionSortLength = <span class=fu>insertionSortLength</span>(a, b);</span>
<span id=cb23-26><a href=#cb23-26></a>        sb.<span class=fu>append</span>(insertionSortLength &gt; <span class=dv>0</span> ? <span class=st>&quot;Insertion Sort&quot;</span> : <span class=st>&quot;Heap Sort&quot;</span>).<span class=fu>append</span>(<span class=st>&quot;</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb23-27><a href=#cb23-27></a>        <span class=kw>if</span> (insertionSortLength &gt; <span class=dv>0</span>) {</span>
<span id=cb23-28><a href=#cb23-28></a>            <span class=co>//如果是插入排序，继续排一步</span></span>
<span id=cb23-29><a href=#cb23-29></a>            <span class=fu>nextInsertionSort</span>(b, insertionSortLength);</span>
<span id=cb23-30><a href=#cb23-30></a>        } <span class=kw>else</span> {</span>
<span id=cb23-31><a href=#cb23-31></a>            <span class=co>//如果是堆排序，确定排到哪个位置了（pos是堆尾）</span></span>
<span id=cb23-32><a href=#cb23-32></a>            <span class=dt>int</span> pos = <span class=fu>heapSortNextPos</span>(a, b);</span>
<span id=cb23-33><a href=#cb23-33></a>            <span class=kw>if</span> (pos &gt; <span class=dv>0</span>) {</span>
<span id=cb23-34><a href=#cb23-34></a>                <span class=co>//继续排一步</span></span>
<span id=cb23-35><a href=#cb23-35></a>                <span class=fu>nextHeapSort</span>(b, pos);</span>
<span id=cb23-36><a href=#cb23-36></a>            }</span>
<span id=cb23-37><a href=#cb23-37></a>        }</span>
<span id=cb23-38><a href=#cb23-38></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb23-39><a href=#cb23-39></a>            sb.<span class=fu>append</span>(b[i]).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb23-40><a href=#cb23-40></a>        }</span>
<span id=cb23-41><a href=#cb23-41></a>        sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb23-42><a href=#cb23-42></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(sb);</span>
<span id=cb23-43><a href=#cb23-43></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb23-44><a href=#cb23-44></a>    }</span>
<span id=cb23-45><a href=#cb23-45></a></span>
<span id=cb23-46><a href=#cb23-46></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>int</span> <span class=fu>insertionSortLength</span>(<span class=dt>int</span>[] a, <span class=dt>int</span>[] b) {</span>
<span id=cb23-47><a href=#cb23-47></a>        <span class=dt>int</span> i = <span class=dv>1</span>;</span>
<span id=cb23-48><a href=#cb23-48></a>        <span class=kw>while</span> (i &lt; b.<span class=fu>length</span> &amp;&amp; b[i] &gt;= b[i - <span class=dv>1</span>]) {</span>
<span id=cb23-49><a href=#cb23-49></a>            i++;</span>
<span id=cb23-50><a href=#cb23-50></a>        }</span>
<span id=cb23-51><a href=#cb23-51></a>        <span class=dt>int</span> j = i;</span>
<span id=cb23-52><a href=#cb23-52></a>        <span class=kw>while</span> (j &lt; b.<span class=fu>length</span> &amp;&amp; a[j] == b[j]) {</span>
<span id=cb23-53><a href=#cb23-53></a>            j++;</span>
<span id=cb23-54><a href=#cb23-54></a>        }</span>
<span id=cb23-55><a href=#cb23-55></a>        <span class=kw>if</span> (j != b.<span class=fu>length</span>) {</span>
<span id=cb23-56><a href=#cb23-56></a>            i = <span class=dv>0</span>;</span>
<span id=cb23-57><a href=#cb23-57></a>        }</span>
<span id=cb23-58><a href=#cb23-58></a>        <span class=kw>return</span> i;</span>
<span id=cb23-59><a href=#cb23-59></a>    }</span>
<span id=cb23-60><a href=#cb23-60></a></span>
<span id=cb23-61><a href=#cb23-61></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>int</span> <span class=fu>heapSortNextPos</span>(<span class=dt>int</span>[] a, <span class=dt>int</span>[] b) {</span>
<span id=cb23-62><a href=#cb23-62></a>        <span class=dt>int</span> i = b.<span class=fu>length</span> - <span class=dv>2</span>;</span>
<span id=cb23-63><a href=#cb23-63></a>        <span class=kw>while</span> (i &gt;= <span class=dv>0</span> &amp;&amp; b[i] &lt;= b[i + <span class=dv>1</span>]) {</span>
<span id=cb23-64><a href=#cb23-64></a>            i--;</span>
<span id=cb23-65><a href=#cb23-65></a>        }</span>
<span id=cb23-66><a href=#cb23-66></a>        <span class=dt>int</span> max = -<span class=dv>1</span>;</span>
<span id=cb23-67><a href=#cb23-67></a>        <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt;= i; j++) {</span>
<span id=cb23-68><a href=#cb23-68></a>            <span class=kw>if</span> (b[j] &gt; max) {</span>
<span id=cb23-69><a href=#cb23-69></a>                max = b[j];</span>
<span id=cb23-70><a href=#cb23-70></a>            }</span>
<span id=cb23-71><a href=#cb23-71></a>        }</span>
<span id=cb23-72><a href=#cb23-72></a>        <span class=kw>while</span> (max &gt; b[i + <span class=dv>1</span>]) {</span>
<span id=cb23-73><a href=#cb23-73></a>            i++;</span>
<span id=cb23-74><a href=#cb23-74></a>        }</span>
<span id=cb23-75><a href=#cb23-75></a>        <span class=kw>return</span> i;</span>
<span id=cb23-76><a href=#cb23-76></a>    }</span>
<span id=cb23-77><a href=#cb23-77></a></span>
<span id=cb23-78><a href=#cb23-78></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>nextInsertionSort</span>(<span class=dt>int</span>[] b, <span class=dt>int</span> pos) {</span>
<span id=cb23-79><a href=#cb23-79></a>        <span class=dt>int</span> tmp = b[pos];</span>
<span id=cb23-80><a href=#cb23-80></a>        <span class=dt>int</span> i = pos - <span class=dv>1</span>;</span>
<span id=cb23-81><a href=#cb23-81></a>        <span class=kw>while</span> (i &gt;= <span class=dv>0</span> &amp;&amp; b[i] &gt; tmp) {</span>
<span id=cb23-82><a href=#cb23-82></a>            b[i + <span class=dv>1</span>] = b[i];</span>
<span id=cb23-83><a href=#cb23-83></a>            i--;</span>
<span id=cb23-84><a href=#cb23-84></a>        }</span>
<span id=cb23-85><a href=#cb23-85></a>        b[++i] = tmp;</span>
<span id=cb23-86><a href=#cb23-86></a>    }</span>
<span id=cb23-87><a href=#cb23-87></a></span>
<span id=cb23-88><a href=#cb23-88></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>nextHeapSort</span>(<span class=dt>int</span>[] b, <span class=dt>int</span> pos) {</span>
<span id=cb23-89><a href=#cb23-89></a>        <span class=co>//交换堆顶和堆尾，堆size--，从堆顶向下调整</span></span>
<span id=cb23-90><a href=#cb23-90></a>        <span class=dt>int</span> tmp = b[<span class=dv>0</span>];</span>
<span id=cb23-91><a href=#cb23-91></a>        b[<span class=dv>0</span>] = b[pos];</span>
<span id=cb23-92><a href=#cb23-92></a>        b[pos] = tmp;</span>
<span id=cb23-93><a href=#cb23-93></a>        <span class=fu>adjust</span>(b, <span class=dv>0</span>, pos);</span>
<span id=cb23-94><a href=#cb23-94></a>    }</span>
<span id=cb23-95><a href=#cb23-95></a>    <span class=co>/**</span></span>
<span id=cb23-96><a href=#cb23-96></a>    <span class=co>*</span> 堆排序的整体过程（这里只是方便参考，本题中没有用到）</span>
<span id=cb23-97><a href=#cb23-97></a>    <span class=co>*/</span></span>
<span id=cb23-98><a href=#cb23-98></a><span class=co>/*    private static void heapSort(int[] a) {</span></span>
<span id=cb23-99><a href=#cb23-99></a><span class=co>        //初始化堆:从第一个非叶子节点开始向前，每一个节点和其子节点进行递归调整</span></span>
<span id=cb23-100><a href=#cb23-100></a><span class=co>        int size = a.length;</span></span>
<span id=cb23-101><a href=#cb23-101></a><span class=co>        for (int i = (a.length - 1) / 2; i &gt;= 0; i--) {</span></span>
<span id=cb23-102><a href=#cb23-102></a><span class=co>            adjust(a, i, size);</span></span>
<span id=cb23-103><a href=#cb23-103></a><span class=co>        }</span></span>
<span id=cb23-104><a href=#cb23-104></a><span class=co>        //交换堆顶和堆尾，堆大小-1，从堆顶向下调整；重复直到堆变为空</span></span>
<span id=cb23-105><a href=#cb23-105></a><span class=co>        while (size &gt; 0) {</span></span>
<span id=cb23-106><a href=#cb23-106></a><span class=co>            //交换</span></span>
<span id=cb23-107><a href=#cb23-107></a><span class=co>            int tmp = a[size - 1];</span></span>
<span id=cb23-108><a href=#cb23-108></a><span class=co>            a[size - 1] = a[0];</span></span>
<span id=cb23-109><a href=#cb23-109></a><span class=co>            a[0] = tmp;</span></span>
<span id=cb23-110><a href=#cb23-110></a><span class=co>            //堆size--,从堆顶向下调整</span></span>
<span id=cb23-111><a href=#cb23-111></a><span class=co>            adjust(a, 0, --size);</span></span>
<span id=cb23-112><a href=#cb23-112></a><span class=co>        }</span></span>
<span id=cb23-113><a href=#cb23-113></a><span class=co>    }*/</span></span>
<span id=cb23-114><a href=#cb23-114></a></span>
<span id=cb23-115><a href=#cb23-115></a>    <span class=co>/**</span></span>
<span id=cb23-116><a href=#cb23-116></a>     <span class=co>*</span> 递归调整当前节点与其子节点</span>
<span id=cb23-117><a href=#cb23-117></a>     <span class=co>*</span> 可以优化为非递归形式（未实现）</span>
<span id=cb23-118><a href=#cb23-118></a>     <span class=co>*/</span></span>
<span id=cb23-119><a href=#cb23-119></a>    <span class=kw>private</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>adjust</span>(<span class=dt>int</span>[] heap, <span class=dt>int</span> pos, <span class=dt>int</span> heapSize) {</span>
<span id=cb23-120><a href=#cb23-120></a>        <span class=dt>int</span> left = pos * <span class=dv>2</span> + <span class=dv>1</span>;</span>
<span id=cb23-121><a href=#cb23-121></a>        <span class=dt>int</span> right = pos * <span class=dv>2</span> + <span class=dv>2</span>;</span>
<span id=cb23-122><a href=#cb23-122></a>        <span class=co>//找节点与其子节点中最大值的节点下标</span></span>
<span id=cb23-123><a href=#cb23-123></a>        <span class=dt>int</span> max = (left &lt; heapSize &amp;&amp; heap[left] &gt; heap[pos]) ? left : pos;</span>
<span id=cb23-124><a href=#cb23-124></a>        max = (right &lt; heapSize &amp;&amp; heap[right] &gt; heap[max]) ? right : max;</span>
<span id=cb23-125><a href=#cb23-125></a>        <span class=kw>if</span> (max != pos) {</span>
<span id=cb23-126><a href=#cb23-126></a>            <span class=co>//调整/交换</span></span>
<span id=cb23-127><a href=#cb23-127></a>            <span class=dt>int</span> tmp = heap[pos];</span>
<span id=cb23-128><a href=#cb23-128></a>            heap[pos] = heap[max];</span>
<span id=cb23-129><a href=#cb23-129></a>            heap[max] = tmp;</span>
<span id=cb23-130><a href=#cb23-130></a>            <span class=co>//递归调整子节点</span></span>
<span id=cb23-131><a href=#cb23-131></a>            <span class=fu>adjust</span>(heap, max, heapSize);</span>
<span id=cb23-132><a href=#cb23-132></a>        }</span>
<span id=cb23-133><a href=#cb23-133></a>    }</span>
<span id=cb23-134><a href=#cb23-134></a>}</span></code></pre></div><h2 id=动态规划>动态规划</h2><p>动态规划思想可以用来解决最优化问题。</p><p>最优化问题的形式 max/min 目标函数F() st. 限制条件（等式、不等式、变量范围限制）</p><h3 id=最长不下降子序列>最长不下降子序列</h3><p>最长子序列长度问题的介绍，在算法总结.md#动态规划</p><h4 id=例1-最长的可接受花色条纹子序列>例1 最长的可接受花色条纹子序列</h4><p>给一个序列，表示可接受的花色序列。再给一个序列，表示已有的花色序列。要从已有的花色序列中裁取可接受的花色序列（每种可接受的花色可保留多份）。</p><pre><code>比如已有的花色序列是 {2 2 4 1 5 5 6 3 1 1 5 6}.  可接受的花色序列是{2 3 1 5 6},
那么有如下的裁取方式{2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, 和 {2 2 3 1 1 5 6}.</code></pre><p><a href=https://www.nowcoder.com/pat/5/problem/4084>题目链接</a></p><h5 id=方法1-映射法-转换为最长不下降子序列长度问题>方法1 映射法 转换为最长不下降子序列长度问题</h5><p>参考：https://www.nowcoder.com/questionTerminal/0171de2cf94a43d690c336a363a41693</p><p>建立映射表 (2,1) (3,2) (1,3) (5,4) (6,5)</p><p>初始条带</p><p>2 2 4 1 5 5 6 3 1 1 5 6 将条带中不存在的颜色去掉 2 2 1 5 5 6 3 1 1 5 6 根据映射表，对条带进行映射: 1 1 3 4 4 5 2 3 3 4 5 <strong>问题转换为求最长不下降子序列</strong></p><div class=sourceCode id=cb25><pre class="sourceCode java"><code class="sourceCode java"><span id=cb25-1><a href=#cb25-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb25-2><a href=#cb25-2></a></span>
<span id=cb25-3><a href=#cb25-3></a><span class=kw>import</span><span class=im> java.util.HashMap;</span></span>
<span id=cb25-4><a href=#cb25-4></a><span class=kw>import</span><span class=im> java.util.Map;</span></span>
<span id=cb25-5><a href=#cb25-5></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb25-6><a href=#cb25-6></a></span>
<span id=cb25-7><a href=#cb25-7></a><span class=co>/**</span></span>
<span id=cb25-8><a href=#cb25-8></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb25-9><a href=#cb25-9></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/20</span> <span class=co>23:19</span></span>
<span id=cb25-10><a href=#cb25-10></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4084</span></span>
<span id=cb25-11><a href=#cb25-11></a> <span class=co>*</span> 将eva喜欢的颜色按顺序编号（赋权），建立映射关系（颜色<span class=co>-</span>编号）。</span>
<span id=cb25-12><a href=#cb25-12></a> <span class=co>*</span> 将条带中不符合eva喜好的颜色去掉。根据映射关系生成剩余条带的编号序列。</span>
<span id=cb25-13><a href=#cb25-13></a> <span class=co>*</span> 则原题目变成：求剩余条带编号的最长不下降子序列长度。</span>
<span id=cb25-14><a href=#cb25-14></a> <span class=co>*/</span></span>
<span id=cb25-15><a href=#cb25-15></a><span class=kw>public</span> <span class=kw>class</span> Advanced1034 {</span>
<span id=cb25-16><a href=#cb25-16></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb25-17><a href=#cb25-17></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb25-18><a href=#cb25-18></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb25-19><a href=#cb25-19></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb25-20><a href=#cb25-20></a>        <span class=bu>Map</span>&lt;<span class=bu>Integer</span>, <span class=bu>Integer</span>&gt; map = <span class=kw>new</span> <span class=bu>HashMap</span>&lt;&gt;(<span class=dv>20</span>);</span>
<span id=cb25-21><a href=#cb25-21></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= m; i++) {</span>
<span id=cb25-22><a href=#cb25-22></a>            map.<span class=fu>put</span>(scanner.<span class=fu>nextInt</span>(), i);</span>
<span id=cb25-23><a href=#cb25-23></a>        }</span>
<span id=cb25-24><a href=#cb25-24></a>        <span class=dt>int</span> l = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb25-25><a href=#cb25-25></a>        <span class=dt>int</span>[] a = <span class=kw>new</span> <span class=dt>int</span>[l];</span>
<span id=cb25-26><a href=#cb25-26></a>        <span class=dt>int</span> count = <span class=dv>0</span>;</span>
<span id=cb25-27><a href=#cb25-27></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; l; i++) {</span>
<span id=cb25-28><a href=#cb25-28></a>            <span class=bu>Integer</span> tmp = map.<span class=fu>get</span>(scanner.<span class=fu>nextInt</span>());</span>
<span id=cb25-29><a href=#cb25-29></a>            <span class=kw>if</span> (tmp != <span class=kw>null</span>) {</span>
<span id=cb25-30><a href=#cb25-30></a>                a[count++] = tmp;</span>
<span id=cb25-31><a href=#cb25-31></a>            }</span>
<span id=cb25-32><a href=#cb25-32></a>        }</span>
<span id=cb25-33><a href=#cb25-33></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb25-34><a href=#cb25-34></a></span>
<span id=cb25-35><a href=#cb25-35></a>        <span class=co>//dp[i]表示以a[i]结尾的最长不下降子序列长度</span></span>
<span id=cb25-36><a href=#cb25-36></a>        <span class=dt>int</span>[] dp = <span class=kw>new</span> <span class=dt>int</span>[count];</span>
<span id=cb25-37><a href=#cb25-37></a>        <span class=co>//边界条件：dp[i] = 1;</span></span>
<span id=cb25-38><a href=#cb25-38></a>        <span class=co>//状态转移方程： dp[i] = max(dp[j]+1,dp[i]) , j = 0,1,,i-1,  当[j] &lt;= a[i],</span></span>
<span id=cb25-39><a href=#cb25-39></a>        <span class=co>//              dp[i] = dp[i],                       当所有a[j]都 &gt; a[i]</span></span>
<span id=cb25-40><a href=#cb25-40></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; count; i++) {</span>
<span id=cb25-41><a href=#cb25-41></a>            dp[i] = <span class=dv>1</span>;</span>
<span id=cb25-42><a href=#cb25-42></a>        }</span>
<span id=cb25-43><a href=#cb25-43></a>        <span class=dt>int</span> max = <span class=dv>0</span>;</span>
<span id=cb25-44><a href=#cb25-44></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt; count; i++) {</span>
<span id=cb25-45><a href=#cb25-45></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>0</span>; j &lt; i; j++) {</span>
<span id=cb25-46><a href=#cb25-46></a>                <span class=kw>if</span> (a[j] &lt;= a[i] &amp;&amp; dp[j] + <span class=dv>1</span> &gt; dp[i]) {</span>
<span id=cb25-47><a href=#cb25-47></a>                    dp[i] = dp[j] + <span class=dv>1</span>;</span>
<span id=cb25-48><a href=#cb25-48></a>                }</span>
<span id=cb25-49><a href=#cb25-49></a>            }</span>
<span id=cb25-50><a href=#cb25-50></a>            max = dp[i] &gt; max ? dp[i] : max;</span>
<span id=cb25-51><a href=#cb25-51></a>        }</span>
<span id=cb25-52><a href=#cb25-52></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(max);</span>
<span id=cb25-53><a href=#cb25-53></a>    }</span>
<span id=cb25-54><a href=#cb25-54></a>}</span></code></pre></div><h5 id=方法2-其他动态规划法>方法2 其他动态规划法</h5><div class=sourceCode id=cb26><pre class="sourceCode java"><code class="sourceCode java"><span id=cb26-1><a href=#cb26-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb26-2><a href=#cb26-2></a></span>
<span id=cb26-3><a href=#cb26-3></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb26-4><a href=#cb26-4></a></span>
<span id=cb26-5><a href=#cb26-5></a><span class=co>/**</span></span>
<span id=cb26-6><a href=#cb26-6></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb26-7><a href=#cb26-7></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/20</span> <span class=co>23:19</span></span>
<span id=cb26-8><a href=#cb26-8></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4084</span></span>
<span id=cb26-9><a href=#cb26-9></a> <span class=co>*</span> 动态规划思想</span>
<span id=cb26-10><a href=#cb26-10></a> <span class=co>*/</span></span>
<span id=cb26-11><a href=#cb26-11></a><span class=kw>public</span> <span class=kw>class</span> Advanced1034_<span class=dv>2</span> {</span>
<span id=cb26-12><a href=#cb26-12></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb26-13><a href=#cb26-13></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb26-14><a href=#cb26-14></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb26-15><a href=#cb26-15></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb26-16><a href=#cb26-16></a>        <span class=dt>int</span>[] a = <span class=kw>new</span> <span class=dt>int</span>[m + <span class=dv>1</span>];</span>
<span id=cb26-17><a href=#cb26-17></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= m; i++) {</span>
<span id=cb26-18><a href=#cb26-18></a>            a[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb26-19><a href=#cb26-19></a>        }</span>
<span id=cb26-20><a href=#cb26-20></a>        <span class=dt>int</span> l = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb26-21><a href=#cb26-21></a>        <span class=dt>int</span>[] b = <span class=kw>new</span> <span class=dt>int</span>[l + <span class=dv>1</span>];</span>
<span id=cb26-22><a href=#cb26-22></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= l; i++) {</span>
<span id=cb26-23><a href=#cb26-23></a>            b[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb26-24><a href=#cb26-24></a>        }</span>
<span id=cb26-25><a href=#cb26-25></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb26-26><a href=#cb26-26></a></span>
<span id=cb26-27><a href=#cb26-27></a>        <span class=co>//dp[i][j]表示，加入第i种颜色后，前j个颜色序列组成的最大非逆子序列长度</span></span>
<span id=cb26-28><a href=#cb26-28></a>        <span class=dt>int</span>[][] dp = <span class=kw>new</span> <span class=dt>int</span>[m + <span class=dv>1</span>][l + <span class=dv>1</span>];</span>
<span id=cb26-29><a href=#cb26-29></a></span>
<span id=cb26-30><a href=#cb26-30></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= m; i++) {</span>
<span id=cb26-31><a href=#cb26-31></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>1</span>; j &lt;= l; j++) {</span>
<span id=cb26-32><a href=#cb26-32></a>                dp[i][j] = <span class=bu>Math</span>.<span class=fu>max</span>(dp[i - <span class=dv>1</span>][j], dp[i][j - <span class=dv>1</span>]);</span>
<span id=cb26-33><a href=#cb26-33></a>                <span class=kw>if</span> (a[i] == b[j]) {</span>
<span id=cb26-34><a href=#cb26-34></a>                    dp[i][j] += <span class=dv>1</span>;</span>
<span id=cb26-35><a href=#cb26-35></a>                }</span>
<span id=cb26-36><a href=#cb26-36></a>            }</span>
<span id=cb26-37><a href=#cb26-37></a>        }</span>
<span id=cb26-38><a href=#cb26-38></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(dp[m][l]);</span>
<span id=cb26-39><a href=#cb26-39></a>    }</span>
<span id=cb26-40><a href=#cb26-40></a>}</span></code></pre></div><h3 id=背包问题>背包问题</h3><p>如果背包问题还不太了解，可以参考：算法笔记——胡凡曾磊 （P444 提高篇（5）动态规划专题） 背包问题进阶：<a href=https://www.cnblogs.com/jbelial/articles/2116074.html>背包九讲</a></p><h4 id=背包问题-1>01背包问题</h4><p>01背包问题是这样的：有n件物品，每件物品的重量w[i],价值c[i]。现有一个背包，容量为V，问如何选择物品装入背包，使装入背包物品的总价值最大？</p><h5 id=例1-用零钱凑一定的金额>例1 用零钱凑一定的金额</h5><p>给n张零钱，面值分别为v[i]，问如何选择零钱，凑成给定的金额V。如果有多种方法，使用面值尽量小的，张数多的方法。</p><p><a href=https://www.nowcoder.com/pat/5/problem/4119>原题链接</a></p><p>这道题目属于：背包问题-01背包问题-01满背包问题</p><p>从最优化问题的角度考虑，</p><p>可以看作是如下的最优化问题（方法1）：</p><p><strong>限制条件</strong>： 变量i 属于[1,n], 面值v[i] 属于{v[1]:v[n]} 选择的面值之和必须<strong>恰好为</strong>给定的金额V <strong>目标函数</strong>： 使用的零钱张数（最多）</p><p>也可以看作是如下的最优化问题（方法2）：</p><p><strong>限制条件</strong>： 变量i 属于[1,n], 面值v[i] 属于{v[1]:v[n]} 选择的零钱总额<strong>小于等于</strong>给定的金额V <strong>目标函数</strong>： 使用的零钱总额（最大）</p><h5 id=方法1-凑给定金额v使用的零钱张数最大>方法1 凑给定金额V，使用的零钱张数最大</h5><p>假设第i张零钱的面值是<span class="math inline">\(v[i]\)</span> 。用<span class="math inline">\(dp[i][v]\)</span>表示从前i张零钱中，凑成金额v时的零钱张数。</p><h6 id=考虑是否选择第i张零钱凑成金额v使用的零钱张数最大>考虑是否选择第i张零钱（凑成金额v，使用的零钱张数最大）</h6><p>如果<strong>选择使用</strong>第i张零钱凑成金额v，使用的零钱张数<span class="math inline">\(dp[i][v]\)</span>由前<span class="math inline">\(i-1\)</span>张零钱使用的张数决定，即<span class="math inline">\(dp[i][v] = dp[i-1][v-v[i]]+1\)</span> 如果<strong>选择不使用</strong>第i张零钱凑成金额v，使用的零钱张数<span class="math inline">\(dp[i][v]\)</span>也由前<span class="math inline">\(i-1\)</span>张零钱使用的张数决定，即<span class="math inline">\(dp[i][v] = dp[i-1][v]\)</span> 最终<strong>是否使用</strong>第i张零钱凑成金额v，选以上两种方式中，使用零钱张数较多的一种，即<span class="math inline">\(dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])\)</span></p><h6 id=关于初始化>关于初始化</h6><p><span class="math inline">\(dp[1:n][1:n]\)</span>全都初始化为了-inf （也可以是其他特定的数值）,表示不能从这些位置开始转移。<span class="math inline">\(dp[1:n][0]\)</span>全部初始化为0，是状态转移方程的边界（起始位置）</p><p>最终<span class="math inline">\(dp[n][V]\)</span>表示恰好凑成金额V所使用的零钱张数</p><h6 id=java代码>java代码</h6><div class=sourceCode id=cb27><pre class="sourceCode java"><code class="sourceCode java"><span id=cb27-1><a href=#cb27-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb27-2><a href=#cb27-2></a></span>
<span id=cb27-3><a href=#cb27-3></a><span class=kw>import</span><span class=im> java.util.ArrayList;</span></span>
<span id=cb27-4><a href=#cb27-4></a><span class=kw>import</span><span class=im> java.util.Arrays;</span></span>
<span id=cb27-5><a href=#cb27-5></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb27-6><a href=#cb27-6></a></span>
<span id=cb27-7><a href=#cb27-7></a><span class=co>/**</span></span>
<span id=cb27-8><a href=#cb27-8></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb27-9><a href=#cb27-9></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/13</span> <span class=co>18:21</span></span>
<span id=cb27-10><a href=#cb27-10></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4119</span></span>
<span id=cb27-11><a href=#cb27-11></a> <span class=co>*</span> 最优化问题：动态规划问题：选硬币问题，满背包问题</span>
<span id=cb27-12><a href=#cb27-12></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb27-13><a href=#cb27-13></a> <span class=co>*</span> 最优化问题描述</span>
<span id=cb27-14><a href=#cb27-14></a> <span class=co>*</span> 目标函数：使用零钱张数最多</span>
<span id=cb27-15><a href=#cb27-15></a> <span class=co>*</span> 限制条件：使用的面值之和为V</span>
<span id=cb27-16><a href=#cb27-16></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb27-17><a href=#cb27-17></a> <span class=co>*</span> 动态规划将最优化问题分解为多个子问题，通过综合子问题的最优解来得到原问题的最优解。且动态规划会将子问题的解保存下来，避免重复计算</span>
<span id=cb27-18><a href=#cb27-18></a> <span class=co>*</span> 动态规划问题的状态转移方程：</span>
<span id=cb27-19><a href=#cb27-19></a> <span class=co>*</span> dp<span class=co>[</span>i<span class=co>][</span>v<span class=co>]</span> <span class=co>=</span> max<span class=co>(</span>dp<span class=co>[</span>i<span class=co>-1][</span>v<span class=co>-</span>v<span class=co>[</span>i<span class=co>]]+1,</span> dp<span class=co>[</span>i<span class=co>-1][</span>v<span class=co>])</span></span>
<span id=cb27-20><a href=#cb27-20></a> <span class=co>*</span> 使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp<span class=co>[</span>i<span class=co>][</span>v<span class=co>]</span>都和前i<span class=co>-1张零钱的使用状况有关</span>。是否使用第i张，取决于哪种情况使用的零钱张数多。</span>
<span id=cb27-21><a href=#cb27-21></a> <span class=co>*/</span></span>
<span id=cb27-22><a href=#cb27-22></a><span class=kw>public</span> <span class=kw>class</span> Advanced1026 {</span>
<span id=cb27-23><a href=#cb27-23></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb27-24><a href=#cb27-24></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb27-25><a href=#cb27-25></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb27-26><a href=#cb27-26></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb27-27><a href=#cb27-27></a>        <span class=dt>int</span>[] coins = <span class=kw>new</span> <span class=dt>int</span>[n + <span class=dv>1</span>];</span>
<span id=cb27-28><a href=#cb27-28></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb27-29><a href=#cb27-29></a>            coins[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb27-30><a href=#cb27-30></a>        }</span>
<span id=cb27-31><a href=#cb27-31></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb27-32><a href=#cb27-32></a>        <span class=co>//排序，逆序</span></span>
<span id=cb27-33><a href=#cb27-33></a>        <span class=bu>Arrays</span>.<span class=fu>sort</span>(coins);</span>
<span id=cb27-34><a href=#cb27-34></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>, j = n; i &lt; j; i++, j--) {</span>
<span id=cb27-35><a href=#cb27-35></a>            <span class=dt>int</span> tmp = coins[i];</span>
<span id=cb27-36><a href=#cb27-36></a>            coins[i] = coins[j];</span>
<span id=cb27-37><a href=#cb27-37></a>            coins[j] = tmp;</span>
<span id=cb27-38><a href=#cb27-38></a>        }</span>
<span id=cb27-39><a href=#cb27-39></a>        <span class=co>//背包数组，记录存入背包的硬币个数；路径记录数组</span></span>
<span id=cb27-40><a href=#cb27-40></a>        <span class=dt>int</span>[][] dp = <span class=kw>new</span> <span class=dt>int</span>[n + <span class=dv>1</span>][m + <span class=dv>1</span>];</span>
<span id=cb27-41><a href=#cb27-41></a>        <span class=dt>boolean</span>[][] flag = <span class=kw>new</span> <span class=dt>boolean</span>[n + <span class=dv>1</span>][m + <span class=dv>1</span>];</span>
<span id=cb27-42><a href=#cb27-42></a>        <span class=co>//默认初始化dp[1:n][0]为0，dp[1:n][1:m]设为-1表示不能从这些位置开始转移。</span></span>
<span id=cb27-43><a href=#cb27-43></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt;= n; i++) {</span>
<span id=cb27-44><a href=#cb27-44></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>1</span>; j &lt; dp[i].<span class=fu>length</span>; j++) {</span>
<span id=cb27-45><a href=#cb27-45></a>                dp[i][j] = -<span class=dv>1</span>;</span>
<span id=cb27-46><a href=#cb27-46></a>            }</span>
<span id=cb27-47><a href=#cb27-47></a>        }</span>
<span id=cb27-48><a href=#cb27-48></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb27-49><a href=#cb27-49></a>            <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>1</span>; j &lt;= m; j++) {</span>
<span id=cb27-50><a href=#cb27-50></a>                dp[i][j] = dp[i - <span class=dv>1</span>][j];</span>
<span id=cb27-51><a href=#cb27-51></a>                <span class=co>//恰好装满的判断:保证不是从-1转移过来的</span></span>
<span id=cb27-52><a href=#cb27-52></a>                <span class=kw>if</span> ((j - coins[i] &gt;= <span class=dv>0</span>) &amp;&amp; (dp[i - <span class=dv>1</span>][j - coins[i]] != -<span class=dv>1</span>)) {</span>
<span id=cb27-53><a href=#cb27-53></a>                    <span class=kw>if</span> (dp[i - <span class=dv>1</span>][j - coins[i]] + <span class=dv>1</span> &gt;= dp[i][j]) {</span>
<span id=cb27-54><a href=#cb27-54></a>                        dp[i][j] = dp[i - <span class=dv>1</span>][j - coins[i]] + <span class=dv>1</span>;</span>
<span id=cb27-55><a href=#cb27-55></a>                        flag[i][j] = <span class=kw>true</span>;</span>
<span id=cb27-56><a href=#cb27-56></a>                    }</span>
<span id=cb27-57><a href=#cb27-57></a>                }</span>
<span id=cb27-58><a href=#cb27-58></a>            }</span>
<span id=cb27-59><a href=#cb27-59></a>        }</span>
<span id=cb27-60><a href=#cb27-60></a>        <span class=kw>if</span> (dp[n][m] != -<span class=dv>1</span>) {</span>
<span id=cb27-61><a href=#cb27-61></a>            <span class=dt>int</span> i = n;</span>
<span id=cb27-62><a href=#cb27-62></a>            <span class=dt>int</span> j = m;</span>
<span id=cb27-63><a href=#cb27-63></a>            <span class=bu>ArrayList</span>&lt;<span class=bu>Integer</span>&gt; list = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb27-64><a href=#cb27-64></a>            <span class=kw>while</span> (i &gt; <span class=dv>0</span> &amp;&amp; j &gt; <span class=dv>0</span>) {</span>
<span id=cb27-65><a href=#cb27-65></a>                <span class=kw>if</span> (flag[i][j]) {</span>
<span id=cb27-66><a href=#cb27-66></a>                    list.<span class=fu>add</span>(coins[i]);</span>
<span id=cb27-67><a href=#cb27-67></a>                    j -= coins[i];</span>
<span id=cb27-68><a href=#cb27-68></a>                }</span>
<span id=cb27-69><a href=#cb27-69></a>                i--;</span>
<span id=cb27-70><a href=#cb27-70></a>            }</span>
<span id=cb27-71><a href=#cb27-71></a>            <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb27-72><a href=#cb27-72></a>            <span class=kw>for</span> (<span class=bu>Integer</span> e : list) {</span>
<span id=cb27-73><a href=#cb27-73></a>                sb.<span class=fu>append</span>(e).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb27-74><a href=#cb27-74></a>            }</span>
<span id=cb27-75><a href=#cb27-75></a>            sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb27-76><a href=#cb27-76></a>            <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(sb);</span>
<span id=cb27-77><a href=#cb27-77></a>        } <span class=kw>else</span> {</span>
<span id=cb27-78><a href=#cb27-78></a>            <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=st>&quot;No Solution&quot;</span>);</span>
<span id=cb27-79><a href=#cb27-79></a>        }</span>
<span id=cb27-80><a href=#cb27-80></a>    }</span>
<span id=cb27-81><a href=#cb27-81></a>}</span></code></pre></div><h6 id=java代码优化降为1维数组滚动数组>java代码优化（降为1维数组/滚动数组）</h6><p>原来的动态规划问题的状态转移方程：</p><p><span class="math inline">\(dp[i][v] = max(dp[i-1][v-v[i]]+1, dp[i-1][v])\)</span></p><p>使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp[i][v]都和前i-1张零钱的使用状况有关。是否使用第i张，取决于哪种情况使用的零钱张数多。</p><p>优化：</p><p>由于使用的零钱张数dp[i][v]都仅和前i-1张零钱的使用状况<span class="math inline">\(dp[i-1][1:v]\)</span>有关，我们可以将2维数组降为1维数组(滚动数组）</p><p>新的状态转移方程：</p><p><span class="math inline">\(dp[v] = max(dp[v-v[i]]+1, dp[v])\)</span></p><p>由于dp[v-v[i]]+1, dp[v]使用的是上一轮（i-1轮）的值，在dp[v]使用前不应当被更改，所以对v的枚举应该逆序进行。</p><div class=sourceCode id=cb28><pre class="sourceCode java"><code class="sourceCode java"><span id=cb28-1><a href=#cb28-1></a><span class=kw>package</span><span class=im> com.jingmin.advanced2;</span></span>
<span id=cb28-2><a href=#cb28-2></a></span>
<span id=cb28-3><a href=#cb28-3></a><span class=kw>import</span><span class=im> java.util.ArrayList;</span></span>
<span id=cb28-4><a href=#cb28-4></a><span class=kw>import</span><span class=im> java.util.Arrays;</span></span>
<span id=cb28-5><a href=#cb28-5></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb28-6><a href=#cb28-6></a></span>
<span id=cb28-7><a href=#cb28-7></a><span class=co>/**</span></span>
<span id=cb28-8><a href=#cb28-8></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb28-9><a href=#cb28-9></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/13</span> <span class=co>18:21</span></span>
<span id=cb28-10><a href=#cb28-10></a> <span class=co>*</span> <span class=co>@</span>discription <span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4119</span></span>
<span id=cb28-11><a href=#cb28-11></a> <span class=co>*</span> 最优化问题：动态规划问题：选硬币问题，满背包问题</span>
<span id=cb28-12><a href=#cb28-12></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb28-13><a href=#cb28-13></a> <span class=co>*</span> 最优化问题描述</span>
<span id=cb28-14><a href=#cb28-14></a> <span class=co>*</span> 目标函数：使用零钱张数最多</span>
<span id=cb28-15><a href=#cb28-15></a> <span class=co>*</span> 限制条件：使用的面值之和恰好为V</span>
<span id=cb28-16><a href=#cb28-16></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb28-17><a href=#cb28-17></a> <span class=co>*</span> 动态规划将最优化问题分解为多个子问题，通过综合子问题的最优解来得到原问题的最优解。且动态规划会将子问题的解保存下来，避免重复计算</span>
<span id=cb28-18><a href=#cb28-18></a> <span class=co>*</span> 动态规划问题的状态转移方程：</span>
<span id=cb28-19><a href=#cb28-19></a> <span class=co>*</span> dp<span class=co>[</span>i<span class=co>][</span>v<span class=co>]</span> <span class=co>=</span> max<span class=co>(</span>dp<span class=co>[</span>i<span class=co>-1][</span>v<span class=co>-</span>v<span class=co>[</span>i<span class=co>]]+1,</span> dp<span class=co>[</span>i<span class=co>-1][</span>v<span class=co>])</span></span>
<span id=cb28-20><a href=#cb28-20></a> <span class=co>*</span> 使用第i张零钱凑成金额v，或不使用第i张零钱凑成金额v，使用的零钱张数dp<span class=co>[</span>i<span class=co>][</span>v<span class=co>]</span>都和前i<span class=co>-1张零钱的使用状况有关</span>。是否使用第i张，取决于哪种情况使用的零钱张数多。</span>
<span id=cb28-21><a href=#cb28-21></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb28-22><a href=#cb28-22></a> <span class=co>*</span> 优化：</span>
<span id=cb28-23><a href=#cb28-23></a> <span class=co>*</span> 由于使用的零钱张数dp<span class=co>[</span>i<span class=co>][</span>v<span class=co>]</span>都仅和前i<span class=co>-1张零钱的使用状况dp[</span>i<span class=co>-1][1:</span>v<span class=co>]</span>有关，我们可以将<span class=co>2维数组降为1维数组(</span>滚动数组）</span>
<span id=cb28-24><a href=#cb28-24></a> <span class=co>*</span> 新的状态转移方程：</span>
<span id=cb28-25><a href=#cb28-25></a> <span class=co>*</span> dp<span class=co>[</span>v<span class=co>]</span> <span class=co>=</span> max<span class=co>(</span>dp<span class=co>[</span>v<span class=co>-</span>v<span class=co>[</span>i<span class=co>]]+1,</span> dp<span class=co>[</span>v<span class=co>])</span></span>
<span id=cb28-26><a href=#cb28-26></a> <span class=co>*</span> 由于dp<span class=co>[</span>v<span class=co>-</span>v<span class=co>[</span>i<span class=co>]]+1,</span> dp<span class=co>[</span>v<span class=co>]</span>使用的是上一轮（i<span class=co>-1轮</span>）的值，在dp<span class=co>[</span>v<span class=co>]</span>使用前不应当被更改，所以对v的枚举应该逆序进行。</span>
<span id=cb28-27><a href=#cb28-27></a> <span class=co>*/</span></span>
<span id=cb28-28><a href=#cb28-28></a><span class=kw>public</span> <span class=kw>class</span> Advanced1026_<span class=dv>2</span> {</span>
<span id=cb28-29><a href=#cb28-29></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb28-30><a href=#cb28-30></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb28-31><a href=#cb28-31></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb28-32><a href=#cb28-32></a>        <span class=dt>int</span> m = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb28-33><a href=#cb28-33></a>        <span class=dt>int</span>[] coins = <span class=kw>new</span> <span class=dt>int</span>[n + <span class=dv>1</span>];</span>
<span id=cb28-34><a href=#cb28-34></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb28-35><a href=#cb28-35></a>            coins[i] = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb28-36><a href=#cb28-36></a>        }</span>
<span id=cb28-37><a href=#cb28-37></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb28-38><a href=#cb28-38></a>        <span class=co>//排序，逆序</span></span>
<span id=cb28-39><a href=#cb28-39></a>        <span class=bu>Arrays</span>.<span class=fu>sort</span>(coins);</span>
<span id=cb28-40><a href=#cb28-40></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>, j = n; i &lt; j; i++, j--) {</span>
<span id=cb28-41><a href=#cb28-41></a>            <span class=dt>int</span> tmp = coins[i];</span>
<span id=cb28-42><a href=#cb28-42></a>            coins[i] = coins[j];</span>
<span id=cb28-43><a href=#cb28-43></a>            coins[j] = tmp;</span>
<span id=cb28-44><a href=#cb28-44></a>        }</span>
<span id=cb28-45><a href=#cb28-45></a>        <span class=co>//背包数组，记录存入背包的硬币个数；路径记录数组</span></span>
<span id=cb28-46><a href=#cb28-46></a>        <span class=dt>int</span>[] dp = <span class=kw>new</span> <span class=dt>int</span>[m + <span class=dv>1</span>];</span>
<span id=cb28-47><a href=#cb28-47></a>        <span class=dt>boolean</span>[][] flag = <span class=kw>new</span> <span class=dt>boolean</span>[n + <span class=dv>1</span>][m + <span class=dv>1</span>];</span>
<span id=cb28-48><a href=#cb28-48></a>        <span class=co>//默认初始化dp[0]为0，dp[1:m]设为-1表示不能从这些位置开始转移。</span></span>
<span id=cb28-49><a href=#cb28-49></a>        <span class=kw>for</span> (<span class=dt>int</span> j = <span class=dv>1</span>; j &lt;= m; j++) {</span>
<span id=cb28-50><a href=#cb28-50></a>            dp[j] = -<span class=dv>1</span>;</span>
<span id=cb28-51><a href=#cb28-51></a>        }</span>
<span id=cb28-52><a href=#cb28-52></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; i++) {</span>
<span id=cb28-53><a href=#cb28-53></a>            <span class=kw>for</span> (<span class=dt>int</span> j = m; j &gt;= coins[i]; j--) {</span>
<span id=cb28-54><a href=#cb28-54></a>                <span class=co>//恰好装满的判断:保证不是从-1转移过来的</span></span>
<span id=cb28-55><a href=#cb28-55></a>                <span class=kw>if</span> (dp[j - coins[i]] != -<span class=dv>1</span>) {</span>
<span id=cb28-56><a href=#cb28-56></a>                    <span class=kw>if</span> (dp[j - coins[i]] + <span class=dv>1</span> &gt;= dp[j]) {</span>
<span id=cb28-57><a href=#cb28-57></a>                        dp[j] = dp[j - coins[i]] + <span class=dv>1</span>;</span>
<span id=cb28-58><a href=#cb28-58></a>                        flag[i][j] = <span class=kw>true</span>;</span>
<span id=cb28-59><a href=#cb28-59></a>                    }</span>
<span id=cb28-60><a href=#cb28-60></a>                }</span>
<span id=cb28-61><a href=#cb28-61></a>            }</span>
<span id=cb28-62><a href=#cb28-62></a>        }</span>
<span id=cb28-63><a href=#cb28-63></a>        <span class=kw>if</span> (dp[m] != -<span class=dv>1</span>) {</span>
<span id=cb28-64><a href=#cb28-64></a>            <span class=dt>int</span> i = n;</span>
<span id=cb28-65><a href=#cb28-65></a>            <span class=dt>int</span> j = m;</span>
<span id=cb28-66><a href=#cb28-66></a>            <span class=bu>ArrayList</span>&lt;<span class=bu>Integer</span>&gt; list = <span class=kw>new</span> <span class=bu>ArrayList</span>&lt;&gt;();</span>
<span id=cb28-67><a href=#cb28-67></a>            <span class=kw>while</span> (i &gt; <span class=dv>0</span> &amp;&amp; j &gt; <span class=dv>0</span>) {</span>
<span id=cb28-68><a href=#cb28-68></a>                <span class=kw>if</span> (flag[i][j]) {</span>
<span id=cb28-69><a href=#cb28-69></a>                    list.<span class=fu>add</span>(coins[i]);</span>
<span id=cb28-70><a href=#cb28-70></a>                    j -= coins[i];</span>
<span id=cb28-71><a href=#cb28-71></a>                }</span>
<span id=cb28-72><a href=#cb28-72></a>                i--;</span>
<span id=cb28-73><a href=#cb28-73></a>            }</span>
<span id=cb28-74><a href=#cb28-74></a>            <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb28-75><a href=#cb28-75></a>            <span class=kw>for</span> (<span class=bu>Integer</span> e : list) {</span>
<span id=cb28-76><a href=#cb28-76></a>                sb.<span class=fu>append</span>(e).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb28-77><a href=#cb28-77></a>            }</span>
<span id=cb28-78><a href=#cb28-78></a>            sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb28-79><a href=#cb28-79></a>            <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(sb);</span>
<span id=cb28-80><a href=#cb28-80></a>        } <span class=kw>else</span> {</span>
<span id=cb28-81><a href=#cb28-81></a>            <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(<span class=st>&quot;No Solution&quot;</span>);</span>
<span id=cb28-82><a href=#cb28-82></a>        }</span>
<span id=cb28-83><a href=#cb28-83></a>    }</span>
<span id=cb28-84><a href=#cb28-84></a>}</span></code></pre></div><h5 id=方法2-使用的零钱面值总额不超过v使得使用的零钱面值总额最大>方法2 使用的零钱面值总额不超过V，使得使用的零钱面值总额最大</h5><p>如果目标函数（使用的零钱总额)最大值就是V，那么原问题（用零钱凑给定金额V）有解。</p><div class=sourceCode id=cb29><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb29-1><a href=#cb29-1></a><span class=co>//牛客网牛友bystc提交的代码</span></span>
<span id=cb29-2><a href=#cb29-2></a><span class=co>//https://www.nowcoder.com/profile/5065450/codeBookDetail?submissionId=12502427</span></span>
<span id=cb29-3><a href=#cb29-3></a><span class=pp>#include </span><span class=im>&lt;cstdio&gt;</span></span>
<span id=cb29-4><a href=#cb29-4></a><span class=pp>#include </span><span class=im>&lt;cmath&gt;</span></span>
<span id=cb29-5><a href=#cb29-5></a><span class=pp>#include </span><span class=im>&lt;algorithm&gt;</span></span>
<span id=cb29-6><a href=#cb29-6></a> </span>
<span id=cb29-7><a href=#cb29-7></a><span class=at>const</span> <span class=dt>int</span> ncoins = <span class=dv>10005</span>;</span>
<span id=cb29-8><a href=#cb29-8></a><span class=at>const</span> <span class=dt>int</span> nmonay = <span class=dv>105</span>;</span>
<span id=cb29-9><a href=#cb29-9></a> </span>
<span id=cb29-10><a href=#cb29-10></a><span class=dt>bool</span> cmp(<span class=at>const</span> <span class=dt>int</span> &amp;a, <span class=at>const</span> <span class=dt>int</span> &amp;b) {</span>
<span id=cb29-11><a href=#cb29-11></a>    <span class=cf>return</span> a &gt; b;</span>
<span id=cb29-12><a href=#cb29-12></a>}</span>
<span id=cb29-13><a href=#cb29-13></a> </span>
<span id=cb29-14><a href=#cb29-14></a><span class=dt>int</span> main() {</span>
<span id=cb29-15><a href=#cb29-15></a>    <span class=dt>int</span> dp[ncoins][nmonay];</span>
<span id=cb29-16><a href=#cb29-16></a>    <span class=dt>int</span>  coins[ncoins];</span>
<span id=cb29-17><a href=#cb29-17></a>    <span class=dt>bool</span> isIncluded[nmonay][ncoins];</span>
<span id=cb29-18><a href=#cb29-18></a> </span>
<span id=cb29-19><a href=#cb29-19></a>    <span class=dt>int</span> n, m;</span>
<span id=cb29-20><a href=#cb29-20></a>    scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st> </span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;n, &amp;m);</span>
<span id=cb29-21><a href=#cb29-21></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; ++i) {</span>
<span id=cb29-22><a href=#cb29-22></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>, &amp;coins[i]);</span>
<span id=cb29-23><a href=#cb29-23></a>    }</span>
<span id=cb29-24><a href=#cb29-24></a>    <span class=bu>std::</span>sort(coins + <span class=dv>1</span>, coins + n + <span class=dv>1</span>, cmp);</span>
<span id=cb29-25><a href=#cb29-25></a> </span>
<span id=cb29-26><a href=#cb29-26></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= m; ++i)</span>
<span id=cb29-27><a href=#cb29-27></a>        <span class=cf>for</span>(<span class=dt>int</span> j = <span class=dv>1</span>; j &lt;= n; ++j)</span>
<span id=cb29-28><a href=#cb29-28></a>            isIncluded[i][j] = <span class=kw>false</span>;</span>
<span id=cb29-29><a href=#cb29-29></a> </span>
<span id=cb29-30><a href=#cb29-30></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt;= m; ++i) dp[<span class=dv>0</span>][i] = <span class=dv>0</span>;</span>
<span id=cb29-31><a href=#cb29-31></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>0</span>; i &lt;= n; ++i) dp[i][<span class=dv>0</span>] = <span class=dv>0</span>;</span>
<span id=cb29-32><a href=#cb29-32></a> </span>
<span id=cb29-33><a href=#cb29-33></a>    <span class=cf>for</span>(<span class=dt>int</span> i = <span class=dv>1</span>; i &lt;= n; ++i)</span>
<span id=cb29-34><a href=#cb29-34></a>        <span class=cf>for</span>(<span class=dt>int</span> j = <span class=dv>1</span>; j &lt;= m; ++j) {</span>
<span id=cb29-35><a href=#cb29-35></a>            <span class=cf>if</span>( j &lt; coins[i] || dp[i - <span class=dv>1</span>][j] &gt;  coins[i] + dp[i - <span class=dv>1</span>][j - coins[i]] ) {</span>
<span id=cb29-36><a href=#cb29-36></a>                dp[i][j] = dp[i - <span class=dv>1</span>][j];</span>
<span id=cb29-37><a href=#cb29-37></a>            }</span>
<span id=cb29-38><a href=#cb29-38></a>            <span class=cf>else</span> {</span>
<span id=cb29-39><a href=#cb29-39></a>                dp[i][j] = dp[i - <span class=dv>1</span>][j - coins[i]] + coins[i];</span>
<span id=cb29-40><a href=#cb29-40></a>                isIncluded[j][i] = <span class=kw>true</span>;</span>
<span id=cb29-41><a href=#cb29-41></a>            }</span>
<span id=cb29-42><a href=#cb29-42></a>        }</span>
<span id=cb29-43><a href=#cb29-43></a> </span>
<span id=cb29-44><a href=#cb29-44></a>    <span class=cf>if</span>(dp[n][m] != m) {</span>
<span id=cb29-45><a href=#cb29-45></a>        printf(<span class=st>&quot;No Solution</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb29-46><a href=#cb29-46></a>        <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb29-47><a href=#cb29-47></a>    }</span>
<span id=cb29-48><a href=#cb29-48></a> </span>
<span id=cb29-49><a href=#cb29-49></a>    <span class=dt>bool</span> flag = <span class=kw>true</span>;</span>
<span id=cb29-50><a href=#cb29-50></a>    <span class=cf>for</span>(<span class=dt>int</span> i = n; i &gt;= <span class=dv>1</span> &amp;&amp; m &gt; <span class=dv>0</span>; --i) {</span>
<span id=cb29-51><a href=#cb29-51></a>        <span class=cf>if</span>(isIncluded[m][i]) {</span>
<span id=cb29-52><a href=#cb29-52></a>            <span class=cf>if</span>(flag) {</span>
<span id=cb29-53><a href=#cb29-53></a>                printf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>, coins[i]);</span>
<span id=cb29-54><a href=#cb29-54></a>                flag = <span class=kw>false</span>;</span>
<span id=cb29-55><a href=#cb29-55></a>            }</span>
<span id=cb29-56><a href=#cb29-56></a>            <span class=cf>else</span></span>
<span id=cb29-57><a href=#cb29-57></a>                printf(<span class=st>&quot; </span><span class=sc>%d</span><span class=st>&quot;</span>, coins[i]);</span>
<span id=cb29-58><a href=#cb29-58></a>            m -= coins[i];</span>
<span id=cb29-59><a href=#cb29-59></a>        }</span>
<span id=cb29-60><a href=#cb29-60></a>    }</span>
<span id=cb29-61><a href=#cb29-61></a>    printf(<span class=st>&quot;</span><span class=sc>\n</span><span class=st>&quot;</span>);</span>
<span id=cb29-62><a href=#cb29-62></a>    <span class=cf>return</span> <span class=dv>0</span>;</span>
<span id=cb29-63><a href=#cb29-63></a>}</span></code></pre></div><h5 id=初始化的问题>初始化的问题</h5><p>不同的初始化条件决定了dp数组的意义： 是装入的总价值的最大值（不一定恰好装满） 还是装入的总价值（但一定装满）</p><p>具体的讲，初始化的问题（可用数学归纳法证明状态的转移过程：见bilibili大雪菜背包九讲专题）：</p><p>对于滚动数组/一维数组，<span class="math inline">\(dp[0:m]\)</span>都初始化为0，则<span class="math inline">\(dp[m]\)</span>中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满） 对于滚动数组/一维数组，<span class="math inline">\(dp[1:m]\)</span>都初始化为<span class="math inline">\(-INF\)</span>，<span class="math inline">\(dp[0] = 0\)</span>, 则<span class="math inline">\(dp[m\)</span>]中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值 对于二维数组，<span class="math inline">\(dp[0:n][0:m]\)</span>都初始化为0，则<span class="math inline">\(dp[n][m]\)</span>中表示的内容，就是背包里装入物品总价值的最大值（背包不一定装满） 对于二维数组，<span class="math inline">\(dp[0:n][1:m]\)</span>都初始化为<span class="math inline">\(-INF\)</span>，<span class="math inline">\(dp[1:n][0] = 0\)</span>, 则<span class="math inline">\(dp[n][m]\)</span>中表示的内容，就是（恰好装满背包容量m时）背包里物品的总价值</p></section></article></main></div><div class="col-sm-3 col-sm-offset-1 doc-sidebar"><div id=sidebar><div class=sidebar-module><div class=sidebar-toc><h4 class=sidebar-heading>Table of Contents</h4><ul><li><strong><a href=#title>PAT甲级习题</a></strong></li></ul></div></div><div class=sidebar-module><h4 class=sidebar-heading>Pages in Categories</h4><ul class=sidebar-category-list><li><a href=https://ole12138.github.io//categories/%E6%95%B0%E5%AD%A6><span class=doc-list-category>数学</span></a><ul><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/>概率论与数理统计-随机变量的数字特征</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93todo/>回归分析总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/>基础数学-三角函数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/>基础数学-代数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/>基础数学-几何</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/>多元微积分-多元微分学-向量值函数和向量分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/>数学分支的总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/>数学物理方法总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>最优化问题总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/>概率论与数理统计-随机事件与概率</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/>概率论与数理统计-随机变量及其分布</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/>泛函分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/>线性代数-向量组的线性相关性</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/>线性代数-向量组的线性相关性</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/>线性代数-向量组的线性相关性习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/>线性代数-相似矩阵与二次型</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/>线性代数-矩阵1</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/>线性代数-矩阵1习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/>线性代数-矩阵初等变换与线性方程组习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/>线性代数-矩阵初等变换与线性方程组习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/>线性代数-行列式</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/>线性代数-行列式习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/>线性代数总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/>高等数学</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/>高等数学-向量代数与空间解析几何</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/>高等数学-向量代数与空间解析几何习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/>高等数学-多元微分学</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/>高等数学-多元微分学-代数应用：多元函数的极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/>高等数学-多元微分学习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/>高等数学-多元微积分-曲线积分与曲面积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-多元微积分-曲线积分与曲面积分习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/>高等数学-多元微积分概述</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/>高等数学-多元积分学-重积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-多元积分学-重积分习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/>高等数学-微分方程</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/>高等数学-微分方程习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/>高等数学-级数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/>高等数学-级数习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/>一元积分学-定积分的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/>一元积分学-定积分的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/>一元积分学-定积分与反常积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>一元积分学-定积分与反常积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/>一元积分学-不定积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>一元积分学-不定积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/>一元微分学-导数的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/>一元微分学的应用-弧微分与曲率</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/>一元函数微分学-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/>一元函数微分学-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/>一元微分学-可导函数的中值定理</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/>一元微分学-导数的应用-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/>可导函数的中值定理习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/>一元微分学-导数和微分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/>函数与极限</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/>函数与极限习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/>高等数学-一元微积分-脉络</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95><span class=doc-list-category>数据结构与算法</span></a><ul><li><span class=active>PAT甲级习题</span></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/>数据结构-栈和队列</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/>数据结构-线性表</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/>数据结构与算法的基本概念</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/>数据结构总结</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/>树和二叉树</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/>算法总结</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E7%89%A9%E7%90%86><span class=doc-list-category>物理</span></a><ul><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/>数学物理方法总结</a></li></ul></li></ul></div><div class=sidebar-module><h4 class=sidebar-heading>Tags</h4><div class=tag-box><a class=tag-item href=https://ole12138.github.io//tags/np%E5%AE%8C%E5%A4%87%E7%90%86%E8%AE%BA>np完备理论</a>
<a class=tag-item href=https://ole12138.github.io//tags/n%E7%BB%B4%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83>n维正态分布</a>
<a class=tag-item href=https://ole12138.github.io//tags/pat>pat</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6>一元微分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86>一元微积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6>一元积分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0>三角函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%89%E8%A7%92%E7%BA%A7%E6%95%B0>三角级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86>不定积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B9%A0%E9%A2%98>习题</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91>二叉排序树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%A0%91>二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86>二叉树的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B>二次型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B%E5%8C%96%E4%B8%BA%E6%A0%87%E5%87%86%E5%9E%8B>二次型化为标准型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BB%A3%E6%95%B0>代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8>代数应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0>伽马函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0>傅里叶级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99>克拉默法则</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%A0%E4%BD%95>几何</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0>函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E7%90%86%E8%AE%BA>函数极限理论</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E7%A9%BA%E9%97%B4>函数空间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>函数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5>分块矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%86%E7%B1%BB>分类</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92>动态规划</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3>动态规划的思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%8F%E6%96%B9%E5%B7%AE>协方差</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5>协方差矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%95%E8%B0%83%E6%80%A7>单调性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97>双端队列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86>反常积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%AF%E5%AF%BC%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86>可导函数的中值定理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F>向量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0>向量代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0>向量值函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%86%85%E7%A7%AF>向量内积</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90>向量分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%9A%84%E6%AD%A3%E4%BA%A4%E6%80%A7>向量的正交性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4>向量空间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84>向量组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%A7%A9>向量组的秩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7>向量组的线性相关性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88>向量组的线性组合</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E9%95%BF%E5%BA%A6>向量长度</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91>哈夫曼树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90>回归分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%BE>图</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86>图的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9D%87%E5%80%BC>均值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6>基础数学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%8D%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>复数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC>多元函数的极值与最值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6>多元微分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86>多元微积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6>多元积分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AE%9A%E7%A7%AF%E5%88%86>定积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8>定积分的应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96>对称矩阵对角化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%BC%E6%95%B0>导数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8>导数的应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>常数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%82%E7%BA%A7%E6%95%B0>幂级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91>平衡二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%B6%E6%9F%A5%E9%9B%86>并查集</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BC%A7%E5%BE%AE%E5%88%86>弧微分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BE%AE%E5%88%86>微分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B>微分方程</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%8E%92%E5%BA%8F>排序</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%A3%E5%88%97>散列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF>数学分支</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90>数学分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B>数学期望</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5>数据结构的基本概念</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E7%BB%84>数组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B4%E6%95%B0%E4%BC%98%E5%8C%96>整数优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E5%B7%AE>方差</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC>方阵的特征值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F>方阵的特征向量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F>方阵的行列式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%98%A0%E5%B0%84>映射</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E7%8E%87>曲率</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86>曲线积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86>曲面积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98>最优化问题</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84>最短路径</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9E%81%E5%80%BC>极值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9E%81%E9%99%90>极限</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%87%E5%87%86%E5%9E%8B>标准型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%88>栈</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91>树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84>树状数组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86>树的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2>森林与二叉树的转换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8>概念与性质</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E7%8E%87%E8%AE%BA>概率论</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E8%BF%B0>概述</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5>正定矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%B3%8A%E6%9D%BE%E7%A7%AF%E5%88%86>泊松积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%89%A9%E7%90%86>物理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%A7%92%E5%8C%96>相似对角化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5>相似矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0>相关系数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9>矩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5>矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E5%90%88%E5%90%8C>矩阵合同</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86>矩阵求逆</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2>矩阵的初等变换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8>矩阵的压缩存储</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9>矩阵的秩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97>矩阵的运算</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%A6%BB%E6%95%A3%E6%9C%80%E4%BC%98%E5%8C%96>离散最优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95>空间解析几何</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3>算法思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95>算法评价方法</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%A7%E6%95%B0>级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0>线性代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84>线性方程组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%A7%A3>线性方程组的解</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84>线性方程组解的结构</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8>线性表</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA>线性表的链式表示</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA>线性表的顺序表示</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91>线索二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96>组合优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%84%89%E7%BB%9C>脉络</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F>行列式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%B1%95%E5%BC%80%E5%85%AC%E5%BC%8F>行列式展开公式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84%E5%BA%94%E7%94%A8>行列式解方程组应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%BE%A8%E6%9E%90>辨析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%BF%9E%E7%BB%AD%E6%80%A7>连续性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E8%BD%AC%E6%8D%A2>递归与非递归转换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86>递归循环迭代遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E7%9A%84%E6%80%9D%E6%83%B3>递归的思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%87%8D%E7%A7%AF%E5%88%86>重积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%98%9F%E5%88%97>队列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6>随机事件</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E7%8E%87>随机事件的概率</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F>随机变量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83>随机变量的分布</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81>随机变量的数字特征</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86>高斯积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6>高等数学</a></div></div></div></div></div><hr><div class=row><div class=col-sm-8><p class=doc-footer-em><a href=# onclick=resetSidebarPos()>Back to TOP</a></p></div></div></div><footer class=doc-footer><p class=doc-footer-em>Browse <strong><a href=https://github.com/ole12138/ole12138.github.io>Repository</a></strong></p><p>Copyright (c) 2020, Jingmin; All rights reserved.</p><p>Powered by <strong><a href=https://github.com/progrhyme/hugo-theme-bootie-docs>Bootie Docs</a></strong> - theme for <a href=http://gohugo.io/>Hugo</a> by <a href=https://github.com/progrhyme/>progrhyme</a>.</p></footer><script src=https://ole12138.github.io//js/jquery.min.js></script><script src=https://ole12138.github.io//js/bootstrap.min.js></script><script src=https://ole12138.github.io//js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script src=https://ole12138.github.io//js/ie10-viewport-bug-workaround.js></script><script src=https://ole12138.github.io//js/bootie-docs.js></script></body></html>