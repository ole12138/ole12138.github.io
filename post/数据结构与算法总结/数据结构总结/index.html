<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=alternate href=/index.xml type=application/rss+xml title="Jingmin's blog"><link rel=icon href=https://ole12138.github.io//favicon.ico><title>数据结构总结 - Jingmin's blog</title><link rel=stylesheet href=https://ole12138.github.io//css/highlight/github.css><link rel=stylesheet href=https://ole12138.github.io//css/bootstrap.min.css><link rel=stylesheet href=https://ole12138.github.io//css/bootstrap-theme.min.css><link rel=stylesheet href=https://ole12138.github.io//css/theme.css><link rel=stylesheet href=https://ole12138.github.io//css/bootie-docs.css><link rel=stylesheet href=https://ole12138.github.io//css/site.css></head><body role=document><nav class="navbar navbar-inverse navbar-fixed-top"><div class=container><div class=navbar-header><button type=button class="navbar-toggle collapsed" data-toggle=collapse data-target=#navbar aria-expanded=false aria-controls=navbar>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button>
<a class=navbar-brand href=https://ole12138.github.io//>Jingmin's blog</a></div><div id=navbar class="navbar-collapse collapse"><ul class="nav navbar-nav"><li><a href=https://ole12138.github.io//>Home</a></li><li><a href=/post>All posts</a></li><li><a href=/tags>Tags</a></li><li><a href=/series>Series</a></li><li><a href=/categories>Categories</a></li><li><a href=/about>About</a></li></ul></div></div></nav><div class=container><div class=row><div class="col-sm-8 doc-main"><main role=main><article><a id=title></a><h1 class=doc-entry-title>数据结构总结</h1><div class=doc-entry-meta><span><time datetime=2020-06-25>June 25, 2020</time></span></div><section><h1 id=树>树</h1><h2 id=二叉树>二叉树</h2><h2 id=二叉树搜索树>二叉树搜索树</h2><h2 id=平衡二叉搜索树avl树>平衡二叉搜索树（AVL树）</h2><p>参考：https://zhuanlan.zhihu.com/p/34899732 参考：https://oi-wiki.org/ds/avl/ 参考：https://www.jianshu.com/p/65c90aa1236d 参考：https://blog.csdn.net/wanderlustLee/article/details/81297253</p><p>AVL树是，在二叉搜索树的前提下，能保证平衡的树。</p><h3 id=avl树特点>AVL树特点</h3><ul><li>二叉搜索树的特点：对树上的任意节点，其左子树上的值都小于当前节点的值，其右子树上的值都大约当前节点的值</li><li>平衡：对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）</li></ul><h3 id=avl树的基本操作功能>AVL树的基本操作/功能</h3><ul><li>二叉搜索树的操作：插入/删除/搜索，可能还包括找上一个/下一个节点</li><li>维持树的平衡</li></ul><h3 id=维持树的平衡>维持树的平衡</h3><h5 id=平衡条件是什么>平衡条件是什么？</h5><p>对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）</p><h5 id=什么原因会失去平衡哪些节点会失去平衡>什么原因会失去平衡，哪些节点会失去平衡？</h5><p>假设当前的树已经平衡。当AVL树进行<strong>插入/删除操作</strong>时，可能造成某些节点左右子树高度的变动，破坏树的平衡。 具体的说，插入/删除位置的<strong>祖先节点可能会失去平衡</strong>。所以插入删除完成后，需要逆着查找路径，依次维护祖先节点的平衡性。</p><h5 id=如何使失去平衡的某个节点恢复平衡>如何使失去平衡的某个节点恢复平衡？</h5><p>我们要做的操作是，调整该节点处的左右子树高度，使其重新平衡。形象的描述就是要进行<strong>旋转操作</strong>，使其重新平衡。</p><p>左旋操作、右旋操作示意图：</p><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/735527-1b4deeefc83a6e16.jpg alt><figcaption>img</figcaption></figure><p>实际上，一次旋转操作并不能保证使失去平衡的树恢复平衡。</p><h5 id=不平衡情况>不平衡情况</h5><p>前面说了插入/删除节点可能导致祖先节点失去平衡。以插入节点为例（删除类似），祖先节点具体<strong>会有4种不平衡情况</strong>：LL、RR、LR、RL。下面具体说明。</p><h6 id=在左孩子的左子树插入节点导致不平衡ll>在左孩子的左子树插入节点导致不平衡LL</h6><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20144254.jpg alt><figcaption>批注 2020-06-11 144254</figcaption></figure><p>这种情况只需在失去平衡的节点Y处，进行一次左旋操作即可。</p><h6 id=在右孩子的右子树插入节点导致不平衡rr>在右孩子的右子树插入节点导致不平衡RR</h6><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20144827.jpg alt><figcaption>批注 2020-06-11 144827</figcaption></figure><p>这种情况只需在失去平衡的节点X处，进行一次右旋操作即可。</p><h6 id=在左孩子的右子树插入节点导致不平衡lr>在左孩子的右子树插入节点导致不平衡LR</h6><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20145834.jpg alt><figcaption>批注 2020-06-11 145834</figcaption></figure><p>这种情况需在失去平衡的节点的左子节点X处，先进行一次左旋操作，再在当前节点Y进行一次右旋操作即可。</p><h6 id=在右孩子的左子树插入节点导致不平衡rl>在右孩子的左子树插入节点导致不平衡RL</h6><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/批注%202020-06-11%20150123.jpg alt><figcaption>批注 2020-06-11 150123</figcaption></figure><p>这种情况需在失去平衡的节点的右子节点处，先进行一次右旋操作，再在当前节点进行一次左旋操作即可。</p><h3 id=java实现插入删除和中序遍历>java实现：（插入/删除和中序遍历）</h3><div class=sourceCode id=cb1><pre class="sourceCode java"><code class="sourceCode java"><span id=cb1-1><a href=#cb1-1></a><span class=kw>package</span><span class=im> com.jingmin.datastructure;</span></span>
<span id=cb1-2><a href=#cb1-2></a></span>
<span id=cb1-3><a href=#cb1-3></a><span class=kw>import</span><span class=im> java.util.Scanner;</span></span>
<span id=cb1-4><a href=#cb1-4></a><span class=kw>import</span><span class=im> java.util.Stack;</span></span>
<span id=cb1-5><a href=#cb1-5></a></span>
<span id=cb1-6><a href=#cb1-6></a><span class=co>/**</span></span>
<span id=cb1-7><a href=#cb1-7></a> <span class=co>* </span><span class=an>@author </span><span class=co>:</span> wangjm</span>
<span id=cb1-8><a href=#cb1-8></a> <span class=co>*</span> <span class=co>@</span>date <span class=co>:</span> <span class=co>2020/6/11</span> <span class=co>16:38</span></span>
<span id=cb1-9><a href=#cb1-9></a> <span class=co>*</span> AVL树<span class=co>(</span>插入<span class=co>/</span>删除操作和中序遍历）</span>
<span id=cb1-10><a href=#cb1-10></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb1-11><a href=#cb1-11></a> <span class=co>*</span> 参考（过程和逻辑）：https<span class=co>://</span>zhuanlan<span class=co>.</span>zhihu<span class=co>.</span>com<span class=co>/</span>p<span class=co>/34899732</span></span>
<span id=cb1-12><a href=#cb1-12></a> <span class=co>*</span> 参考（类结构和部分实现）：https<span class=co>://</span>blog<span class=co>.</span>csdn<span class=co>.</span>net<span class=co>/</span>qq_25806863<span class=co>/</span>article<span class=co>/</span>details<span class=co>/74755131</span></span>
<span id=cb1-13><a href=#cb1-13></a> <span class=co>*</span> 相关题目<span class=co>:</span> https<span class=co>://</span>www<span class=co>.</span>nowcoder<span class=co>.</span>com<span class=co>/</span>pat<span class=co>/5/</span>problem<span class=co>/4117</span></span>
<span id=cb1-14><a href=#cb1-14></a> <span class=co>*</span> <span class=kw>&lt;p&gt;</span></span>
<span id=cb1-15><a href=#cb1-15></a> <span class=co>*</span> 注意：java里没有指针，在子节点的方法中，想修改父亲节点的对子节点的引用，需要借助递归+返回值</span>
<span id=cb1-16><a href=#cb1-16></a> <span class=co>*/</span></span>
<span id=cb1-17><a href=#cb1-17></a><span class=kw>public</span> <span class=kw>class</span> AVLTree {</span>
<span id=cb1-18><a href=#cb1-18></a>    <span class=co>/**</span></span>
<span id=cb1-19><a href=#cb1-19></a>     <span class=co>*</span> AVL树的根</span>
<span id=cb1-20><a href=#cb1-20></a>     <span class=co>*/</span></span>
<span id=cb1-21><a href=#cb1-21></a>    Node1024 root;</span>
<span id=cb1-22><a href=#cb1-22></a></span>
<span id=cb1-23><a href=#cb1-23></a>    <span class=co>/**</span></span>
<span id=cb1-24><a href=#cb1-24></a>     <span class=co>*</span> 插入操作</span>
<span id=cb1-25><a href=#cb1-25></a>     <span class=co>*/</span></span>
<span id=cb1-26><a href=#cb1-26></a>    <span class=kw>public</span> <span class=dt>void</span> <span class=fu>insert</span>(<span class=dt>int</span> n) {</span>
<span id=cb1-27><a href=#cb1-27></a>        root = <span class=fu>insert</span>(root, n);</span>
<span id=cb1-28><a href=#cb1-28></a>    }</span>
<span id=cb1-29><a href=#cb1-29></a></span>
<span id=cb1-30><a href=#cb1-30></a>    <span class=co>/**</span></span>
<span id=cb1-31><a href=#cb1-31></a>     <span class=co>*</span> 删除操作</span>
<span id=cb1-32><a href=#cb1-32></a>     <span class=co>*/</span></span>
<span id=cb1-33><a href=#cb1-33></a>    <span class=kw>public</span> <span class=dt>void</span> <span class=fu>delete</span>(<span class=dt>int</span> n) {</span>
<span id=cb1-34><a href=#cb1-34></a>        root = <span class=fu>delete</span>(root, n);</span>
<span id=cb1-35><a href=#cb1-35></a>    }</span>
<span id=cb1-36><a href=#cb1-36></a></span>
<span id=cb1-37><a href=#cb1-37></a>    <span class=kw>public</span> <span class=dt>static</span> Node1024 <span class=fu>insert</span>(Node1024 node, <span class=dt>int</span> n) {</span>
<span id=cb1-38><a href=#cb1-38></a>        <span class=kw>if</span> (node == <span class=kw>null</span>) {</span>
<span id=cb1-39><a href=#cb1-39></a>            <span class=kw>return</span> <span class=kw>new</span> <span class=fu>Node1024</span>(n);</span>
<span id=cb1-40><a href=#cb1-40></a>        }</span>
<span id=cb1-41><a href=#cb1-41></a>        <span class=co>//递归插入</span></span>
<span id=cb1-42><a href=#cb1-42></a>        <span class=kw>if</span> (n &lt; node.<span class=fu>value</span>) {</span>
<span id=cb1-43><a href=#cb1-43></a>            node.<span class=fu>lChild</span> = <span class=fu>insert</span>(node.<span class=fu>lChild</span>, n);</span>
<span id=cb1-44><a href=#cb1-44></a>        } <span class=kw>else</span> <span class=kw>if</span> (n &gt; node.<span class=fu>value</span>) {</span>
<span id=cb1-45><a href=#cb1-45></a>            node.<span class=fu>rChild</span> = <span class=fu>insert</span>(node.<span class=fu>rChild</span>, n);</span>
<span id=cb1-46><a href=#cb1-46></a>        }</span>
<span id=cb1-47><a href=#cb1-47></a>        <span class=co>//使当前节点保持平衡</span></span>
<span id=cb1-48><a href=#cb1-48></a>        <span class=co>// 注意，insert()是个递归函数，所以随后也逆着查找路径，逐级维护各祖先节点的平衡。</span></span>
<span id=cb1-49><a href=#cb1-49></a>        node = <span class=fu>reBalance</span>(node);</span>
<span id=cb1-50><a href=#cb1-50></a>        <span class=co>//更新当前节点高度(就算插入后仍然平衡，但是高度可能会改变）</span></span>
<span id=cb1-51><a href=#cb1-51></a>        node.<span class=fu>setHeight</span>();</span>
<span id=cb1-52><a href=#cb1-52></a>        <span class=kw>return</span> node;</span>
<span id=cb1-53><a href=#cb1-53></a>    }</span>
<span id=cb1-54><a href=#cb1-54></a></span>
<span id=cb1-55><a href=#cb1-55></a>    <span class=kw>public</span> <span class=dt>static</span> Node1024 <span class=fu>delete</span>(Node1024 node, <span class=dt>int</span> n) {</span>
<span id=cb1-56><a href=#cb1-56></a>        <span class=kw>if</span> (node == <span class=kw>null</span>) {</span>
<span id=cb1-57><a href=#cb1-57></a>            <span class=kw>return</span> <span class=kw>null</span>;</span>
<span id=cb1-58><a href=#cb1-58></a>        }</span>
<span id=cb1-59><a href=#cb1-59></a>        <span class=co>//如果要删除的不是当前节点，递归去子节点删除</span></span>
<span id=cb1-60><a href=#cb1-60></a>        <span class=kw>if</span> (n &lt; node.<span class=fu>value</span>) {</span>
<span id=cb1-61><a href=#cb1-61></a>            node.<span class=fu>lChild</span> = <span class=fu>delete</span>(node.<span class=fu>lChild</span>, n);</span>
<span id=cb1-62><a href=#cb1-62></a>        } <span class=kw>else</span> <span class=kw>if</span> (n &gt; node.<span class=fu>value</span>) {</span>
<span id=cb1-63><a href=#cb1-63></a>            node.<span class=fu>rChild</span> = <span class=fu>delete</span>(node.<span class=fu>rChild</span>, n);</span>
<span id=cb1-64><a href=#cb1-64></a>        } <span class=kw>else</span> {</span>
<span id=cb1-65><a href=#cb1-65></a>            <span class=co>//如果删除的就是本节点，考虑本节点是叶子/单链/满分支</span></span>
<span id=cb1-66><a href=#cb1-66></a>            <span class=kw>if</span> (node.<span class=fu>lChild</span> != <span class=kw>null</span> &amp;&amp; node.<span class=fu>rChild</span> != <span class=kw>null</span>) {</span>
<span id=cb1-67><a href=#cb1-67></a>                <span class=co>//满分支情况</span></span>
<span id=cb1-68><a href=#cb1-68></a>                <span class=co>//去右子树找下一个节点(一定是个叶子），换到当前位置</span></span>
<span id=cb1-69><a href=#cb1-69></a>                Node1024 min = node.<span class=fu>rChild</span>;</span>
<span id=cb1-70><a href=#cb1-70></a>                <span class=kw>while</span> (min.<span class=fu>lChild</span> != <span class=kw>null</span>) {</span>
<span id=cb1-71><a href=#cb1-71></a>                    min = min.<span class=fu>lChild</span>;</span>
<span id=cb1-72><a href=#cb1-72></a>                }</span>
<span id=cb1-73><a href=#cb1-73></a>                min.<span class=fu>rChild</span> = <span class=fu>delete</span>(node.<span class=fu>rChild</span>, min.<span class=fu>value</span>);</span>
<span id=cb1-74><a href=#cb1-74></a>                min.<span class=fu>lChild</span> = node.<span class=fu>lChild</span>;</span>
<span id=cb1-75><a href=#cb1-75></a>                node = min;</span>
<span id=cb1-76><a href=#cb1-76></a>            } <span class=kw>else</span> {</span>
<span id=cb1-77><a href=#cb1-77></a>                <span class=co>//单链/叶子情况</span></span>
<span id=cb1-78><a href=#cb1-78></a>                node = (node.<span class=fu>lChild</span> != <span class=kw>null</span>) ? node.<span class=fu>lChild</span> : node.<span class=fu>rChild</span>;</span>
<span id=cb1-79><a href=#cb1-79></a>            }</span>
<span id=cb1-80><a href=#cb1-80></a>        }</span>
<span id=cb1-81><a href=#cb1-81></a>        <span class=co>//叶子节点删掉就没了，不需要如下操作。</span></span>
<span id=cb1-82><a href=#cb1-82></a>        <span class=kw>if</span> (node != <span class=kw>null</span>) {</span>
<span id=cb1-83><a href=#cb1-83></a>            <span class=co>//重新平衡</span></span>
<span id=cb1-84><a href=#cb1-84></a>            node = <span class=fu>reBalance</span>(node);</span>
<span id=cb1-85><a href=#cb1-85></a>            <span class=co>//更新当前节点高度</span></span>
<span id=cb1-86><a href=#cb1-86></a>            node.<span class=fu>setHeight</span>();</span>
<span id=cb1-87><a href=#cb1-87></a>        }</span>
<span id=cb1-88><a href=#cb1-88></a>        <span class=kw>return</span> node;</span>
<span id=cb1-89><a href=#cb1-89></a>    }</span>
<span id=cb1-90><a href=#cb1-90></a></span>
<span id=cb1-91><a href=#cb1-91></a>    <span class=kw>private</span> <span class=dt>static</span> Node1024 <span class=fu>reBalance</span>(Node1024 node) {</span>
<span id=cb1-92><a href=#cb1-92></a>        <span class=dt>int</span> factor = node.<span class=fu>getFactor</span>();</span>
<span id=cb1-93><a href=#cb1-93></a>        <span class=kw>if</span> (factor &gt; <span class=dv>1</span>) {</span>
<span id=cb1-94><a href=#cb1-94></a>            <span class=kw>if</span> (node.<span class=fu>lChild</span>.<span class=fu>getFactor</span>() &gt; <span class=dv>0</span>) {</span>
<span id=cb1-95><a href=#cb1-95></a>                <span class=co>//LL不平衡情形，单次右旋</span></span>
<span id=cb1-96><a href=#cb1-96></a>                node = <span class=fu>rightRotate</span>(node);</span>
<span id=cb1-97><a href=#cb1-97></a>            } <span class=kw>else</span> {</span>
<span id=cb1-98><a href=#cb1-98></a>                <span class=co>//LR不平衡情形，先左旋，再右旋</span></span>
<span id=cb1-99><a href=#cb1-99></a>                node.<span class=fu>lChild</span> = <span class=fu>leftRotate</span>(node.<span class=fu>lChild</span>);</span>
<span id=cb1-100><a href=#cb1-100></a>                node = <span class=fu>rightRotate</span>(node);</span>
<span id=cb1-101><a href=#cb1-101></a>            }</span>
<span id=cb1-102><a href=#cb1-102></a>        } <span class=kw>else</span> <span class=kw>if</span> (factor &lt; -<span class=dv>1</span>) {</span>
<span id=cb1-103><a href=#cb1-103></a>            <span class=kw>if</span> (node.<span class=fu>rChild</span>.<span class=fu>getFactor</span>() &gt; <span class=dv>0</span>) {</span>
<span id=cb1-104><a href=#cb1-104></a>                <span class=co>//RL不平衡情形，先右旋，再左旋</span></span>
<span id=cb1-105><a href=#cb1-105></a>                node.<span class=fu>rChild</span> = <span class=fu>rightRotate</span>(node.<span class=fu>rChild</span>);</span>
<span id=cb1-106><a href=#cb1-106></a>                node = <span class=fu>leftRotate</span>(node);</span>
<span id=cb1-107><a href=#cb1-107></a>            } <span class=kw>else</span> {</span>
<span id=cb1-108><a href=#cb1-108></a>                <span class=co>//RR不平衡情形，单次左旋</span></span>
<span id=cb1-109><a href=#cb1-109></a>                node = <span class=fu>leftRotate</span>(node);</span>
<span id=cb1-110><a href=#cb1-110></a>            }</span>
<span id=cb1-111><a href=#cb1-111></a>        }</span>
<span id=cb1-112><a href=#cb1-112></a>        <span class=kw>return</span> node;</span>
<span id=cb1-113><a href=#cb1-113></a>    }</span>
<span id=cb1-114><a href=#cb1-114></a></span>
<span id=cb1-115><a href=#cb1-115></a></span>
<span id=cb1-116><a href=#cb1-116></a>    <span class=co>/**</span></span>
<span id=cb1-117><a href=#cb1-117></a>     <span class=co>*</span> 右旋操作</span>
<span id=cb1-118><a href=#cb1-118></a>     <span class=co>*/</span></span>
<span id=cb1-119><a href=#cb1-119></a>    <span class=kw>private</span> <span class=dt>static</span> Node1024 <span class=fu>rightRotate</span>(Node1024 root) {</span>
<span id=cb1-120><a href=#cb1-120></a>        <span class=co>//右旋操作</span></span>
<span id=cb1-121><a href=#cb1-121></a>        Node1024 left = root.<span class=fu>lChild</span>;</span>
<span id=cb1-122><a href=#cb1-122></a>        root.<span class=fu>lChild</span> = left.<span class=fu>rChild</span>;</span>
<span id=cb1-123><a href=#cb1-123></a>        left.<span class=fu>rChild</span> = root;</span>
<span id=cb1-124><a href=#cb1-124></a>        <span class=co>//更新高度(root旋转到了较下面的位置，要先更新高度）</span></span>
<span id=cb1-125><a href=#cb1-125></a>        root.<span class=fu>setHeight</span>();</span>
<span id=cb1-126><a href=#cb1-126></a>        left.<span class=fu>setHeight</span>();</span>
<span id=cb1-127><a href=#cb1-127></a>        <span class=co>//返回新的上级节点</span></span>
<span id=cb1-128><a href=#cb1-128></a>        <span class=kw>return</span> left;</span>
<span id=cb1-129><a href=#cb1-129></a>    }</span>
<span id=cb1-130><a href=#cb1-130></a></span>
<span id=cb1-131><a href=#cb1-131></a>    <span class=co>/**</span></span>
<span id=cb1-132><a href=#cb1-132></a>     <span class=co>*</span> 左旋操作</span>
<span id=cb1-133><a href=#cb1-133></a>     <span class=co>*/</span></span>
<span id=cb1-134><a href=#cb1-134></a>    <span class=kw>private</span> <span class=dt>static</span> Node1024 <span class=fu>leftRotate</span>(Node1024 root) {</span>
<span id=cb1-135><a href=#cb1-135></a>        <span class=co>//左旋操作</span></span>
<span id=cb1-136><a href=#cb1-136></a>        Node1024 right = root.<span class=fu>rChild</span>;</span>
<span id=cb1-137><a href=#cb1-137></a>        root.<span class=fu>rChild</span> = right.<span class=fu>lChild</span>;</span>
<span id=cb1-138><a href=#cb1-138></a>        right.<span class=fu>lChild</span> = root;</span>
<span id=cb1-139><a href=#cb1-139></a>        <span class=co>//更新高度</span></span>
<span id=cb1-140><a href=#cb1-140></a>        root.<span class=fu>setHeight</span>();</span>
<span id=cb1-141><a href=#cb1-141></a>        right.<span class=fu>setHeight</span>();</span>
<span id=cb1-142><a href=#cb1-142></a>        <span class=kw>return</span> right;</span>
<span id=cb1-143><a href=#cb1-143></a>    }</span>
<span id=cb1-144><a href=#cb1-144></a></span>
<span id=cb1-145><a href=#cb1-145></a>    <span class=co>/**</span></span>
<span id=cb1-146><a href=#cb1-146></a>     <span class=co>*</span> 中序遍历</span>
<span id=cb1-147><a href=#cb1-147></a>     <span class=co>*/</span></span>
<span id=cb1-148><a href=#cb1-148></a>    <span class=kw>public</span> <span class=bu>String</span> <span class=fu>inOrderTraversal</span>() {</span>
<span id=cb1-149><a href=#cb1-149></a>        <span class=kw>if</span> (<span class=kw>this</span>.<span class=fu>root</span> == <span class=kw>null</span>) {</span>
<span id=cb1-150><a href=#cb1-150></a>            <span class=kw>return</span> <span class=kw>null</span>;</span>
<span id=cb1-151><a href=#cb1-151></a>        }</span>
<span id=cb1-152><a href=#cb1-152></a>        Node1024 node = root;</span>
<span id=cb1-153><a href=#cb1-153></a>        <span class=bu>Stack</span>&lt;Node1024&gt; stack = <span class=kw>new</span> <span class=bu>Stack</span>&lt;&gt;();</span>
<span id=cb1-154><a href=#cb1-154></a>        <span class=bu>StringBuilder</span> sb = <span class=kw>new</span> <span class=bu>StringBuilder</span>();</span>
<span id=cb1-155><a href=#cb1-155></a>        <span class=kw>while</span> (node != <span class=kw>null</span> || !stack.<span class=fu>isEmpty</span>()) {</span>
<span id=cb1-156><a href=#cb1-156></a>            <span class=kw>while</span> (node != <span class=kw>null</span>) {</span>
<span id=cb1-157><a href=#cb1-157></a>                stack.<span class=fu>push</span>(node);</span>
<span id=cb1-158><a href=#cb1-158></a>                node = node.<span class=fu>lChild</span>;</span>
<span id=cb1-159><a href=#cb1-159></a>            }</span>
<span id=cb1-160><a href=#cb1-160></a>            <span class=kw>if</span> (!stack.<span class=fu>isEmpty</span>()) {</span>
<span id=cb1-161><a href=#cb1-161></a>                node = stack.<span class=fu>pop</span>();</span>
<span id=cb1-162><a href=#cb1-162></a>                sb.<span class=fu>append</span>(node.<span class=fu>value</span>).<span class=fu>append</span>(<span class=st>&quot; &quot;</span>);</span>
<span id=cb1-163><a href=#cb1-163></a>                node = node.<span class=fu>rChild</span>;</span>
<span id=cb1-164><a href=#cb1-164></a>            }</span>
<span id=cb1-165><a href=#cb1-165></a>        }</span>
<span id=cb1-166><a href=#cb1-166></a>        <span class=kw>if</span> (sb.<span class=fu>length</span>() &gt; <span class=dv>0</span>) {</span>
<span id=cb1-167><a href=#cb1-167></a>            sb.<span class=fu>setLength</span>(sb.<span class=fu>length</span>() - <span class=dv>1</span>);</span>
<span id=cb1-168><a href=#cb1-168></a>        }</span>
<span id=cb1-169><a href=#cb1-169></a>        <span class=kw>return</span> sb.<span class=fu>toString</span>();</span>
<span id=cb1-170><a href=#cb1-170></a>    }</span>
<span id=cb1-171><a href=#cb1-171></a></span>
<span id=cb1-172><a href=#cb1-172></a>    <span class=co>/**</span></span>
<span id=cb1-173><a href=#cb1-173></a>     <span class=co>*</span> 测试</span>
<span id=cb1-174><a href=#cb1-174></a>     <span class=co>*/</span></span>
<span id=cb1-175><a href=#cb1-175></a>    <span class=kw>public</span> <span class=dt>static</span> <span class=dt>void</span> <span class=fu>main</span>(<span class=bu>String</span>[] args) {</span>
<span id=cb1-176><a href=#cb1-176></a>        <span class=bu>Scanner</span> scanner = <span class=kw>new</span> <span class=bu>Scanner</span>(<span class=bu>System</span>.<span class=fu>in</span>);</span>
<span id=cb1-177><a href=#cb1-177></a>        <span class=dt>int</span> n = scanner.<span class=fu>nextInt</span>();</span>
<span id=cb1-178><a href=#cb1-178></a>        AVLTree tree = <span class=kw>new</span> <span class=fu>AVLTree</span>();</span>
<span id=cb1-179><a href=#cb1-179></a>        <span class=kw>for</span> (<span class=dt>int</span> i = <span class=dv>0</span>; i &lt; n; i++) {</span>
<span id=cb1-180><a href=#cb1-180></a>            tree.<span class=fu>insert</span>(scanner.<span class=fu>nextInt</span>());</span>
<span id=cb1-181><a href=#cb1-181></a>        }</span>
<span id=cb1-182><a href=#cb1-182></a>        scanner.<span class=fu>close</span>();</span>
<span id=cb1-183><a href=#cb1-183></a>        <span class=bu>System</span>.<span class=fu>out</span>.<span class=fu>println</span>(tree.<span class=fu>root</span>.<span class=fu>value</span>);</span>
<span id=cb1-184><a href=#cb1-184></a><span class=co>//        System.out.println(tree.inOrderTraversal());</span></span>
<span id=cb1-185><a href=#cb1-185></a><span class=co>//        System.out.println(&quot;Delete 80:&quot;);</span></span>
<span id=cb1-186><a href=#cb1-186></a><span class=co>//        tree.delete(80);</span></span>
<span id=cb1-187><a href=#cb1-187></a><span class=co>//        System.out.println(tree.inOrderTraversal());</span></span>
<span id=cb1-188><a href=#cb1-188></a><span class=co>//        System.out.println(&quot;Delete 88:&quot;);</span></span>
<span id=cb1-189><a href=#cb1-189></a><span class=co>//        tree.delete(88);</span></span>
<span id=cb1-190><a href=#cb1-190></a><span class=co>//        System.out.println(tree.inOrderTraversal());</span></span>
<span id=cb1-191><a href=#cb1-191></a><span class=co>//        System.out.println(&quot;Delete 70:&quot;);</span></span>
<span id=cb1-192><a href=#cb1-192></a><span class=co>//        tree.delete(70);</span></span>
<span id=cb1-193><a href=#cb1-193></a><span class=co>//        System.out.println(tree.inOrderTraversal());</span></span>
<span id=cb1-194><a href=#cb1-194></a>    }</span>
<span id=cb1-195><a href=#cb1-195></a>}</span>
<span id=cb1-196><a href=#cb1-196></a></span>
<span id=cb1-197><a href=#cb1-197></a><span class=co>/**</span></span>
<span id=cb1-198><a href=#cb1-198></a> <span class=co>*</span> AVL树节点</span>
<span id=cb1-199><a href=#cb1-199></a> <span class=co>*/</span></span>
<span id=cb1-200><a href=#cb1-200></a><span class=kw>class</span> Node1024 {</span>
<span id=cb1-201><a href=#cb1-201></a>    <span class=dt>int</span> height;</span>
<span id=cb1-202><a href=#cb1-202></a>    <span class=dt>int</span> value;</span>
<span id=cb1-203><a href=#cb1-203></a>    Node1024 lChild, rChild;</span>
<span id=cb1-204><a href=#cb1-204></a></span>
<span id=cb1-205><a href=#cb1-205></a>    <span class=kw>public</span> <span class=fu>Node1024</span>(<span class=dt>int</span> value) {</span>
<span id=cb1-206><a href=#cb1-206></a>        <span class=kw>this</span>.<span class=fu>value</span> = value;</span>
<span id=cb1-207><a href=#cb1-207></a>        <span class=kw>this</span>.<span class=fu>height</span> = <span class=dv>1</span>;</span>
<span id=cb1-208><a href=#cb1-208></a>    }</span>
<span id=cb1-209><a href=#cb1-209></a></span>
<span id=cb1-210><a href=#cb1-210></a>    <span class=co>/**</span></span>
<span id=cb1-211><a href=#cb1-211></a>     <span class=co>*</span> 更新节点的高度</span>
<span id=cb1-212><a href=#cb1-212></a>     <span class=co>*/</span></span>
<span id=cb1-213><a href=#cb1-213></a>    <span class=kw>public</span> <span class=dt>void</span> <span class=fu>setHeight</span>() {</span>
<span id=cb1-214><a href=#cb1-214></a>        <span class=dt>int</span> lHeight = <span class=kw>this</span>.<span class=fu>lChild</span> == <span class=kw>null</span> ? <span class=dv>0</span> : <span class=kw>this</span>.<span class=fu>lChild</span>.<span class=fu>height</span>;</span>
<span id=cb1-215><a href=#cb1-215></a>        <span class=dt>int</span> rHeight = <span class=kw>this</span>.<span class=fu>rChild</span> == <span class=kw>null</span> ? <span class=dv>0</span> : <span class=kw>this</span>.<span class=fu>rChild</span>.<span class=fu>height</span>;</span>
<span id=cb1-216><a href=#cb1-216></a>        <span class=kw>this</span>.<span class=fu>height</span> = <span class=dv>1</span> + (lHeight &gt; rHeight ? lHeight : rHeight);</span>
<span id=cb1-217><a href=#cb1-217></a>    }</span>
<span id=cb1-218><a href=#cb1-218></a></span>
<span id=cb1-219><a href=#cb1-219></a>    <span class=co>/**</span></span>
<span id=cb1-220><a href=#cb1-220></a>     <span class=co>*</span> 计算平衡因子</span>
<span id=cb1-221><a href=#cb1-221></a>     <span class=co>*/</span></span>
<span id=cb1-222><a href=#cb1-222></a>    <span class=kw>public</span> <span class=dt>int</span> <span class=fu>getFactor</span>() {</span>
<span id=cb1-223><a href=#cb1-223></a>        <span class=dt>int</span> lHeight = <span class=kw>this</span>.<span class=fu>lChild</span> == <span class=kw>null</span> ? <span class=dv>0</span> : <span class=kw>this</span>.<span class=fu>lChild</span>.<span class=fu>height</span>;</span>
<span id=cb1-224><a href=#cb1-224></a>        <span class=dt>int</span> rHeight = <span class=kw>this</span>.<span class=fu>rChild</span> == <span class=kw>null</span> ? <span class=dv>0</span> : <span class=kw>this</span>.<span class=fu>rChild</span>.<span class=fu>height</span>;</span>
<span id=cb1-225><a href=#cb1-225></a>        <span class=kw>return</span> lHeight - rHeight;</span>
<span id=cb1-226><a href=#cb1-226></a>    }</span>
<span id=cb1-227><a href=#cb1-227></a>}</span></code></pre></div><h3 id=c实现仅插入操作>c++实现：（仅插入操作）</h3><div class=sourceCode id=cb2><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id=cb2-1><a href=#cb2-1></a><span class=co>//来源：牛客网牛友提交的答案</span></span>
<span id=cb2-2><a href=#cb2-2></a><span class=co>//https://www.nowcoder.com/profile/4547010/codeBookDetail?submissionId=8196767</span></span>
<span id=cb2-3><a href=#cb2-3></a><span class=pp>#include </span><span class=im>&lt;iostream&gt;</span></span>
<span id=cb2-4><a href=#cb2-4></a><span class=pp>#include </span><span class=im>&lt;cstdio&gt;</span></span>
<span id=cb2-5><a href=#cb2-5></a><span class=pp>#include </span><span class=im>&lt;string&gt;</span></span>
<span id=cb2-6><a href=#cb2-6></a><span class=kw>using</span> <span class=kw>namespace</span> std;</span>
<span id=cb2-7><a href=#cb2-7></a> </span>
<span id=cb2-8><a href=#cb2-8></a><span class=kw>struct</span> node</span>
<span id=cb2-9><a href=#cb2-9></a>{</span>
<span id=cb2-10><a href=#cb2-10></a>    <span class=dt>int</span> v,h;</span>
<span id=cb2-11><a href=#cb2-11></a>    node *l,*r;</span>
<span id=cb2-12><a href=#cb2-12></a>};</span>
<span id=cb2-13><a href=#cb2-13></a> </span>
<span id=cb2-14><a href=#cb2-14></a>node tree[<span class=dv>22</span>];</span>
<span id=cb2-15><a href=#cb2-15></a><span class=dt>int</span> sum;</span>
<span id=cb2-16><a href=#cb2-16></a> </span>
<span id=cb2-17><a href=#cb2-17></a><span class=dt>int</span> H(node *a)</span>
<span id=cb2-18><a href=#cb2-18></a>{</span>
<span id=cb2-19><a href=#cb2-19></a>    <span class=cf>return</span> a?(a-&gt;h):(-<span class=dv>1</span>);</span>
<span id=cb2-20><a href=#cb2-20></a>}</span>
<span id=cb2-21><a href=#cb2-21></a> </span>
<span id=cb2-22><a href=#cb2-22></a>node *LL(node *k1)</span>
<span id=cb2-23><a href=#cb2-23></a>{</span>
<span id=cb2-24><a href=#cb2-24></a>    node *k2 = k1-&gt;l;</span>
<span id=cb2-25><a href=#cb2-25></a>    k1-&gt;l = k2-&gt;r;</span>
<span id=cb2-26><a href=#cb2-26></a>    k2-&gt;r = k1;</span>
<span id=cb2-27><a href=#cb2-27></a>    k1-&gt;h = max(H(k1-&gt;l),H(k1-&gt;r))+<span class=dv>1</span>;</span>
<span id=cb2-28><a href=#cb2-28></a>    k2-&gt;h = max(H(k2-&gt;l),H(k2-&gt;r))+<span class=dv>1</span>;</span>
<span id=cb2-29><a href=#cb2-29></a>    <span class=cf>return</span> k2;</span>
<span id=cb2-30><a href=#cb2-30></a>}</span>
<span id=cb2-31><a href=#cb2-31></a> </span>
<span id=cb2-32><a href=#cb2-32></a>node *RR(node *k1)</span>
<span id=cb2-33><a href=#cb2-33></a>{</span>
<span id=cb2-34><a href=#cb2-34></a>    node *k2 = k1-&gt;r;</span>
<span id=cb2-35><a href=#cb2-35></a>    k1-&gt;r = k2-&gt;l;</span>
<span id=cb2-36><a href=#cb2-36></a>    k2-&gt;l = k1;</span>
<span id=cb2-37><a href=#cb2-37></a>    k1-&gt;h = max(H(k1-&gt;l),H(k1-&gt;r))+<span class=dv>1</span>;</span>
<span id=cb2-38><a href=#cb2-38></a>    k2-&gt;h = max(H(k2-&gt;l),H(k2-&gt;r))+<span class=dv>1</span>;</span>
<span id=cb2-39><a href=#cb2-39></a>    <span class=cf>return</span> k2;</span>
<span id=cb2-40><a href=#cb2-40></a>}</span>
<span id=cb2-41><a href=#cb2-41></a> </span>
<span id=cb2-42><a href=#cb2-42></a>node *LR(node *k1)</span>
<span id=cb2-43><a href=#cb2-43></a>{</span>
<span id=cb2-44><a href=#cb2-44></a>    k1-&gt;l = RR(k1-&gt;l);</span>
<span id=cb2-45><a href=#cb2-45></a>    <span class=cf>return</span> LL(k1);</span>
<span id=cb2-46><a href=#cb2-46></a>}</span>
<span id=cb2-47><a href=#cb2-47></a> </span>
<span id=cb2-48><a href=#cb2-48></a>node *RL(node *k1)</span>
<span id=cb2-49><a href=#cb2-49></a>{</span>
<span id=cb2-50><a href=#cb2-50></a>    k1-&gt;r = LL(k1-&gt;r);</span>
<span id=cb2-51><a href=#cb2-51></a>    <span class=cf>return</span> RR(k1);</span>
<span id=cb2-52><a href=#cb2-52></a>}</span>
<span id=cb2-53><a href=#cb2-53></a> </span>
<span id=cb2-54><a href=#cb2-54></a>node *insertnode(node *root,<span class=dt>int</span> x)</span>
<span id=cb2-55><a href=#cb2-55></a>{</span>
<span id=cb2-56><a href=#cb2-56></a>    <span class=cf>if</span>(root==<span class=dv>0</span>)</span>
<span id=cb2-57><a href=#cb2-57></a>    {</span>
<span id=cb2-58><a href=#cb2-58></a>        root = &amp;tree[sum++];</span>
<span id=cb2-59><a href=#cb2-59></a>        root-&gt;l = root-&gt;r = <span class=dv>0</span>;</span>
<span id=cb2-60><a href=#cb2-60></a>        root-&gt;v = x;</span>
<span id=cb2-61><a href=#cb2-61></a>        root-&gt;h = <span class=dv>0</span>;</span>
<span id=cb2-62><a href=#cb2-62></a>    }</span>
<span id=cb2-63><a href=#cb2-63></a>    <span class=cf>else</span> <span class=cf>if</span>(x &lt; root-&gt;v)</span>
<span id=cb2-64><a href=#cb2-64></a>    {</span>
<span id=cb2-65><a href=#cb2-65></a>        root-&gt;l = insertnode(root-&gt;l, x);</span>
<span id=cb2-66><a href=#cb2-66></a>        <span class=cf>if</span>(H(root-&gt;l) - H(root-&gt;r)==<span class=dv>2</span>)</span>
<span id=cb2-67><a href=#cb2-67></a>            root = (x &lt; root-&gt;l-&gt;v)?LL(root):LR(root);</span>
<span id=cb2-68><a href=#cb2-68></a>    }</span>
<span id=cb2-69><a href=#cb2-69></a>    <span class=cf>else</span></span>
<span id=cb2-70><a href=#cb2-70></a>    {</span>
<span id=cb2-71><a href=#cb2-71></a>        root-&gt;r = insertnode(root-&gt;r, x);</span>
<span id=cb2-72><a href=#cb2-72></a>        <span class=cf>if</span>(H(root-&gt;r) - H(root-&gt;l)==<span class=dv>2</span>)</span>
<span id=cb2-73><a href=#cb2-73></a>            root = (x &gt; root-&gt;r-&gt;v)?RR(root):RL(root);</span>
<span id=cb2-74><a href=#cb2-74></a>    }</span>
<span id=cb2-75><a href=#cb2-75></a>    root-&gt;h = max(H(root-&gt;l), H(root-&gt;r))+<span class=dv>1</span>;</span>
<span id=cb2-76><a href=#cb2-76></a>    <span class=cf>return</span> root;</span>
<span id=cb2-77><a href=#cb2-77></a>}</span>
<span id=cb2-78><a href=#cb2-78></a> </span>
<span id=cb2-79><a href=#cb2-79></a><span class=dt>int</span> main()</span>
<span id=cb2-80><a href=#cb2-80></a>{</span>
<span id=cb2-81><a href=#cb2-81></a>    <span class=dt>int</span> n;</span>
<span id=cb2-82><a href=#cb2-82></a>    node *root = <span class=dv>0</span>;</span>
<span id=cb2-83><a href=#cb2-83></a>    scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>,&amp;n);</span>
<span id=cb2-84><a href=#cb2-84></a>    <span class=cf>for</span>(<span class=dt>int</span> i=<span class=dv>0</span>;i&lt;n;i++)</span>
<span id=cb2-85><a href=#cb2-85></a>    {</span>
<span id=cb2-86><a href=#cb2-86></a>        <span class=dt>int</span> x;</span>
<span id=cb2-87><a href=#cb2-87></a>        scanf(<span class=st>&quot;</span><span class=sc>%d</span><span class=st>&quot;</span>,&amp;x);</span>
<span id=cb2-88><a href=#cb2-88></a>        root = insertnode(root,x);</span>
<span id=cb2-89><a href=#cb2-89></a>    }</span>
<span id=cb2-90><a href=#cb2-90></a>    printf(<span class=st>&quot;</span><span class=sc>%d\n</span><span class=st>&quot;</span>,root-&gt;v);</span>
<span id=cb2-91><a href=#cb2-91></a>}</span></code></pre></div><h1 id=图>图</h1><h2 id=图的逻辑结构>图的逻辑结构</h2><h2 id=图的存储结构>图的存储结构</h2><h4 id=邻接矩阵>邻接矩阵</h4><h4 id=邻接表>邻接表</h4><p>邻接表将邻接矩阵的每行改为单链表存储,具有 n 个顶点,可以用 n 个单链表构成的链表数组存放。 每个 单链表链接一个顶点发出的所有边结点,链表长度即为对应的 顶点的度数。</p><h4 id=邻接多重边表>邻接多重边表</h4><p>邻接多重边表的存储结构不再以顶点为中心,而是以边为 中心。 每条边用一个边结点表示,每个边结点 包含两个端点信息、 和对应两个端点的下一条边结点的指针。 所需存储空间与邻接表相同,但是克服了边属性修改需要两次 的操作的问题。</p><h4 id=半边数据结构>半边数据结构</h4><h4 id=其他图的存储结构>其他图的存储结构</h4><h5 id=三维网格>三维网格</h5><p>节点：三维网格的网格（或网格点）表示节点，用3维数组存储。</p><p>边：每个网格（或网格点）只和周围的6个网格（网格点）邻接。这样的存储结构只能包含边的邻接关系信息，不能包含权值信息。</p><p>可另外使用6个三维网格，单独存储每个网格（网格点）上下左右前后6条邻接边的权值信息。</p><h5 id=三维网格模型的压缩存储csr>三维网格模型的压缩存储CSR</h5><p>CSR：compressed storage format</p><p><a href=http://sourcedb.ict.cas.cn/cn/ictthesis/200907/P020090722590003844310.pdf>参考</a></p><h1 id=散列>散列</h1><h2 id=散列的概念>散列的概念</h2><p><strong>散列</strong>是一种算法（更像是一种思想）。</p><p><strong>散列函数</strong>是将<strong>一系列输入</strong>映射到<strong>有限的存储空间</strong>的函数。</p><p>不同的输入可能会散列成相同的输出（发生<strong>碰撞/冲突</strong>），所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的<a href=https://baike.baidu.com/item/消息摘要/4547744>消息摘要</a>的函数。</p><h2 id=散列的存取过程>散列的存取过程</h2><h3 id=散列的存入操作>散列的存入操作</h3><p>向散列映射的存储空间中存内容前，先<strong>计算散列函数/散列值/地址序标</strong>。 如果<strong>没有发生碰撞</strong>（即散列值对应的存储地址中还没有存入内容），<strong>直接</strong>向对应的存储地址中<strong>写入内容</strong>； 如果<strong>发生了碰撞</strong>，按下面几种<strong>处理冲突</strong>的方法，<strong>寻找新的存储地址</strong>，直到找到空着的存储地址，向其中<strong>写入内容</strong>。</p><h3 id=散列的取出操作>散列的取出操作</h3><p>与散列的存入过程类似，只是要注意，根据散列值/地址序标取内容时，要判断一下是未发生碰撞前存入的值，还是第几次碰撞的值，然后对应取出。</p><h2 id=处理冲突的方法>处理冲突的方法</h2><p>参考：https://baike.baidu.com/item/hash/390310</p><p>参考：https://blog.csdn.net/zeb_perfect/article/details/52574915</p><h3 id=开放寻址法>开放寻址法</h3><p>Hi=(H(key) + di) MOD m,i=1,2,…，k(k&lt;=m-1)，其中H(key)为<a href=https://baike.baidu.com/item/散列函数>散列函数</a>，m为<a href=https://baike.baidu.com/item/散列表>散列表</a>长，di为增量序列，可有下列三种取法：</p><p>1)． di=1,2,3,…，m-1，称线性探测再散列；</p><p>2)． di=1<sup>2,-1</sup>2,2<sup>2,-2</sup>2,3<sup>2,…，±k</sup>2,(k&lt;=m/2)称二次探测再散列；</p><p>3)． di=<a href=https://baike.baidu.com/item/伪随机数>伪随机数</a>序列，称伪随机探测再散列。</p><blockquote><p>注：但是牛客网题目：平方探测的查找式子是(key + step * step) % size 而不是(key % size + step * step)%size</p></blockquote><h3 id=再散列法>再散列法</h3><p>Hi=RHi(key),i=1,2,…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。</p><h3 id=链地址法拉链法>链地址法（拉链法）</h3><p><em>HashMap</em> 就是<em>使用</em>链地址法来<em>解决冲突</em>的（jdk8中采用平衡树来替代链表存储<em>冲突</em>的元素，但<em>hash</em>() <em>方法</em>原理相同）。</p><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/20160918154444663 alt><figcaption>img</figcaption></figure><p>拉链法的优缺点： 优点： ①拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短； ②由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况； ③开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间。而拉链法中可取α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间； ④在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 缺点： 指针需要额外的空间，故当结点规模较小时，开放定址法较为节省空间，而若将节省的指针空间用来扩大散列表的规模，可使装填因子变小，这又减少了开放定址法中的冲突，从而提高平均查找速度。</p><h3 id=建立一个公共溢出区>建立一个公共溢出区</h3><p>假设哈希函数的值域为[0,m-1],则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。</p><h1 id=树状数组>树状数组</h1><p>参考：https://zhuanlan.zhihu.com/p/25185969</p><p>参考*：https://oi-wiki.org/ds/fenwick/</p><p>树状数组可以用来求<strong>数组的区间和</strong>与<strong>前缀和</strong>。（虽然稍稍增加了单点修改的时间）</p><h2 id=树状数组c>树状数组C[]</h2><p>原始数组a[],其中各元素<span class="math inline">\(a_i\)</span>是所需数据。</p><p>树状数组c[],其中各元素<span class="math inline">\(c_i\)</span>管理了一定范围内的a[j:i]元素。</p><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/v2-c57150473a48e2ce46e4a206da5fda21_1200x500.jpg alt><figcaption>树状数组详细讲解，不会算法也能看懂哦~</figcaption></figure><p>c1 = a1 c2 = a1 + a2 c3 = a3 c4 = a1 + a2 + a3 + a4 c5 = a5 c6 = a5 + a6 c7 = a7 c8 = a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8</p><p>c[1]管理的是a[1]； c[2] 管理的是a[1] & a[2] ； c[3]管理的是a[3]； c[4]管理的是a[1] & a[2] & a[3] & a[4]； c[5] 管理的是a[5]； c[6] 管理的是a[5] & a[6] ； c[7]管理的是 a[7]； c[8]管理的是 a[1] & a[2] & a[3] & a[4] & a[5] & a[6] & a[7] & a[8]；</p><h3 id=c_i管理元素的个数><span class="math inline">\(c_i\)</span>管理元素的个数</h3><figure><img src=https://picgo12138.oss-cn-hangzhou.aliyuncs.com/md/fenwick1.png alt><figcaption>img</figcaption></figure><p>c[]中元素<span class="math inline">\(c_i\)</span>具体管理了几个a[]中元素，<strong>由数组标号的二进制形式末尾0的个数决定</strong>。 例如， <span class="math inline">\(1_{(10)}=1_{(2)}\)</span>末尾没有0，管理2^0=1个元素 <span class="math inline">\(2_{(10)}=10_{(2)}\)</span>末尾1个0，管理2^1=2个元素 <span class="math inline">\(3_{(10)}=11_{(2)}\)</span>末尾没有0，管理2^0=1个元素 <span class="math inline">\(4_{(10)}=100_{(2)}\)</span>末尾2个0，管理2^2=4个元素 <span class="math inline">\(5_{(10)}=101_{(2)}\)</span>末尾没有0，管理2^0=1个元素 <span class="math inline">\(6_{(10)}=110_{(2)}\)</span>末尾1个0，管理2^1=2个元素 <span class="math inline">\(7_{(10)}=111_{(2)}\)</span>末尾没有0，管理2^0=1个元素 <span class="math inline">\(8_{(10)}=1000_{(2)}\)</span>末尾3个0，管理2^3=8个元素</p><p>那么怎么获取二进制数末尾0的个数？ 还记得计算机中原码和补码的相互转换吗？ 正数的原码和补码是相同的。 负数的原/补码转换有两种方法： 方法1：表示成2进制，按位取反（不包含符号位），最后再+1 方法2：表示成2进制，从末尾开始向高位，末尾的连续的0和第一个1不变，然后剩下的高位数字都取反（不包含符号位）</p><p>二进制负数的原码补码的相互转换方法2给了我们灵感。转换后高位都取反，中间1个1不变，低位都是0不变。</p><p>比如一个数n=4（带符号32位太长了，这里简单点用8位） n的原码（正数）：<span class="math inline">\(4_{(10)}=100_{(2)}=00000100_{(2)}\)</span> <strong>n的补码</strong>：<span class="math inline">\(4_{(10)}=100_{(2)}=00000100_{(2)}\)</span> -n的原码(负数）:<span class="math inline">\(-4_{(10)}=-100_{(2)}=10000100_{(2)}\)</span> <strong>-n的补码</strong>: <span class="math inline">\(\text{补}[-4_{(10)}]=\text{补}[-100_{(2)}]=11111100_{(2)}\)</span></p><p>计算机中都是补码运算，<strong>相反数补码按位与</strong>，即n & (-n)，只保留了最低位开始的第1个1.从而得到了这个数二进制形式末尾0的个数，或者管理的元素个数。</p><p>回到树状数组，将此操作（<strong>相反数补码按位与</strong>）写成函数，用来获取<span class="math inline">\(c_i\)</span>管理a[j:i]元素个数</p><div class=sourceCode id=cb3><pre class="sourceCode c"><code class="sourceCode c"><span id=cb3-1><a href=#cb3-1></a><span class=dt>int</span> lowbit(<span class=dt>int</span> x) {</span>
<span id=cb3-2><a href=#cb3-2></a>  <span class=co>// 算出x二进制的从右往左出现第一个1以及这个1之后的那些0组成数的二进制对应的十进制的数</span></span>
<span id=cb3-3><a href=#cb3-3></a>  <span class=co>//相反数补码按位与</span></span>
<span id=cb3-4><a href=#cb3-4></a>  <span class=cf>return</span> x &amp; -x;</span>
<span id=cb3-5><a href=#cb3-5></a>}</span></code></pre></div><h3 id=单点修改>单点修改</h3><p>由于我们没有维护a[]，而是维护了树状数组c[]，修改<span class="math inline">\(a_i\)</span>对应于修改c[]中所有管理<span class="math inline">\(a_i\)</span>的元素。</p><div class=sourceCode id=cb4><pre class="sourceCode c"><code class="sourceCode c"><span id=cb4-1><a href=#cb4-1></a><span class=dt>void</span> add(<span class=dt>int</span> x, <span class=dt>int</span> k) {</span>
<span id=cb4-2><a href=#cb4-2></a>  <span class=cf>while</span> (x &lt;= n) {  <span class=co>// 不能越界</span></span>
<span id=cb4-3><a href=#cb4-3></a>    c[x] = c[x] + k;</span>
<span id=cb4-4><a href=#cb4-4></a>    x = x + lowbit(x);</span>
<span id=cb4-5><a href=#cb4-5></a>  }</span>
<span id=cb4-6><a href=#cb4-6></a>}</span></code></pre></div><h3 id=求前缀和>求前缀和</h3><p>求前缀和a[1:i]，从c[i]对应的位置开始加，向靠近0的位置找管理不到的（找到上级就不管它的下级了）</p><div class=sourceCode id=cb5><pre class="sourceCode c"><code class="sourceCode c"><span id=cb5-1><a href=#cb5-1></a><span class=dt>int</span> getsum(<span class=dt>int</span> x) {  <span class=co>// a[1]……a[x]的和</span></span>
<span id=cb5-2><a href=#cb5-2></a>  <span class=dt>int</span> ans = <span class=dv>0</span>;</span>
<span id=cb5-3><a href=#cb5-3></a>  <span class=cf>while</span> (x &gt;= <span class=dv>1</span>) {</span>
<span id=cb5-4><a href=#cb5-4></a>    ans = ans + c[x];</span>
<span id=cb5-5><a href=#cb5-5></a>    x = x - lowbit(x);</span>
<span id=cb5-6><a href=#cb5-6></a>  }</span>
<span id=cb5-7><a href=#cb5-7></a>  <span class=cf>return</span> ans;</span>
<span id=cb5-8><a href=#cb5-8></a>}</span></code></pre></div><h2 id=树状数组t1-t2>树状数组T1[], T2[]</h2><h3 id=区间修改区间求和>区间修改&区间求和</h3><p>原始数组a[],其中各元素<span class="math inline">\(a_i\)</span>是所需数据。 假设数组b[]是a[]的差分数组，则<span class="math inline">\(a_i = \Sigma_{j=1}^i b_i\)</span> ，也即b[]的前缀和为<span class="math inline">\(a_i\)</span></p><p>a[]的前缀和<span class="math inline">\(\Sigma_{i=1}^r a_i\)</span>，经数学推导，可以表示为<span class="math inline">\(\Sigma_{i=1}^r b_i\)</span>和<span class="math inline">\(\Sigma_{i=1}^r (i \cdot b_i)\)</span>的线性运算，分别用b[]和d[]维护。证明：</p><p><span class="math inline">\(\begin{array}{l} \sum_{i=1}^{r} a_{i} \\ =\sum_{i=1}^{r} \sum_{j=1}^{i} b_{j} \\ =\sum_{i=1}^{r} b_{i} \times(r-i+1) \\ =\sum_{i=1}^{r} b_{i} \times(r+1)-\sum_{i=1}^{r} b_{i} \times i \end{array}\)</span></p><p>即a[]的前缀和 可以用 b[]前缀和与d[]前缀和表示。 a[]的区间和也可以表示为两个前缀和的相减。</p><p>综上，a[]可以用其差分数组b[]表示，a[]的前缀和可以用b[]的前缀和与d[]的前缀和表示。</p><p>前面两节我们介绍了使用树状数组c[]表示a[]作<a href=#单点修改>单点修改</a>和求<a href=#前缀和>前缀和</a>。 那么我们同样可以用树状数组t1[],t2[]表示b[],d[]。</p><div class=sourceCode id=cb6><pre class="sourceCode c"><code class="sourceCode c"><span id=cb6-1><a href=#cb6-1></a><span class=dt>int</span> t1[MAXN], t2[MAXN], n;</span>
<span id=cb6-2><a href=#cb6-2></a></span>
<span id=cb6-3><a href=#cb6-3></a><span class=kw>inline</span> <span class=dt>int</span> lowbit(<span class=dt>int</span> x) { <span class=cf>return</span> x &amp; (-x); }</span>
<span id=cb6-4><a href=#cb6-4></a></span>
<span id=cb6-5><a href=#cb6-5></a><span class=dt>void</span> add(<span class=dt>int</span> k, <span class=dt>int</span> v) {</span>
<span id=cb6-6><a href=#cb6-6></a>  <span class=dt>int</span> v1 = k * v;</span>
<span id=cb6-7><a href=#cb6-7></a>  <span class=cf>while</span> (k &lt;= n) {</span>
<span id=cb6-8><a href=#cb6-8></a>    t1[k] += v, t2[k] += v1;</span>
<span id=cb6-9><a href=#cb6-9></a>    k += lowbit(k);</span>
<span id=cb6-10><a href=#cb6-10></a>  }</span>
<span id=cb6-11><a href=#cb6-11></a>}</span>
<span id=cb6-12><a href=#cb6-12></a></span>
<span id=cb6-13><a href=#cb6-13></a><span class=dt>int</span> getsum(<span class=dt>int</span> *t, <span class=dt>int</span> k) {</span>
<span id=cb6-14><a href=#cb6-14></a>  <span class=dt>int</span> ret = <span class=dv>0</span>;</span>
<span id=cb6-15><a href=#cb6-15></a>  <span class=cf>while</span> (k) {</span>
<span id=cb6-16><a href=#cb6-16></a>    ret += t[k];</span>
<span id=cb6-17><a href=#cb6-17></a>    k -= lowbit(k);</span>
<span id=cb6-18><a href=#cb6-18></a>  }</span>
<span id=cb6-19><a href=#cb6-19></a>  <span class=cf>return</span> ret;</span>
<span id=cb6-20><a href=#cb6-20></a>}</span>
<span id=cb6-21><a href=#cb6-21></a></span>
<span id=cb6-22><a href=#cb6-22></a><span class=dt>void</span> add1(<span class=dt>int</span> l, <span class=dt>int</span> r, <span class=dt>int</span> v) {</span>
<span id=cb6-23><a href=#cb6-23></a>  add(l, v), add(r + <span class=dv>1</span>, -v);  <span class=co>// 将区间加差分为两个前缀加</span></span>
<span id=cb6-24><a href=#cb6-24></a>}</span>
<span id=cb6-25><a href=#cb6-25></a></span>
<span id=cb6-26><a href=#cb6-26></a><span class=dt>long</span> <span class=dt>long</span> getsum1(<span class=dt>int</span> l, <span class=dt>int</span> r) {</span>
<span id=cb6-27><a href=#cb6-27></a>  <span class=cf>return</span> (r + <span class=dv>1</span>) * getsum(t1, r) - <span class=dv>1</span> * l * getsum(t1, l - <span class=dv>1</span>) -</span>
<span id=cb6-28><a href=#cb6-28></a>         (getsum(t2, r) - getsum(t2, l - <span class=dv>1</span>));</span>
<span id=cb6-29><a href=#cb6-29></a>}</span></code></pre></div><p>注意：现在已经无法直接获取到<span class="math inline">\(a_i\)</span>,只能求a[]在区间上的和。</p></section></article></main></div><div class="col-sm-3 col-sm-offset-1 doc-sidebar"><div id=sidebar><div class=sidebar-module><div class=sidebar-toc><h4 class=sidebar-heading>Table of Contents</h4><ul><li><strong><a href=#title>数据结构总结</a></strong></li></ul></div></div><div class=sidebar-module><h4 class=sidebar-heading>Pages in Categories</h4><ul class=sidebar-category-list><li><a href=https://ole12138.github.io//categories/http><span class=doc-list-category>Http</span></a><ul><li><a href=/Servlet3.1-Specification.pdf>Servlet3.1-Specification（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/>HTTP认证方式</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/>发起HTTP请求：使用OkHttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/>发起HTTP请求：使用HttpURLConnection</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/https%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E8%BD%AC%E8%BD%BD/>HTTPS简单介绍（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/ssl%E6%88%96tls%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0%E8%BD%AC%E8%BD%BD/>SSL或TLS协议运行机制的概述（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6%E8%BD%AC%E8%BD%BD/>彻底搞懂HTTPS的加密机制（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/>发起HTTP请求：使用JDK11的HttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/>发起HTTP请求：使用Apache的HttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/>HTTP协议介绍(转载)</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%BD%AC%E8%BD%BD/>发起HTTP请求：Spring中RestTemplate设置与携带请求头（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%BD%AC%E8%BD%BD/>发起HTTP请求：Spring中的RestTempalate的基本使用（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/>Java发起HTTP请求方式汇总</a></li></ul></li><li><a href=https://ole12138.github.io//categories/java><span class=doc-list-category>Java</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-spring%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6xsd%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/>随笔-Spring项目配置文件xsd引用问题</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springmvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%BD%AC%E8%BD%BD/>SpringMVC源码分析（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BD%BF%E7%94%A8%E8%BD%AC%E8%BD%BD/>SpringMVC工作流程与使用方式（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E8%BD%AC%E8%BD%BD/>Java设计模式之适配器模式（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/>发起HTTP请求：使用OkHttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/>发起HTTP请求：使用HttpURLConnection</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-jdk%E7%89%88%E6%9C%AC%E7%9A%84%E5%88%87%E6%8D%A2/>随笔-JDK版本的切换</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/>发起HTTP请求：使用JDK11的HttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/>发起HTTP请求：使用Apache的HttpClient</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-java%E4%B8%AD%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E9%97%AD/>Java中资源的关闭</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/>Java设计模式之代理模式</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%BD%AC%E8%BD%BD/>发起HTTP请求：Spring中RestTemplate设置与携带请求头（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%BD%AC%E8%BD%BD/>发起HTTP请求：Spring中的RestTempalate的基本使用（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/>Java发起HTTP请求方式汇总</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E8%BD%AC%E8%BD%BD/>Java8函数式编程入门（转载）</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E6%B3%A8%E8%A7%A3annotation%E8%BD%AC%E8%BD%BD/>Java Annotation认知（转载）</a></li></ul></li><li><a href=https://ole12138.github.io//categories/java%E9%9A%8F%E7%AC%94><span class=doc-list-category>Java随笔</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-spring%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6xsd%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/>随笔-Spring项目配置文件xsd引用问题</a></li></ul></li><li><a href=https://ole12138.github.io//categories/spring><span class=doc-list-category>Spring</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E4%BB%8Exml%E5%90%AF%E5%8A%A8%E6%B3%A8%E8%A7%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E8%BF%87%E7%A8%8B/>Spring从xml启动注解扫描的过程</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%BD%AC%E8%BD%BD/>Spring文档中文翻译(转载)</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%B5%B7%E6%AD%A5/>Spring源码分析起步</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/>Spring构建restfulWebService</a></li></ul></li><li><a href=https://ole12138.github.io//categories/todo><span class=doc-list-category>Todo</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/>发起HTTP请求：使用HttpURLConnection</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB><span class=doc-list-category>前后端分离</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/web%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E8%BD%AC%E8%BD%BD/>Web前后端分离的实现方式（转载）</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E5%B7%A5%E5%85%B7><span class=doc-list-category>工具</span></a><ul><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/maven%E6%89%93%E5%8C%85/>Maven打包</a></li><li><a href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/maven%E4%BD%BF%E7%94%A8%E8%BD%AC%E8%BD%BD/>Maven pom.xml中的元素modules、parent、properties以及import（转载）</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E6%95%B0%E5%AD%A6><span class=doc-list-category>数学</span></a><ul><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/>概率论与数理统计-数理统计-假设检验</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/>概率论与数理统计-数理统计-参数估计</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/>概率论与数理统计-数理统计-基本概念</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/>概率论与数理统计-概率论-大数定律与中心极限定理</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/>概率论与数理统计-概率论-随机变量的数字特征</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/>数学分支的总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/>数学物理方法总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>最优化问题总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/>概率论与数理统计-数理统计-方差分析与回归分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/>概率论与数理统计-概率论-随机事件与概率</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/>概率论与数理统计-概率论-随机变量及其分布</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/>泛函分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/>线性代数-相似矩阵与二次型</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/>线性代数-相似矩阵与二次型习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/>高等数学-级数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/>高等数学-级数习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/>线性代数-向量组的线性相关性</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/>线性代数-向量组的线性相关性习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/>线性代数-矩阵初等变换与线性方程组习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/>线性代数-矩阵初等变换与线性方程组习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/>线性代数-矩阵1</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/>线性代数-矩阵1习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/>线性代数-行列式</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/>线性代数-行列式习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/>线性代数总结</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-多元微积分-曲线积分与曲面积分习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/>高等数学-多元微积分-曲线积分与曲面积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-多元积分学-重积分习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/>高等数学-多元积分学-重积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/>高等数学-多元微分学习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/>高等数学-多元微积分-多元微分学-向量值函数和向量分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/>高等数学-多元微分学-代数应用：多元函数的极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/>高等数学-多元微分学</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/>高等数学-多元微积分概述</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/>高等数学-向量代数与空间解析几何</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/>高等数学-向量代数与空间解析几何习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/>高等数学-微分方程</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/>高等数学-微分方程习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/>高等数学-一元积分学-定积分的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/>高等数学-一元积分学-定积分的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/>高等数学-一元积分学-定积分与反常积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-一元积分学-定积分与反常积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/>高等数学-一元积分学-不定积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-一元积分学-不定积分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/>高等数学-一元微分学-一元微分学的应用-弧微分与曲率</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/>高等数学-一元微分学-导数的应用</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/>高等数学-一元函数微分学-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/>高等数学-一元函数微分学-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/>高等数学-一元微分学-可导函数的中值定理</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/>高等数学-一元微分学-可导函数的中值定理习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/>高等数学-一元微分学-导数的应用-单调性与极值</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/>高等数学-一元微分学-导数和微分</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/>高等数学-基础概念-函数与极限</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/>高等数学-基础概念-函数与极限习题</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/>高等数学-一元微积分-脉络</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/>高等数学与数学分析</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/>基础数学-三角函数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/>基础数学-代数</a></li><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/>基础数学-几何</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95><span class=doc-list-category>数据结构与算法</span></a><ul><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/>PAT甲级习题</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/>数据结构-栈和队列</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/>数据结构-线性表</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/>数据结构与算法的基本概念</a></li><li><span class=active>数据结构总结</span></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/>树和二叉树</a></li><li><a href=/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/>算法总结</a></li></ul></li><li><a href=https://ole12138.github.io//categories/%E7%89%A9%E7%90%86><span class=doc-list-category>物理</span></a><ul><li><a href=/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/>数学物理方法总结</a></li></ul></li></ul></div><div class=sidebar-module><h4 class=sidebar-heading>Tags</h4><div class=tag-box><a class=tag-item href=https://ole12138.github.io//tags/annotation>annotation</a>
<a class=tag-item href=https://ole12138.github.io//tags/authorization>authorization</a>
<a class=tag-item href=https://ole12138.github.io//tags/controller%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E5%80%BC>controller方法返回值</a>
<a class=tag-item href=https://ole12138.github.io//tags/http>http</a>
<a class=tag-item href=https://ole12138.github.io//tags/http1.1>http1.1</a>
<a class=tag-item href=https://ole12138.github.io//tags/http2>http2</a>
<a class=tag-item href=https://ole12138.github.io//tags/httpclient>httpclient</a>
<a class=tag-item href=https://ole12138.github.io//tags/https>https</a>
<a class=tag-item href=https://ole12138.github.io//tags/httpsurlconnection>httpsurlconnection</a>
<a class=tag-item href=https://ole12138.github.io//tags/httpurlconnection>httpurlconnection</a>
<a class=tag-item href=https://ole12138.github.io//tags/jar%E5%8C%85>jar包</a>
<a class=tag-item href=https://ole12138.github.io//tags/java>java</a>
<a class=tag-item href=https://ole12138.github.io//tags/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82>java发起http请求</a>
<a class=tag-item href=https://ole12138.github.io//tags/java%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82>java实现http请求</a>
<a class=tag-item href=https://ole12138.github.io//tags/java%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7>java构建工具</a>
<a class=tag-item href=https://ole12138.github.io//tags/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>java设计模式</a>
<a class=tag-item href=https://ole12138.github.io//tags/jdk%E4%BB%A3%E7%90%86>jdk代理</a>
<a class=tag-item href=https://ole12138.github.io//tags/jdk%E7%89%88%E6%9C%AC%E7%9A%84%E5%88%87%E6%8D%A2>jdk版本的切换</a>
<a class=tag-item href=https://ole12138.github.io//tags/json%E7%9A%84%E4%BC%A0%E8%BE%93>json的传输</a>
<a class=tag-item href=https://ole12138.github.io//tags/jsp%E6%95%B0%E6%8D%AE%E5%9B%9E%E6%98%BE>jsp数据回显</a>
<a class=tag-item href=https://ole12138.github.io//tags/maven>maven</a>
<a class=tag-item href=https://ole12138.github.io//tags/np%E5%AE%8C%E5%A4%87%E7%90%86%E8%AE%BA>np完备理论</a>
<a class=tag-item href=https://ole12138.github.io//tags/n%E7%BB%B4%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83>n维正态分布</a>
<a class=tag-item href=https://ole12138.github.io//tags/pat>pat</a>
<a class=tag-item href=https://ole12138.github.io//tags/restfulwebservice>restfulwebservice</a>
<a class=tag-item href=https://ole12138.github.io//tags/restful%E6%9E%B6%E6%9E%84>restful架构</a>
<a class=tag-item href=https://ole12138.github.io//tags/resttemplate>resttemplate</a>
<a class=tag-item href=https://ole12138.github.io//tags/servlet>servlet</a>
<a class=tag-item href=https://ole12138.github.io//tags/spring>spring</a>
<a class=tag-item href=https://ole12138.github.io//tags/springboot>springboot</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc>springmvc</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B>springmvc初始化过程</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B>springmvc工作流程</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E6%B3%A8%E8%A7%A3>springmvc注解</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90>springmvc源码分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E7%BB%84%E4%BB%B6>springmvc组件</a>
<a class=tag-item href=https://ole12138.github.io//tags/springmvc%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B>springmvc请求处理过程</a>
<a class=tag-item href=https://ole12138.github.io//tags/spring%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3>spring中文文档</a>
<a class=tag-item href=https://ole12138.github.io//tags/spring%E6%BA%90%E7%A0%81>spring源码</a>
<a class=tag-item href=https://ole12138.github.io//tags/spring%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84xsd%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98>spring配置文件的xsd引用问题</a>
<a class=tag-item href=https://ole12138.github.io//tags/ssl>ssl</a>
<a class=tag-item href=https://ole12138.github.io//tags/tls>tls</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6>一元微分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86>一元微积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6>一元积分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0>三角函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%89%E8%A7%92%E7%BA%A7%E6%95%B0>三角级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86>不定积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86>中心极限定理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%B9%A0%E9%A2%98>习题</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91>二叉排序树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%A0%91>二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86>二叉树的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B>二次型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BA%8C%E6%AC%A1%E5%9E%8B%E5%8C%96%E4%B8%BA%E6%A0%87%E5%87%86%E5%9E%8B>二次型化为标准型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BB%A3%E6%95%B0>代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8>代数应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F>代理模式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0>伽马函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86>依赖管理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C>假设检验</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2>傅里叶变换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0>傅里叶级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99>克拉默法则</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86>全局异常处理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%85%B3%E9%97%AD%E8%B5%84%E6%BA%90>关闭资源</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%A0%E4%BD%95>几何</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0>函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B>函数式编程</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E7%90%86%E8%AE%BA>函数极限理论</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E7%A9%BA%E9%97%B4>函数空间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>函数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5>分块矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%86%E5%B8%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%81%87%E8%AE%BE>分布类型的假设</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%86%E7%B1%BB>分类</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%88%87%E6%AF%94%E9%9B%AA%E5%A4%AB%E4%B8%8D%E7%AD%89%E5%BC%8F>切比雪夫不等式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB>前后端分离</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92>动态规划</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3>动态规划的思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8C%BA%E9%97%B4%E4%BC%B0%E8%AE%A1>区间估计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%8F%E6%96%B9%E5%B7%AE>协方差</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5>协方差矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8D%95%E8%B0%83%E6%80%A7>单调性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1>参数估计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%82%E6%95%B0%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C>参数的假设检验</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A>参数绑定</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97>双端队列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%8D%E5%B0%84>反射</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86>反常积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%8F%AF%E5%AF%BC%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86>可导函数的中值定理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F>向量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0>向量代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0>向量值函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%86%85%E7%A7%AF>向量内积</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90>向量分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%9A%84%E6%AD%A3%E4%BA%A4%E6%80%A7>向量的正交性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4>向量空间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84>向量组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%A7%A9>向量组的秩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7>向量组的线性相关性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%BB%84%E5%90%88>向量组的线性组合</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%90%91%E9%87%8F%E9%95%BF%E5%BA%A6>向量长度</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91>哈夫曼树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90>回归分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%BE>图</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86>图的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9C%A8%E5%8F%8D%E5%B0%84%E4%B8%AD%E4%BD%BF%E7%94%A8annotation>在反射中使用annotation</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9D%87%E5%80%BC>均值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6>基础数学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%8D%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>复数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC>多元函数的极值与最值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6>多元微分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86>多元微积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6>多元积分学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B>大数定律</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AE%9A%E7%A7%AF%E5%88%86>定积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8>定积分的应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E5%AF%B9%E8%A7%92%E5%8C%96>对称矩阵对角化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F>对象适配器模式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%BC%E6%95%B0>导数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%AF%BC%E6%95%B0%E7%9A%84%E5%BA%94%E7%94%A8>导数的应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B8%B8%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0>常数项级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%82%E7%BA%A7%E6%95%B0>幂级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91>平衡二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%B9%B6%E6%9F%A5%E9%9B%86>并查集</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BC%A7%E5%BE%AE%E5%88%86>弧微分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BE%AE%E5%88%86>微分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B>微分方程</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%80%BB%E4%BD%93%E4%B8%8E%E4%B8%AA%E4%BD%93>总体与个体</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83>抽样分布</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%8B%A6%E6%88%AA%E5%99%A8>拦截器</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%8E%92%E5%BA%8F>排序</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%A3%E5%88%97>散列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6>数学</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF>数学分支</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90>数学分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B>数学期望</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5>数据结构的基本概念</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1>数理统计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B0%E7%BB%84>数组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%95%B4%E6%95%B0%E4%BC%98%E5%8C%96>整数优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0>文件上传</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E5%B7%AE>方差</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90>方差分析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC>方阵的特征值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F>方阵的特征向量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%96%B9%E9%98%B5%E7%9A%84%E8%A1%8C%E5%88%97%E5%BC%8F>方阵的行列式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%97%A0%E5%81%8F%E4%BC%B0%E8%AE%A1>无偏估计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%98%A0%E5%B0%84>映射</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E7%8E%87>曲率</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86>曲线积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86>曲面积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98>最优化问题</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84>最短路径</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%89%E6%95%88%E4%BC%B0%E8%AE%A1>有效估计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C>服务端数据校验</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9E%81%E5%80%BC>极值</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%9E%81%E9%99%90>极限</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%87%E5%87%86%E5%9E%8B>标准型</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%88>栈</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91>树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84>树状数组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86>树的遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A0%B7%E6%9C%AC>样本</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A3%AE%E6%9E%97%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2>森林与二叉树的转换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8>概念与性质</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E7%8E%87%E8%AE%BA>概率论</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1>概率论与数理统计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%A6%82%E8%BF%B0>概述</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%AD%A3%E5%AE%9A%E7%9F%A9%E9%98%B5>正定矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%B3%8A%E6%9D%BE%E7%A7%AF%E5%88%86>泊松积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E6%B3%8A%E6%9D%BE%E7%A7%AF%E5%88%86%E7%9A%84%E6%A6%82%E7%8E%87%E8%AE%BA%E5%BA%94%E7%94%A8>泊松积分的概率论应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%82%B9%E4%BC%B0%E8%AE%A1>点估计</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%89%A9%E7%90%86>物理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%89%B9%E5%BE%81%E5%87%BD%E6%95%B0>特征函数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%99%BB%E5%BD%95%E8%AE%A4%E8%AF%81>登录认证</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%A7%92%E5%8C%96>相似对角化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5>相似矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0>相关系数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9>矩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5>矩阵</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E5%90%88%E5%90%8C>矩阵合同</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86>矩阵求逆</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2>矩阵的初等变换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8>矩阵的压缩存储</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9>矩阵的秩</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%90%E7%AE%97>矩阵的运算</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%A6%BB%E6%95%A3%E6%9C%80%E4%BC%98%E5%8C%96>离散最优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%A9%BA%E9%97%B4>空间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95>空间解析几何</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB>算法分类</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3>算法思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95>算法评价方法</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F>类适配器模式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%B3%BB%E7%BB%9F%E8%AF%AF%E5%B7%AE>系统误差</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%A7%E6%95%B0>级数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0>线性代数</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84>线性方程组</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E7%9A%84%E8%A7%A3>线性方程组的解</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84>线性方程组解的结构</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8>线性表</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E8%A1%A8%E7%A4%BA>线性表的链式表示</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA>线性表的顺序表示</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91>线索二叉树</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96>组合优化</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD>统计推断</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BB%9F%E8%AE%A1%E9%87%8F>统计量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BC%BA%E7%9C%81%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F>缺省适配器模式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4>置信区间</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E7%BD%AE%E4%BF%A1%E5%BA%A6>置信度</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%84%89%E7%BB%9C>脉络</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F>行列式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F%E5%B1%95%E5%BC%80%E5%85%AC%E5%BC%8F>行列式展开公式</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%A1%8C%E5%88%97%E5%BC%8F%E8%A7%A3%E6%96%B9%E7%A8%8B%E7%BB%84%E5%BA%94%E7%94%A8>行列式解方程组应用</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81>身份认证</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%BE%A8%E6%9E%90>辨析</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E8%BF%9E%E7%BB%AD%E6%80%A7>连续性</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E8%BD%AC%E6%8D%A2>递归与非递归转换</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86>递归循环迭代遍历</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%80%92%E5%BD%92%E7%9A%84%E6%80%9D%E6%83%B3>递归的思想</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%87%8D%E7%A7%AF%E5%88%86>重积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%98%9F%E5%88%97>队列</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6>随机事件</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A6%82%E7%8E%87>随机事件的概率</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F>随机变量</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83>随机变量的分布</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81>随机变量的数字特征</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86>静态代理</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE>静态资源访问</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%AB%98%E6%96%AF%E7%A7%AF%E5%88%86>高斯积分</a>
<a class=tag-item href=https://ole12138.github.io//tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6>高等数学</a></div></div></div></div></div><hr><div class=row><div class=col-sm-8><p class=doc-footer-em><a href=# onclick=resetSidebarPos()>Back to TOP</a></p></div></div></div><footer class=doc-footer><p class=doc-footer-em>Browse <strong><a href=https://github.com/ole12138/ole12138.github.io>Repository</a></strong></p><p>Copyright (c) 2020, Jingmin; All rights reserved.</p><p>Powered by <strong><a href=https://github.com/progrhyme/hugo-theme-bootie-docs>Bootie Docs</a></strong> - theme for <a href=http://gohugo.io/>Hugo</a> by <a href=https://github.com/progrhyme/>progrhyme</a>.</p></footer><script src=https://ole12138.github.io//js/jquery.min.js></script><script src=https://ole12138.github.io//js/bootstrap.min.js></script><script src=https://ole12138.github.io//js/highlight.pack.js></script><script>hljs.initHighlightingOnLoad();</script><script src=https://ole12138.github.io//js/ie10-viewport-bug-workaround.js></script><script src=https://ole12138.github.io//js/bootie-docs.js></script></body></html>