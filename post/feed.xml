<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Jingmin's blog</title><link>https://ole12138.github.io/post/</link><description>Recent content in Posts on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Wed, 13 Jan 2021 20:23:43 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/post/feed.xml" rel="self" type="application/rss+xml"/><item><title>HTTP认证方式</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 13 Jan 2021 20:23:43 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F/</guid><description>HTTP认证方式 本节参考： https://zhuanlan.zhihu.com/p/64584734 https://www.loginradius.com/blog/async/everything-you-want-to-know-about-authorization-headers/ https://www.cnblogs.com/xiongmaomengnan/p/6671206.html https://www.jianshu.com/p/cf5a900d4ef7
B/S和C/S形式的远程通信，一般都是基于HTTP和RFC的方式进行的。今天说一下HTTP通信过程中的身份认证。
服务器上的资源，并不都是公开的。某些资源的访问需要具有一定的权限才可以。
HTTP/1.0中在http头中引入了权限（Authorization）字段。
Basic Auth 最初的认证是简单认证，在HTTP报文（头部）中是这样的
Authorization: Basic &amp;lt;username:password的base64加密结果&amp;gt; 像这样：
Authorization: Basic AXVubzpwQDU1dzByYM== 但是HTTP报文在网络上是有可能被截获的，而base64加密过的结果，也很容易解密，从而导致用户名和密码被其他人获取。
Bearer Token 为了减少（加密过的）用户名和密码在网络上传递的次数，降低被盗用的风险， 可在简单认证通过后，服务器返回一个token。之后访问服务器需要权限的资源就不再使用（加密过的）用户名和密码，而是使用token。
可以把这个token放到HTTP报文头部，像这样的形式：
Authorization: Bearer &amp;lt;token&amp;gt; API Key 类似于Bearer Token，客户端调用服务器API时，常常需要携带token，一般叫做API Key。
常见的调用形式：
GET /endpoint?api_key=abcdefgh123456789 也常常将API Key放置到HTTP头部：
X-API-Key: abcdefgh123456789 Digest Auth Digest认证试图解决Basic认证的缺陷而设计，用户密码并没有在网络上传递，传递的是密码（和账号等其他几个参数）的hash值。而通过hash值破解出密码一般认为是不现实的。
摘要认证的一个改进之处是用摘要代替密码的传输，遵循的基本原则是“绝对不通过网络发送明文密码”，而是发送一个密码的摘要信息，并且这摘要信息是不可逆的，即无法通 过摘要信息反推出密码信息
客户端向服务器请求认证的过程：
客户端发起请求 服务返回401未认证， 并要求使用Digest认证， 并提供一个随机串nonce，以及支持的hash算法 客户端计算： hash(nonce+账号+密码)， 并将hash结果和账号名发送给服务器 服务器根据账号名，找到对应的账户信息， 同样计算hash(nonce+账号+密码)， 对比计算的hash值与客户端传回的hash值， 对比通过即可将原来客户端请求的资源发送给客户 摘要认证的一个改进之处可以防止重放攻击。摘要被截获也可能跟密码一起好用，为了防止重放攻击的发送，服务器可以向客户端发送一个称为随机数nonce的特殊令牌，这个数会经常发生变化(可能是每毫秒，或者每次认证都发生变化，具体由服务器控制)，客户端在计算摘要之前要先将这个随机数附加到密码上去。这样，在密码中加入随机数就会使得摘要随着随机数的每次变化而变化，记录下的密码摘要只对特定的随机数有效，而没有密码的话，攻击者就无法计算出正确的摘要，这样就可以防止重放攻击的发生。
但是，摘要认证并不能防止中间人攻击。即客户端的请求直接被中间人拦截，中间人拿着客户端的请求信息去请求服务器。实际上HTTP都不能解决中间人攻击问题，需要HTTPS才可以解决。
当前常用的认证方式（会话级别：登录认证） 本章节非原创，转载来源：https://www.cnblogs.com/fengzheng/p/8416393.html
场景说明 以一个电商系统，假设淘宝为例，如果我们想要下单，首先需要注册一个账号。拥有了账号之后，我们需要输入用户名（比如手机号或邮箱）、密码完成登录过程。之后如果你在一段时间内再次进入系统，是不需要输入用户名和密码的，只有在连续长时间不登录的情况下（例如一个月没登录过）访问系统，再次需要输入用户名和密码。如果使用频率很频繁，通常是一年都不用再输一次密码，所以经常在换了一台电脑或者一部手机之后，一些经常使用的网站或 APP 不记得密码了。
提炼出来整个过程大概就是如下几步：
首次使用，需要通过邮箱或手机号注册； 注册完成后，需要提供用户名和密码完成登录； 下次再使用，通常不会再次输入用户名和密码即可直接进入系统并使用其功能（除非连续长时间未使用）； OAuth 认证 OAuth 认证比较常见的就是微信登录、微博登录、qq登录等，简单来说就是利用这些比较权威的网站或应用开放的 API 来实现用户登录，用户可以不用在你的网站或应用上注册账号，直接用已有的微信、微博、qq 等账号登录。</description></item><item><title>发起HTTP请求：使用OkHttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/</link><pubDate>Wed, 13 Jan 2021 15:54:12 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8okhttpclient/</guid><description>发起HTTP请求：使用OkHttpClient 现在java比较好用的http客户端是开源的OkHttp。支持HTTP/2, 简单易用且灵活。
官网：https://square.github.io/okhttp/
简单使用测试（http、https类型的get，post）：
class OkHttpClientUtilTest { @Test public void doGet() throws IOException { String url = &amp;#34;http://httpbin.org/anything&amp;#34;; OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(url) .build(); try (Response response = client.newCall(request).execute()) { String res = response.body().string(); System.out.println(res); } request = new Request.Builder() .get() .url(url + &amp;#34;?key1=value1&amp;amp;key2=value2&amp;#34;).header(&amp;#34;Cookie&amp;#34;, &amp;#34;cook1=sd;cook2=sdd;&amp;#34;).build(); try (Response response = client.newCall(request).execute()) { String res = response.body().string(); System.out.println(res); } url = &amp;#34;https://httpbin.org/anything&amp;#34;; request = new Request.</description></item><item><title>发起HTTP请求：使用HttpURLConnection</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</link><pubDate>Wed, 13 Jan 2021 13:25:34 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</guid><description>发起HTTP请求：使用HttpURLConnection 使用JDK原生的HttpURLConnection发起HTTP请求
注意：到Java8为止，HttpURLConnection不支持HTTP2，只支持到HTTP1.1。 要使用支持HTTP2的HttpURLConnection，需要升级到Java11 import lombok.Cleanup; import java.io.*; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.nio.charset.StandardCharsets; /** * 使用JDK原生的HttpURLConnection发起HTTP请求 */ public class HttpURLConnectionUtil { public static String doGet(String httpurl) { // 返回结果字符串 String result = null; try { // 创建远程url连接对象 URL url = new URL(httpurl); // 通过远程url连接对象打开一个连接，强转成httpURLConnection类 @Cleanup(&amp;#34;disconnect&amp;#34;) HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 设置连接方式：get connection.setRequestMethod(&amp;#34;GET&amp;#34;); // 设置连接主机服务器的超时时间：15000毫秒 connection.setConnectTimeout(15000); // 设置读取远程返回的数据时间：60000毫秒 connection.setReadTimeout(60000); // 发送请求 connection.</description></item><item><title>HTTPS简单介绍（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 12 Jan 2021 12:06:18 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>HTTPS简单介绍（转载） 本章节非原创，转载来源：https://juejin.cn/post/6844903599303032845
一、HTTP存在的问题 1.1 可能被窃听 HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送 由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:Wireshark) 1.2 认证问题 无法确认你发送到的服务器就是真正的目标服务器(可能服务器是伪装的) 无法确定返回的客户端是否是按照真实意图接收的客户端(可能是伪装的客户端) 无法确定正在通信的对方是否具备访问权限，Web 服务器上某些重要的信息，只想发给特定用户即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。 1.3 可能被篡改 1.请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack，MITM）。
二、HTTPS介绍 2.1 什么是HTTPS 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
2.2 HTTPS怎么解决上述问题 HTTPS是在通信接口部分用 TLS(Transport Layer Security 传输层安全性协议)，TLS协议采用主从式架构模型，用于在两个应用程序间通过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。
2.3 SSL和TLS的关系 传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。 网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。 IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。 2.4 TLS/SSL 协议 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</description></item><item><title>SSL或TLS协议运行机制的概述（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDssl%E6%88%96tls%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/</link><pubDate>Tue, 12 Jan 2021 10:14:27 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDssl%E6%88%96tls%E5%8D%8F%E8%AE%AE%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0/</guid><description>互联网的通信安全，建立在SSL/TLS协议之上。
本文简要介绍SSL/TLS协议的运行机制。文章的重点是设计思想和运行过程，不涉及具体的实现细节。如果想了解这方面的内容，请参阅RFC文档。
一、作用
不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。
（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。
（2） 篡改风险（tampering）：第三方可以修改通信内容。
（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。
SSL/TLS协议是为了解决这三大风险而设计的，希望达到：
（1） 所有信息都是加密传播，第三方无法窃听。
（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。
（3） 配备身份证书，防止身份被冒充。
互联网是开放环境，通信双方都是未知身份，这为协议的设计带来了很大的难度。而且，协议还必须能够经受所有匪夷所思的攻击，这使得SSL/TLS协议变得异常复杂。
二、历史
互联网加密通信协议的历史，几乎与互联网一样长。
1994年，NetScape公司设计了SSL协议（Secure Sockets Layer）的1.0版，但是未发布。
1995年，NetScape公司发布SSL 2.0版，很快发现有严重漏洞。
1996年，SSL 3.0版问世，得到大规模应用。
1999年，互联网标准化组织ISOC接替NetScape公司，发布了SSL的升级版TLS 1.0版。
2006年和2008年，TLS进行了两次升级，分别为TLS 1.1版和TLS 1.2版。最新的变动是2011年TLS 1.2的修订版。
目前，应用最广泛的是TLS 1.0，接下来是SSL 3.0。但是，主流浏览器都已经实现了TLS 1.2的支持。
TLS 1.0通常被标示为SSL 3.1，TLS 1.1为SSL 3.2，TLS 1.2为SSL 3.3。
三、基本的运行过程
SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。
但是，这里有两个问题。
（1）如何保证公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个&amp;quot;对话密钥&amp;quot;（session key），用它来加密信息。由于&amp;quot;对话密钥&amp;quot;是对称加密，所以运算速度非常快，而服务器公钥只用于加密&amp;quot;对话密钥&amp;quot;本身，这样就减少了加密运算的消耗时间。
因此，SSL/TLS协议的基本过程是这样的：
（1） 客户端向服务器端索要并验证公钥。
（2） 双方协商生成&amp;quot;对话密钥&amp;quot;。
（3） 双方采用&amp;quot;对话密钥&amp;quot;进行加密通信。</description></item><item><title>彻底搞懂HTTPS的加密机制（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 12 Jan 2021 10:04:38 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82https%E7%9A%84%E5%8A%A0%E5%AF%86%E6%9C%BA%E5%88%B6/</guid><description>彻底搞懂HTTPS的加密机制（为什么这么设计） 本章节非原创，转载来源：https://zhuanlan.zhihu.com/p/43789231
HTTPS（SSL/TLS）的加密机制虽然是个前端后端等都应了解的基本问题，但网上的很多HTTPS相关文章也总会忽略一些内容，我学习它的时候也废了挺大功夫。 对称加密、非对称加密、数字签名、数字证书等等，在学习过程中，除了了解“它是什么”，你是否有想过“为什么是它”？我认为理解了后者才真正理解了HTTPS的加密机制。
本文以问题的形式逐步展开，一步步解开HTTPS的面纱，希望能帮助你彻底搞懂HTTPS。特别是对于了解过HTTPS却在有些地方有所卡壳的人，希望本文能帮助你理清思路。
为什么需要加密？ 因为http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了，他还可以篡改传输的信息且不被双方察觉，这就是中间人攻击。所以我们才需要对信息进行加密。最简单容易理解的就是对称加密 。
什么是对称加密？ 就是有一个密钥，它可以对一段内容加密，加密后只能用它才能解密看到原本的内容，和我们日常生活中用的钥匙作用差不多。
用对称加密可行吗？ 如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。 然而最大的问题就是这个密钥怎么让传输的双方知晓，同时不被别人知道。如果由服务器生成一个密钥并传输给浏览器，那这个传输过程中密钥被别人劫持弄到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。 换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行啦！这么做显然不现实。 怎么办？所以我们就需要神奇的非对称加密
什么是非对称加密？ 有两把密钥，通常一把叫做公钥、一把叫做私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。 用非对称加密可行吗？ 鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥直接明文传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！因为只有服务器有相应的私钥能解开这条数据。 然而由服务器到浏览器的这条路怎么保障安全？如果服务器用它的的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，这个公钥被谁劫持到的话，他也能用该公钥解密服务器传来的信息了。所以目前似乎只能保证由浏览器向服务器传输数据时的安全性（其实仍有漏洞，下文会说），那利用这点你能想到什么解决方案吗？
改良的非对称加密方案，似乎可以？ 我们已经理解通过一组公钥私钥，已经可以保证单个方向传输的安全性，那用两组公钥私钥，是不是就能保证双向传输都安全了？请看下面的过程：
某网站拥有用于非对称加密的公钥A、私钥A’；浏览器拥有用于非对称加密的公钥B、私钥B’。 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。 浏览器把公钥B明文传输给服务器。 之后浏览器向服务器传输的所有东西都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有这个私钥A’可以解密，所以能保证这条数据的安全。 服务器向浏览器传输的所有东西都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。 的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？最主要的原因是非对称加密算法非常耗时，特别是加密解密一些较大数据的时候有些力不从心，而对称加密快很多，看来必须得用对称加密，那我们能不能运用非对称加密的特性解决前面提到的对称加密的问题？
非对称加密+对称加密？ 既然非对称加密耗时，非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，而且非对称加密、解密各只需用一次即可。 请看一下这个过程：
某网站拥有用于非对称加密的公钥A、私钥A’。 浏览器像网站服务器请求，服务器把公钥A明文给传输浏览器。 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。 服务器拿到后用私钥A’解密得到密钥X。 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都用密钥X加密解密。 完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。
中间人攻击 中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到密钥A’就能干坏事了。请看：
某网站拥有用于非对称加密的公钥A、私钥A’。 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。 中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）。 浏览器随机生成一个用于对称加密的密钥X，用公钥B（浏览器不知道公钥被替换了）加密后传给服务器。 中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器。 服务器拿到后用私钥A’解密得到密钥X。 这样在双方都不会发现异常的情况下，中间人得到了密钥B。根本原因是浏览器无法确认自己收到的公钥是不是网站自己的。那么下一步就是解决下面这个问题：
如何证明浏览器收到的公钥一定是该网站的公钥？ 现实生活中，如果想证明某身份证号一定是小明的，怎么办？看身份证。这里政府机构起到了“公信”的作用，身份证是由它颁发的，它本身的权威可以对一个人的身份信息作出证明。互联网中能不能搞这么个公信机构呢？给网站颁发一个“身份证”？
数字证书 网站在使用HTTPS前，需要向“CA机构”申请颁发一份数字证书，数字证书里有证书持有者、证书持有者的公钥等信息，服务器把证书传输给浏览器，浏览器从证书里取公钥就行了，证书就如身份证一样，可以证明“该公钥对应该网站”。然而这里又有一个显而易见的问题了，证书本身的传输过程中，如何防止被篡改？即如何证明证书本身的真实性？身份证有一些防伪技术，数字证书怎么防伪呢？解决这个问题我们就基本接近胜利了！
如何放防止数字证书被篡改？ 我们把证书内容生成一份“签名”，比对证书内容和签名是否一致就能察觉是否被篡改。这种技术就叫数字签名：
数字签名 这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程（原图出处找不到了，可以看出来这图已经被转载了无数次了。。。）
数字签名的制作过程：
CA拥有非对称加密的私钥和公钥。 CA对证书明文信息进行hash。 对hash后的值用私钥加密，得到数字签名。 明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。 那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）
浏览器验证过程：
拿到证书，得到明文T，数字签名S。 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。 用证书里说明的hash算法对明文T进行hash得到T’。 比较S’是否等于T’，等于则表明证书可信。 为什么这样可以证明证书可信呢？我们来仔细想一下。</description></item><item><title>随笔-JDK版本的切换</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-jdk%E7%89%88%E6%9C%AC%E7%9A%84%E5%88%87%E6%8D%A2/</link><pubDate>Mon, 11 Jan 2021 18:11:08 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-jdk%E7%89%88%E6%9C%AC%E7%9A%84%E5%88%87%E6%8D%A2/</guid><description>JDK版本的切换 有时为了使用新一点的API，项目需要使用高版本的JDK，比如JDK8切换到JDK11.
有时为了维护旧项目，需要使用旧版本的JDK，比如JDK8切换到JDK7.
这就需要安装和切换对应的JDK
安装对应版本的JDK 一般我们使用Java SE版本。Linux自带的是openJDK，windows下我们一般使用Oracle 的JDK。
下载安装过程略。
IDEA中切换SDK 我们的项目一般都是在IDE工具中开发的。Java典型的IDE是intellij IDEA。
在IDEA中打开对应的项目。作如下操作：
File-&amp;gt;Project Structure-&amp;gt;SDKs-&amp;gt;点&amp;quot;+&amp;ldquo;号新建一个JDK，JDK所在目录选定前面JDK的安装目录。
这样，项目就会使用对应的JDK。
若已经按之前的JDK版本打开/导入了项目，为了使新的JDK生效，还需要做如下操作：
File-&amp;gt;Project Structure-&amp;gt;Modules-&amp;gt;点击右侧Dependencis选项卡-&amp;gt;Module SDK选择刚刚新建的那个JDK
Maven中切换compiler版本 我们一般是使用Maven构建程序的。
打开Maven要用到的pom文件，编译插件部分作如下修改：
&amp;lt;plugin&amp;gt; &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;source&amp;gt;11&amp;lt;/source&amp;gt; &amp;lt;target&amp;gt;11&amp;lt;/target&amp;gt; &amp;lt;!--&amp;lt;release&amp;gt;11&amp;lt;/release&amp;gt;--&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; 最终，运行maven编译通过。</description></item><item><title>发起HTTP请求：使用JDK11的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 17:08:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</guid><description>发起HTTP请求：使用JDK11的HttpClient JDK11 API中原生的增加了HTTP客户端类HttpClient，用于发起HTTP请求，支持HTTP/2.
以下内容非原创，参考/转载来源：https://www.dariawan.com/tutorials/java/java-11-standard-http-client-vs-apache-httpclient/
JDK11的HttpClient使用测试：
package com.wangjm.http.connection; import com.google.common.net.UrlEscapers; import org.junit.jupiter.api.Test; import java.net.ProxySelector; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.Duration; /** * @author : wangjm * @date : 2021/1/11 20:47 * JDK11 API 提供了HttpClient，支持HTTP/2 * 简单使用的情况下，http和https链接的请求都是相同的 */ class JDKHttpClientUtilTest { @Test public void doTest() throws Exception { final HttpClient HTTP_CLIENT = HttpClient.newBuilder() .version(HttpClient.Version.HTTP_2) // default .followRedirects(HttpClient.Redirect.NORMAL) // Always redirect, except from HTTPS URLs to HTTP URLs. .</description></item><item><title>发起HTTP请求：使用Apache的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 14:34:53 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</guid><description>Java发起HTTP请求：使用Apache的HttpClient 许多小伙伴都喜欢用apache的HttpComponts里的HttpClient来向远程发起HTTP请求
从HttpComponents官网的features说明来看，当前版本(HttpClient4.5)仅支持到HTTP/1.1。 但是HttpCore.5.1BETA将支持HTTP/2，可惜还在BETA阶段。
使用方式：
项目中引入对应的maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 参考了别人的代码,简单使用：
/** * 使用apache的HttpClient发起HTTP以及HTTPS请求 * 注意：当前的apache的HttpClient4.5只支持到HTTP/1.1 * 参考：https://zhuanlan.zhihu.com/p/69285935 * 参考：https://blog.csdn.net/happylee6688/article/details/47148227 */ public class HttpClientUtil { private static PoolingHttpClientConnectionManager connMgr; private static RequestConfig requestConfig; private static final int MAX_TIMEOUT = 7000; static { // 设置连接池 connMgr = new PoolingHttpClientConnectionManager(); // 设置连接池大小 connMgr.setMaxTotal(100); connMgr.setDefaultMaxPerRoute(connMgr.getMaxTotal()); RequestConfig.Builder configBuilder = RequestConfig.custom(); // 设置连接超时 configBuilder.setConnectTimeout(MAX_TIMEOUT); // 设置读取超时 configBuilder.setSocketTimeout(MAX_TIMEOUT); // 设置从连接池获取连接实例的超时 configBuilder.</description></item><item><title>Java中资源的关闭</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-java%E4%B8%AD%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E9%97%AD/</link><pubDate>Sun, 10 Jan 2021 22:52:50 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E9%9A%8F%E7%AC%94-java%E4%B8%AD%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B3%E9%97%AD/</guid><description>Java中资源的关闭 在Java编程过程中，如果打开了外部资源（文件、数据库连接、网络连接等），必须在这些外部资源使用完毕后，手动关闭它们。因为外部资源不由JVM管理，无法享用JVM的垃圾回收机制，如果不在编程时确保在正确的时机关闭外部资源，就会导致外部资源泄露，紧接着就会出现文件被异常占用，数据库连接过多导致连接池溢出等诸多很严重的问题。
一般
传统的资源关闭方式 为了确保外部资源一定要被关闭，通常关闭代码被写入finally代码块中，当然还必须注意到关闭资源时可能抛出的异常。（最后抛出的异常是关闭资源过程中又新抛出的异常）
JDK7及其之后的资源关闭方式 确实，在JDK7以前，Java没有自动关闭外部资源的语法特性，直到JDK7中新增了try-with-resource语法，才实现了这一功能。 注意1：只有一个外部资源的句柄对象实现了AutoCloseable接口，JDK7中便可以利用try-with-resource语法更优雅的关闭资源，消除板式代码。 注意2：try-with-resource时，如果对外部资源的处理和对外部资源的关闭均遭遇了异常，“关闭异常”将被抑制，“处理异常”将被抛出，但“关闭异常”并没有丢失，而是存放在“处理异常”的被抑制的异常列表中。（最后抛出的异常是之前最先抛出的异常）
lombok 方式 使用 lombok 提供的注解 @Cleanup。
进一步阅读 Java 之优雅地关闭资源 try-with-resource、lombok
Lombok之@Cleanup使用
使用Try-with-resources自动关闭资源
Jdk6 7 9 流关闭的新姿势</description></item><item><title>HTTP协议介绍(转载)</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</link><pubDate>Sun, 10 Jan 2021 18:52:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</guid><description>HTTP 协议介绍 本章节非原创，转载来源：http://www.ruanyifeng.com/blog/2016/08/http.html
HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。
本文介绍 HTTP 协议的历史演变和设计思路。
一、HTTP/0.9 HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。
最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。
GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。
协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt;Hello World&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 服务器发送完毕，就关闭TCP连接。
二、HTTP/1.0 2.1 简介 1996年5月，HTTP/1.0 版本发布，内容大大增加。
首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。
再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
2.2 请求格式 下面是一个1.0版的HTTP请求的例子。
GET / HTTP/1.0 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */* 可以看到，这个格式与0.9版有很大变化。
第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。
2.3 回应格式 服务器的回应如下。
HTTP/1.0 200 OK Content-Type: text/plain Content-Length: 137582 Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996 15:55:28 GMT Server: Apache 0.</description></item><item><title>Java设计模式之代理模式</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link><pubDate>Sat, 09 Jan 2021 17:19:57 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid><description>Java设计模式之代理模式 代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式;即通过代理对象访问目标对象.这样做的好处是:
符合开闭原则，方便增加功能：可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能. 这里使用到编程中的一个思想:不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。 中介隔离作用：某些情况下，客户不想或不应当直接访问目标对象。 代理模式下，用户对对象的访问流程如下：
静态代理 静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类.
定义接口（目标类的接口）
public interface Subject { public void doSomething(); } 实现类（目标类，或者之后会被代理的类）
public class SubjectImpl1 implements Subject { @Override public void doSomething() { System.out.println(&amp;#34;do something with implimentation 1.&amp;#34;); } } 静态代理类
public class StaticProxy implements Subject { Subject target; public StaticProxy(Subject target) { this.target = target; } @Override public void doSomething() { System.out.println(&amp;#34;before doSomething&amp;#34;); target.doSomething(); System.out.println(&amp;#34;after doSomething&amp;#34;); } } 测试
class PoxyTest { //静态代理的测试 @Test public void doStaticProxyTest() { Subject subject = new StaticProxy(new SubjectImpl1()); subject.</description></item><item><title>发起HTTP请求：Spring中RestTemplate设置与携带请求头（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Fri, 08 Jan 2021 16:56:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>Rest设置请求头以及进一步配置 本章节“Rest设置与携带请求头”部分非原创，转载来源：https://juejin.cn/post/6844904202397827086
本节主要集中在如何携带自定义的请求头，如设置 User-Agent，携带 Cookie
Get 携带请求头 Post 携带请求头 拦截器方式设置统一请求头 I. 项目搭建 1. 配置 借助 SpringBoot 搭建一个 SpringWEB 项目，提供一些用于测试的 REST 服务
SpringBoot 版本: 2.2.1.RELEASE 核心依赖: spring-boot-stater-web &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件application.yml中，添加
logging: pattern: console: (%msg%n%n){blue} 2. Rest 服务 添加三个接口，分别提供 GET 请求，POST 表单，POST json 对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明
@RestController public class DemoRest { private String getHeaders(HttpServletRequest request) { Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); String name; JSONObject headers = new JSONObject(); while (headerNames.</description></item><item><title>发起HTTP请求：Spring中的RestTempalate的基本使用（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Jan 2021 17:28:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate的认识与基本使用 RestTemplate介绍 在Spring的生态下，则可以利用RestTemplate来发起Http请求。
spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。
RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如 Apache HttpComponents、Netty或OkHttp等其它HTTP library。
RestTemplate构成与实现逻辑：
RestTemplate包含以下几个部分：
HttpMessageConverter 对象转换器 ClientHttpRequestFactory 默认是JDK的HttpURLConnection ResponseErrorHandler 异常处理 ClientHttpRequestInterceptor 请求拦截器 用一张图可以很直观的理解：
RestTempalate的基本使用 本节&amp;quot;RestTempalate的基本使用&amp;quot;非原创，转载来源：https://juejin.cn/post/6844903656165212174
0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么
简单的给出了一下常见的问题如下
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本节主要关注在RestTemplate的简单Get/Post请求的使用方式上：
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种
// get 请求 public &amp;lt;T&amp;gt; T getForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public &amp;lt;T&amp;gt; T postForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; postForEntity(); // put 请求 public void put(); // pathch public &amp;lt;T&amp;gt; T patchForObject // delete public void delete() // options public Set&amp;lt;HttpMethod&amp;gt; optionsForAllow // exchange public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说</description></item><item><title>Java发起HTTP请求方式汇总</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</link><pubDate>Thu, 07 Jan 2021 16:31:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</guid><description>作为一个Java后端，需要通过HTTP请求其他的网络资源可以说是一个比较常见的case了；一般怎么做呢？
直接捞起Apache的HttpClient开始做 (只支持到HTTP/1.1,最近的Http5.1-beta开始支持HTTP/2) 知名的开源库如OkHttp 原生的HttpURLConnection （Since: JDK1.1） 原生的HttpClient （JDK11） Spring的生态中可以利用RestTemplate来发起Http请求。 发送HTTP请求时，要注意区分http和https类型的请求</description></item><item><title>Java8函数式编程入门（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDjava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</link><pubDate>Thu, 07 Jan 2021 10:40:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDjava8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</guid><description>文章非原创，转载来源：https://www.cnblogs.com/snowinpluto/p/5981400.html
1. 概述 1.1 函数式编程简介 我们最常用的面向对象编程（Java）属于命令式编程（Imperative Programming）这种编程范式。常见的编程范式还有逻辑式编程（Logic Programming），函数式编程（Functional Programming）。
函数式编程作为一种编程范式，在科学领域，是一种编写计算机程序数据结构和元素的方式，它把计算过程当做是数学函数的求值，而避免更改状态和可变数据。
函数式编程并非近几年的新技术或新思维，距离它诞生已有大概50多年的时间了。它一直不是主流的编程思维，但在众多的所谓顶级编程高手的科学工作者间，函数式编程是十分盛行的。
什么是函数式编程？简单的回答：一切都是数学函数。函数式编程语言里也可以有对象，但通常这些对象都是恒定不变的 —— 要么是函数参数，要什么是函数返回值。函数式编程语言里没有 for/next 循环，因为这些逻辑意味着有状态的改变。相替代的是，这种循环逻辑在函数式编程语言里是通过递归、把函数当成参数传递的方式实现的。
举个例子：
a = a + 1 这段代码在普通成员看来并没有什么问题，但在数学家看来确实不成立的，因为它意味着变量值得改变。
1.2 Lambda 表达式简介 Java 8的最大变化是引入了Lambda（Lambda 是希腊字母 λ 的英文名称）表达式——一种紧凑的、传递行为的方式。
先看个例子：
button.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent event) { System.out.println(&amp;#34;button clicked&amp;#34;); } }); 这段代码使用了匿名类。ActionListener 是一个接口，这里 new 了一个类实现了 ActionListener 接口，然后重写了 actionPerformed 方法。actionPerformed 方法接收 ActionEvent 类型参数，返回空。
这段代码我们其实只关心中间打印的语句，其他都是多余的。所以使用 Lambda 表达式，我们就可以简写为：
button.addActionListener(event -&amp;gt; System.out.println(&amp;#34;button clicked&amp;#34;)); 2. Lambda 表达式 2.1 Lambda 表达式的形式 Java 中 Lambda 表达式一共有五种基本形式，具体如下：</description></item><item><title>Web前后端分离的实现方式（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDweb%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 06 Jan 2021 15:49:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDweb%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid><description>Web实现前后端分离，前后端解耦 博文非原创，转载来源：https://zhuanlan.zhihu.com/p/79336787
一、前言 ”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。
并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。
前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。
注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。 应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】
一般只有Web服务器才能被外网访问，应用服务器只能内网访问。
二、为什么前后端分离 一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。
前后端工作分配不均。
不仅仅开发效率慢，而且代码难以维护。
而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。
而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。
前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。
三、从MVC到前后端分离 MVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。
其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。
对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。
模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。
综上所述，MVC 的交互过程如下图所示：
也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？
答案是 REST。
REST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！
国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。</description></item><item><title>Spring构建restfulWebService</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</link><pubDate>Wed, 06 Jan 2021 11:18:01 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/springboot%E6%9E%84%E5%BB%BArestfulwebservice/</guid><description>Spring构建restfulWebService 这是官网提供的一个例子，这里练习。
实际上这里用的是Springboot来创建的。
What You Will Build build a service that will accept HTTP GET requests at http://localhost:8080/greeting.
It will respond with a JSON representation of a greeting, as the following listing shows:
{&amp;#34;id&amp;#34;:1,&amp;#34;content&amp;#34;:&amp;#34;Hello, World!&amp;#34;} You can customize the greeting with an optional name parameter in the query string, as the following listing shows:
http://localhost:8080/greeting?name=User The name parameter value overrides the default value of World and is reflected in the response, as the following listing shows:</description></item><item><title>Maven pom.xml中的元素modules、parent、properties以及import（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDmaven%E4%BD%BF%E7%94%A8/</link><pubDate>Wed, 06 Jan 2021 10:00:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDmaven%E4%BD%BF%E7%94%A8/</guid><description>Maven pom.xml中的元素modules、parent、properties以及import 非原创，转载来源：https://www.cnblogs.com/youzhibing/p/5427130.html
另，Maven文档链接：https://maven.apache.org/guides/introduction/introduction-to-the-pom.html
maven的核心是pom.xml。印象最深的就是如下四个元素：modules、parent、properties、import。
modules 从字面意思来说，module就是模块，而pom.xml中的modules也正是这个意思，用来管理同个项目中的各个模块；如果maven用的比较简单，或者说项目的模块在pom.xml没进行划分，那么此元素是用不到的；不过一般大一点的项目是要用到的。
需求场景 如果我们的项目分成了好几个模块，那么我们构建的时候是不是有几个模块就需要构建几次了（到每个模块的目录下执行mvn命令）？当然，你逐个构建没问题，但是非要这么麻烦的一个一个的构建吗，那么简单的做法就是使用聚合，一次构建全部模块。
具体实现 a.既然使用聚合，那么就需要一个聚合的载体，先创建一个普通的maven项目account-aggregator,如下图：
因为是个聚合体，仅仅负责聚合其他模块，那么就只需要上述目录，该删除的就删了；注意的是pom文件的书写：
&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.youzhibing.account&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;account-aggregator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;Account Aggrregator&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; &amp;lt;modules&amp;gt;　&amp;lt;!-- 模块都写在此处 --&amp;gt; &amp;lt;module&amp;gt;account-register&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;account-persist&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;/project&amp;gt; b.创建子模account-register、account-persist:右击account-aggregator，new &amp;ndash;&amp;gt; other &amp;ndash;&amp;gt; Maven，选择Maven Module，创建maven模块。
c.创建完成后，项目结构如下，那么此时account-aggregator可以收缩起来了，我们操作具体子模块就好了。
d.注意点，当我们打开包结构的子模块的pom文件时，发现离预期的多了一些内容，我们坐下处理就好了
e.那么编码完了之后，我们只需要构建account-aggregator就好了，所有的子模块都会构建。
parent 继承，和java中的继承相当，作用就是复用
需求场景 若每个子模块都都用的了spring，那么我们是不是每个子模块都需要单独配置spring依赖了?,这么做是可以的，但是我们有更优的做法，那就是继承，用parent来实现。
具体实现 a.配置父pom.xml
我就用聚合pom来做父pom,配置子模块的公共依赖。
父(account-aggregator)pom.xml :
&amp;lt;project xmlns=&amp;#34;http://maven.apache.org/POM/4.0.0&amp;#34; xmlns:xsi=&amp;#34;http://www.w3.org/2001/XMLSchema-instance&amp;#34; xsi:schemaLocation=&amp;#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&amp;#34;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;com.youzhibing.account&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;account-aggregator&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt; &amp;lt;name&amp;gt;Account Aggrregator&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; &amp;lt;modules&amp;gt; &amp;lt;!-- 模块都写在此处 --&amp;gt; &amp;lt;module&amp;gt;account-register&amp;lt;/module&amp;gt; &amp;lt;module&amp;gt;account-persist&amp;lt;/module&amp;gt; &amp;lt;/modules&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;!</description></item><item><title>Java Annotation认知（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDjava%E6%B3%A8%E8%A7%A3annotation/</link><pubDate>Tue, 05 Jan 2021 12:00:39 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDjava%E6%B3%A8%E8%A7%A3annotation/</guid><description>转载，原网址：https://www.cnblogs.com/skywang12345/p/3344137.html
Annotation Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。
Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。
内置的注解 Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。
作用在代码的注解是
@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 作用在其他注解的注解(或者说 元注解)是:
@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 从 Java 7 开始，额外添加了 3 个注解:
@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 Annotation 架构 从中，我们可以看出：</description></item><item><title>Java开发技能需求</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E9%9C%80%E6%B1%82%E4%B8%8E%E5%AD%A6%E4%B9%A0/</link><pubDate>Tue, 05 Jan 2021 11:02:34 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/java%E5%BC%80%E5%8F%91%E6%8A%80%E8%83%BD%E9%9C%80%E6%B1%82%E4%B8%8E%E5%AD%A6%E4%B9%A0/</guid><description>Java开发技能需求（待掌握技能） 参考：BOSS直聘招聘需求
常用Java中间件
dubbo，分布式缓存，消息队列
redis，kafka，zookeeper，etcd
大数据：Hadoop，spark，flink
Spring，SpringBoot，SpringCloud
分布式数据库：DRDS，oceanBase，ShardingSphere
docker，CI，CD工具
maven，gradle
Java多线程、缓存、安全
HTTP、Rest相关概念
VUE，REAT
Java生态圈技术框架、中间件、系统架构汇总 参考：Java生态圈技术框架、中间件、系统架构汇总
Java开发技能学习 gantt dateFormat YYYY-MM-DD title Java开发技能学习 section Spring Spring项目的建立（xml） :done, springInit, 2021-01-06, 2021-01-07 java发起Http请求-restTemplate :done, restTemplate, 2021-01-07, 3d Spring之Interceptor :active, crit,2021-01-10,2d SpringMVC之Servlet与Interceptor :2021-01-13,2d Spring缓存 :2021-01-15,2d Spring之redis以及消息中间件的使用 :2021-01-17,5d section SpringBoot SpringBoot项目的建立（xml） :done, springBootInit, 2021-01-06, 2021-01-07 SpringBoot之restfulService :done, restfulService, 2021-01-06, 2021-01-07 section Maven Maven的pom的标签 :done, mavanPom, 2021-01-05, 2021-01-06 section Java Java函数式编程与lambda表达式 :done, javaLambda, 2021-01-07, 2021-01-08 Java代理模式 :done, javaProxy, 2021-01-09, 1d java发起Http请求-apache的HttpClient :crit,httpClient,after restTemplate,1d java发起Http请求-HttpUrlConnection :done,2021-01-10,1d java发起Http请求-OkHttp :active,1d</description></item><item><title>概率论与数理统计-数理统计-假设检验</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</link><pubDate>Tue, 22 Dec 2020 22:58:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</guid><description>概率论与数理统计-数理统计-假设检验 除了对总体的参数的估计外，统计推断的另一类重要问题是假设检验问题。 在总体的1）分布函数完全未知或2）只知其形式、但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。 例如，提出总体服从泊松分布的假设，又如，对于正态总体提出数学期望等于\(\mu_{0}\)的假设等。 我们要根据样本对所提出的假设作出是接受，还是拒绝的决策，假设检验是作出这一决策的过程。这里，先结合例子来说明假设检验的基本思想和做法。
假设检验 假设检验的引入 例子 例 1 某车间用一台包装机包装葡萄糖. 袋装糖的净重是一个随机变量,它 服从正态分布. 当机器正常时,其均值为 0.5 kg,标准差为 0.015 kg. 某日开工后为检验包装机是否正常,随机地抽取它所包装的糖 9 袋,称得净重为 \((\mathrm{kg})\)： \(\begin{array}{llllllll}0.497 &amp;amp; 0.506 &amp;amp; 0.518 &amp;amp; 0.524 &amp;amp; 0.498 &amp;amp; 0.511 &amp;amp; 0.520 &amp;amp; 0.515 &amp;amp; 0.512\end{array}\) 问机器是否正常?
也就是问，根据抽取的样本，可不可以判断正态总体\(X \sim N\left(\mu, \sigma^{2}\right)\) 的分布为\(X\sim N(0.5,0.015^2)\)? 这里以 \(\mu, \sigma\) 分别表示这一天袋装糖的净重总体 \(X\) 的均值和标准差. 由于长期实践表明标准差比较稳定,我们就设 \(\sigma=0.015 .\) （也就是作了简化，只检验均值）。 于是 \(X \sim N\left(\mu, 0.015^{2}\right),\) 这里 \(\mu\) 未 知. 问题是根据样本值来判断 \(\mu=0.5\) 还是 \(\mu \neq 0.</description></item><item><title>概率论与数理统计-数理统计-参数估计</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</link><pubDate>Thu, 17 Dec 2020 19:57:46 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/</guid><description>概率论与数理统计-数理统计-参数估计 统计推断的基本问题可以分为两大类，一类是估计问题，另一类是假设检验问题。本章讨论总体参数的点估计和区间估计.
点估计 设总体X的分布函数的形式已知，但它的一个或多个参数未知，借助于总体X的一个样本来估计总体未知参数的值的问题称为参数的点估计问题
点估计问题的一般提法如下: 设总体 \(X\) 的分布函数 \(F(x ; \theta)\) 的形式为已知, $ $ 是待估参数. \(X_{1}, X_{2}, \cdots, X_{n}\) 是 \(X\) 的一个样本 \(, x_{1}, x_{2}, \cdots, x_{n}\) 是相应的一个样本值. 点估计间题就是要构造一个适当的统计量 \(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right),\) 用它的观察值 \(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\) 作为未知参数 \(\theta\) 的近似值. 我们称 \(\hat{\theta}\left(X_{1}, X_{2}, \cdots, X_{n}\right)\) 为 \(\theta\) 的估计量,称 \(\hat{\theta}\left(x_{1}, x_{2}, \cdots, x_{n}\right)\) 为 \(\theta\) 的估计值. 在不致混淆的情况下统称估计量和估计值为估计。
注意：由于估计量是样本的函数. 因此对于不同的样本值， \(\theta\) 的估计值一般是不相同的.
矩估计法 设 \(X\) 为连续型随机变量,其概率密度为 \(f\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right),\) 或 \(X\) 为离散型随机变量,其分布律为 \(P\{X=x\}=p\left(x ; \theta_{1}, \theta_{2}, \cdots, \theta_{k}\right),\) 其中 \(\theta_{1}, \theta_{2}, \cdots, \theta_{k}\) 为待估参数 \(, X_{1}, X_{2}, \cdots, X_{n}\) 是来自 \(X\) 的样本.</description></item><item><title>概率论与数理统计-数理统计-基本概念</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Sun, 13 Dec 2020 07:31:02 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>概率论与数理统计-数理统计-基本概念 前面章节讲述了概率论的基本内容，随后将讲述数理统计。
数理统计以概率论为理论基础，根据试验或观察得到的数据，来研究随机现象，对研究对象的客观规律性作出种种合理的估计和判断。
数理统计的内容包括：
如何收集、整理数据资料1 如何对所得的数据资料进行分析、研究，从而对所研究的对象的性质、特点作出推断（统计推断）。 概率论与数理统计的对比：
在概率论中，我们所研究的随机变量，它的分布都是假设已知的，在这一前提下去研究它的性质、特点和规律性，例如求出它的数字特征，讨论随机变量函数的分布，介绍常用的各种分布等。 在数理统计中，我们研究的随机变量，它的分布是未知的，或者是不完全知道的，人们是通过对所研究的随机变量进行重复独立的观察，得到许多观察值，对这些数据进行分析，从而对所研究的随机变量的分布作出种种推断的。
本章我们介绍总体、随机样本及统计量等基本概念，并着重介绍几个常用统计量及抽样分布。
总体与样本 总体的概念 我们知道，随机试验的结果很多是可以用数来表示的，另有一些试验的结果虽是定性的，但总可以将它数量化。
例如 例如，检验某个学校学生的血型这一试验，其可能结果有O型、A型、B型、AB型4种，是定性的。如果分别以1,2,3,4依次记这4种血型，那么试验的结果就能用数来表示了。 研究对象的总体，简称为总体。 而在数理统计中，我们往往关心研究对象的某一项数量指标（即随机变量，例如研究某种型号灯泡的寿命这一数量指标），考虑与这一数量指标相联系的随机试验，对这一数量指标进行试验或观察，我们将试验的全部可能的观察值称为总体2，这些值不一定都不相同，数目上也不一定是有限的，每一个可能观察值称为个体。 总体中所包含的个体的个数称为总体的容量。容量为有限的称为有限总体，容量为无限的称为无限总体。
总体中的每一个个体是随机试验的一个观察值，因此它是某一随机变量X的值，这样，一个总体对应于一个随机变量X.我们对总体的研究就是对一个随机变量X的研究，X的分布函数和数字特征就称为总体的分布函数和数字特征，今后将不区分总体与相应的随机变量，笼统称为总体X
样本的概念 样本的引入 在实际中，总体的分布一般是未知的，或只知道它具有某种形式而其中包含着未知参数。 在数理统计中，人们都是通过从总体中抽取一部分个体，根据获得的数据来对总体分布作出推断的。被抽出的部分个体叫做总体的一个样本。
所谓从总体抽取一个个体，就是对总体X进行一次观察并记录其结果。 我们在相同的条件下对总体X，进行n次重复的、独立的观察，将n次观察结果按试验的次序记为\(X_{1}, X_{2}, \cdots, X_{n}\)。 由于\(X_{1}, X_{2}, \cdots, X_{n}\)是都随机变量X的观察结果，且每次观察都是在相同条件下进行的，有理由认为\(X_{1}, X_{2}, \cdots, X_{n}\)都是与X同分布的随机变量。 由于\(X_{1}, X_{2}, \cdots, X_{n}\)是都随机变量X的观察结果，且每次观察都是独立进行的，则\(X_{1}, X_{2}, \cdots, X_{n}\)作为随机变量是相互独立的。 这样获取的互相独立的、与X同分布的\(X_{1}, X_{2}, \cdots, X_{n}\)，称为来自总体的一个简单随机样本。
当 \(n\) 次观察一经完成,我们就得到一组实数 \(x_{1}, x_{2}, \cdots, x_{n},\) 它们依次是随机 变量 \(X_{1}, X_{2}, \cdots, X_{n}\) 的观察值,称为样本值.
对于有限总体，采用放回抽样（独立重复试验）就能得到简单随机样本，但放回抽样使用起来不方便，当个体的总数N比要得到的样本的容量n大得多时，在实际中可将不放回抽样近似地当作放回抽样来处理。 至于无限总体，因抽取一个个体不影响它的分布，所以总是用不放回抽样例如，在生产过程中，每隔一定时间抽取一个个体，抽取n个就得到一个简单随机样本，实验室中的记录，水文、气象等观察资料都是样本。试制新产品得到的样品的质量指标，也常被认为是样本
样本的定义 设 \(X\) 是具有分布函数 \(F\) 的随机变量,若 \(X_{1}, X_{2}, \cdots, X_{n}\) 是具有同一分布函数 \(F\) 的、相互独立的随机变量,则称 \(X_{1}, X_{2}, \cdots, X_{n}\) 为从分布函数 \(F\) （ 或总体F、或总体X）得到的容量为n的简单随机样本，简称样本，它们的观察值\(x_{1}, x_{2}, \cdots, x_{n}\) 称为样本值,又称为 \(X\) 的 \(n\) 个独立的观察值.</description></item><item><title>概率论与数理统计-概率论-大数定律与中心极限定理</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</link><pubDate>Thu, 03 Dec 2020 07:31:02 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/</guid><description>概率论与数理统计-大数定律与中心极限定理 本章介绍概率统计理论中非常重要的两类定理：大数定律和中心极限定理。
大数定律讨论的是一列随机变量的均值的收敛性问题。（独立、同期望、同方差的随机变量列\(\{X_n\}\)的算数平均依概率收敛于期望\(\mu\)）
中心极限定理考虑的是一列随机变量和的极限分布问题。（独立、同分布的随机变量列\(\{X_n\}\)的和的分布近似为正态分布）
基本概念 依概率收敛 设\(X_{1}, X_{2}, \cdots\)为一随机变量序列，X为一随机变量， 若对任意\(\epsilon&amp;gt;0\)，有\(\lim _{n \rightarrow \infty} P\left(\left|X_{n}-X\right| \geqslant \epsilon\right)=0\)， 则称\(\{x_n\)}$依概率收敛于X.
切比雪夫不等式 切比雪夫不等式的提出 19世纪俄国数学家切比雪夫研究统计规律中，论证并用标准差表达了一个不等式，这个不等式具有普遍的意义，被称作切比雪夫定理，其大意是：
任意一个数据集中，位于其平均数m个标准差范围内的比例（或部分）总是至少为1－1/m2， 其中m为大于1的任意正数。对于m=2，m=3和m=5有如下结果：
所有数据中，至少有3/4（或75%）的数据位于平均数2个标准差范围内。 所有数据中，至少有8/9（或88.9%）的数据位于平均数3个标准差范围内。 所有数据中，至少有24/25（或96%)的数据位于平均数5个标准差范围内 。 换言之, 与平均相差k个标准差以上的值，数目不多于1/k^2
与平均相差2个标准差以上的值，数目不多于1/4 与平均相差3个标准差以上的值，数目不多于1/9 与平均相差5个标准差以上的值，数目不多于1/25 切比雪夫不等式的数学描述 说法一： 设随机变量X的数学期望为\(\mu\)，方差为\(\sigma^2\)， 则对于任意\(\epsilon&amp;gt;0\)，有\(P(|X-\mu| \geqslant \epsilon) \leqslant \frac{\sigma^{2}}{\epsilon^{2}}\)
说法二： 设随机变量X的数学期望为\(\mu\)，方差为\(\sigma^2\)， 则对于任意\(\epsilon&amp;gt;0\)，有\(P(|X-\mu|&amp;lt;\epsilon) \geqslant 1-\frac{\sigma^{2}}{\epsilon^{2}}\)
说法三：（取\(\epsilon=k \sigma\)） 设随机变量X的数学期望为\(\mu\)，方差为\(\sigma^2\)， 则\(P(\mu -k\sigma &amp;lt;X&amp;lt;\mu +k\sigma )\geq 1-{\frac {1}{k^{2}}}\)
证明: 以下仅证明X是连续型随机变量的情形(X是离散型随机变量类似): 设随机变量X的密度函数为\(f(x)\),则有 \(\begin{aligned} P(|X-\mu| \geqslant \epsilon) &amp;amp;=\int_{|x-\mu| \geqslant \epsilon} f(x) \mathrm{d} x \leqslant \int_{|x-\mu| \geqslant \epsilon} \frac{|x-\mu|^{2}}{\epsilon^{2}} f(x) \mathrm{d} x \\ &amp;amp; \leqslant \frac{1}{\epsilon^{2}} \int_{-\infty}^{+\infty}(x-\mu)^{2} f(x) \mathrm{d} x=\frac{\sigma^{2}}{\epsilon^{2}} \end{aligned}\)</description></item><item><title>概率论与数理统计-概率论-随机变量的数字特征</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/</link><pubDate>Fri, 27 Nov 2020 09:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/</guid><description>概率论与数理统计-随机变量的数字特征 随机变量及其概率分布章节，我们讨论了随机变量的分布函数，它完整反映了随机变量（在一定范围内）的概率特性。
然而很多时候，我们不需要或者很难知道随机变量的完整特性，只需要知道它的某些重要指标。 （比如在调查一群人的身高或者某地居民的收入时，我们经常关心这些量的均值或者个体之间的差异。在碰到多个随机变量时，还需要一些指标来反映这些随机变量之间的关系。）
与随机变量密切相关的指标统称为数字特征。重要的数字特征有数学期望、方差、协方差、相关系数以及矩等.
数学期望 离散型随机变量的数学期望 离散型随机变量的数学期望的定义 设离散型随机变量X的概率分布律为\(P\left(X=x_{k}\right)=p\left(x_{k}\right), \quad k=1,2, \cdots\) 如果无穷级数\(\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)绝对收敛， 则称\(\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)为（离散型）随机变量X的数学期望，简称数学期望或均值， 记作 \(E(X)\)，即\(E(X)=\sum_{k=1}^{\infty} x_{k} p\left(x_{k}\right)\)
常见离散型随机变量的数学期望 0-1分布的期望\(E(X)=p\) 设X服从参数为p的两点分布（0-1分布），即\(P(X=0)=1-p, \quad P(X=1)=p, \quad 0&amp;lt;p&amp;lt;1\) 则\(E(X)=1 \times p+0 \times(1-p)=p\)
二项分布\(X \sim B(n, p)\)的期望\(E(X)=n p\) 证明（方法一）：
因为\(X \sim B(n, p)\)，所以\(P(X=k)=C_{n}^{k} p^{k}(1-p)^{n-k}, \quad k=0,1,2, \cdots, n\) 则： \(\begin{aligned} E(X) &amp;amp;=\sum_{k=0}^{n} k \mathrm{C}_{n}^{k} p^{k}(1-p)^{n-k}=\sum_{k=0}^{n} \frac{k n !}{k !(n-k) !} p^{k}(1-p)^{n-k} \\ &amp;amp;=n p \sum_{k=1}^{n} \frac{(n-1) !}{(k-1) !</description></item><item><title>数学分支的总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%94%AF%E7%9A%84%E6%80%BB%E7%BB%93/</guid><description>数学分支的总结 参考：关于数学分支的总结(zz)
基础数学：
数论：古典数论 解析数论，代数数论，超越数论, 模型式与模函数论
代数学：线性代数 群论, 群表示论, 李群, 李代数, 代数群, 典型群, 同调代数, 代数K理论, Kac-Moody代数, 环论, 代数, 体, 格, 序结构. 域论和多项式 拓扑群 矩阵论 向量代数 张量代数
几何学：（整体，局部）微分几何, 代数几何, 流形上的分析, 黎曼流形与洛仑兹流形, 齐性空间与对称空间, 调和映照, 子流形理论, 杨–米尔斯场与纤维丛理论, 辛流形. 凸几何与离散几何 欧氏几何 非欧几何 解析几何
拓扑学：微分拓扑, 代数拓扑, 低维流形, 同伦论, 奇点与突变理论, 点集拓扑. 流形和胞腔复形 大范围分析,微分拓扑 同调论 复流形
函数论： 函数逼近论.
泛函分析：（非）线性泛函分析, 算子理论, 算子代数, 差分与泛函方程, 广义函数. 变分法，积分变换 积分方程
微分方程：泛函微分方程, 特征与谱理论及其反问题, 定性理论, 稳定性理论、分支理论,混沌理论, 奇摄动理论,动力系统, 常微分方程 非线性椭圆(和抛物)方程,偏微分方程, 微局部分析与一般偏微分算子理论, 调混合型及其它带奇性的方程, 非线性发展方程和无穷维动力系统.
数学物理：规范场论, 引力场论的经典理论与量子理论, 孤立子理论.</description></item><item><title>数学物理方法总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E7%89%A9%E7%90%86%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>数学物理方法总结 坐标变换 直角坐标、柱坐标、球坐标变换
矢量的坐标变换/三种常用坐标系中的矢量场
柱坐标系、球坐标系与直角坐标系之间单位矢量的转换
不同坐标系下基矢量的关系
拉普拉斯算子从笛卡尔坐标系到圆柱坐标系下的推导过程</description></item><item><title>最优化问题总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</guid><description>最优化问题总结 最优化问题概述 参考：https://zhuanlan.zhihu.com/p/22801652
最优化问题的引出 以下都是最优化问题的例子： 上班怎么选择乘车路线，才能舒服又快速的到达公司；旅游如何选择航班和宾馆，既省钱又能玩的开心； 跳槽应该选择哪家公司，钱多、事少、离家近，前台妹子颜值高；买房子应该选在哪里，交通发达有学区，生活便利升值快。
可以看出，上面所有的问题都面临无数的选择， 我们会根据自己的偏好对每个选择打一个不同的分数，再从所有的选择中找出最优的一个。这个寻求最优解的过程其实就是最优化问题。
我们要打的分数就称为目标函数。
最优化问题往往还要面临一定的约束条件，比如对旅行路线的选择，总花费和出发、到达时间就构成了约束条件，对买房子的选择，离公司的路程、总价也可能构成约束条件。我们选择的最优解也必须满足这些约束条件。
最优化问题的定义 最优化问题就可以定义为： 在给定的约束条件下， 选择最优的参数和方案，来使得目标函数最大化/最小化的问题。
最优化问题的数学形式是：
img 这里可以看到最优化问题的三个基本要素：
目标函数: 用来衡量结果的好坏 参数值：未知的因子，需要通过数据来确定。 约束条件：需要满足的限制条件 最优化问题的分类 按约束条件分类 根据约束条件的种类，最优化问题可以分成以下种类：
img 按目标函数分类 而根据目标函数的状态， 最优化问题又可以分成：
img 按解法分类（解法的选择） 在实际的工作中，我们如何来选择最优化问题的解法呢？
基本的依据有以下几点：
目标函数是否连续可导 目标函数的形式，是否为线性函数或者二次函数 img 对应上图：
离散最优化方法： 主要用于求解目标函数不连续或者不可导的情况，典型的解法有爬山法、模拟退火、遗传算法和蚁群算法等。 线性规划和二次规划：运筹学的重要研究内容，适用于目标函数是线性或二次函数的形式。 连续最优化方法： 适用于逻辑回归、SVM、神经网络等机器学习问题，主要方法包括梯度下降、牛顿法和拟牛顿法。 离散最优化 参考：百度百科：整数规划 参考：知乎：运筹学发展概况（上） 参考：知乎：运筹学发展概况（中）
最优化问题似乎自然地分成两类：一类是连续变量的问题，另一类是离散变量的问题。具有离散变量的问题，我们称它为组合的(和离散最优化、整数规划常常混用，实际上范围稍稍有点不同）。在连续变量的问题里，一般地是求一组实数，或者一个函数；在组合问题里，是从一个无限集或者可数无限集里寻找一个对象——典型地是一个整数，一个集合，一个排列，或者一个图。一般地，这两类问题有相当不同的特色，并且求解它们的方法也是很不同的。
整数优化 数规划是指规划中的变量（全部或部分）限制为整数
包括组合优化、0-1优化。。。
而组合最优化通常都可表述为整数规划问题。
组合优化 参考：组合优化百度百科 参考：知乎：离散/整数/组合/非凸优化概述及其在AI的应用
组合优化是20 世纪60 年代逐渐发展起来的一个交叉学科分支，它的研究对象是有限集合上的极值问题。</description></item><item><title>概率论与数理统计-数理统计-方差分析与回归分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/</guid><description>概率论与数理统计-数理统计-方差分析与回归分析 //TODO
参考：https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90 参考：概率论与数理统计.浙大第四版
方差分析和回归分析都是数理统计中具有广泛应用的内容. 本章对它们的 最基本部分作一介绍.
（本章节最好直接阅读教材，这里总结并不到位。这里引入了许多统计量的分布，证明参见：概率论与数理统计.浙大第四版）
单因素试验的方差分析 在科学试验和生产实践中，影响一事物的因素往往是很多的。 例如，在化工生产中，有原料成分、原料剂量、催化剂、反应温度、压力溶液浓度、反应时间、机器设备及操作人员的水平等因素每一因素的改变都有可能影响产品的数量和质量。 有些因素影响较大，有些较小。为了使生产过程得以稳定，保证优质、高产就有必要找出对产品质量有显著影响的那些因素.为此，我们需进行试验。 方差分析就是根据试验的结果进行分析，鉴别各个有关因素对试验结果影响的有效方法.
单因素试验 在试验中，我们将要考察的指标称为试验指标（对应随机变量）。影响试验指标的条件称为因素.（随机变量的参数，作为自变量看待） 因素可分为两类， 一类是人们可以控制的（可控因素）； 一类是人们不能控制的（不可控因素）。例如，反应温度、原料剂量、溶液浓度等是可以控制的，而测量误差、气象条件等一般是难以控制的。以下我们所说的因素都是指可控因素。 因素所处的状态，称为该因素的水平（见下述各例）。 如果在一项试验的过程中只有一个因素在改变称为单因素试验，如果多于一个因素在改变称为多因素试验。
例子 设有三台机器,用来生产规格相同的铝合金薄板. 取样,测量薄板的 厚度精确至千分之一厘米.得结果： 这里，试验的指标是薄板的厚度。机器为因素，不同的三台机器就是这个因素的三个不同的水平。 我们假定除机器这一因素外，材料的规格、操作人员的水平等其他条件都相同。这是单因素试验。 试验的目的是为了考察各台机器所生产的薄板的厚度有无显著的差异，即考察机器这一因素对厚度有无显著的影响。 如果厚度有显著差异，就表明机器这一因素对厚度的影响是显著的
本节仅限于讨论单因素试验.
方差分析法 在实际中试验的指标往往要受到一种或多种因素的影响。方差分析就是通过对试验数据进行分析，检验方差相同的多个（多于两个）正态总体的均值是否相等，用以判断各因素对试验指标的影响是否显著。方差分析按影响试验指标的因素的个数分为单因素方差分析、双因素方差分析和多因素方差分析，本章只介绍前面两种。
在上面例子中,我们在因素的每一个水平下进行独立试验,其结果是一个样本. 表中数据可看成来自三个不同总体(每个水平对应一个总体)的样本值. 将各个总体的均值依次记为 \(\mu_{1}, \mu_{2}, \mu_{3}\). 上面的例子的问题是：机器这一因素对厚度的影响是显著？按题意需检验假设： \(H_{0}: \mu_{1}=\mu_{2}=\mu_{3}\) \(H_{1}: \mu_{1}, \mu_{2}, \mu_{3}\) 不全相等.
现在进而假设各总体均为正态变量,且各总体的方差相等,但参数均未知. 那么 这是一个检验同方差的多个正态总体均值是否相等的问题.
下面所要讨论的方差分析法,就是解决这类问题（检验同方差的多个正态总体均值是否相等）的一种统计方法.
单因素试验方差分析的数学模型与假设检验问题 现在开始讨论单因素试验的方差分析. 设因素 \(A\) 有 \(s\) 个水平 \(A_{1}, A_{2}, \cdots, A_{s},\) 在水平 \(A_{j}(j=1,2, \cdots, s)\) 下,进行 \(n_{j}\left(n_{j} \geqslant 2\right)\) 次独立试验,得到如下图表的结果： 我们假定 : 各个水平 \(A_{j}(j=1,2, \cdots, s)\) 下的样本 \(X_{1 j}, X_{2 j}, \cdots, X_{n_{j} j}\) 来自具有相同方差 \(\sigma^{2},\) 均值分别为 \(\mu_{j}(j=1,2, \cdots, s)\) 的正态总体 \(N\left(\mu_{j}, \sigma^{2}\right), \mu_{j}\) 与 \(\sigma^{2}\) 未知.</description></item><item><title>概率论与数理统计-概率论-随机事件与概率</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E4%B8%8E%E6%A6%82%E7%8E%87/</guid><description>概率论与数理统计-随机事件与概率 基本概念 现象 现象
现象是事物表现出来的，能被人感觉到的一切情况。现象是人能够看到、听到、闻到、触摸到的。
按照是否有自然属性来分，现象可分为自然现象和社会现象。 按照现象的结果是否唯一来分，现象可分为确定性现象和随机现象。
概率统计研究的主要目标是随机现象，即现象的结果有多种可能，且事先无法准确预测将会发生哪种结果。
随机试验 对随机现象进行一次观察，称为一次随机试验（试验）
概率论中将满足下面三个条件的试验称为随机试验，简称试验：
可在相同的条件下重复进行； 每次试验的结果不止一个 试验之前不能确定哪一个结果会发生，但所有的结果是明确可知的 样本点 随机试验中每一个可能发生的结果（现象观察到的结果），称为一个样本点。一般记作\(\omega\)
样本空间 随机试验中所有可能发生的结果，即所有的样本点，称为样本空间。一般记作\(\Omega= \{\omega\}\).
随机事件
样本空间的任意子集,都称为随机事件（事件）。
特殊事件(不可能事件与必然事件) 不可能事件：不含样本点的事件（不含任何元素），称为不可能事件。用集合的语言描述为空集\(\varnothing\)
必然事件：包含样本空间所有样本点的事件（包含所有可能的结果，因此该事件一定会发生），称为必然事件。用集合的语言描述为样本空间全集\(\Omega\)
事件的发生 若事件A中的某个样本点在随机试验中出现（某个样本点被观测到），称为事件A发生。 即事件A中某个样本点被观测到\(\Leftrightarrow\)事件A发生
事件的关系与运算 经常要用简单事件表示一些复杂事件（尤其是研究概率的过程中）。 因此需要讨论使事件的关系与运算。
这里的事件用集合来表示，所以实际上是集合的关系与运算。
包含关系\(A \subset B\) 定义:A发生导致B发生,称:B包含A,或称A被B包含.记\(A \subset B\).集合论：A的元素必属于B。图示：
B包含A （定义，称，记，集合论，图）
相等关系A=B \(B \subset A, B \subset A\)，则A=B
互斥关系\(A B=\varnothing\) 在试验中，事件A与B不能同时发生，即\(A B=\varnothing\)，则称A，B互为互斥事件
设\(A_1, A_2, \cdots, A_n\)是一组事件， 若它们两两互斥(都是互斥事件)， 且它们的并等于样本空间（\(\cup_{i=1}^{n} A_i = \Omega\)）， 称这组事件构成一个互不相容的完备事件组（完备事件组）
对立关系 每次事件中，“事件A不发生”的事件称为事件A的对立事件或者逆事件。记为\(\bar{A}\)。
性质： \((1) A+A=\Omega\) \((2) A \bar{A}=\varnothing\)</description></item><item><title>概率论与数理统计-概率论-随机变量及其分布</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E6%A6%82%E7%8E%87%E8%AE%BA-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83/</guid><description>概率论与数理统计-随机变量及其分布 （一维）随机变量与分布函数 随机变量的概念 随机变量的引入 对于不同的随机现象， 有些随机现象的结果（样本点）往往是一个某个数量指标，可以用实数来表示（比如色子掷出点数）； 有些随机现象的结果（样本点）没有数量特征，只标记某种属性（比如硬币抛出正反面，公司某年是盈是亏）。
对于没有数量特征的样本点，我们可以人为引入数字来标记结果。 这样，每个随机现象的结果（或者说每次随机试验的结果），都有一个实数与之对应。
随机变量的定义 设试验的样本空间为\(\Omega\)，如果对于每个样本点\(\omega \in \Omega\)，都有一个实数\(X(\omega)\)与之对应，则称\(X(\omega)\)为随机变量。
注意：随机变量\(X(\omega)\)常简写为X 。但是，随机变量实际上是个因变量，对应的自变量是样本空间中的样本点。 注意：随机变量常用大写英文字母X,Y,Z等，或者希腊字母\(\xi,\eta,\zeta\)等表示。
落在某范围的随机变量可以表示随机事件 有了随机变量，随机事件（样本空间的子集）就可以用随机变量的区间来描述。 即随机事件可以用随机变量落在某个范围内来表示。
例如，抛掷硬币3次，用X表示正面朝上的次数， 随机事件”至少有两次正面朝上“可以写为\(\{\omega | X(\omega) \ge 2\}\)，一般直接简写为\(\{ X \ge 2\}\)
随机变量的分布函数 在随机事件章节，我们讨论过随机事件发生的概率。 我们已经知道随机事件可以用随机变量落在某个范围来表示， 则我们可以用随机变量描述事件的概率，即随机变量落在某个范围内的概率，引入随机变量的（概率）分布函数。
随机变量的分布函数定义 设X是一个随机变量，称\(F(x)=P(X \le x) , -\infty &amp;lt; x &amp;lt; +\infty\)为随机变量X的分布函数。
注意：\(F(x)\)的定义域是实数集\(R\)，对于每个实数x，\(F(X)\)表示随机变量小于等于x的概率，显然\(0\le x \le 1\)
随机变量的分布函数的性质 下面列出的是任何随机变量的分布函数的共性。之后还会单独讨论离散型随机变量和连续性随机变量的特性。
\(F(-\infty)=\lim_{-\infty} F(x) = 0, F(+\infty)=\lim_{+\infty} F(x) = 1\) \(P(a&amp;lt;X\le b) = F(b) - F(a)\) 因为\(\{a &amp;lt; X \le b\} = \{ X \le b\} - \{X \le a\}\) 所以随机变量X落在区间\((a,b]\)的概率为：\(P(a&amp;lt;X\le b) = P(b) - P(a) = F(b) - F(a)\)</description></item><item><title>泛函分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%B3%9B%E5%87%BD%E5%88%86%E6%9E%90%E6%80%BB%E7%BB%93/</guid><description>泛函分析 参考：维基百科：泛函分析
泛函分析（英语：Functional Analysis）是现代数学分析的一个分支，隶属于分析学，其研究的主要对象是函数构成的函数空间。泛函分析历史根源是由对函数空间的研究和对函数的变换（如傅立叶变换等）的性质的研究。这种观点被证明是对微分方程和积分方程的研究中特别有用。
使用泛函这个词作为表述源自变分法，代表作用于函数的函数，这意味着，一个函数的参数是函数。
赋范线性空间 从现代观点来看，泛函分析研究的主要是实数域或复数域上的完备赋范线性空间。这类空间被称为巴拿赫空间，巴拿赫空间中最重要的特例被称为希尔伯特空间，其上的范数由一个内积导出。这类空间是量子力学数学描述的基础。更一般的泛函分析也研究Fréchet空间和拓扑向量空间等没有定义范数的空间。
泛函分析所研究的一个重要对象是巴拿赫空间和希尔伯特空间上的连续线性算子。这类算子可以导出C*-代数和其他算子代数的基本概念。
希尔伯特空间 主条目：希尔伯特空间
希尔伯特空间（Hilbert）可以利用以下结论完全分类，即对于任意两个希尔伯特空间，若其基的基数相等，则它们必彼此同构。对于有限维希尔伯特空间而言，其上的连续线性算子即是线性代数中所研究的线性变换。对于无穷维希尔伯特空间而言，其上的任何态射均可以分解为可数维度（基的基数为\(\displaystyle \aleph _{0}\)）上的态射，所以泛函分析主要研究可数维度上的希尔伯特空间及其态射。希尔伯特空间中的一个尚未完全解决的问题是，是否对于每个希尔伯特空间上的算子，都存在一个真不变子空间。该问题在某些特定情况下的答案是肯定的。
巴拿赫空间 主条目：巴拿赫空间
一般的巴拿赫空间（Banach）比较复杂，例如没有通用的办法构造其上的一组基。
对于每个实数\(\displaystyle p\)，如果\(\displaystyle p\geq 1\)，一个巴拿赫空间的例子是“所有绝对值的\(\displaystyle p\)次方的积分收敛的勒贝格可测函数”所构成的空间。（参看Lp空间）
在巴拿赫空间中，相当部分的研究涉及到对偶空间的概念，即巴拿赫空间上所有连续线性泛函所构成的空间。对偶空间的对偶空间可能与原空间并不同构，但总可以构造一个从巴拿赫空间到其对偶空间的对偶空间的一个单同态。
微分的概念可以在巴拿赫空间中得到推广，微分算子作用于其上的所有函数，一个函数在给定点的微分是一个连续线性映射。
主要结果和定理 泛函分析的主要定理包括：
一致有界定理（亦称共鸣定理），该定理描述一族有界算子的性质。 谱定理包括一系列结果，其中最常用的结果给出了希尔伯特空间上正规算子的一个积分表达，该结果在量子力学的数学描述中起到了核心作用。 哈恩-巴拿赫定理（Hahn-Banach Theorem）研究了如何将一个算子保范数地从一个子空间延拓到整个空间。另一个相关结果是对偶空间的非平凡性。 开映射定理和闭图像定理。 泛函分析与选择公理 泛函分析所研究的大部分空间都是无穷维的。为了证明无穷维向量空间存在一组基，必须要使用佐恩引理（Zorn’s Lemma）。此外，泛函分析中大部分重要定理都构建于哈恩-巴拿赫定理的基础之上，而该定理本身就是选择公理（Axiom of Choice）弱于布尔素理想定理（Boolean prime ideal theorem）的一个形式。
泛函分析的研究现状 泛函分析目前包括以下分支：
软分析（soft analysis），其目标是将数学分析用拓扑群、拓扑环和拓扑向量空间的语言表述。 巴拿赫空间的几何结构，以Jean Bourgain的一系列工作为代表。 非交换几何，此方向的主要贡献者包括Alain Connes，其部分工作是以George Mackey的遍历论中的结果为基础的。 与量子力学相关的理论，狭义上被称为数学物理，从更广义的角度来看，如按照Israel Gelfand所述，其包含表示论的大部分类型的问题。</description></item><item><title>线性代数-相似矩阵与二次型</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B/</guid><description>线性代数-相似矩阵与二次型 本章主要讨论方阵的特征值与特征向量、方阵的相似对角化和二次型的化简等问题。
其中涉及向量的内积、长度及正交等知识，下面先介绍这些知识。
向量的内积、长度及正交性 向量的内积 向量内积的引入 在（平面/空间）解析几何中，我们曾引进向量的数量积/内积：\(x \cdot y=|x||y| \cos \theta\)， 然后定义了向量间的夹角余弦与夹角（包括垂直的定义）， 且以互相垂直向量为轴，建立直角坐标系，有（直角坐标系中的）数量积的坐标表示：\(\left(x_{1}, x_{2}, x_{3}\right) \cdot\left(y_{1}, y_{2}, y_{3}\right)=x_{1} y_{1}+x_{2} y_{2}+x_{3} y_{3}\)
n维向量的内积是数量积的一种推广。但n维向量没有3维向量那样直观的长度和夹角的概念，因此只能按数量积的直角坐标计算公式来推广。并且反过来，利用内积来定义n维向量的长度和夹角。
向量x与y内积的定义 设有n维向量： \(\boldsymbol{x}=\left(\begin{array}{c}x_{1} \\ x_{2} \\ \vdots \\ x_{n}\end{array}\right), \boldsymbol{y}=\left(\begin{array}{c}y_{1} \\ y_{2} \\ \vdots \\ y_{n}\end{array}\right)\) 令\([x, y]=x_{1} y_{1}+x_{2} y_{2}+\cdots+x_{n} y_{n}\) 称[ x, y]为向量x与y的内积
当x与y都是列向量时， 有\([x, y]=x^{T} y\)
向量的内积，结果是个实数。
向量内积的基本性质 （其中 x, y, z 为 n 维向量, \(\lambda\) 为实数）
\([x, y]=[y, x]\)
\([\lambda x, y]=\lambda[x, y]\)
\([x+y, z]=[x, z]+[y, z]\)</description></item><item><title>线性代数-相似矩阵与二次型习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5%E4%B8%8E%E4%BA%8C%E6%AC%A1%E5%9E%8B%E4%B9%A0%E9%A2%98/</guid><description>线性代数-相似矩阵与二次型习题 内积,正交的概念 内积的概念 例1 image-20201012145035553 image-20201012145106438 正交矩阵的判定与证明 可用正交矩阵的定义\(A^T A = E\)判断, 也可用\(A^T=A^{-1}\)判断, 也可用构成A向量组的向量是否都两两正交,且向量都是单位向量来判断
例1 image-20201012151808714 image-20201012151832177 例2 image-20201012153113164 略
例3 image-20201012161359690 证明： A、B是正交矩阵，根据定义知道AA’=A’A=E, BB’=B’B=E, 那么(AB)(AB)‘=(AB)(B’A’)=ABB’A’=A(BB’)A=AEA’=AA’=E
线性无关向量组的正交化(施密特正交化) 例1 image-20201012150738793 image-20201012150855741 特征值与特征向量 求特征值与特征向量 例1 image-20201013105735880 image-20201013105806041 特征值的证明 特征值相同的证明 一般根据\(Ax=\lambda x, x\neq 0\)的定义,化为齐次方程组\((A-\lambda E)x = 0, x\neq 0\), 利用齐次方程组有非零解的条件求特征值, 即用\(|A-\lambda E|=0\)来证明特征值相等.
也有习题是从\(Ax=\lambda x, x\neq 0\)的定义,直接入手,用矩阵乘法等来做.</description></item><item><title>高等数学-级数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0/</guid><description>高等数学-级数 高等数学（数学分析）主要分为两块，微积分与级数。两者都建立在函数的极限理论之上。
级数是表示函数、研究函数性质以及数值计算的一种工具。函数可以展开成幂级数、三角级数的形式，级数也可以求其对应的和函数，因此把函数展开到级数形式可以研究函数的一些性质，也可以用级数计算函数。
常数项级数部分主要介绍级数的概念与一般性质。 函数项级数主要介绍幂级数、和三角级数（包括Fourier级数），着重讨论函数展开成幂级数、三角级数的问题，以及函数项级数表示成和函数的问题。
级数的基本概念与性质 级数的定义 高中我们已经学过数列。
简单的讲，无穷数列的和，就是级数。记为\(\sum_{n=1}^{\infty} a_n\)。 级数定义：给定一个无穷数列\(u_{1}, u_{2}, u_{3}, \cdots, u_{n}, \cdots\)，则\(\sum_{i=1}^{\infty} u_{i}=u_{1}+u_{2}+u_{3}+\cdots+u_{i}+\cdots\)称为级数，其中的第n项\(u_n\)称为一般项。
当级数的各项\(a_i\)都是常数时，形成的级数叫常数项级数； 当级数的各项\(a_i\)都是关于x的函数时，形成的级数叫函数项级数。 当级数的各项\(a_i\)都是复数时，形成的级数叫复数项级数；
类比研究反常积分的过程，研究反常要从正常开始，研究无限要从有限开始。 为了研究无限的级数，我们可以先看有限的部分和（前n项和）。 \(S_n = a_1 + a_2 + a_3 + ... + a_n\)，称为级数的部分和（前n项和）。
二重级数：给定带有两个下标i和j的无穷数集{aij}(i=1,2,…;j=1,2,…)，称记号a11+a12+…+a21+a22+…+a31+a32+…是二重级数(double series)。记作\(\sum_{m=1,n=1}^{\infty} a_{mn}\)，也可记作\(\sum_{m=1}^{\infty} \sum_{n=1}^{\infty} a_{mn}\)，其中m，n各自独立地取正整数1，2，3，…
级数的收敛、发散、和的概念 如果\(\Sigma_{n=1}^{\infty} a_n = \lim_{n \rightarrow \infty} S_n = S\)，称级数${n=1}^{} a_n \(**收敛**于S，这时S又称作级数\){n=1}^{} a_n $的和
如果\(\Sigma_{n=1}^{\infty} a_n\)的部分和\(\lim_{n \rightarrow \infty} S_n\)不存在，称级数$_{n=1}^{} a_n $发散。
级数的性质 级数的四则运算性质 级数加减法、乘法，结果的收敛区间取原来两级数的收敛区间\((-R_1, R_1)\)和\((-R_2,R_2)\)中较小的一个. 级数的数乘不改变收敛区间， 级数的除法可能比原来两级数的收敛区间小得多（不做讨论）
级数的加减法性质（逐项相加、相减性质） \(\Sigma_{n=1}^{\infty} a_n \pm \Sigma_{n=1}^{\infty} b_n = \Sigma_{n=1}^{\infty} (a_n \pm b_n)\)</description></item><item><title>高等数学-级数习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Nov 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E7%BA%A7%E6%95%B0%E4%B9%A0%E9%A2%98/</guid><description>高等数学-级数习题 级数审敛 级数收敛定义与性质判敛 例1 image-20200823001536092 image-20200823001546204 image-20200823083227207 image-20200823083238321 例2 image-20200823084522441 image-20200823084539210 例3 image-20200823094409497 image-20200823094439081 例4 image-20200823112128319 image-20200823112143018 例5 image-20200823131153930 image-20200823131210561 image-20200823131232305 image-20200823131245506 例6 image-20200823184049122 image-20200823184112259 例7 image-20200824095539210 image-20200824095600695 正项级数审敛 比较审敛与极限审敛 比较审敛法的一般形式，以及基本不等式的应用 例1 image-20200823000329492 image-20200823000343399 （主要是根据不等式：\(a+b \ge 2\sqrt{ab}\)）</description></item><item><title>线性代数-向量组的线性相关性</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/</link><pubDate>Mon, 10 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7/</guid><description>线性代数-向量组的线性相关性 向量与向量组 向量 向量的定义 n 个有次序的数 \(a_{1}, a_{2}, \cdots, a_{n}\) 所组成的数组称为n 维向量, 这 \(n\)个数称为该向量的 n 个分量，第 i 个数 \(a_i\) 称为第 \(i\) 个分量。（代数，或者说线性代数中的定义）
在解析几何中，我们把“既有大小又有方向的量”叫做向量，并把可随意平行移动的有向线段作为向量的几何形象。在引进坐标系以后，这种向量就有了坐标表示式——三个有次序的实数，也就是本书中的3维向量。因此，当n≤3时，n维向量可以把有向线段作为几何形象，但当n&amp;gt;3时，n维向量就不再有这种几何形象，只是沿用一些几何术语罢了。
实向量与复向量 分量全为实数的向量称为实向量，分量为复数的向量称为复向量本书中除特别指明者外，一般只讨论实向量
行向量与列向量 n维向量可写成一行，也可写成一列。分别称为行向量和列向量，也就是行矩阵和列矩阵，并规定行向量与列向量都按矩阵的运算规则进行运算。
n维列向量： \(a=\left(\begin{array}{c}a_{1} \\ a_{2} \\ \vdots \\ a_{n}\end{array}\right)\)
n维行向量： \(a^{\mathrm{T}}=\left(a_{1}, a_{2}, \cdots, a_{n}\right)\)
从矩阵角度看，有着相同分量的行向量与列向量。总看做是两个不同的向量（虽然按照向量的定义，a与\(a^T\)应是同一个向量）
向量组 下面我们先讨论只含有限个向量的向量组，以后再把讨论的结果推广到含无限多个向量的向量组.
向量组的定义 若干个同维数的列向量（或同维数的行向量）所组成的集合叫做向量组。
（注意：向量组的每个元素都是一个向量，应该使用boldsymbol黑体，但是一些地方我偷懒了，没有用黑体，下面要注意分辨）
eg: 一个m×n矩阵的全体列向量是一个含n个m维列向量的向量组， 它的全体行向量是一个含m个n维行向量的向量组
eg2: 线性方程\(A_{m \times n} x=0\)的全体解当R（A）&amp;lt;n时是一个含无限多个n维列向量的向量组
有限个向量的向量组与矩阵一一对应 矩阵的列向量组和行向量组都是只含有限个向量的向量组；反之，一个含有限个向量的向量组总可以构成一个矩阵。
总之，含有限个向量的有序向量组可以与矩阵一一对应。
eg1: \(m\) 个 \(n\) 维列向量所组成的向量组 \(A: a_{1}, a_{2}, \cdots, a_{m}\) 构成一个 \(n \times m\) 矩阵： \(\boldsymbol{A}=\left(\boldsymbol{a}_{1}, \boldsymbol{a}_{2}, \cdots, \boldsymbol{a}_{m}\right)\)</description></item><item><title>线性代数-向量组的线性相关性习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/</link><pubDate>Mon, 10 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E5%90%91%E9%87%8F%E7%BB%84%E7%9A%84%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B9%A0%E9%A2%98/</guid><description>线性代数-向量组的线性相关性习题 向量组与矩阵 例1 image-20200927202411878 image-20200927203348612 (1)由于AP=PB， 即： \(A(x，Ax，A^2x)\\=(Ax，A^2x，A^3x)\\=(Ax，A^2x，3Ax-2A^2x)\\=(x，Ax，A^2x)\left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\) ， 从而： \(AP=P \left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\) ， 所以： \(B＝ \left[\begin{array}{c} 0&amp;amp; 0&amp;amp; 0\\ 1&amp;amp; 0&amp;amp; 3\\ 0&amp;amp; 1&amp;amp; -2\end{array}\right]\)
\(|A|=|PAP^{-1}|\\ =|P|\cdot |B| \cdot |P^{-1}|\\ =|P|\cdot |B| \cdot |P|^{-1}\\ =|B| =0\) 向量组的线性表示 向量b可由向量组A线性表示的证明 例1 image-20200926165347373 要证： \(a_{1}\) 能由 \(a_{2}, a_{3}\) 线性表示\(\Leftrightarrow\) 即证\(a_1 = (a_2, a_3) \left(\begin{array}{c} k_1 \\ k_2 \end{array}\right)\)有解 \(\Leftrightarrow\) 即证\(R(a_2, a_3) = R(a_2, a_3, a_1)\) 由\(R\left(a_{2}, a_{3}, a_{4}\right)=3\)得，\(a_{2}, a_{3}, a_{4}\)线性无关，则\(a_{2}, a_{3}\)线性无关，则\(R(a_{2}, a_{3})=2\) 又\(R\left(a_{1}, a_{2}, a_{3}\right)=2\) 则\(R\left(a_{1}, a_{2}, a_{3}\right)=R(a_2, a_3)\)，则\(a_1 = (a_2, a_3) \left(\begin{array}{c} k_1 \\ k_2 \end{array}\right)\)有解，则\(a_{1}\) 能由 \(a_{2}, a_{3}\) 线性表示 (2)要证\(a_{4}\) 不能由 \(a_{1}, a_{2}, a_{3}\) 线性表示\(\Leftrightarrow\) 即证\(a_4 = (a_1,a_2, a_3) \left(\begin{array}{c} x_1 \\ x_2 \\x_3 \end{array}\right)\)无解 \(\Leftrightarrow\) 即证\(R(a_1,a_2, a_3) &amp;lt; R(a_1,a_2, a_3,a_4 )\)</description></item><item><title>线性代数-矩阵初等变换与线性方程组习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 02 Aug 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E4%B9%A0%E9%A2%98/</guid><description>线性代数-矩阵初等变换与线性方程组习题 矩阵初等变换 变换成最简型 例1 image-20200921231812376 image-20200921231920227 求初等变换矩阵 初等行变换\(A \rightarrow E\) 即\(PA = E\) 又\(PE = P\) 则\((P|E) \rightarrow (E|P)\)
例1 image-20200922112607294 image-20200922112648746 例2 A不是方阵时，可逆矩阵可能不唯一 image-20200922124111248 image-20200922124142564 我用初等行变换的方法做第二问，得到的答案是： \(Q=\left(\begin{array}{rrr}1 &amp;amp; 2 &amp;amp; 0 \\ -1 &amp;amp; -2 &amp;amp; 1 \\ -4 &amp;amp; -7 &amp;amp; 1\end{array}\right)\) 与标准答案不同。 参考网上的意思是：当\(A^T\)（或\(A\)）不是方阵时，Q不唯一。 https://zhidao.baidu.com/question/1695810374576283988.html?qbl=relate_question_4 https://m.iask.sina.com.cn/b/20287408.html
求逆矩阵 例1 image-20200922151824498 image-20200922151837916 例2 image-20200922172625133 image-20200922172640005 例3 image-20200922174724888 image-20200922174737292 矩阵的秩 初等变换前后的矩阵是同型矩阵。</description></item><item><title>线性代数-矩阵初等变换与线性方程组习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</link><pubDate>Thu, 30 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B52%E7%9F%A9%E9%98%B5%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84/</guid><description>线性代数-矩阵初等变换与线性方程组习题 矩阵初等变换 变换成最简型 例1 image-20200921231812376 image-20200921231920227 求初等变换矩阵 初等行变换\(A \rightarrow E\) 即\(PA = E\) 又\(PE = P\) 则\((P|E) \rightarrow (E|P)\)
例1 image-20200922112607294 image-20200922112648746 例2 A不是方阵时，可逆矩阵可能不唯一 image-20200922124111248 image-20200922124142564 我用初等行变换的方法做第二问，得到的答案是： \(Q=\left(\begin{array}{rrr}1 &amp;amp; 2 &amp;amp; 0 \\ -1 &amp;amp; -2 &amp;amp; 1 \\ -4 &amp;amp; -7 &amp;amp; 1\end{array}\right)\) 与标准答案不同。 参考网上的意思是：当\(A^T\)（或\(A\)）不是方阵时，Q不唯一。 https://zhidao.baidu.com/question/1695810374576283988.html?qbl=relate_question_4 https://m.iask.sina.com.cn/b/20287408.html
求逆矩阵 例1 image-20200922151824498 image-20200922151837916 例2 image-20200922172625133 image-20200922172640005 例3 image-20200922174724888 image-20200922174737292 矩阵的秩 初等变换前后的矩阵是同型矩阵。</description></item><item><title>线性代数-矩阵1</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/</link><pubDate>Sat, 25 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51/</guid><description>线性代数-矩阵1 矩阵 矩阵的概念 矩阵的定义 \(m \times n\)个数，排成m行n列的表格：(为表示它们是一个整体，总加一个括弧) \(\boldsymbol{A}=\left(\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp;\ddots &amp;amp; \vdots \\ a_{m 1} &amp;amp; a_{m 2} &amp;amp; \cdots &amp;amp; a_{m n}\end{array}\right)\)， 称为一个\(m \times n\)矩阵。简记为A。
实矩阵/复矩阵 元蒙是实数的矩阵称为实矩阵,元素是复数的矩阵称为复矩阵
方阵 当\(m=n\)时，称为n阶矩阵（或n阶方阵）。即行数与列数都等于 \(n\) 的矩阵称为n 阶矩阵或 \(n\) 阶方阵.
方阵的行列式 设\(A=[a_{ij}]\)为n阶矩阵，其所有元素构成的行列式称为方阵A的行列式。记为\(|A|\)。 注1：仅方阵才有行列式 注2：A=0与\(|A|=0\)不要搞混。
零矩阵 如果一个矩阵的所有元素都是0，称这个矩阵为0矩阵。简记为0.
行矩阵/列矩阵 只有一行的矩阵： \(\boldsymbol{A}=\left(a_{1} a_{2} \cdots a_{n}\right)\) 称为行矩阵（又称行向量）
只有一列的矩阵： \(\boldsymbol{B}=\left(\begin{array}{c}b_{1} \\ b_{2} \\ \vdots \\ b_{m}\end{array}\right)\) 称为列矩阵（又称列向量）</description></item><item><title>线性代数-矩阵1习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 25 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E7%9F%A9%E9%98%B51%E4%B9%A0%E9%A2%98/</guid><description>线性代数-矩阵1习题 矩阵的基本运算 主要涉及矩阵加法、数乘、乘法、转置。
矩阵的乘法 矩阵乘法的计算 例1 image-20200921171929520 image-20200921172018763 例2 image-20200921172152544 image-20200921172215029 例3 image-20200921172911518 image-20200921172926683 例4 这题没做出来 image-20200921172950596 image-20200921173003021 例5 image-20200921194558092 image-20200921194609085 矩阵乘法的性质 例1 一般矩阵乘法不可交换 image-20200921172539170 例2 基本消元不成立 image-20200921172656436 image-20200921172703926 image-20200921172722887 image-20200921172735637 image-20200921172748928 求逆矩阵 直接求逆矩阵 二阶：逆矩阵为：行列式分之伴随
高阶：\((A|E) \rightarrow (E | A^-1)\)</description></item><item><title>线性代数-行列式</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</link><pubDate>Mon, 20 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F/</guid><description>线性代数-行列式 行列式 行列式的概念 排列 1个n阶排列是指由\(1,2,...,n\)共n个数构成的一个有序数组。通常用\(j_1,j_2,...j_n\)表示一个n阶排列。
逆序 一个排列中，如果一个大的数排在小的数之前，就称这两个数构成一个逆序。（两个数的逆序）
逆序数 一个排列的逆序总数称为这个排列的逆序数. 用 \(\tau\left(j_{1} j_{2} \cdots j_{n}\right)\) 表示排列 \(j_{1} j_{2} \cdots j_{n}\) 的逆序数。
奇排列与偶排列 如果一个排列的逆序数是偶数，则称这个排列为偶排列，否则称为奇排列.
行列式 行列式是一个数。
对于n阶行列式，有： \(\left|\begin{array}{cccc}a_{11} &amp;amp; a_{12} &amp;amp; \cdots &amp;amp; a_{1 n} \\ a_{21} &amp;amp; a_{22} &amp;amp; \cdots &amp;amp; a_{2 n} \\ \vdots &amp;amp; \vdots &amp;amp; &amp;amp; \vdots \\ a_{n 1} &amp;amp; a_{n 2} &amp;amp; \cdots &amp;amp; a_{nn}\end{array}\right|\) \(=\sum_{j_{1} j_{2} \cdots j_{n}}(-1)^{\tau\left(j_{1} j_{2} \cdots j_{n}\right)} a_{1 j_{1}} a_{2 j_{2}} \cdots a_{n j_{n}}\) \(\sum_{j_{1} j_{2} \cdots j_{n}}\) 表示对所有 \(n\) 阶排列求和,它结果是所有（取自不同行不同列的 n 个元素的乘积再乘以一个\(\pm 1\)）结果的代数和。各项的正负号由排列的逆序数决定。</description></item><item><title>线性代数-行列式习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/</link><pubDate>Mon, 20 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0-%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B9%A0%E9%A2%98/</guid><description>线性代数-行列式习题 行列式的计算 代数余子式的计算 例1 image-20200911221652230 image-20200911221836795 例2 image-20200911232642881 image-20200911232659350 抽象行列式的计算 例1 image-20200911225811869 image-20200911225837139 例2 image-20200911230416735 image-20200911230429298 例3 image-20200911231016396 image-20200911231054693 数值行列式的计算 例1 image-20200911234112887 image-20200911234206440 例2 image-20200912000823836 image-20200912000854139</description></item><item><title>线性代数总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 19 Jul 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E6%80%BB%E7%BB%93/</guid><description>线性代数总结 根据同济线性代数第一版的序言，线性代数本是高等数学第13章，后来提出来单独成书。
线性代数分为6块内容：行列式、矩阵、向量与向量空间、方程组、特征值、二次型。 概念互相渗透，联系紧密。
行列式、矩阵、向量、方程组联系尤为紧密。 向量是研究方程组的解的过程中，提炼抽象出来的。（并提出了向量的相关无关、向量的秩、矩阵的秩的概念） 行列式和矩阵式求解方程组的过程中，提炼的工具。（消元的过程中，无法避免\(ad-bc\)的形式，将其定义为二阶行列式；系数与未知数的相乘并相加，系数提出来更简洁，就成了系数矩阵） 矩阵按列分块，就变成了向量。（解方程组的问题就变成了各列向量能否线性表示b的问题）
二次型的几何意义：空间解析几何的二次曲面。
线性代数的难点和重点：
两难一重 重点一 方程组 有无解？有几个解？如何求解以及参数处理 重点二 特征值、特征向量 \(A\alpha = \lambda \alpha\)，矩阵相似，对角阵相似。综合性强 难点 向量 线性表示、相关无关、秩 线性代数的特点： 1）概念多，定理多，运算法则多，符号多（易混淆） 2）内容上纵横交错，知识前后联系紧密（需要编织知识网络，重视一题多解）（解法灵活多变） 3）逻辑推理要求高（尤其是证明）
向量 概念,运算 线性表示 问\(\alpha_1, \alpha_2 ... \alpha_n\) 能否线性表示\(\beta\),等于问一个非齐次方程组\((\alpha_1, \alpha_2 ... \alpha_n)X=\beta\) 有解没解的问题. 线性相关与无关 线性相关与无关定义 设\(\alpha_1, \alpha_2, ... ,\alpha_n\) 为一组n维向量，如果存在一组不全为0的数\(k_1, k_2, ... , k_s\)，使得\(k_1 \alpha_1 + k_2 \alpha_2 + ... + k_s \alpha_s = 0\) 成立，称向量组\(\alpha_1, \alpha_2, .</description></item><item><title>PAT甲级习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/pat%E4%B9%A0%E9%A2%98/</guid><description>PAT甲级习题 栈的模拟 例1 已知入栈顺序1-N，并给定栈最大容积M。判断出栈顺序是否正确, 以及是否爆栈
题目链接
方法：栈的模拟
由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈。利用这个过程来确定出入栈顺序。
package com.jingmin.advanced2; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Stack; /** * @author : wangjm * @date : 2020/6/26 09:55 * @discription : https://www.nowcoder.com/pat/5/problem/4090 * 已知入栈顺序，判断出栈顺序是否正确, 以及是否爆栈: 栈的模拟 * 由于入栈是固定从1到N的，那么某元素出栈前，比它小的数都应当已经入栈 */ public class Advanced1040 { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); String[] s = br.readLine().split(&amp;#34; &amp;#34;); int m = Integer.parseInt(s[0]); int n = Integer.parseInt(s[1]); int k = Integer.</description></item><item><title>数据结构-栈和队列</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84/</guid><description>栈和队列 image-20200328200545921 栈 基本概念 栈的定义 栈（ Stack）只允许在一端进行插入或删除操作的线性表
后进先出（LIFO）
共享栈的定义 将两个栈底设置在共享空间的两端，栈顶向空间中间延伸
优点：存取时间复杂度仍为O（1），但空间利用更加有效
栈的基本操作 Initstack（&amp;amp;S）：初始化一个空栈S StackEmpty（S）：判断一个栈是否为空，若栈为空则返回true，否则返回 False。 Push（&amp;amp;S,x）：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop（&amp;amp;S，&amp;amp;x）：出栈，若栈非空，则弹出栈顶元素，并用×返回。 GetTop（s，&amp;amp;x）：读栈顶元素，若栈非空则用×返回栈顶元素。 ClearStack（&amp;amp;S）：销毁栈，并释放S占用的内存空间。
存储结构 顺序存储 image-20200328201504762 而对于共享栈：
image-20200328203132531 链式存储 image-20200328203310146 所有的操作都在表头进行。入栈出栈对应于单链表在表头的插入和删除，判空也与单链表相同。
栈的应用 括号匹配 表达式求值 中缀表达式转后缀式1 表达式求值、表达式转二叉树
中缀表达式转后缀表达式主要有两种方法
根据中缀表达式，写出表达式树，然后后序遍历，即得到后缀表达式（去掉括号的输出）。 读取中缀表达式，直接输出操作数，利用栈保存操作符。向栈中保存操作符前，栈中优先级高的操作符要先输出/参与运算。这样得到的输出也是后缀表达式。 例如，中缀表达式a + bc + (d e + f) * g，其转换成后缀表达式则为a b c * + d e * f + g * +。
中缀表达式转换后缀表达式过程：使用栈（保存操作符）的方法，具体过程如下：
如果遇到操作数，我们就直接将其输出（加入到后缀表达式）。 如果遇到操作符，（栈中优先级高的操作符要先输出/参与运算，再把当前操作符入栈） 若为’(’，直接入栈 若为’)‘，则依次把栈中的运算符输出（加入到后缀表达式），直到出现’(‘，并从栈中删除’(’； 注意，左括号只弹出并不输出。 若为’+‘，’-‘，’*‘，’，‘/’ 若高于栈顶元素优先级，或栈空，或栈顶为’(’，直接入栈； 否则，先依次弹出栈顶运算符，直到一个优先级比它低的运算符或’(‘为止; 弹出完这些元素后，才将遇到的操作符压入到栈中。 有一点需要注意，只有在遇到"</description></item><item><title>数据结构-线性表</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid><description>线性表 线性表是一种数据结构，其逻辑结构为线性结构；存储结构（实现）有两种：顺序、链式；对应的运算（操作）也略有不同：顺序表示可以随机访问，链式表示可以随机插入删除
线性表的定义和基本操作 线性表是具有相同类型的n（n&amp;gt;=0）个元素的有限序列，其中n为表长，当n=0时，该表为空表
若L命名为线性表，则一般表示为\(L=\left(a_{1}, a_{2}, \dots, a_{i}, a_{i+1}, \dots, a_{n}\right)\)
线性表的特点 表中元素个数有限
表中元素具有逻辑上的顺序性，在序列中各个元素排序有其先后次序
表中元素都是数据元素，每个元素都是单个元素
表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间
表中元素具有抽象性，即讨论元素间一对一的逻辑关系，而不考虑元素究竟表示的内容
线性表是一种逻辑结构，表示元素之间一对一相邻的关系
线性表的基本操作 9种基本操作：初始化、销毁、增删改查、遍历、是否为空、获取长度
InitList(8L)：初始化表。构造一个空的线性表 DestroyList（&amp;amp;L）：销毁操作。销毁线性表，并释放线性表所占用的内存空间。 LocateElem（L,e)按值查找操作。在表中查找具有给定关键值得元素。 GetELem(L,i) 按位查找操作。获取表中第个位置的元素的值。 Listlnsert(&amp;amp;L,i,e）插入操作。在表中的第个位置上插入指定元素e插 LIstDelete（&amp;amp;L, &amp;amp;e）：删除操作。删除表L中第个位置的元素，并用e返回删除元素的值。 Printlist（L)：输出操作。按前后顺序输出线性表的所有元素值。 Empty（L）：判空操作。若为空表，则返回TRUE否则返回ALSE。 Length（L）：求表长。返回线性表的长度，即L中数据元素的个数。
线性表的顺序表示 顺序表的定义 线性表的顺序存储又称顺序表
一组地址连续存放的存储单元依次存放线性表的元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。
数组静态分配，数组动态分配（使用指针）
顺序表的基本操作 插入、删除、按值查找
线性表的链式表示 线性表的链式存储，简称链表
通过一组任意的存储单元来存储线性表中的数据元素，通过指针实现线性逻辑关系。
单链表 单链表的定义 带头节点的单链表和不带头节点的单链表
image-20200316185925947 带头节点单链表优点： 链表的第一个位置和其他位置的操作统一 空表和非空表的操作统一
单链表的基本操作 建立：头插、尾插
查找：按序号查找&amp;amp;按值查找
插入：按序号查找+插入（前插/后插）
前插与后插的转换：插入前交换节点内容
删除：按序号查找+删除
删除给定节点*p:交换节点内容+删除
表长
双链表 双链表可以看作是：一个带头节点的单链表+另一个不带头节点的单链表；所以其头节点并不能统一操作。
image-20200321134928900 插入
image-20200321135430055 删除
image-20200321135550537 循环链表 循环单链表 统一插入删除操作</description></item><item><title>数据结构与算法的基本概念</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>绪论 数据结构的基本概念 基本概念和术语 image-20200316002505193 数据 信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合
数据对象 具有相同性质的数据元素的集合，是数据的一个子集数据元素数据的基本单位，通常作为一个整体进行考虑和处理
数据项 构成数据元素的不可分割的最小单位
数据类型 数据结构的三要素 数据不是孤立的，他们存在着某种关系，这种相互关系我们叫做结构
数据结构是相互之间存在—种或多种特定关系的数据元素的集合
数据结构三要素：逻辑结构、物理结构、数据的运算
逻辑结构 分为：线性结构、非线性结构（集合、树形结构、图状结构）
与数据间的逻辑有关，与数据在计算机中如何存储无关
物理结构 也称存储结构
数据在计算机中的存储，包括数据元素在计算机中的存储、数据元素间关系的存储
分为：顺序存储、链式存储、索引存储、散列存储
数据的运算 运算（操作）包括运算的定义和实现，运算的定义针对逻辑结构，运算的实现针对存储结构
算法和算法评价 算法的基本概念 算法 对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。
算法的特性：有穷，可行，确定，输入，输出
算法（指导者） 程序（实施者） 解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有很多个算法。 程序是某种程序设计语言对算法的具体实现。 必须有穷 可以无穷 必须正确 可以错误 可以用伪代码，程序语言等描述 只能由程序语言编写并运行 算法效率的度量 好算法的标准 正确性算法应能够正确地解决求解问题
可读性算法应具有良好的可读性，以帮助人们理解
健壮性输入非法数据时，算法能适应的做出反应或进行处理
效率与存储量效率是指算法执行时间，存储量需求是指算法执行过程中所需最大存储空间
时间复杂度 语句频度 该条语句可能重复执行的次数
T(n) 所有语句的频度之和，其中n为问题的规模
时间复杂度 T(n)=O(f(n))，其中O表示T(n)与f(n)在\(n \rightarrow \infty\)时为同阶无穷大。即两者相同数量级。
最坏时间复杂度、最好时间复杂度、平均时间复杂度
加法规则：\(T(n)=T 1(n)+T 2(n)=O(f(n))+O(g(n))=O(\max (f(n), g(n))\)</description></item><item><title>数据结构总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</guid><description>树 二叉树 二叉树搜索树 平衡二叉搜索树（AVL树） 参考：https://zhuanlan.zhihu.com/p/34899732 参考：https://oi-wiki.org/ds/avl/ 参考：https://www.jianshu.com/p/65c90aa1236d 参考：https://blog.csdn.net/wanderlustLee/article/details/81297253
AVL树是，在二叉搜索树的前提下，能保证平衡的树。
AVL树特点 二叉搜索树的特点：对树上的任意节点，其左子树上的值都小于当前节点的值，其右子树上的值都大约当前节点的值 平衡：对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1） AVL树的基本操作/功能 二叉搜索树的操作：插入/删除/搜索，可能还包括找上一个/下一个节点 维持树的平衡 维持树的平衡 平衡条件是什么？ 对树上的任意节点，其左子树高度与右子树高度相差不超过1.（高度差可为-1，0，1）
什么原因会失去平衡，哪些节点会失去平衡？ 假设当前的树已经平衡。当AVL树进行插入/删除操作时，可能造成某些节点左右子树高度的变动，破坏树的平衡。 具体的说，插入/删除位置的祖先节点可能会失去平衡。所以插入删除完成后，需要逆着查找路径，依次维护祖先节点的平衡性。
如何使失去平衡的某个节点恢复平衡？ 我们要做的操作是，调整该节点处的左右子树高度，使其重新平衡。形象的描述就是要进行旋转操作，使其重新平衡。
左旋操作、右旋操作示意图：
img 实际上，一次旋转操作并不能保证使失去平衡的树恢复平衡。
不平衡情况 前面说了插入/删除节点可能导致祖先节点失去平衡。以插入节点为例（删除类似），祖先节点具体会有4种不平衡情况：LL、RR、LR、RL。下面具体说明。
在左孩子的左子树插入节点导致不平衡LL 批注 2020-06-11 144254 这种情况只需在失去平衡的节点Y处，进行一次左旋操作即可。
在右孩子的右子树插入节点导致不平衡RR 批注 2020-06-11 144827 这种情况只需在失去平衡的节点X处，进行一次右旋操作即可。
在左孩子的右子树插入节点导致不平衡LR 批注 2020-06-11 145834 这种情况需在失去平衡的节点的左子节点X处，先进行一次左旋操作，再在当前节点Y进行一次右旋操作即可。
在右孩子的左子树插入节点导致不平衡RL 批注 2020-06-11 150123 这种情况需在失去平衡的节点的右子节点处，先进行一次右旋操作，再在当前节点进行一次左旋操作即可。
java实现：（插入/删除和中序遍历） packagecom.jingmin.datastructure; importjava.util.Scanner; importjava.util.Stack; /** * @author : wangjm * @date : 2020/6/11 16:38 * AVL树(插入/删除操作和中序遍历） * &amp;lt;p&amp;gt; * 参考（过程和逻辑）：https://zhuanlan.</description></item><item><title>树和二叉树</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>树和二叉树 树和森林 树的基本概念 树的定义 树是一种逻辑结构
image-20200410215743659 树是n（n≥0）个结点的有限集合，n=0时，称为空树。
而任意非空树应满足： 1）有且仅有一个特定的称为根的结点。 2）当n&amp;gt;1时，其余结点可分为m（m&amp;gt;0）个互不相交的有限集合，其中每一个集合本身又是一棵树，称为根结点的子树。
树的特点之一：n个结点的树中只有n-1条边
树基本术语 祖先节点和子孙节点
双亲节点和孩子节点
兄弟节点
节点的度：树中一个结点的子结点的个数
树的度：树中最大的节点度数称为树的度
分支结点：度大于0的结点（子节点个数大于0的节点）
叶子结点：度为0的结点
节点的层次：从根节点开始数，根为第一层（也有的教材中定为0层）
节点的高度：节点到叶子节点所有路径上包含节点个数的最大值。
节点的深度：从根节点到该节点唯一的路径上包含的节点个数，根节点深度为1
树的高度（深度）：树中结点的最大层数
有序树和无序树
路径：树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的。路径是有方向的，从上到下；不同兄弟树中节点不存在路径。
路径长度：路径上所经历边的个数。
森林：m（m≥0）棵互不相交的树的集合
树的性质 树中的结点数等于所有结点的度数加1 度为m的树中第层上至多有\(m^{i-1}\)个结点（i≥1） 高度为h的m叉树至多有\((m^h-1)/(m-1)\)个结点(由等比数列前n项和公式获得) 具有n个结点的m叉树的最小高度为\(\left\lceil\log _{\mathrm{m}}(\mathrm{n}(m-1)+1)\right\rceil\)，这是由上一条性质反推出来的 树的存储结构 树和森林的遍历 树和森林及二叉树的转换 树的应用——并查集 二叉树 二叉树的基本概念 定义及特点 二叉树的存储结构 二叉树的遍历 线索二叉树 二叉树的应用 二叉排序树 平衡二叉树 哈夫曼树及哈夫曼编码</description></item><item><title>算法总结</title><link>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</link><pubDate>Thu, 25 Jun 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</guid><description>算法总结 算法 什么是算法 从字面上来说，**算法也就是用于计算的方法。是用来解决某些问题的方法。**通过这个方法，可以达到想要的计算结果。它就像我们小时候学些的一些数学公式和解题步骤。
算法特征 算法，一般有5个特征：
有穷性： 算法的执行步骤、时间、都是有限的。不会无休止的一直执行下去。 确切性： 算法的每一步都必须有明确的定义和描述。 输入： 一个算法应该有相应的输入条件，就像我们小时候做的应用题，已知什么什么。来求某个结果，已知部分便是输入条件。 输出： 算法必须有明确的结果输出。没有结果，那这个算法是没有任何意义的。 可行性： 算法的步骤必须是可行的，无法执行的则没有意义，也解决不了任何问题 算法分类 按照算法的应用来分：算法可以分为基本算法、几何算法、加密/解密算法、查找算法、图表数据分析算法等。 按照算法的思路（思想）来分：算法可以分为递推算法、递归算法、穷举算法、分治算法等。
按算法的应用来划分 基本算法：常规的循环、迭代、递归 递归、循环、迭代、遍历的区别 程序的运行快慢一般与其中重复执行的代码息息相关，而“重复执行”的方式又分为以下4种：
递归：一个函数反复调用自身的行为，特指函数本身； 循环：满足一定条件下，重复执行某些行为，如while结构； 迭代：按某种规则执行一个序列中的每一项，每次执行的结果又作为下次执行的初始值，直到满足某个精度或条件； 递推：由前一项可以推出后一项，是从前面的已知结果推出未知结果。当前一项的结果作为后一项的初始值时，就成了迭代。（有时候和迭代混用） 遍历：按某种规则访问图形结构中每一个节点，特指图形结构。 说明例子：
【递归】
你自己不太了解小孩子的需求，为了缩小范围，让你的儿子去给孙子挑选。儿子比你强点有限，但依然不太了解小孩子的需求。为了缩小范围，你又让你孙子去挑选。如此这般，直到找到合适的玩具。
【循环】
你去小卖铺买了一个玩具，拿回家后孩子不喜欢，你也没问他为什么不喜欢。然后你又去同一个小卖铺买了一个玩具，拿回家后孩子又不喜欢。。。如此往复 10 次，孩子才满意。
每次去买玩具的目标、行为都一样，这叫循环。
【迭代】
你去小卖铺买了个一个玩具，拿回家后孩子不喜欢。你耐心的询问后得知他喜欢乐高的玩具，于是你就去大超市给他买了乐高，回家后孩子还是不喜欢，耐心询问后得知他喜欢乐高玩具中最贵的那个玩具，于是你就去奢侈品商店给他买了乐高限量版玩具，拿回家后孩子很满意。
每次去买玩具都跟上一次不一样，或是有了新的目标，或是缩小了搜寻范围，这叫迭代。
来源：CyrusCao_知乎_https://www.zhihu.com/question/20278387/answer/109266159
递归、迭代、循环常常可以转换，且转换后程序的效率不一定相同。递归由于效率低的问题，经常要求转换成循环结构的非递归形式。
递归、分治策略、动态规划以及贪心算法之间的关系
最大公因数 辗转相减法是一种简便的求出两数最大公约数的方法。由其可推出辗转相除法。
辗转相除法求两正整数的迭代次数较少。
辗转相除,使余数消失的那个除数就是最大公因数
算法流程 gcb(m,n): m&amp;gt;n, r 是 m ÷ n 的余数， 若r不为0， 继续gcd(n,r); 若r为0，则n是最大公因数
递归法 int divisor(int m,int n) { if (m % n == 0) { return n; } else { return divisor(n,m % n); } } 迭代法 public static int gcd(int a,int b){ //如果相等 if(a==b){ return a; } //保证大数除以小数 int l,x=a,y=b; if(a&amp;gt;b){ x=b; y=a; } //迭代出现余数为0 while((l=(y%x))!</description></item><item><title>高等数学-多元微积分-曲线积分与曲面积分习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 25 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-多元微积分-曲线积分与曲面积分习题 对弧长的曲线积分 平面上对弧长的曲线积分 定积分法计算曲线积分 例1 image-20200908161927973 image-20200908161943734 例2 image-20200909080136016 image-20200909080148446 image-20200909080204906 本题也可以利用奇偶对称性消去积分中的\(2xy\)项，并把曲线表示为$x=t , y = t $的参数方程来做。
例3 image-20200909104603162 image-20200909104617370 奇偶性对称性计算曲线积分 例1 image-20200908170857630 image-20200908170909878 替换法计算曲线积分 例1 image-20200909081222333 image-20200909081239333 空间中对弧长的曲线积分 奇偶性对称性计算曲线积分 例1 image-20200909082742684 image-20200909082815350 对坐标的曲线积分 平面上对坐标的曲线积分 定积分法计算曲线积分 例1 image-20200908173101430 image-20200908173046204 例2 image-20200908183019048 image-20200908183030996 例3 image-20200909084520590 image-20200909084540456 此题也可以用（格林公式法）将平面上的曲线积分转换为二重积分的方法来做。</description></item><item><title>高等数学-多元微积分-曲线积分与曲面积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</link><pubDate>Mon, 20 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86%E4%B8%8E%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86/</guid><description>高等数学-多元微积分-曲线积分与曲面积分 定积分的积分范围是数轴上的一个区间（线状）； 二重积分的积分范围是平面内的一个闭区域（面状）； 三重积分的积分范围是空间内的一个闭区域（体状）； 本章将积分范围推广到平面以及空间内的一段曲线弧（曲线积分）； 还将积分范围推广到空间内的一片曲面（曲面积分）；
积分域 积分号 举例 线状 \(\int\) 定积分\(\int_a^b f(x)dx\)
曲线积分\(\int_L\) 面状 \(\iint\) 二重积分\(\iint_D f(x,y) d\sigma\)
曲面积分\(\iint_\Sigma\) 体状 \(\iiint\) 三重积分\(\iiint_\Omega f(x,y,z) dv\) 研究/学习过程： 研究背景 -&amp;gt; 抽象（积分种类） -&amp;gt; 性质 -&amp;gt; 计算 -&amp;gt; 应用
对弧长的曲线积分（第一类曲线积分） 背景 空间曲线的质量问题
元素法： \(\forall ds \in L\) \(dm = \rho(x,y)ds\) \(m=\int_L dm = \int_L \rho(x,y) ds\)
这里积分是在L上积分，不是上下限； 这里是\(ds\)不是\(dx\); 所以这是一种新的积分类型
抽象（对弧长的曲线积分概念） \(\int_L f(x,y)ds\)称为\(f(x,y)\)在平面内的曲线段L上对弧长的曲线积分。 \(\int_L f(x,y,z)ds\)称为\(f(x,y,z)\)在空间曲线段L上对弧长的曲线积分。</description></item><item><title>高等数学-多元积分学-重积分习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 15 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-多元积分学-重积分习题 考察重积分的定义与性质 考察重积分的定义 例1 image-20200807112011942 image-20200807111955188 例2 image-20200807112421044 image-20200807112433583 考察重积分的性质 考察积分区域对称性与被积函数奇偶性 例1 image-20200807113457486 image-20200807113437559 例2 这道题凑了另一半出来，就比较有灵性了 image-20200808095110758 image-20200808095127225 例3 关于y=x对称的一道题 image-20200809111942648 image-20200809111926326 考察二重积分的中值定理 例1 image-20200808165259530 image-20200808165348010 重积分比较大小 例1 image-20200808201135688 image-20200808201208106 重积分的计算 变换积分次序 不变换积分次序无法计算的情形： \(x^{2 n} e^{\pm x^{2}} d x\) \(e^{\frac{1}{x}} d x\) \(\sin \frac{1}{x} d x\) \(\cos \frac{1}{x} d x\)</description></item><item><title>高等数学-多元积分学-重积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/</link><pubDate>Sun, 12 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E9%87%8D%E7%A7%AF%E5%88%86/</guid><description>高等数学-多元积分学-重积分 由一元函数积分学我们知道，定积分是某种形式的和的极限。这种和的极限的概念推广到定义在区域、曲线、曲面上的多元函数的情形，就得到了重积分、曲线积分以及曲面积分的概念。
二重积分的概念与性质 二重积分概念的引入 曲顶柱体的体积 对于平顶柱体体积：体积 = 高 \(\times\) 底面积
对于曲顶柱体，需要将底面（区域）划分为足够小的区域，用极限理论来讨论。
image-20200804162655119 首先,用一组曲线网把 区域D 分成 n 个小闭区域\(\Delta \sigma_{1}, \Delta \sigma_{2}, \cdots, \Delta \sigma_{n}\). 则曲顶柱体可以看作是以小闭区域为底面的小曲顶柱体组成的。
\(f(x, y)\) 连续,对于一个很小的小闭区域\(\Delta \sigma_{i}\)来说 \(, f(x, y)\) 变化很小,我们可以近似看作小平顶柱体。 从\(\Delta \sigma_{i}\)中任取一点\(\left(\xi_{i}, \eta_{i}\right),\) 以 \(f\left(\xi_{i}, \eta_{i}\right)\) 为高而底面积为\(\Delta \sigma_{i}\)的体积为\(f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i} \quad(i=1,2, \cdots, n)\) 则这n个小平顶柱体的总体积为\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)，即原曲顶柱体的体积近似为\(\sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)。 当这n个小闭区域的直径的最大值（记作\(\lambda\)）趋于0时，取上述和的极限，所得极限自然的定义为曲顶柱面的体积\(V=\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}, \eta_{i}\right) \Delta \sigma_{i}\)
注：闭区域的直径指区域上任意两点的最大距离。
平面薄片的质量 对于均匀薄片（ 面密度是常数），质量为：质量=面密度 \(\times\) 面积</description></item><item><title>高等数学-多元微分学习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 08 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6%E4%B9%A0%E9%A2%98/</guid><description>高等数学-多元微分学习题 考察多元函数定义、极限存在、连续性、可微、可偏导、泰勒定理 多元函数的定义 例1 image-20200702122423759 例2 image-20200702122611230 偏导数的定义 偏导数是把多元函数其中一元看作变量，其他元看作常数后，求函数的变化率（求导）
例1 image-20200709144415604 image-20200709144432350 例2 image-20200710163615194 image-20200710163631402 例3 image-20200710231400530 image-20200710231418304 image-20200710231429789 例4 image-20200711000314135 image-20200711000327726 image-20200711000344744 例5 image-20200713145337218 例6 image-20200713145652539 image-20200713145725465 例7 image-20200713162205205 image-20200713162250977 极值的定义 例1 image-20200710232139022 image-20200710232158542 例2 image-20200713175333243 例3 image-20200713180142424 image-20200713180435932 例4 image-20200714171451504 连续不一定可偏导，可偏导不一定连续 例1 连续不一定可偏导，可偏导不一定连续 image-20200711093916297 image-20200711093943298 可微必连续 例1 证明可微必连续 可微必可导 例1 证明可微必可偏导 求证：如果函数 \(z=f(x, y)\) 在点 \((x, y)\) 可微分,那么该函数在点\((x, y)\) 的偏导数 \(\frac{\partial z}{\partial x}\) 与 \(\frac{\partial z}{\partial y}\) 必定存在 \(,\) 且函数 \(z=f(x, y)\) 在点 \((x, y)\) 的全微分为\(\mathrm{d} z=\frac{\partial z}{\partial x} \Delta x+\frac{\partial z}{\partial y} \Delta y\)</description></item><item><title>高等数学-多元微积分-多元微分学-向量值函数和向量分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/</link><pubDate>Mon, 06 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8E%E5%90%91%E9%87%8F%E5%88%86%E6%9E%90/</guid><description>高等数学-多元微积分-多元微分学-向量值函数和向量分析 一元向量值函数 \(f: D \rightarrow \mathbf{R}^{n}\) 一元向量值函数定义 定义 设数集 \(D\subset R\),则称映射 \(f: D \rightarrow \mathbf{R}^{n}\) 为一元向量值函数, 通常记为\(\boldsymbol{r}=\boldsymbol{f}(t), t \in D\) 其中数集 D 称为函数的定义域, , t称为自变量, \(\boldsymbol{r}\) 称为因变量.
例子：空间解析几何的参数方程形式，就是向量值函数
空间曲线\(\Gamma\)的参数方程就是一个一元向量值函数， \(\left\{\begin{array}{l}x=\varphi(t) \\ y=\psi(t), \quad t \in[\alpha, \beta] \\ z=\omega(t)\end{array}\right.\) 也可以写成向量形式： \(\boldsymbol{r}=x \boldsymbol{i}+y \boldsymbol{j}+z \boldsymbol{k}, \quad \boldsymbol{f}(t)=\varphi(t) \boldsymbol{i}+\psi(t) \boldsymbol{j}+\omega(t) \boldsymbol{k}\) 简记为向量方程： \(\boldsymbol{r}=\boldsymbol{f}(t), t \in[\alpha, \boldsymbol{\beta}]\)
一元向量值函数的极限 定义 2 设向量值函数 \(f(t)\) 在点 \(t_{0}\) 的某一去心邻域内有定义,如果存在一 个常向量 \(\boldsymbol{r}_{0},\) 对于任意给定的正数 \(\varepsilon,\) 总存在正数 \(\delta,\) 使得当 \(t\) 满足 \(0&amp;lt;\left|t-t_{0}\right|&amp;lt;\delta\)时，对应的函数值 \(\boldsymbol{f}(t)\) 都满足不等式\(\left|\boldsymbol{f}(t)-\boldsymbol{r}_{0}\right|&amp;lt;\varepsilon\), 那么,常向量 \(\boldsymbol{r}_{0},\) 就叫做向量值函数 \(\boldsymbol {f(t)}\) 当 \(t \rightarrow t_{0}\) 时的极限 \(,\) 记作\(\lim _{t \rightarrow t_{0}} \boldsymbol f(t)=\boldsymbol r_{0} \quad\) 或 \(\quad \boldsymbol{f}(t) \rightarrow \boldsymbol{r}_{0}, l \rightarrow t_{0}\)</description></item><item><title>高等数学-多元微分学-代数应用：多元函数的极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/</link><pubDate>Sun, 05 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%BB%A3%E6%95%B0%E5%BA%94%E7%94%A8%E6%9E%81%E5%80%BC%E4%B8%8E%E6%9C%80%E5%80%BC/</guid><description>高等数学-多元微分学-代数应用：多元函数的极值与最值 代数应用：多元函数的极值 极值/最值问题，其实就是最优化问题。
注意：极值问题，可能取值的的位置，包括驻点、不可导点、边界点。
无条件极值的定义域为开区域，考虑的是定义域内的驻点是否取极值。 条件极值多了约束，考虑的是有约束的情况下是否取极值。（如果约束正好是对应无条件极值的边界，则条件极值考虑的是边界点是否取极值）
例如求 \(f(x, y)\) 在区域 \(D=\left\{(x, y) \mid x^{2}+4 y^{2} \leqslant 4\right\}\) 上的极值/最值。 可以拆成两部分来求： 在区域 \(D_1=\left\{(x, y) \mid x^{2}+4 y^{2} &amp;lt; 4\right\}\) 上找到所有的驻点判断是否取极值（求非条件极值） 在区域 \(D_2=\left\{(x, y) \mid x^{2}+4 y^{2} = 4\right\}\) 上，即给定约束\(x^{2}+4 y^{2} = 4\)的条件下，求函数的极值（求条件极值）
实际问题中，很多问题只在开区域内取最值，这个时候，可以不考虑在边界上取极值的情况（不用考虑条件极值）
多元函数极值的概念 一元函数 多元函数 极值的定义 函数\(f(x)\)在\(x_0\)的某邻域内有定义，对于该邻域内的任意点x，恒有\(f(x)&amp;gt;f(x_0)\),称\(f(x_0)\)为极小值。若邻域内任意点，恒有\(f(x&amp;lt;f(x_0)\),称\(f(x_0)\)为极大值。 设函数 \(z=f(x, y)\) 在 \(P\left(x_{0}, y_{0}\right)\) 点的某邻域内有定义,如果对于该邻城内异于 \(P\left(x_{0},y_{0}\right)\) 点的任一点 \(Q(x, y),\) 恒有\(f(x, y)&amp;gt;f\left(x_{0}, y_{0}\right) \quad\left(\text { 或 } f(x, y)&amp;lt;f\left(x_{0}, y_{0}\right)\right)\)，则称 \(f\left(x_{0}, y_{0}\right)\) 为 \(f(x, y)\) 的极小值(或极大值) ， 极大值与极小值统称极值.</description></item><item><title>高等数学-多元微分学</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</link><pubDate>Fri, 03 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E5%A4%9A%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/</guid><description>高等数学-多元微分学 极限、连续性、偏导数、全微分定义及性质 多元函数是有多个自由变量的函数，在其上可以定义距离的概念。可以考虑函数的极限、连续性、可导可微性。
多元函数的极限 以二元函数为例，\(\lim _{x \rightarrow x_{0} \atop y \rightarrow y_{0}} f(x, y)=A \Leftrightarrow \forall \varepsilon&amp;gt;0, \exists \delta&amp;gt;0,\) 当 \(0&amp;lt;\sqrt{\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}}&amp;lt;\delta\) 时，恒有 \(\quad|f(x, y)-A|&amp;lt;\varepsilon\)
极限性质 一元函数 多元函数 定理 极限\(\lim _{x \rightarrow x_{0}} f(x)=A\) \(\Leftrightarrow\) \(f\left(x_{0}^{-}\right)=f\left(x_{0}^{+}\right)=A\) 极限\(\lim _{x \rightarrow x_{0} \atop y \rightarrow y_{0}} f(x, y)=A\)存在，\(\Rightarrow\) 从各路径趋于\((x_0,y_0)\)的函数值\(f(x,y)\)都等于A；
逆否命题也成立：若存在两条路径取得的极限值不同，则极限不存在 不相同 极限运算法则 有理运算、复合运算 有理运算、复合运算 相同 性质 保号性、夹逼性、局部有界性、极限和无穷小的关系 保号性、夹逼性、局部有界性、极限和无穷小的关系 相同 多元函数证明极限存在，只能通过极限定义证明。多元函数证明极限不存在，可选两条路径证明趋于\((x_0, y_0)\)时函数值\(f(x,y)\)不相等。</description></item><item><title>高等数学-多元微积分概述</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/</link><pubDate>Fri, 03 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%A4%9A%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%8C%83%E5%9B%B4/</guid><description>高等数学-多元微积分概述 参考：维基百科：多元微积分 参考：维基百科：向量分析
多元函数 多元函数是指定义域为\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)或其一部分，值域为\(\displaystyle \scriptstyle \mathbb {R}\)或\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)}的函数。第二种情况可归结为第一种情况，因为它实际上可看成\(\displaystyle m\)个定义在\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)上，值域是$ \(的坐标函数。这样的函数让定义域中的每个元素（即[*n*元组](https://zh.wikipedia.org/wiki/多元组)\)x=(x_{1},x_{2},,x_{n})\(）对应唯一一个值域中的元素，记为\)f(x)\(或\)f(x_{1},x_{2},,x_{n})$，如下所示：
\(\displaystyle f\colon {\begin{array}{rcl}E&amp;amp;\longrightarrow &amp;amp;F\\(x_{1},\ldots ,x_{n})&amp;amp;\longmapsto &amp;amp;f(x_{1},\ldots ,x_{n})\end{array}}\)
如果线性空间\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)和\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)上赋有范数，就可以研究这种多元函数的连续性和可微性。如果固定除一个变量外的其他变量，多元函数的研究就可归结为值域是\(\displaystyle \scriptstyle \mathbb {R} ^{m}\)的函数。如果分别考虑坐标函数的话，甚至可归结为值域是$ $的函数。比如，这种函数的导数存在的话，就称为原来多元函数的偏导数。
多元函数的分析 数学分析中的经典概念可以推广到多元函数，但也要引入线性代数中的概念。
极限与连续性 主条目：函数极限和连续函数
设\(\displaystyle E\)是\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)中的一个开集，\(\displaystyle f\)是定义在\(\displaystyle E\)上的函数。给\(\displaystyle \scriptstyle \mathbb {R} ^{n}\)赋予一个范数之后，就可以这样定义连续性：对\(\displaystyle E\)中的每个点\(\displaystyle a\)，\(\displaystyle f\)在\(\displaystyle a\)处连续当且仅当
在多元微积分领域，对函数极限和连续性的研究可导致许多违反直觉的结果。例如，一些二元标量函数，当\(\displaystyle x\)，\(\displaystyle y\)沿不同路径（例如直线与抛物线）趋近于极限点时，函数的值不同。[1]:19-22例如，函数
沿任何直线 \(\displaystyle y=kx\) 趋近于原点 \(\displaystyle (0,0)\) 时，f趋近于0。然而，当变量x，y沿抛物线 \(\displaystyle y=x^{2}\) 趋近于原点时，f趋近于0.</description></item><item><title>高等数学-向量代数与空间解析几何</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</link><pubDate>Wed, 01 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95/</guid><description>高等数学-向量代数与空间解析几何 这里先引进向量的概念,根据向量的线性运算建立空间坐标系,然后利用坐标讨论向量的运算；并介绍空间解析几何的有关内容。
在平面解析几何中,通过坐标法把平面上的点与一对有次序的数对应起来，把平面上的图形和方程对应起来,从而可以用代数方法来研究几何问题. 空间解析几何也是按照类似的方法建立起来的.通过坐标法把空间中的点与一对有次序的数对应起来，把空间里的图形和方程对应起来,从而可以用代数方法来研究几何问题.
向量及向量代数理论 向量的基本概念与定义（几何刻画） 向量/矢量：有大小、有方向的量。分为自由向量与非自由向量。数学中研究自由向量。z 向量的表示：一般用带方向的线段表示。一般记为\(\boldsymbol a, \vec{a}, \vec{AB}\)
自由向量：与起点位置无关的向量。数学研究自由向量（而速度等物理量，和位置有关，不属于自由向量）
向量相等：如果两个向量\(\vec{a}\)与\(\vec{b}\)大小相等、且方向相同，称这两个向量相等。
向量的模：向量的大小叫做向量的模。向量\(\vec{AB} , a\) 和 \(\vec{a}\) 的模依次记作 \(|\overrightarrow{A B}|,|\boldsymbol a|\) 和 \(|\vec{a}|\)
单位向量：模为1的向量称为单位向量。
向量的夹角：设有两个非零向置 \(a, b,\) 任取空间一点 \(O,\)作 \(\overline{O A}=a, \overline{O B}=b,\) 规定不超过 \(\pi\) 的 \(\angle A O B\) ( 设 \(\varphi=\angle A O B, 0 \leqslant \varphi \leqslant \pi)\) 称为向量 \(a\) 与 \(b\) 的夹角。记作 \(\hat{(\boldsymbol{a}, \boldsymbol{b})}\) 或 \(\hat{(\boldsymbol{b}, \boldsymbol{a})},\) 即 \(\hat{(\boldsymbol{a}, \boldsymbol{b})}=\varphi\)
image-20200831202837187 向量共线/向量平行：若两个向量的起点放到一起时，当它们的终点和公共起点在一条直线上，称这两个向量共线。两平行向量一定共线，两向量共线也一定平行，两个概念等同。
向量共面：设有\(k(k\ge 3)\)个向量，当它们的起点放在一起时，如果k个终点和它们的公共起点在同一平面上，就称这k个向量共面。</description></item><item><title>高等数学-向量代数与空间解析几何习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 01 Apr 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%90%91%E9%87%8F%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95%E4%B9%A0%E9%A2%98/</guid><description>高等数学-向量代数与空间解析几何习题 向量概念的考察 向量 例1 image-20200905184450689 image-20200905184511797 或者根据交点到两边的对称点的两个向量是两个大小相等、方向相反的向量来做。
夹角余弦 例1 image-20200905174929818 image-20200905174845185 例2 image-20200906093626296 image-20200906093637707 向量的数量积 例1 image-20200905233247357 image-20200905233302354 向量的向量积 例1 image-20200906094519793 image-20200906094504383 向量的混合积 例1 image-20200906103157596 image-20200906103051483 两直线共面，混合积为0
空间平面 例1 image-20200905175405890 image-20200905175426305 image-20200905175444606 例2 image-20200905183510586 image-20200905183529769 此题也可用过直线的平面束的方法来做。</description></item><item><title>高等数学-微分方程</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</link><pubDate>Sat, 28 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/</guid><description>高等数学-微分方程 许多问题中，往往不能直接给出所需要的函数关系，看是根据问题所提供的情况，有时可以列出含有要找的函数及其导数的关系式。这样的关系式就是微分方程。
微分方程建立后，对它进行研究，找出未知函数来，这就是解微分方程。
微分方程的基本概念 微分方程 微分方程：含有自变量、未知函数以及未知函数导数或微分的方程。
常微分方程：未知函数是一元函数的微分方程。
常微分方程一般形式：\(F\left(x, y, y^{\prime}, \cdots * y^{(n)}\right)=0\)
常微分方程标准形式（可解出最高阶导数）：\(y^{(n)}=f\left(x, y, y^{\prime}, \cdots, y^{(n-1)}\right)\)
微分方程的阶：微分方程中所出现的未知函数的最高阶导数的阶数。
微分方程的解：建立微分方程后，找出满足微分方程的函数，这个函数代入微分方程能使该方程成为恒等式，这个函数就叫做微分方程的解。
微分方程的通解：如果微分方程的解中含有任意常数，且任意常数的个数与微分方程的阶数相同，这样的解叫做微分方程的通解。
微分方程的初值条件（定解条件）：根据实际情况给定的条件，用来确定微分方程的通解中的任意常数。
微分方程的特解：确定了通解中的任意常数后，就得到了微分方程的特解。
微分方程的积分曲线：微分方程的解\(y=y(x)\)所表示的曲线。
一阶微分方程\(y^{\prime}=f(x, y)\)及解法 一阶微分方程标准形式\(\frac{dy}{dx} = P(x,y)\)
利用变量代换（因变量的变量代换或者自变量的变量代换）把一个微分方程化为变量可分离的方程，或者化为已知求解步骤的方程，这是解微分方程最常用的方法。
一阶微分方程中，可解的方程有： 可分离变量的微分方程、 齐次微分方程、 线性微分方程、 非线性微分方程中的伯努利方程
一阶的微分方程中，一般的非线性微分方程不可解。
可分离变量的一阶微分方程 可分离变量的一阶微分方程：某些一阶微分方程可以化成即微分方程一端只含x和\(dx\)，另一端只含y和\(dy\)
的形式。如\(\frac{dy}{dx} = P(x)Q(y)\)，或者\(g(y) \mathrm{d} y=f(x) \mathrm{d} x\)。
对于可分离变量的一阶微分方程，分离变量后，两边取积分即可求得原方程得通解。
分离变量法是求解微分方程的根本方法。
一阶[x与y齐次]微分方程 注：请注意微分方程中齐次的不同意义
齐次方程 如果一阶微分方程可以写成\(\frac{\mathrm{d} y}{\mathrm{d} x}=\varphi\left(\frac{y}{x}\right)\)，是x与y齐次的一阶微分方程，简称齐次方程。
求解x与y齐次的一阶微分方程，方法是作变量代换\(u=\frac{y}{x}\)，则\(y=ux, \frac{dy}{dx}=x \frac{du}{dx} + u\)。 代入原方程得\(u+x \frac{\mathrm{d} u}{\mathrm{d} x}=\varphi(u)\)。 这是一个可分离变量的一阶微分方程，分离变量得 \(\frac{\mathrm{d} u}{\varphi(u)-u}=\frac{\mathrm{d} x}{x}\)，两边取积分可求得原方程通解。
可化为齐次的方程 1）对于方程\(\frac{\mathrm{d} Y}{\mathrm{d} X}=\frac{a X+b Y}{a_{1} X+b_{1} Y}\)，自然可化为齐次方程。</description></item><item><title>高等数学-微分方程习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/</link><pubDate>Sat, 28 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E4%B9%A0%E9%A2%98/</guid><description>高等数学-微分方程习题 解一阶微分方程 解可分离变量微分方程 例1 image-20200729145702745 image-20200729145847968 例2 image-20200729152157020 image-20200729152211540 例3 image-20200730091430224 image-20200730091506205 例4 image-20200730092154090 image-20200730092238167 例5 image-20200730103034490 image-20200730103046475 例6 image-20200730173038743 image-20200730173051788 例7 image-20200730181328524 image-20200730181343137 例8 image-20200731150442991 image-20200731150502652 image-20200731150513764 例9 image-20200731172127318 image-20200731172139952 例10 image-20200801184321854 image-20200801184336764 例11 image-20200802071647351 image-20200802071702160 解齐次方程 齐次方程，这里指一阶[y与x齐次]微分方程</description></item><item><title>高等数学-一元积分学-定积分的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/</link><pubDate>Wed, 25 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8/</guid><description>高等数学-一元积分学-定积分的应用 几何应用 image-20200501180543268 面积 直角坐标系中\(L : y=f(x) \geqslant 0 \quad(a \leq x \leq b)\) image-20200501175849500 \(A=\int_{a}^{b} f(x) d x\)
极坐标系中\(L: r=r(\theta) \quad(\alpha \leq 0 \leq \beta)\) image-20200501175959748 取\([\theta,\theta+d \theta] \subset[\alpha, \beta]\), \(d A=\frac{1}{2} r^{2}(\theta) d \theta\) \(A=\frac{1}{2} \int_{\alpha}^{\beta} r^{2}(\theta) d \theta\)
image-20200501180100016 \(A=\frac{1}{2} \int_{\alpha}^{\beta}\left[r_{2}^{2}(\theta)-r_{1}^{2}(\theta)\right] d \theta\)
旋转体表面积 image-20200501180617690 取\([x, x+d x]&amp;lt;[a, b]\), \(d A=2 \pi | f(x) | \cdot d s\) \(2 \pi \cdot | f(x) | \cdot \sqrt{\left.</description></item><item><title>高等数学-一元积分学-定积分的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/</link><pubDate>Wed, 25 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E7%9A%84%E5%BA%94%E7%94%A8%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元积分学-定积分的应用 几何应用 求面积体积 例1 image-20200502000848670 \(L : y=\sqrt{x-1}\) 1) 求曲线上的切线,且该切线过原点 2) 求曲线、切线、x轴所夹图形的面积 3) 所夹图形绕x轴旋转一周形成的图形的体积
image-20200502000955372 image-20200502001142899 image-20200502001349125 image-20200502001514639 例2 1)求摆线第一拱的面积 2)摆线第一拱绕x轴旋转一周形成图形的体积
image-20200502004215531 image-20200502004300550 image-20200502004519452 image-20200502004640486 例3 image-20200502004746608 例4 image-20200502004851139 例5 image-20200503162329535 image-20200503162400622 image-20200503162436990 例6 image-20200503195524460 image-20200503195656893 例7 image-20200503202823319 image-20200503204103337 image-20200503204145282 例8 image-20200503224911756 image-20200503225229388 例9 image-20200503225926801 例10 image-20200505175756028 image-20200505175743687 例11 image-20200505220808540 image-20200505220740301 例12 image-20200505222551355 image-20200505222532742 例13 image-20200508223637226 image-20200508223731369 image-20200508223619295 例14 image-20200508225342070 image-20200508225327824 例15 image-20200508230030524 image-20200508230005684 例16 image-20200508231241231 image-20200508231226651 例17 image-20200511135002879 image-20200511134940465 例18 image-20200511140558087 image-20200511140533596 例19 image-20200511150208005 image-20200511150230262 例20 image-20200511154214348 image-20200511154233324 例21 image-20200511165911131 image-20200511165855226 例22 image-20200511171329849 image-20200511171306058 例23 image-20200511172027585 image-20200511171955794 image-20200511172010771 例24 image-20200511180658728 image-20200511180730657 例25 image-20200511201758979 image-20200511201827919 例26 image-20200511212157990 image-20200511212214391 例27 image-20200511213746835 image-20200511213728683 已知面积条件求函数或参数 例1 image-20200511152811348 image-20200511152822324 image-20200511152738831 image-20200511152751831 例2 image-20200511160232884 image-20200511160158563 例3 image-20200511205203321 image-20200511205144609 例4 image-20200511211758884 image-20200511211738785 物理应用 质心问题 例1 image-20200504002911771 image-20200504002943464 image-20200504003010939 image-20200504003034119 引力问题 例1 image-20200504003745942 做功问题 反抗重力做功 例1 image-20200504082553773 image-20200504082612752 例2 image-20200511215504230 image-20200511215447367 例3 image-20200511215753755 image-20200511215735083 image-20200511215724062 克服阻力做功 假设匀速做功</description></item><item><title>高等数学-一元积分学-定积分与反常积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</link><pubDate>Sun, 22 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86/</guid><description>高等数学-一元积分学-定积分与反常积分 定积分 定积分概念 函数\(f(x)\)在[a,b]有定义且有界，分割为\(\Delta x_i\)小段，每段上取点\(\xi_i\)处函数值作乘积\(f\left(\xi_{i}\right) \Delta x_{i}\)，求和取极限\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}\)，其中\(\lambda=\max _{1 \leq i \leq n}\left|\Delta x_{i}\right|\)
如果上述极限存在，则称\(f(x)\)在[a,b]上可积，并称上述极限为\(f(x)\)在[a,b]上的定积分，记为\(\lim _{\lambda \rightarrow 0} \sum_{i=1}^{n} f\left(\xi_{i}\right) \Delta x_{i}=\int_{a}^{b} f(x) \mathrm{d} x\)
（有界是可积的必要条件）
定积分和原函数存在的判定 定积分存在定理 \(f(x)\)在[a,b]上连续，则定积分\(\int_{a}^{b} f(x) \mathrm{d} x\)存在
\(f(x)\)在[a,b]上有界，且只有有限个间断点，则定积分\(\int_{a}^{b} f(x) \mathrm{d} x\)存在（一般可以看作多个连续的定积分相加）
原函数存在定理 \(f(x)\)在[a,b]上连续，则原函数存在
注：如果\(f(x)\)不连续，则原函数存在与否与定积分\(\int_{a}^{b} f(x) \mathrm{d} x\)存在与否不相关
牛顿-莱布尼兹定理 由前面定理\(f(x)\)在[a,b]上连续，则原函数存在，定积分存在。
若\(f(x)\)在[a,b]上连续，\(F(x)\)是\(f(x)\)的一个原函数，则\(\int_{a}^{b} f(x) \mathrm{d} x=\left.F(x)\right|_{a} ^{b}=F(b)-F(a)\)，这个关系叫做牛顿-莱布尼兹公式
证明:
定积分性质 以下均设\(f(x)\)与\(g(x)\)可积
四则与上下限 \(\int_{a}^{b} f(x) \mathrm{d} x=-\int_{b}^{a} f(x) \mathrm{d} x\)
\(\int_{a}^{a} f(x) \mathrm{d} x=0\)</description></item><item><title>高等数学-一元积分学-定积分与反常积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 22 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%B9%BF%E4%B9%89%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元积分学-定积分与反常积分 定积分与积分函数 求定积分 分部积分法求定积分 例1 image-20200505174539033 image-20200505174520659 例2 image-20200505203737772 image-20200505203716425 例3 image-20200505213436150 image-20200505213413514 例4 image-20200509233644000 image-20200509233627415 image-20200509234405371 例5 image-20200510013419787 image-20200510013359350 例6 image-20200510133450231 image-20200510133334263 例7 image-20200510134044574 image-20200510134017639 image-20200510134028330 例8 image-20200510134425063 image-20200510134414384 换元法求定积分 常规换元法 例1 image-20200501093018919 例2 image-20200505120232614 image-20200505120213021 例3 image-20200505173436928 image-20200505173420100 例4 image-20200505174839095 image-20200505174820131 例5 image-20200507205407235 image-20200507205342154 image-20200507205356908 例6 image-20200509125408300 image-20200509125353858 例7 image-20200509180150947 image-20200509180132634 例8 image-20200509184235605 image-20200509184250679 例9 image-20200509190730467 image-20200509190710787 例10 image-20200509234556966 image-20200509234539465 例11 image-20200510012658277 image-20200510012645336 例12 image-20200510013936696 image-20200510013913701 例13 image-20200510145312859 image-20200510145250432 例14 image-20200510191658265 image-20200510191637402 例15 image-20200802220310984 解：换元法：\(设t=e^{-2x}\)，然后设\(u=\sqrt{1-t}\)求解</description></item><item><title>高等数学-一元积分学-不定积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</link><pubDate>Fri, 20 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/</guid><description>高等数学-一元积分学-不定积分 不定积分 概念与性质 原函数 原函数：如果\(F^{\prime}(x)=f(x)\)，则\(F(x)\)是\(f(x)\)的原函数。
如果\(f(x)\)存在原函数，则存在无穷多个原函数，且任意两个原函数相差常数。
原函数存在定理：连续函数一定存在原函数
不定积分 不定积分，即一个函数的原函数，包括它的所有原函数，即\(\int f(x) d x=F(x)+c\)
不定积分性质 以下在\(f(x)\)连续的前提下
\(\left(\int f(x) \mathrm{d} x\right)^{\prime}=f(x) ; \mathrm{d} \int f(x) \mathrm{d} x=f(x) \mathrm{d} x\)
\(\int f^{\prime}(x) \mathrm{d} x=f(x)+C_{;} \int \mathrm{d} f(x)=f(x)+C\)
\(\int(f(x) \pm g(x)) \mathrm{d} x=\int f(x) \mathrm{d} x \pm \int g(x) \mathrm{d} x\)
\(\int k f(x) \mathrm{d} x=k \int f(x) \mathrm{d} x,\) 常数 \(k \neq 0\)
不定积分工具 基本公式 \(\int k d x=k x+C\)
\(\int x^{a} d x=\left\{\begin{array}{ll} \frac{1}{a+1} \cdot x ^{a+1} &amp;amp; ,&amp;amp; a\neq -1\\ \ln |x|+c &amp;amp; , &amp;amp; a=-1\end{array}\right.</description></item><item><title>高等数学-一元积分学-不定积分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 20 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E7%A7%AF%E5%88%86%E5%AD%A6-%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元积分学-不定积分 求不定积分 换元积分法 第一类换元积分法 例1 image-20200422205016069 例2 image-20200422205108701 image-20200422205130343 例3 image-20200422205154594 image-20200422205216680 例4 image-20200422205243332 例5 image-20200422205329766 例6 image-20200422210256137 image-20200422210326399 例7 image-20200422210354812 例8 image-20200422210421022 例9 image-20200422210446108 例10 image-20200422210531099 例11 image-20200425130701361 image-20200425130801763 例12 image-20200425131233607 image-20200425131254167 image-20200425131314711 image-20200425145018590 例13 image-20200425144943007 例14 image-20200426112941286 例15 image-20200426113333046 例16 image-20200426113954477 例17 image-20200426121016605 例18 image-20200426152532636 例19 image-20200426154129241 例20 image-20200426154522051 例21 image-20200426175857969 例22 image-20200426180639081 例23 image-20200426215400625 \(=-2\tan \frac{\sqrt{x}}{2} + C\)</description></item><item><title>高等数学-一元微分学-一元微分学的应用-弧微分与曲率</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/</link><pubDate>Sun, 15 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元微分学-一元微分学的应用-弧微分与曲率 弧微分与曲率 考察弧微分的定义 例1 image-20200419201751511 image-20200419201738165 考察曲率的定义 例1 image-20200419221426971 image-20200419221445751 image-20200419221500943</description></item><item><title>高等数学-一元微分学-导数的应用</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/</link><pubDate>Sun, 15 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%BC%A7%E5%BE%AE%E5%88%86%E4%B8%8E%E6%9B%B2%E7%8E%87/</guid><description>高等数学-一元微分学-导数的应用 弧微分与曲率 弧微分 直角座标系中，\(\mathrm{d} s=\sqrt{1+y^{\prime 2}} \mathrm{d} x,(\mathrm{d} x&amp;gt;0)\)
参数方程中，\(\mathrm{d} s=\sqrt{x^{\prime 2}(t)+y^{\prime 2}(t)} \mathrm{d} t,(\mathrm{d} t&amp;gt;0)\)
极坐标系中，\(\mathrm{d} s=\sqrt{p^{2}(\theta)+p^{\prime}(\theta)^{2}} \mathrm{d} \theta,(\mathrm{d} \theta&amp;gt;0)\)
极坐标系中的证明： \(r=r(\theta)\) \(x=r \cos \theta, y=r \sin \theta\) \(\frac{d x}{d \theta}=\frac{\partial x}{\partial r} \frac{d r}{d \theta}+\frac{\partial x}{\partial \theta}=\cos \theta r^{\prime}-r \sin \theta\) \(\frac{d y}{d \theta}=\frac{\partial y}{\partial r} \frac{d r}{d \theta}+\frac{\partial y}{\partial \theta}=\sin \theta r^{\prime}+r \cos \theta\) \(d s=\sqrt{\left(\frac{d x}{d \theta}\right)^{2}+\left(\frac{d y}{d \theta}\right)^{2}} d \theta=\sqrt{r^{2}+r^{\prime}(\theta)^{2}} d \theta\)
曲率 曲率的引入 在数学上，曲线的曲率表明曲线在某一点的弯曲程度的数值。</description></item><item><title>高等数学-一元函数微分学-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元函数微分学-单调性与极值 概念 极值、最值（略）
曲线的凹凸性 同理可有曲线是凸的的定义
曲线的拐点 连续曲线y=f(x)上的凹、凸弧的分界点称为该曲线的拐点
曲线的驻点 连续曲线y=f(x)上若f’(x)=0的解为a则称其为f(x)的驻点或称稳定点、临界点
极值与单调性的的判定 单调性的判定 在区间I上恒有\(f^{\prime}(x) \geqslant 0\)，称f(x)在区间I上单调增加；同理判断单调减少。
极值的判定 确定函数定义域 找所有的不可导点和导数为0点 根据极值的判定条件来判定 极值的判定条件（充分条件） 极值第一充分条件 函数在某点连续，该点左侧导数大于0，右侧导数小于0，则该点取得极大值
函数在某点连续，该点左侧导数小于0，右侧导数大于0，则该点取得极小值
极值第二充分条件 函数在某点的一阶导数等于0，二阶导数不等于0。若该点的二阶导数大于0，该点取得极小值；若该点的二阶导数小于0，则该点取得极大值
函数取极值的性质 极值的必要条件 \(x=x_{0}\)处取得极值，且可导 \(\Rightarrow\) 导数为零：\(f^{\prime}\left(x_{0}\right)=0\)
凹凸性与拐点的判定 凹凸性的判定 函数在区间I上恒有\(f^{\prime \prime}(x) \geqslant 0\)（且不在任意子区间上取等号），则曲线在区间I上是凹的。 \(f^{\prime \prime}(x) \leqslant 0\)，凸的。
拐点的必要条件 函数在某点取得拐点，且二阶导数存在，则二阶导数等于0
拐点的充分条件 函数在某点连续，某去心邻域二阶可导，左右邻域二阶导数反号，则函数在该点取拐点
最值的求法 闭区间上最值求法 （1）求出f（x）在该区间内部的一切驻点及不可导的点，并计算相应的函数值； （2）求出f（x）在闭区间两端点处的函数值 （3）比较上述（1）（2）中求出的函数值，最大者为最大值，最小者为最小值 （4）如果（2）区间内部只有个可疑极值点，并且是极大（极小值点，则它必是f（x）的最大（最小值点此时的区间”可以是闭的，也可以是开的、半开半闭或无穷区间实际上遇到的多数是（4）
应用题求最值 （1）建模：建立目标函数的表达式y=f（x），及相应的定义区间1； （2）如果f（x）在I内可导，则求出f（x）在I内的一切驻点； （3）如果I内只有一个驻点，并且经检验，是极大（极小）值点，则在此唯一的驻点处函数必为最大（最小）值
不等式的证明 构造函数求极值来证明 移项构造函数求最值，恒大于（或恒大于等于或。。。）某个值，得证。
函数的渐近线 水平渐近线 若\(\lim_{x \rightarrow+\infty} f(x)=b_{1}\)，则\(y=b_{1}\)是一条水平渐近线； 若\(\lim_{x \rightarrow-\infty} f(x)=b_{2}\)，则\(y=b_{2}\)是一条水平渐近线（若\(b_1 = b_2\),只算作一条）
铅直渐近线 若存在\(x_0\)，使\(\lim_{x \rightarrow x_{0}^{-}} f(x)=\infty\)（或者\(\lim _{x \rightarrow x_{0}^{+}} f(x)=\infty\)），则\(x=x_0\)是一条铅直渐近线。</description></item><item><title>高等数学-一元函数微分学-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC/</guid><description>高等数学-一元函数微分学-单调性与极值 概念 极值、最值（略）
曲线的凹凸性 同理可有曲线是凸的的定义
曲线的拐点 连续曲线y=f(x)上的凹、凸弧的分界点称为该曲线的拐点
曲线的驻点 连续曲线y=f(x)上若f’(x)=0的解为a则称其为f(x)的驻点或称稳定点、临界点
极值与单调性的的判定 单调性的判定 在区间I上恒有\(f^{\prime}(x) \geqslant 0\)，称f(x)在区间I上单调增加；同理判断单调减少。
极值的判定 确定函数定义域 找所有的不可导点和导数为0点 根据极值的判定条件来判定 极值的判定条件（充分条件） 极值第一充分条件 函数在某点连续，该点左侧导数大于0，右侧导数小于0，则该点取得极大值
函数在某点连续，该点左侧导数小于0，右侧导数大于0，则该点取得极小值
极值第二充分条件 函数在某点的一阶导数等于0，二阶导数不等于0。若该点的二阶导数大于0，该点取得极小值；若该点的二阶导数小于0，则该点取得极大值
函数取极值的性质 极值的必要条件 \(x=x_{0}\)处取得极值，且可导 \(\Rightarrow\) 导数为零：\(f^{\prime}\left(x_{0}\right)=0\)
凹凸性与拐点的判定 凹凸性的判定 函数在区间I上恒有\(f^{\prime \prime}(x) \geqslant 0\)（且不在任意子区间上取等号），则曲线在区间I上是凹的。 \(f^{\prime \prime}(x) \leqslant 0\)，凸的。
拐点的必要条件 函数在某点取得拐点，且二阶导数存在，则二阶导数等于0
拐点的充分条件 函数在某点连续，某去心邻域二阶可导，左右邻域二阶导数反号，则函数在该点取拐点
最值的求法 闭区间上最值求法 （1）求出f（x）在该区间内部的一切驻点及不可导的点，并计算相应的函数值； （2）求出f（x）在闭区间两端点处的函数值 （3）比较上述（1）（2）中求出的函数值，最大者为最大值，最小者为最小值 （4）如果（2）区间内部只有个可疑极值点，并且是极大（极小值点，则它必是f（x）的最大（最小值点此时的区间”可以是闭的，也可以是开的、半开半闭或无穷区间实际上遇到的多数是（4）
应用题求最值 （1）建模：建立目标函数的表达式y=f（x），及相应的定义区间1； （2）如果f（x）在I内可导，则求出f（x）在I内的一切驻点； （3）如果I内只有一个驻点，并且经检验，是极大（极小）值点，则在此唯一的驻点处函数必为最大（最小）值
不等式的证明 构造函数求极值来证明 移项构造函数求最值，恒大于（或恒大于等于或。。。）某个值，得证。
函数的渐近线 水平渐近线 若\(\lim_{x \rightarrow+\infty} f(x)=b_{1}\)，则\(y=b_{1}\)是一条水平渐近线； 若\(\lim_{x \rightarrow-\infty} f(x)=b_{2}\)，则\(y=b_{2}\)是一条水平渐近线（若\(b_1 = b_2\),只算作一条）
铅直渐近线 若存在\(x_0\)，使\(\lim_{x \rightarrow x_{0}^{-}} f(x)=\infty\)（或者\(\lim _{x \rightarrow x_{0}^{+}} f(x)=\infty\)），则\(x=x_0\)是一条铅直渐近线。</description></item><item><title>高等数学-一元微分学-可导函数的中值定理</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86/</guid><description>高等数学-一元微分学-可导函数的中值定理 函数的导数分类 函数的导数分为4种情况，导数大于0，等于0，小于0，不可导
可导的局部特性 以导数大于0为例，根据函数极限的局部保号性：
\(\begin{aligned} if \quad &amp;amp; f^{\prime}(a)&amp;gt;0 ,f^{\prime}(a) =\lim_{x \rightarrow a} \frac{f(x)-f(a)}{x-a}&amp;gt;0 \\ \Rightarrow \quad&amp;amp; \exists \delta&amp;gt;0, x&amp;lt;|x-a|&amp;lt;\delta , \frac{f(x)-f(a)}{x-a}&amp;gt;0 \end{aligned}\)
即导数大于0，表示在极小邻域内，函数值递增 同理，导数小于0，表示在极小邻域内，函数值递减 同理，导数等于0，表示在极小邻域内，函数取极值
费马定理 函数在某点及邻域有定义，在该点取极值，在该点导数存在 \(\Rightarrow\) 该点导数为0（该点是驻点）。
即有：
\(f(x)\)在\(x=a\)取极值， \(\Rightarrow \nLeftarrow\) \(f&amp;#39;(a)=0\) 或 不存在\(f&amp;#39;(a)\)
\(f(x)\)可导且在\(x=a\)取极值， \(\Rightarrow \nLeftarrow\) \(f&amp;#39;(a)=0\)
可导函数的中值定理 几个中值定理的共同条件：一个函数在闭区间连续，开区间可导，中间存在一个点怎么怎么样
高阶中值定理（拉格朗日余项泰勒定理）的条件：一个函数在闭区间n阶连续，开区间n+1阶可导，中间存在一个点怎么怎么样
罗尔定理 若\(f(x)\)在闭区间\([a, b]\)内连续，在开区间\((a, b)\)内可导，且\(f(a)=f(b)\)，则至少存在一点\(\xi \in(a, b)\)，\(f^{\prime}(\xi)=0\)
image-20200417102902630 拉格朗日中值定理 若\(f(x)\)在闭区间\([a, b]\)内连续，在开区间\((a, b)\)内可导，且\(f(a)=f(b)\)，则至少存在一点\(\xi \in(a, b)\)，\(f(b)-f(a)=f^{\prime}(\xi)(b-a)\)
image-20200417110059482 作辅助函数+罗尔定理可证此定理； 所作的辅助函数：直线AB-曲线AB，则在端点处都为0，满足罗尔定理条件。
柯西中值定理 若\(f(x), g(x)\)在闭区间\([a, b]\)连续，在开区间\((a, b)\)可导，且\(g^{\prime}(x) \neq 0, x \in(a, b)\)则至少存在一点\(\xi \in(a, b)\)，使得\(\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f^{\prime}(\xi)}{g^{\prime}(\xi)}\)。</description></item><item><title>高等数学-一元微分学-可导函数的中值定理习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元微分学-可导函数的中值定理习题 考察中值定理的定义 考察罗尔定理的定义 例1 image-20200419191223856 image-20200419191114818 考察拉格朗日中值定理定义 例1 image-20200419194020246 image-20200419194350114 例2 image-20200419195057298 image-20200419195136725 image-20200419195152638 例3 image-20200420195449158 image-20200420195433746 其实这道题就是求极限，没考察中值定理
例4 image-20200420224321957 image-20200420224306297 例5 image-20200421151721709 image-20200421151648390 image-20200421151707394 例6 image-20200421194140003 image-20200421194123394 例7 image-20200421210050736 image-20200421210034865 考察泰勒定理 例1 image-20200419200751777 image-20200419200728386 例2 image-20200420110500021 image-20200420110442108 分母也可使用泰勒展开替换</description></item><item><title>高等数学-一元微分学-导数的应用-单调性与极值</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 13 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%BA%94%E7%94%A8-%E5%8D%95%E8%B0%83%E6%80%A7%E4%B8%8E%E6%9E%81%E5%80%BC%E4%B9%A0%E9%A2%98/</guid><description>高等数学-一元微分学-导数的应用-单调性与极值 单调性与极值 取得极值求参数 例1 image-20200421003426239 image-20200421003408417 求函数极值最值拐点 例1 image-20200419195708739 image-20200419195723861 例2 image-20200419200119412 image-20200419200408718 例3 image-20200421215552152 image-20200421215539424 例4 image-20200421223721753 image-20200421223647790 image-20200421223707139 例5 image-20200421234610269 image-20200421234549317 不等式的证明 例1 image-20200419105526487 image-20200419105612557 例2 image-20200419105817774 image-20200419110336084 image-20200419110432991 例3 image-20200419111217580 image-20200419111349386 image-20200419111417677 例4 image-20200419111515417 image-20200419111621331 image-20200419111738948 image-20200419111823189 image-20200419111854517 例5 image-20200420133940016 image-20200420134002071 例6 image-20200421211229118 image-20200421211213122 例7 image-20200421212306546 image-20200421212244606 例8 image-20200421212720592 image-20200421212704141 例9 image-20200421230538382 image-20200421230518064 例10 image-20200421232406926 image-20200421232344310 例11 image-20200421233509457 image-20200421233445561 方程根的讨论 零点定理证明方程有根 例1 image-20200419112411767 罗尔定理加原函数证明方程有根 image-20200419112651426 例1 image-20200419112806674 image-20200419112837164 image-20200419112910603 单调法求方程根的数目 设立函数，关注定义域 找出驻点和不可导点，考察这些点处的值 关注区间两侧，做草图 例1 image-20200419114101538 image-20200419114230396 image-20200419114257690 例2 image-20200419114323890 image-20200419114404601 image-20200419114626282 例3 image-20200422004431575 image-20200422004417498 例4 image-20200422004808801 image-20200422004739575 image-20200422004756135 例5 image-20200422105544816 image-20200422105531412 已知方程根数目求参数的范围 例1 image-20200420121227949 image-20200420121202318 例2 image-20200420223346656 image-20200420223327541 函数极值点的判定 设立函数，关注定义域 找出驻点和不可导点 极值点的判别法 第一判别法：一阶导数左边大于0右边小于0，极大值 第二判别法：二阶导数小于0，极大值 例1 image-20200419120525676 image-20200419120600695 image-20200419120619583 例2 image-20200419120740848 image-20200419120833477 image-20200419120906304 image-20200419121043544 image-20200419121155925 例3 image-20200419121249527 image-20200419121336818 例4 image-20200420210515185 image-20200420210441704 例5 image-20200420222151454 image-20200420222110963 image-20200420222133567 例6 image-20200420224050066 image-20200420224032845 例7 image-20200420224820402 image-20200420224803435 例8 image-20200421000705445 image-20200421000637031 例9 image-20200421002732769 image-20200421002713453 凹凸性或拐点的判定 二阶导数与0的比较判断凹凸性</description></item><item><title>高等数学-一元微分学-导数和微分</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/</link><pubDate>Wed, 11 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E4%B8%80%E5%85%83%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%AF%BC%E6%95%B0%E5%92%8C%E5%BE%AE%E5%88%86/</guid><description>高等数学-一元微分学-导数和微分 概念定理和公式 导数与微分定义 导数与可导定义 设函数\(y=f(x)\)在\(x_0\)的邻域内有定义，\(f^{\prime}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=\lim _{\Delta x \rightarrow 0} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)，称函数\(y=f(x)\)在点\(x_0\)处可导，极限值称为函数的导数
还可以写成\(x \rightarrow x_0\)的等价定义（略）
由于导数是根据极限定义的。则 \(y=f(x)\)在\(x_0\)处可导\(\Leftrightarrow\) \(f_{-}^{\prime}\left(x_{0}\right)\)和\(f_{+}^{\prime}\left(x_{0}\right)\)存在且相等
左导数：\(f^{\prime}_{-}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0^{-}} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)
右导数：\(f^{\prime}_{+}\left(x_{0}\right)=\lim _{\Delta x \rightarrow 0^{+}} \frac{f\left(x_{0}+\Delta x\right)-f\left(x_{0}\right)}{\Delta x}\)
导数几何意义 根据定义，导数是一个分式的极限，其中分子是函数在两点处的差值，分母是两点处的差值
函数在某点的导数，对应直角坐标系中曲线在该点处的斜率，即\(\tan \alpha=f^{\prime}\left(x_{0}\right)\)。
区间内可导与闭区间上可导 如果函数\(y=f(x)\)在\((a, b)\)内每一点均可导，称函数在\((a, b)\)内可导； 如果函数在\((a, b)\)内可导，且在x=a和x=b分别具有右导数\(f^{\prime}+(a)\)和左导数\(f^{\prime}-(b)\)，则函数在\([a, b]\)上可导。
微分与可微定义 如果函数y=f（x）在点x处的某邻域内有定义， \(\Delta y=A \Delta x+o(\Delta x)\)， 称y=f(x)在x处可微， 称\(d y=d f(x)=A \Delta x\)为f(x)在x处的微分。
又\(f^{\prime}(x)=\lim _{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}=A\)，记\(d x=\Delta x\)，则微分又可以写成\(\mathrm{d} y=f^{\prime}(x) \mathrm{d} x\)</description></item><item><title>高等数学-基础概念-函数与极限</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</link><pubDate>Fri, 06 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/</guid><description>高等数学-基础概念-函数与极限 数学分析/高等数学（数学系教材是数学分析，理工科教材是高等数学）是由微积分演进而来，在微积分发展至现代阶段中，从应用中的方法总结升华为一类综合性分析方法。
数学分析（英语：mathematical analysis）区别于其他非数学类学生的高等数学内容，是分析学中最古老、最基本的分支，一般指以微积分学、无穷级数和解析函数等的一般理论为主要内容。
微积分学的研究对象是函数，微积分学的理论基础是极限理论，极限理论的理论基础是实数理论。
级数是研究函数的一种方法和工具，理论基础也是极限理论。通过函数展开成级数，研究函数在无穷多项和表示下的性质，以及进行数值计算。
综上，数学分析的研究对象是函数，数学分析的基本方法是极限的方法，或者说是无穷小分析。它的发展由微积分开始，并扩展到函数的连续性、可微分及可积分等各种特性。
此章节介绍函数与极限的相关概念与性质
映射 映射定义 设 \(X_{ }, Y\) 是两个非空集合,如果存在一个法则 \(f,\) 使得对 \(X\) 中每个元素x, 按法则 \(f,\) 在 Y 中有唯一确定的元素 y 与之对应,那么称 \(f\) 为从 X 到 Y 的映射， 记作\(f: X \rightarrow Y\) 其中 \(y\) 称为元素 \(x\) (在映射 \(f\) 下)的像,并记作 \(f(x)\), 即 而元素 x 称为元素 \(y\) ( 在映射 \(f\) 下 ) 的一个原像 ; 集合 \(X\) 称为映射 \(f\) 的定义域, 记 作 \(D_{f},\) 即 $D_{f}=X ; $ \(X\) 中所有元素的像所组成的集合称为映射 \(f\) 的值域, 记作 \(R_{f}\) 或\(f(X),\) 即\(R_{f}=f(X)=\{f(x) \mid x \in X\}\)</description></item><item><title>高等数学-基础概念-函数与极限习题</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/</link><pubDate>Fri, 06 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90%E4%B9%A0%E9%A2%98/</guid><description>高等数学-基础概念-函数与极限习题 首先判断未定式类型，使用对应的方法 无法根据未定式求解时，考虑根据定义来做，或者夹逼定理，泰勒展开等 对于含有绝对值的式子求极限，需要分类讨论
根据未定式的形式求极限 \(\frac{0}{0}\)型、\(\frac{\infty}{\infty}\)型 等价无穷小求极限 例1 \(\lim _{x \rightarrow 0} \frac{e^{x}-e^{\ln (1+x)}}{x \arcsin 2 x}\)=？
答：
\(\frac{e^{x}-e^{\ln (1+x)}}{x+0} \frac{e^{x}}{x \arcsin 2 x}=\lim _{x \rightarrow 0} e^{\ln (1+x)} \cdot \frac{e^{x-\ln (1+x)}-1}{2 x^{2}}=\lim _{x \rightarrow 0} \frac{e^{x-\ln (1+x)}-1}{2 x^{2}}\) \(=\lim _{x \rightarrow 0} \frac{x-\ln (1+x)}{2 x^{2}}=\lim _{x \rightarrow 0} \frac{1-\frac{1}{1+x}}{4 x}=\frac{1}{4}\)
例2 image-20200401180016813 image-20200401180054656 例3 image-20200402090331972 image-20200402090433834 例4 image-20200403111854513 image-20200403112000737 例5 image-20200403171516699 image-20200403171545204 例6 image-20200403172337378 image-20200403172416159 例7 image-20200409084345553 这里使用等价无穷小，也可以使用和差化积+泰勒展开</description></item><item><title>高等数学-一元微积分-脉络</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/</link><pubDate>Sun, 01 Mar 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6-%E4%B8%80%E5%85%83%E5%BE%AE%E7%A7%AF%E5%88%86-%E8%84%89%E7%BB%9C/</guid><description>高等数学-一元微积分-脉络 极限与函数极限 微积分的基础是函数极限理论，也称无穷小理论。从趋于某个点的情况，研究附近的函数情况。
导数 用极限定义了函数的导函数，简称导数。
\(y^{\prime} = f^{\prime}(x) = \lim_{x\rightarrow x_0} \frac{y(x) - y(x_0)}{x-x_0} = \lim_{\Delta x \rightarrow 0} \frac{\Delta y}{\Delta x}\)
根据导函数定义可以求出常见函数（初等函数）的导函数形式。（常函数、幂函数、指数函数、对数函数、三角函数等都有确定的导函数形式）
微分 定义函数\(y=f(x)\)可微：\(\Delta x \rightarrow 0\)时，有\(\Delta y = A \Delta x + o(\Delta x)\)，称函数\(y(x)\)可微。
实际上，上式两边同时除以\(\Delta x\)取极限，可得\(A = y^{\prime}(x)\)，即： \(\Delta x \rightarrow 0\)时，有\(\Delta y = y^{\prime} \Delta x + o(\Delta x)\)，称函数\(y(x)\)可微。
函数差分\(\Delta y\)的主要部分\(A \Delta x\)称为函数的微分。记为$dy = A x = y^{} x = y^{} d x $。
在导数章节，我们求出了常见函数（初等函数）的导函数形式。 又根据函数的微分$dy = y^{} d x $， 我们可以得到常见函数（初等函数）的微分。</description></item><item><title>高等数学与数学分析</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</link><pubDate>Wed, 26 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E6%95%B0%E5%AD%A6%E5%88%86%E6%9E%90%E5%92%8C%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/</guid><description>高等数学 高等数学（理工科）与数学分析（数学系）实际上讲的是同一块内容。数学分析侧重讲思想与证明，高等数学侧重讲计算。高等数学里概念性的东西如果有疑问，可以去数学分析里找。
初等数学的研究对象基本是不变的量，高等数学的研究对象是变动的量。 而函数关系是变量之间的依赖关系，极限方法是研究变量的一种基本方法。
数学分析 数学分析（英语：mathematical analysis）区别于其他非数学类学生的高等数学内容，是分析学中最古老、最基本的分支，一般指以微积分学、无穷级数和解析函数等的一般理论为主要内容，并包括它们的理论基础（实数、函数、测度和极限的基本理论）的一个较为完整的数学学科。它也是大学数学专业的一门基础课程。[1]
数学分析研究的内容包括实数、复数、实函数及复变函数。数学分析是由微积分演进而来，在微积分发展至现代阶段中，从应用中的方法总结升华为一类综合性分析方法，且初等微积分中也包括许多数学分析的基础概念及技巧，可以认为这些应用方法是高等微积分生成的前提。数学分析的方式和其几何有关，不过只要任一数学空间有定义邻域（拓扑空间）或是有针对两物件距离的定义（度量空间），就可以用数学分析的方式进行分析。
数学分析又称高级微积分，分析学中最古老、最基本的分支。一般指以微积分学和无穷级数一般理论为主要内容，并包括它们的理论基础（实数、函数和极限的基本理论）的一个较为完整的数学学科。
它的发展由微积分开始，并扩展到函数的连续性、可微分及可积分等各种特性。
数学分析的主要内容是微积分学，微积分学的理论基础是极限理论，极限理论的理论基础是实数理论。
数学分析的研究对象是函数，它从局部和整体这两个方面研究函数的基本形态，从而形成微分学和积分学的基本内容。
数学分析的基本方法是极限的方法，或者说是无穷小分析。
数学分析分支领域 数学分析在当前被分为以下几个分支领域：
实分析是数学分析中，专门处理实数及实值函数的一个分支[5][6]。这包括对极限、微分、积分、幂级数和测度的研究。 复分析，是对从复平面到复平面的复数可微函数的研究，和复数的解析函数（或亚纯函数）有密切的关系。可以应用在许多不同的数学领域中，包括代数几何、数论、应用数学等，也广为应用在物理领域中，例如流体力学、热力学、机械工程、电机工程及量子场论。 泛函分析探讨函数空间及一些和向量空间相关的结构（例如内积、范数及拓扑空间）等，以及在作用在这些空间中的线性算子[7][8]，也会介绍例如巴拿赫空间以及希尔伯特空间的概念。 傅立叶分析研究如何将一个函数或者信号表达为基本波形的叠加，并扩展成傅立叶级数和傅立叶变换的概念。 微分方程是未知数为一变数或多变数的函数，且方程和函数其导数或高阶导数有关的方程[9][10][11]。微分方程在工程、物理、经济、生物学中都是重要的一部分。 数值分析是研究数学分析中相关问题（和离散数学不同）中有关数值近似（和符号运算不同）算法的研究。[12]。许多问题的解析解是很难求得的，数值分析不在意解析解，比较著重在可接受的误差范围内找到近似解。 学科代码：34 数学分析▪ 3410:微分学▪ 3420:积分学▪ 3430:级数论▪ 3499:数学分析其他学科
空间 参考：网易公开课：上海交通大学公开课：数学之旅：函数空间 参考：https://zhuanlan.zhihu.com/p/42381836 参考：https://www.jianshu.com/p/42593a412339 参考：https://www.bilibili.com/read/cv3843646/
数学空间 空间即为点的集合
在空间里 原点, 基 这两个东西最重要. 原点就是坐标完全为0的一个点, 基为定义这个空间最基础的“方向”。以二维平面直角坐标系为例，O就是原点, 而 i, j 就是这个空间的两个基。空间中的任意点都可以表示为\(P = a \boldsymbol i + b \boldsymbol j\)，所有可能的权重\((a,b)\)代入上述关系式中，可以得到关于a,b的点集\({a \boldsymbol i + b \boldsymbol j}\)
基其实不要求正交，但不能平行（平行的话相当于少了一条基）
假设有n个不平行的基\(\boldsymbol \varphi_n\)，那么这组基张成的空间中的任意一点为\(P = \Sigma_{i= 1}^n a_i \varphi_i\)。这个空间是里面所有点的点集。
实空间和复空间都是1维的，线性空间是n维的。
数学的空间：研究工作的对象（元素）和遵循的规则（结构）。 （线性结构：加法和数乘；拓扑结构：距离、范数、开集）</description></item><item><title>基础数学-三角函数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/</guid><description>基础数学-三角函数 诱导公式 公式一 公式二 sin（2kπ+α）=sin α
cos（2kπ+α）=cos α
tan（2kπ+α）=tan α
cot（2kπ+α）=cot α
sec（2kπ+α）=sec α
csc（2kπ+α）=csc α sin（π+α）=-sin α
cos（π+α）=-cos α
tan（π+α）=tan α
cot（π+α）=cot α
sec（π+α）=-sec α
csc（π+α）=-csc α 公式三 公式四 sin（-α）=-sin α
cos（-α）=cos α
tan（-α）=-tan α
cot（-α）=-cot α
sec（-α）=sec α
csc（-α）=-csc α sin（π-α）=sin α
cos（π-α）=-cos α
tan（π-α）=-tan α
cot（π-α）=-cot α
sec（π-α）=-sec α
csc（π-α）=csc α 公式五 公式六 sin（α-π）=-sin α
cos（α-π）=-cos α</description></item><item><title>基础数学-代数</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E4%BB%A3%E6%95%B0/</guid><description>基础数学-代数 代数等式 \(a^{3}+b^{3}=(a+b)\left(a^{2}-a b+b^{2}\right)\)
\(a^{3}-b^{3}=(a-b)\left(a^{2}+a b+b^{2}\right)\)
\(1^{2}+2^{2}+\cdots+n^{2}=\frac{n(n+1)(2 n+1)}{6}\)
复数运算 \(|x+y i|=\sqrt{x^{2}+y^{2}}\)
\(|z|=|\bar{z}|\)
\(z+\bar{z}=2 a(\) 实数 \(), \quad z-\bar{z}=2 b i\)
\(z \cdot \bar{z}=|z|^{2}=a^{2}+b^{2}(\) 实数 \()\)
\(\overline{z_{1}+z_{2}}=\bar{z}_{1}+\bar{z}_{2}\)
\(\overline{z_{1}-z_{2}}=\bar{z}_{1}-\bar{z}_{2}\)
\(\overline{z_{1} \cdot z_{2}}=\bar{z}_{1} \cdot \bar{z}_{2}\)
\(\overline{z_{1} / z_{2}}=\bar{z}_{1} / \bar{z}_{2}\left(z_{2} \neq 0\right)\)
代数不等式 基本不等式（均值不等式） \(\frac{a+b}{2} \geqslant \sqrt{a b} \quad(a&amp;gt;0, b&amp;gt;0)\)，当且仅当\(a=b\)取等号。
或\(a+b \geq 2 \sqrt{a b},(a&amp;gt;0, b&amp;gt;0)\)
基本不等式变形 \(a+b \geq 2 \sqrt{a b}\) ，当且仅当\(a=b\)取等号。
\(\frac{b}{a}+\frac{a}{b} \geq 2\)，其中a, b同号。
\(a b \leq\left(\frac{a+b}{2}\right)^{2} \quad(a, b \in R)\)</description></item><item><title>基础数学-几何</title><link>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/</link><pubDate>Tue, 25 Feb 2020 05:24:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E6%95%B0%E5%AD%A6%E6%80%BB%E7%BB%93/%E5%9F%BA%E7%A1%80%E6%95%B0%E5%AD%A6-%E5%87%A0%E4%BD%95/</guid><description>基础数学-几何 距离公式 点到直线的距离 设直维L的方程为Ax+By+C=0，点 P的坐标为\((x_0,y_0)\)，则点 P到直线L的距离为： \(\frac{\left|A x_{0}+B y_{0}+C\right|}{\sqrt{A^{2}+B^{2}}}\)
两条直线间的距离 设直线L1的方程为 \(A x+B y+C_{1}=0 \quad ;\) 直线L2的方程为 \(A x+B y+C_{2}=0\) 则 2条平行线之间的间距 \(: \frac{\left|C_{1}-C_{2}\right|}{\sqrt{A^{2}+B^{2}}}\)
三角形中的公式 正弦定理 正弦定理 在任意\(\triangle ABC\)中，角A、B、C所对的边长分别为a、b、c，三角形外接圆的半径为R，直径为D。则有： \(\frac{a}{\sin A}=\frac{b}{\sin B}=\frac{c}{\sin C}=2 R=D\) 一个三角形中，各边和所对角的正弦之比相等，且该比值等于该三角形外接圆的直径（半径的2倍）长度。
正弦定理的推广 \(\triangle A B C\) 中，若角A, \(B,\) C所对的边为a, \(b, c,\) 三角形外接圆半径为 \(R,\) 直径为D，正弦定理进行变形有： \(a=2 R \sin A, b=2 R \sin B, c=2 R \sin C\) \(a\sin B=b\sin A, b\sin C=c\sin B, a\sin C=c\sin A\) \(a: b: c=\sin A: \sin B: \sin C\) \(\frac{a}{\sin A}=\frac{a+b}{\sin A+\sin B}=\frac{a+b+c}{\sin A+\sin B+\sin C} \quad\) (等比，不变) \(S=\frac{1}{2} a b \sin C=\frac{1}{2} a c \sin B=\frac{1}{2} b c \sin A=\frac{a b c}{4 R}=\frac{a b c}{2 D} \quad\) (三角形面积公式)</description></item></channel></rss>