<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>java发起http请求 on Jingmin's blog</title><link>https://ole12138.github.io/series/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/</link><description>Recent content in java发起http请求 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Wed, 13 Jan 2021 13:25:34 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/series/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/feed.xml" rel="self" type="application/rss+xml"/><item><title>发起HTTP请求：使用HttpURLConnection</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</link><pubDate>Wed, 13 Jan 2021 13:25:34 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8httpurlconnection/</guid><description>发起HTTP请求：使用HttpURLConnection 使用JDK原生的HttpURLConnection发起HTTP请求
注意：到Java8为止，HttpURLConnection不支持HTTP2，只支持到HTTP1.1。 要使用支持HTTP2的HttpURLConnection，需要升级到Java11 import lombok.Cleanup; import java.io.*; import java.net.HttpURLConnection; import java.net.MalformedURLException; import java.net.URL; import java.nio.charset.StandardCharsets; /** * 使用JDK原生的HttpURLConnection发起HTTP请求 */ public class HttpURLConnectionUtil { public static String doGet(String httpurl) { // 返回结果字符串 String result = null; try { // 创建远程url连接对象 URL url = new URL(httpurl); // 通过远程url连接对象打开一个连接，强转成httpURLConnection类 @Cleanup(&amp;#34;disconnect&amp;#34;) HttpURLConnection connection = (HttpURLConnection) url.openConnection(); // 设置连接方式：get connection.setRequestMethod(&amp;#34;GET&amp;#34;); // 设置连接主机服务器的超时时间：15000毫秒 connection.setConnectTimeout(15000); // 设置读取远程返回的数据时间：60000毫秒 connection.setReadTimeout(60000); // 发送请求 connection.</description></item><item><title>HTTPS简单介绍（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Tue, 12 Jan 2021 12:06:18 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BDhttps%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>HTTPS简单介绍（转载） 本章节非原创，转载来源：https://juejin.cn/post/6844903599303032845
一、HTTP存在的问题 1.1 可能被窃听 HTTP 本身不具备加密的功能,HTTP 报文使用明文方式发送 由于互联网是由联通世界各个地方的网络设施组成,所有发送和接收经过某些设备的数据都可能被截获或窥视。(例如大家都熟悉的抓包工具:Wireshark) 1.2 认证问题 无法确认你发送到的服务器就是真正的目标服务器(可能服务器是伪装的) 无法确定返回的客户端是否是按照真实意图接收的客户端(可能是伪装的客户端) 无法确定正在通信的对方是否具备访问权限，Web 服务器上某些重要的信息，只想发给特定用户即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。 1.3 可能被篡改 1.请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击被称为中间人攻击（Man-in-the-Middle attack，MITM）。
二、HTTPS介绍 2.1 什么是HTTPS 超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。
2.2 HTTPS怎么解决上述问题 HTTPS是在通信接口部分用 TLS(Transport Layer Security 传输层安全性协议)，TLS协议采用主从式架构模型，用于在两个应用程序间通过网络创建起安全的连接，防止在交换数据时受到窃听及篡改。
2.3 SSL和TLS的关系 传输层安全性协议（英语：Transport Layer Security，缩写作 TLS），及其前身安全套接层（Secure Sockets Layer，缩写作 SSL）是一种安全协议，目的是为互联网通信，提供安全及数据完整性保障。 网景公司（Netscape）在1994年推出首版网页浏览器，网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。 IETF将SSL进行标准化，1999年公布第一版TLS标准文件。随后又公布RFC 5246 （2008年8月）与 RFC 6176 （2011年3月）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛支持这个协议。 2.4 TLS/SSL 协议 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</description></item><item><title>发起HTTP请求：使用JDK11的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 17:08:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</guid><description>发起HTTP请求：使用JDK11的HttpClient JDK11 API中原生的增加了HTTP客户端类HttpClient，用于发起HTTP请求，支持HTTP/2.
以下内容非原创，参考/转载来源：https://www.dariawan.com/tutorials/java/java-11-standard-http-client-vs-apache-httpclient/
JDK11的HttpClient使用测试：
package com.wangjm.http.connection; import com.google.common.net.UrlEscapers; import org.junit.jupiter.api.Test; import java.net.ProxySelector; import java.net.URI; import java.net.http.HttpClient; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.time.Duration; /** * @author : wangjm * @date : 2021/1/11 20:47 * JDK11 API 提供了HttpClient，支持HTTP/2 * 简单使用的情况下，http和https链接的请求都是相同的 */ class JDKHttpClientUtilTest { @Test public void doTest() throws Exception { final HttpClient HTTP_CLIENT = HttpClient.newBuilder() .version(HttpClient.Version.HTTP_2) // default .followRedirects(HttpClient.Redirect.NORMAL) // Always redirect, except from HTTPS URLs to HTTP URLs. .</description></item><item><title>发起HTTP请求：使用Apache的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 14:34:53 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</guid><description>Java发起HTTP请求：使用Apache的HttpClient 许多小伙伴都喜欢用apache的HttpComponts里的HttpClient来向远程发起HTTP请求
从HttpComponents官网的features说明来看，当前版本(HttpClient4.5)仅支持到HTTP/1.1。 但是HttpCore.5.1BETA将支持HTTP/2，可惜还在BETA阶段。
使用方式：
项目中引入对应的maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 参考了别人的代码,简单使用：
/** * 使用apache的HttpClient发起HTTP以及HTTPS请求 * 注意：当前的apache的HttpClient4.5只支持到HTTP/1.1 * 参考：https://zhuanlan.zhihu.com/p/69285935 * 参考：https://blog.csdn.net/happylee6688/article/details/47148227 */ public class HttpClientUtil { private static PoolingHttpClientConnectionManager connMgr; private static RequestConfig requestConfig; private static final int MAX_TIMEOUT = 7000; static { // 设置连接池 connMgr = new PoolingHttpClientConnectionManager(); // 设置连接池大小 connMgr.setMaxTotal(100); connMgr.setDefaultMaxPerRoute(connMgr.getMaxTotal()); RequestConfig.Builder configBuilder = RequestConfig.custom(); // 设置连接超时 configBuilder.setConnectTimeout(MAX_TIMEOUT); // 设置读取超时 configBuilder.setSocketTimeout(MAX_TIMEOUT); // 设置从连接池获取连接实例的超时 configBuilder.</description></item><item><title>HTTP协议介绍(转载)</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</link><pubDate>Sun, 10 Jan 2021 18:52:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/http%E5%8D%8F%E8%AE%AE%E4%B8%8E%E6%8A%A5%E6%96%87/</guid><description>HTTP 协议介绍 本章节非原创，转载来源：http://www.ruanyifeng.com/blog/2016/08/http.html
HTTP 协议是互联网的基础协议，也是网页开发的必备知识，最新版本 HTTP/2 更是让它成为技术热点。
本文介绍 HTTP 协议的历史演变和设计思路。
一、HTTP/0.9 HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。
最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。
GET /index.html 上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页index.html。
协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt;Hello World&amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 服务器发送完毕，就关闭TCP连接。
二、HTTP/1.0 2.1 简介 1996年5月，HTTP/1.0 版本发布，内容大大增加。
首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
其次，除了GET命令，还引入了POST命令和HEAD命令，丰富了浏览器与服务器的互动手段。
再次，HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。
2.2 请求格式 下面是一个1.0版的HTTP请求的例子。
GET / HTTP/1.0 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */* 可以看到，这个格式与0.9版有很大变化。
第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。
2.3 回应格式 服务器的回应如下。
HTTP/1.0 200 OK Content-Type: text/plain Content-Length: 137582 Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996 15:55:28 GMT Server: Apache 0.</description></item><item><title>发起HTTP请求：Spring中RestTemplate设置与携带请求头（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Fri, 08 Jan 2021 16:56:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>Rest设置请求头以及进一步配置 本章节“Rest设置与携带请求头”部分非原创，转载来源：https://juejin.cn/post/6844904202397827086
本节主要集中在如何携带自定义的请求头，如设置 User-Agent，携带 Cookie
Get 携带请求头 Post 携带请求头 拦截器方式设置统一请求头 I. 项目搭建 1. 配置 借助 SpringBoot 搭建一个 SpringWEB 项目，提供一些用于测试的 REST 服务
SpringBoot 版本: 2.2.1.RELEASE 核心依赖: spring-boot-stater-web &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件application.yml中，添加
logging: pattern: console: (%msg%n%n){blue} 2. Rest 服务 添加三个接口，分别提供 GET 请求，POST 表单，POST json 对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明
@RestController public class DemoRest { private String getHeaders(HttpServletRequest request) { Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); String name; JSONObject headers = new JSONObject(); while (headerNames.</description></item><item><title>发起HTTP请求：Spring中的RestTempalate的基本使用（转载）</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Jan 2021 17:28:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate的认识与基本使用 RestTemplate介绍 在Spring的生态下，则可以利用RestTemplate来发起Http请求。
spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。
RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如 Apache HttpComponents、Netty或OkHttp等其它HTTP library。
RestTemplate构成与实现逻辑：
RestTemplate包含以下几个部分：
HttpMessageConverter 对象转换器 ClientHttpRequestFactory 默认是JDK的HttpURLConnection ResponseErrorHandler 异常处理 ClientHttpRequestInterceptor 请求拦截器 用一张图可以很直观的理解：
RestTempalate的基本使用 本节&amp;quot;RestTempalate的基本使用&amp;quot;非原创，转载来源：https://juejin.cn/post/6844903656165212174
0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么
简单的给出了一下常见的问题如下
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本节主要关注在RestTemplate的简单Get/Post请求的使用方式上：
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种
// get 请求 public &amp;lt;T&amp;gt; T getForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public &amp;lt;T&amp;gt; T postForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; postForEntity(); // put 请求 public void put(); // pathch public &amp;lt;T&amp;gt; T patchForObject // delete public void delete() // options public Set&amp;lt;HttpMethod&amp;gt; optionsForAllow // exchange public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说</description></item><item><title>Java发起HTTP请求方式汇总</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</link><pubDate>Thu, 07 Jan 2021 16:31:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</guid><description>作为一个Java后端，需要通过HTTP请求其他的网络资源可以说是一个比较常见的case了；一般怎么做呢？
直接捞起Apache的HttpClient开始做 (只支持到HTTP/1.1,最近的Http5.1-beta开始支持HTTP/2) 知名的开源库如OkHttp 原生的HttpURLConnection （Since: JDK1.1） 原生的HttpClient （JDK11） Spring的生态中可以利用RestTemplate来发起Http请求。 发送HTTP请求时，要注意区分http和https类型的请求</description></item></channel></rss>