<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java发起HTTP请求 on Jingmin's blog</title><link>https://ole12138.github.io/series/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/</link><description>Recent content in Java发起HTTP请求 on Jingmin's blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>Copyright (c) 2020, Jingmin; All rights reserved.</copyright><lastBuildDate>Mon, 11 Jan 2021 17:08:09 +0800</lastBuildDate><atom:link href="https://ole12138.github.io/series/java%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82/feed.xml" rel="self" type="application/rss+xml"/><item><title>发起HTTP请求：使用JDK11的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 17:08:09 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8jdk11%E7%9A%84httpclient/</guid><description>发起HTTP请求：使用JDK11的HttpClient JDK11 API中原生的增加了HTTP客户端类，用于发起HTTP请求，支持HTTP/2.</description></item><item><title>Java发起HTTP请求：使用Apache的HttpClient</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</link><pubDate>Mon, 11 Jan 2021 14:34:53 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8apache%E7%9A%84httpclient/</guid><description>Java发起HTTP请求：使用Apache的HttpClient 许多小伙伴都喜欢用apache的HttpComponts里的HttpClient来向远程发起HTTP请求
从HttpComponents官网的features说明来看，当前版本(HttpClient4.5)仅支持到HTTP/1.1。 但是HttpCore.5.1BETA将支持HTTP/2，可惜还在BETA阶段。
使用方式：
项目中引入对应的maven依赖：
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.apache.httpcomponents&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;httpclient&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;4.5.13&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 简单使用： 参考：
public class HttpClientUtil { public static String doGet(String url) { String result = &amp;#34;&amp;#34;; try { // 通过址默认配置创建一个httpClient实例 @Cleanup CloseableHttpClient httpClient = HttpClients.createDefault(); // 创建httpGet远程连接实例 HttpGet httpGet = new HttpGet(url); // 设置请求头信息，鉴权 httpGet.setHeader(&amp;#34;Authorization&amp;#34;, &amp;#34;Bearer da3efcbf-0845-4fe3-8aba-ee040be542c0&amp;#34;); // 设置配置请求参数 RequestConfig requestConfig = RequestConfig.custom() // 连接主机服务超时时间 .setConnectTimeout(35000) // 请求超时时间 .setConnectionRequestTimeout(35000) // 数据读取超时时间 .setSocketTimeout(60000) .</description></item><item><title>转载：发起HTTP请求：Spring中RestTemplate设置与携带请求头</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</link><pubDate>Fri, 08 Jan 2021 16:56:48 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%ADresttempalate%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%A4%B4/</guid><description>Rest设置请求头以及进一步配置 本章节“Rest设置与携带请求头”部分非原创，转载来源：https://juejin.cn/post/6844904202397827086
本节主要集中在如何携带自定义的请求头，如设置 User-Agent，携带 Cookie
Get 携带请求头 Post 携带请求头 拦截器方式设置统一请求头 I. 项目搭建 1. 配置 借助 SpringBoot 搭建一个 SpringWEB 项目，提供一些用于测试的 REST 服务
SpringBoot 版本: 2.2.1.RELEASE 核心依赖: spring-boot-stater-web &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt; 为了后续输出的日志更直观，这里设置了一下日志输出格式，在配置文件application.yml中，添加
logging: pattern: console: (%msg%n%n){blue} 2. Rest 服务 添加三个接口，分别提供 GET 请求，POST 表单，POST json 对象，然后返回请求头、请求参数、cookie，具体实现逻辑相对简单，也不属于本篇重点，因此不赘述说明
@RestController public class DemoRest { private String getHeaders(HttpServletRequest request) { Enumeration&amp;lt;String&amp;gt; headerNames = request.getHeaderNames(); String name; JSONObject headers = new JSONObject(); while (headerNames.</description></item><item><title>转载：发起HTTP请求：Spring中的RestTempalate的基本使用</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Thu, 07 Jan 2021 17:28:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82spring%E4%B8%AD%E7%9A%84resttempalate%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>RestTemplate的认识与基本使用 RestTemplate介绍 在Spring的生态下，则可以利用RestTemplate来发起Http请求。
spring框架提供的RestTemplate类可用于在应用中调用rest服务，它简化了与http服务的通信方式，统一了RESTful的标准，封装了http链接， 我们只需要传入url及返回值类型即可。相较于之前常用的HttpClient，RestTemplate是一种更优雅的调用RESTful服务的方式。
RestTemplate默认依赖JDK提供http连接的能力（HttpURLConnection），如果有需要的话也可以通过setRequestFactory方法替换为例如 Apache HttpComponents、Netty或OkHttp等其它HTTP library。
RestTemplate构成与实现逻辑：
RestTemplate包含以下几个部分：
HttpMessageConverter 对象转换器 ClientHttpRequestFactory 默认是JDK的HttpURLConnection ResponseErrorHandler 异常处理 ClientHttpRequestInterceptor 请求拦截器 用一张图可以很直观的理解：
RestTempalate的基本使用 本节&amp;quot;RestTempalate的基本使用&amp;quot;非原创，转载来源：https://juejin.cn/post/6844903656165212174
0. 目标 在介绍如何使用RestTemplate之前，我们先抛出一些小目标，至少需要知道通过RestTemplate可以做些什么，以及我们要用它来干些什么
简单的给出了一下常见的问题如下
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 post请求中RequestBody的请求方式与普通的请求方式区别 https/http两种访问如何分别处理 如何在请求中带上指定的Header 有跨域的问题么？如果有怎么解决 有登录验证的请求，该怎么办，怎样携带身份信息 上传文件可以支持么 对于需要代理才能访问的http资源，加代理的姿势是怎样的 上面的问题比较多，目测不是一篇博文可以弄完的，因此对这个拆解一下，本节主要关注在RestTemplate的简单Get/Post请求的使用方式上：
普通的Get请求获取返回数据，怎么玩？ post提交表达的请求，如何处理 1. 基本接口 捞出源码，看一下其给出的一些常用接口，基本上可以分为下面几种
// get 请求 public &amp;lt;T&amp;gt; T getForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(); // head 请求 public HttpHeaders headForHeaders(); // post 请求 public URI postForLocation(); public &amp;lt;T&amp;gt; T postForObject(); public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; postForEntity(); // put 请求 public void put(); // pathch public &amp;lt;T&amp;gt; T patchForObject // delete public void delete() // options public Set&amp;lt;HttpMethod&amp;gt; optionsForAllow // exchange public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; exchange() 上面提供的几个接口，基本上就是Http提供的几种访问方式的对应，其中exchange却又不一样，后面细说</description></item><item><title>Java发起HTTP请求方式汇总</title><link>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</link><pubDate>Thu, 07 Jan 2021 16:31:40 +0800</pubDate><guid>https://ole12138.github.io/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF/%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E6%B1%87%E6%80%BBjava/</guid><description>作为一个Java后端，需要通过HTTP请求其他的网络资源可以说是一个比较常见的case了；一般怎么做呢？
直接捞起Apache的HttpClient开始做 (只支持到HTTP/1.1,最近的Http5.1-beta开始支持HTTP/2) 知名的开源库如OkHttp 原生的HttpURLConnection （Since: JDK1.1） 原生的HttpClient （JDK11） Spring的生态中可以利用RestTemplate来发起Http请求。 发送HTTP请求时，要注意区分http和https类型的请求</description></item></channel></rss>